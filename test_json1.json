{"code": {"body": "    public void execute(BatchParams batchParams,int index,Integer data,String object) throws BatchException{\n        LOGGER.info(\"\");\n        Employee where = new Employee();\n        where.setId(1);\n        Employee set = new Employee();\n        set.setName(\"\");\n        dao.update(set,where);\n    }", "comment": "/**\n     * \u5904\u7406\u6bcf\u4e00\u6761\u8bb0\u5f55\n     * <b>\u4e1a\u52a1\u5904\u7406\u65b9\u6cd5</b><br/>\n     * \u5982\u679c\u5b50\u7c7b\u8986\u76d6\u4e86getDataList()\u65b9\u6cd5\uff0c<br/>\n     * \u5219\u6b64\u65b9\u6cd5\u662f\u5bf9dataList\u7684\u5355\u4e2a\u5143\u7d20\u8fdb\u884c\u5904\u7406\uff0c<br/>\n     * \u5bf9\u4e8edataList\u7684\u904d\u5386\u662f\u5728StepService\u91cc\u8fdb\u884c\u7684\uff0c\u6bcf\u4e2a\u5143\u7d20\u5355\u72ec\u8c03\u8d77\u4e00\u4e2a\u7ebf\u7a0b\u8fdb\u884c\u5904\u7406;\n     * \u540c\u65f6\u5e76\u53d1\u7684\u6700\u5927\u7ebf\u7a0b\u6570\u53ef\u5728\u8868BATCH_STEP\u91cc\u914d\u7f6e<br/>\n     * \u82e5\u4e0d\u8986\u76d6dataList\uff0cStepService\u662f\u76f4\u63a5\u8c03\u8d77\u6b64\u65b9\u6cd5<br/>\n     * \u82e5dataList.size\u5927\u4e8e1\uff0c\u5219\u6b64\u65b9\u6cd5\u662f\u5e76\u53d1\u7684\n     *\n     * @param index     \u8868\u793adata\u5728object\u91cc\u7684\u4e0b\u6807\uff0c\u4ee3\u8868\u8fd9\u6761\u8bb0\u5f55\u5728\u6587\u4ef6\u7684\u7b2c\u51e0\u884c ,\u4ece1\u5f00\u59cb\n     * @param data \u4e3agetDataList()\u65b9\u6cd5\u8fd4\u56de\u7684\u5217\u8868\u91cc\u7684\u4e00\u4e2a\u5177\u4f53\u6570\u636e\uff0c\u4f8b\u5982\u662f\u6587\u4ef6\u91cc\u7684\u4e00\u6761\u8bb0\u5f55\n     * @param object    \u4e3agetObjectList()\u65b9\u6cd5\u8fd4\u56de\u7684\u5217\u8868\u7684\u4e00\u4e2a\u5177\u4f53\u5bf9\u8c61,\u4e0d\u80fd\u5728\u6b64\u65b9\u6cd5\u5185\u4fee\u6539object\u7684\u4efb\u4f55\u5c5e\u6027\n     */"}}
{"code": {"body": "    public List<Integer> getDataList(BatchParams batchParams, int offset, int pageSize, String object)\n            throws BatchException {\n        List<Integer> list = new ArrayList<Integer>();\n        for (int i = 0; i < pageSize; i++) {\n            list.add(offset + i);\n        }\n        return list;\n    }", "comment": "/**\n     * \u5206\u9875\u5904\u7406\n     * @param batchParams\n     * @param offset\n     * @param pageSize\n     * @param object\n     * @return\n     * @throws BatchException\n     */"}}
{"code": {"body": "public Stack(){\n        head = null;\n    }", "comment": "/* ---------------------- Ende der inneren Klasse ----------------------*/"}}
{"code": {"body": "public DrawingPanel(){\n            super();\n            addMouseListener(this);\n            setDoubleBuffered(true);\n            drawableObjects = new ArrayList<>();\n            dt = 35; \n            lastLoop = System.nanoTime();\n            javax.swing.Timer timer = new javax.swing.Timer(dt, this);\n            timer.start();\n        }", "comment": "/**\n         * Konstruktor\n         */"}}
{"code": {"body": "        public void addObject(DrawableObject d){\n            drawableObjects.add(d);\n        }", "comment": "/**\n         * Diese Methode f\u00fcgt ein neues Objekt zum Zeichnen hinzu. Die\n         * Klasse des Objekts muss mindestens das Interface DrawableObject implementieren.\n         * @param d Das ab sofort zu zeichnende Objekt\n         */"}}
{"code": {"body": "        public void removeObject(DrawableObject d){\n            drawableObjects.remove(d);\n        }", "comment": "/**\n         * Diese Methode entfernt ein Objekt aus der Menge der zu zeichnenden Objekte. Die\n         * Klasse des Objekts muss mindestens das Interface DrawableObject implementieren.\n         * @param d Das ab sofort nicht mehr zu zeichnende Objekt\n         */"}}
{"code": {"body": "        public void keyTyped(KeyEvent e){\n\n        }", "comment": "/**\n         * Unbenutzt bis auf Weiteres\n         */"}}
{"code": {"body": "        public void keyPressed(KeyEvent e){\n            Iterator<DrawableObject> iterator = drawableObjects.iterator();\n            while (iterator.hasNext()){\n                DrawableObject tempDO = iterator.next();\n                if (tempDO instanceof InteractableObject){\n                    ((InteractableObject)tempDO).keyPressed(e.getKeyCode());\n                }\n            }\n        }", "comment": "/**\n         * Weitergabe an Zeichnungsobjekte.\n         */"}}
{"code": {"body": "        public void keyReleased(KeyEvent e){\n            Iterator<DrawableObject> iterator = drawableObjects.iterator();\n            while (iterator.hasNext()){\n                DrawableObject tempDO = iterator.next();\n                if (tempDO instanceof InteractableObject){\n                    ((InteractableObject)tempDO).keyReleased(e.getKeyCode());\n                }\n            }\n\n        }", "comment": "/**\n         * Weitergabe an Zeichnungsobjekte.\n         */"}}
{"code": {"body": "        public void mousePressed(MouseEvent e) {\n        }", "comment": "/**\n         * Unbenutzt bis auf Weiteres\n         */"}}
{"code": {"body": "        public void mouseReleased(MouseEvent e) {\n            Iterator<DrawableObject> iterator = drawableObjects.iterator();\n            while (iterator.hasNext()){\n                DrawableObject tempDO = iterator.next();\n                if (tempDO instanceof InteractableObject){\n                    ((InteractableObject)tempDO).mouseReleased(e);\n                }\n            }\n        }", "comment": "/**\n         * Unbenutzt bis auf Weiteres\n         */"}}
{"code": {"body": "        public void mouseEntered(MouseEvent e) {\n        }", "comment": "/**\n         * Unbenutzt bis auf Weiteres\n         */"}}
{"code": {"body": "        public void mouseExited(MouseEvent e) {\n        }", "comment": "/**\n         * Unbenutzt bis auf Weiteres\n         */"}}
{"code": {"body": "        public void mouseClicked(MouseEvent e) {\n        }", "comment": "/**\n         * Weitergabe an Zeichnungsobjekte.\n         */"}}
{"code": {"body": "public MainFrame(String name, int x, int y, int width, int height) {\n        panels = new ArrayList<>();\n        activePanel = new DrawingPanel();\n        panels.add(activePanel);\n        add(activePanel);\n        addKeyListener(activePanel);\n        setLocation(x,y);\n        setSize(width,height);\n        setTitle(name);\n        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        setVisible(true);\n    }", "comment": "/**\n     * Konstruktor\n     * @param name Der Titel des Fensters\n     * @param x Die obere linke x-Koordinate des Fensters bzgl. des Bildschirms\n     * @param y Die obere linke y-Koordinaite des Fensters bzgl. des Bildschirms\n     * @param width Die Breite des Fensters\n     * @param height Die H\u00f6he des Fensters\n     */"}}
{"code": {"body": "    public DrawingPanel getActiveDrawingPanel(){\n        return activePanel;\n    }", "comment": "/**\n     * Liefert das aktuell vom DrawWindow angezeigte DrawingBoard zur\ufffdck\n     * @return Das aktuelle DrawingBoard\n     */"}}
{"code": {"body": "    public void addNewDrawingPanel(){\n        DrawingPanel tempDB = new DrawingPanel();\n        panels.add(tempDB);\n    }", "comment": "/**\n     * F\ufffdgt dem DrawWindow ein neues DrawingBoard hinzu. Dieses wird nicht zum\n     * aktuellen DrawingBoard!\n     */"}}
{"code": {"body": "    public void setActiveDrawingPanel(int index){\n        if (index < panels.size()){\n            remove(activePanel);\n            removeKeyListener(activePanel);\n\n            activePanel = panels.get(index);\n            add(activePanel);\n            addKeyListener(activePanel);\n            setSize(this.getSize());\n            setVisible(true);\n        }\n    }", "comment": "/**\n     * \ufffdndert das aktuell vom DrawWindow gezeigte DrawingBoard.\n     * @param index Der Index des neuen zu zeigenden DrawingBoards (angefangen bei 0).\n     */"}}
{"code": {"body": "    public static <T> ServerResponse createServerResponseBySuccess(String msg,T data){\n        return new ServerResponse(ResponseCode.SUCCESS,msg,data);\n    }", "comment": "/**\n     *{\"status\":0\uff0c\"msg\":\"aaa\"\uff0c\"date\":{}}\n     */"}}
{"code": {"body": "    public static ServerResponse createServerResponseByError(Integer status,String msg){\n        return new ServerResponse(status,msg);\n    }", "comment": "/**\n     *{\"status\":\u81ea\u5b9a\u4e49\uff0c\"msg\":\"aaa\"}\n     */"}}
{"code": {"body": "    public Integer getId() {\n        return id;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_cart.id\n     *\n     * @return the value of neuedu_cart.id\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setId(Integer id) {\n        this.id = id;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_cart.id\n     *\n     * @param id the value for neuedu_cart.id\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Integer getUserId() {\n        return userId;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_cart.user_id\n     *\n     * @return the value of neuedu_cart.user_id\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setUserId(Integer userId) {\n        this.userId = userId;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_cart.user_id\n     *\n     * @param userId the value for neuedu_cart.user_id\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Integer getProductId() {\n        return productId;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_cart.product_id\n     *\n     * @return the value of neuedu_cart.product_id\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setProductId(Integer productId) {\n        this.productId = productId;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_cart.product_id\n     *\n     * @param productId the value for neuedu_cart.product_id\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Integer getQuantity() {\n        return quantity;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_cart.quantity\n     *\n     * @return the value of neuedu_cart.quantity\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setQuantity(Integer quantity) {\n        this.quantity = quantity;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_cart.quantity\n     *\n     * @param quantity the value for neuedu_cart.quantity\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Integer getChecked() {\n        return checked;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_cart.checked\n     *\n     * @return the value of neuedu_cart.checked\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setChecked(Integer checked) {\n        this.checked = checked;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_cart.checked\n     *\n     * @param checked the value for neuedu_cart.checked\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Date getCreateTime() {\n        return createTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_cart.create_time\n     *\n     * @return the value of neuedu_cart.create_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setCreateTime(Date createTime) {\n        this.createTime = createTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_cart.create_time\n     *\n     * @param createTime the value for neuedu_cart.create_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Date getUpdateTime() {\n        return updateTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_cart.update_time\n     *\n     * @return the value of neuedu_cart.update_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setUpdateTime(Date updateTime) {\n        this.updateTime = updateTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_cart.update_time\n     *\n     * @param updateTime the value for neuedu_cart.update_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Integer getId() {\n        return id;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_category.id\n     *\n     * @return the value of neuedu_category.id\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setId(Integer id) {\n        this.id = id;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_category.id\n     *\n     * @param id the value for neuedu_category.id\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Integer getParentId() {\n        return parentId;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_category.parent_id\n     *\n     * @return the value of neuedu_category.parent_id\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setParentId(Integer parentId) {\n        this.parentId = parentId;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_category.parent_id\n     *\n     * @param parentId the value for neuedu_category.parent_id\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public String getName() {\n        return name;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_category.name\n     *\n     * @return the value of neuedu_category.name\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setName(String name) {\n        this.name = name == null ? null : name.trim();\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_category.name\n     *\n     * @param name the value for neuedu_category.name\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Integer getStatus() {\n        return status;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_category.status\n     *\n     * @return the value of neuedu_category.status\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setStatus(Integer status) {\n        this.status = status;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_category.status\n     *\n     * @param status the value for neuedu_category.status\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Integer getSortOrder() {\n        return sortOrder;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_category.sort_order\n     *\n     * @return the value of neuedu_category.sort_order\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setSortOrder(Integer sortOrder) {\n        this.sortOrder = sortOrder;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_category.sort_order\n     *\n     * @param sortOrder the value for neuedu_category.sort_order\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Date getCreateTime() {\n        return createTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_category.create_time\n     *\n     * @return the value of neuedu_category.create_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setCreateTime(Date createTime) {\n        this.createTime = createTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_category.create_time\n     *\n     * @param createTime the value for neuedu_category.create_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Date getUpdateTime() {\n        return updateTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_category.update_time\n     *\n     * @return the value of neuedu_category.update_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setUpdateTime(Date updateTime) {\n        this.updateTime = updateTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_category.update_time\n     *\n     * @param updateTime the value for neuedu_category.update_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Integer getId() {\n        return id;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_order.id\n     *\n     * @return the value of neuedu_order.id\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setId(Integer id) {\n        this.id = id;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_order.id\n     *\n     * @param id the value for neuedu_order.id\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Integer getUserId() {\n        return userId;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_order.user_id\n     *\n     * @return the value of neuedu_order.user_id\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setUserId(Integer userId) {\n        this.userId = userId;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_order.user_id\n     *\n     * @param userId the value for neuedu_order.user_id\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Long getOrderNo() {\n        return orderNo;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_order.order_no\n     *\n     * @return the value of neuedu_order.order_no\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setOrderNo(Long orderNo) {\n        this.orderNo = orderNo;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_order.order_no\n     *\n     * @param orderNo the value for neuedu_order.order_no\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Integer getShippingId() {\n        return shippingId;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_order.shipping_id\n     *\n     * @return the value of neuedu_order.shipping_id\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setShippingId(Integer shippingId) {\n        this.shippingId = shippingId;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_order.shipping_id\n     *\n     * @param shippingId the value for neuedu_order.shipping_id\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public BigDecimal getPayment() {\n        return payment;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_order.payment\n     *\n     * @return the value of neuedu_order.payment\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setPayment(BigDecimal payment) {\n        this.payment = payment;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_order.payment\n     *\n     * @param payment the value for neuedu_order.payment\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Integer getPaymentType() {\n        return paymentType;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_order.payment_type\n     *\n     * @return the value of neuedu_order.payment_type\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setPaymentType(Integer paymentType) {\n        this.paymentType = paymentType;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_order.payment_type\n     *\n     * @param paymentType the value for neuedu_order.payment_type\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Integer getPostage() {\n        return postage;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_order.postage\n     *\n     * @return the value of neuedu_order.postage\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setPostage(Integer postage) {\n        this.postage = postage;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_order.postage\n     *\n     * @param postage the value for neuedu_order.postage\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Integer getStatus() {\n        return status;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_order.status\n     *\n     * @return the value of neuedu_order.status\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setStatus(Integer status) {\n        this.status = status;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_order.status\n     *\n     * @param status the value for neuedu_order.status\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Date getPaymentTime() {\n        return paymentTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_order.payment_time\n     *\n     * @return the value of neuedu_order.payment_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setPaymentTime(Date paymentTime) {\n        this.paymentTime = paymentTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_order.payment_time\n     *\n     * @param paymentTime the value for neuedu_order.payment_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Date getSendTime() {\n        return sendTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_order.send_time\n     *\n     * @return the value of neuedu_order.send_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setSendTime(Date sendTime) {\n        this.sendTime = sendTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_order.send_time\n     *\n     * @param sendTime the value for neuedu_order.send_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Date getEndTime() {\n        return endTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_order.end_time\n     *\n     * @return the value of neuedu_order.end_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setEndTime(Date endTime) {\n        this.endTime = endTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_order.end_time\n     *\n     * @param endTime the value for neuedu_order.end_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Date getCloseTime() {\n        return closeTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_order.close_time\n     *\n     * @return the value of neuedu_order.close_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setCloseTime(Date closeTime) {\n        this.closeTime = closeTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_order.close_time\n     *\n     * @param closeTime the value for neuedu_order.close_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Date getCreateTime() {\n        return createTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_order.create_time\n     *\n     * @return the value of neuedu_order.create_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setCreateTime(Date createTime) {\n        this.createTime = createTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_order.create_time\n     *\n     * @param createTime the value for neuedu_order.create_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Date getUpdateTime() {\n        return updateTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_order.update_time\n     *\n     * @return the value of neuedu_order.update_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setUpdateTime(Date updateTime) {\n        this.updateTime = updateTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_order.update_time\n     *\n     * @param updateTime the value for neuedu_order.update_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Integer getId() {\n        return id;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_order_item.id\n     *\n     * @return the value of neuedu_order_item.id\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setId(Integer id) {\n        this.id = id;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_order_item.id\n     *\n     * @param id the value for neuedu_order_item.id\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Integer getUserId() {\n        return userId;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_order_item.user_id\n     *\n     * @return the value of neuedu_order_item.user_id\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setUserId(Integer userId) {\n        this.userId = userId;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_order_item.user_id\n     *\n     * @param userId the value for neuedu_order_item.user_id\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Long getOrderNo() {\n        return orderNo;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_order_item.order_no\n     *\n     * @return the value of neuedu_order_item.order_no\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setOrderNo(Long orderNo) {\n        this.orderNo = orderNo;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_order_item.order_no\n     *\n     * @param orderNo the value for neuedu_order_item.order_no\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Integer getProductId() {\n        return productId;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_order_item.product_id\n     *\n     * @return the value of neuedu_order_item.product_id\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setProductId(Integer productId) {\n        this.productId = productId;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_order_item.product_id\n     *\n     * @param productId the value for neuedu_order_item.product_id\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public String getProductName() {\n        return productName;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_order_item.product_name\n     *\n     * @return the value of neuedu_order_item.product_name\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setProductName(String productName) {\n        this.productName = productName == null ? null : productName.trim();\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_order_item.product_name\n     *\n     * @param productName the value for neuedu_order_item.product_name\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public String getProductImage() {\n        return productImage;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_order_item.product_image\n     *\n     * @return the value of neuedu_order_item.product_image\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setProductImage(String productImage) {\n        this.productImage = productImage == null ? null : productImage.trim();\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_order_item.product_image\n     *\n     * @param productImage the value for neuedu_order_item.product_image\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public BigDecimal getCurrentUnitPrice() {\n        return currentUnitPrice;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_order_item.current_unit_price\n     *\n     * @return the value of neuedu_order_item.current_unit_price\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setCurrentUnitPrice(BigDecimal currentUnitPrice) {\n        this.currentUnitPrice = currentUnitPrice;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_order_item.current_unit_price\n     *\n     * @param currentUnitPrice the value for neuedu_order_item.current_unit_price\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Integer getQuantity() {\n        return quantity;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_order_item.quantity\n     *\n     * @return the value of neuedu_order_item.quantity\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setQuantity(Integer quantity) {\n        this.quantity = quantity;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_order_item.quantity\n     *\n     * @param quantity the value for neuedu_order_item.quantity\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public BigDecimal getTotalPrice() {\n        return totalPrice;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_order_item.total_price\n     *\n     * @return the value of neuedu_order_item.total_price\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setTotalPrice(BigDecimal totalPrice) {\n        this.totalPrice = totalPrice;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_order_item.total_price\n     *\n     * @param totalPrice the value for neuedu_order_item.total_price\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Date getCreateTime() {\n        return createTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_order_item.create_time\n     *\n     * @return the value of neuedu_order_item.create_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setCreateTime(Date createTime) {\n        this.createTime = createTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_order_item.create_time\n     *\n     * @param createTime the value for neuedu_order_item.create_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Date getUpdateTime() {\n        return updateTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_order_item.update_time\n     *\n     * @return the value of neuedu_order_item.update_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setUpdateTime(Date updateTime) {\n        this.updateTime = updateTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_order_item.update_time\n     *\n     * @param updateTime the value for neuedu_order_item.update_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Integer getId() {\n        return id;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_payinfo.id\n     *\n     * @return the value of neuedu_payinfo.id\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setId(Integer id) {\n        this.id = id;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_payinfo.id\n     *\n     * @param id the value for neuedu_payinfo.id\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Integer getUserId() {\n        return userId;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_payinfo.user_id\n     *\n     * @return the value of neuedu_payinfo.user_id\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setUserId(Integer userId) {\n        this.userId = userId;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_payinfo.user_id\n     *\n     * @param userId the value for neuedu_payinfo.user_id\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Long getOrderNo() {\n        return orderNo;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_payinfo.order_no\n     *\n     * @return the value of neuedu_payinfo.order_no\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setOrderNo(Long orderNo) {\n        this.orderNo = orderNo;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_payinfo.order_no\n     *\n     * @param orderNo the value for neuedu_payinfo.order_no\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Integer getPayPlatform() {\n        return payPlatform;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_payinfo.pay_platform\n     *\n     * @return the value of neuedu_payinfo.pay_platform\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setPayPlatform(Integer payPlatform) {\n        this.payPlatform = payPlatform;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_payinfo.pay_platform\n     *\n     * @param payPlatform the value for neuedu_payinfo.pay_platform\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public String getPlatformNumber() {\n        return platformNumber;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_payinfo.platform_number\n     *\n     * @return the value of neuedu_payinfo.platform_number\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setPlatformNumber(String platformNumber) {\n        this.platformNumber = platformNumber == null ? null : platformNumber.trim();\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_payinfo.platform_number\n     *\n     * @param platformNumber the value for neuedu_payinfo.platform_number\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public String getPlatformStatus() {\n        return platformStatus;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_payinfo.platform_status\n     *\n     * @return the value of neuedu_payinfo.platform_status\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setPlatformStatus(String platformStatus) {\n        this.platformStatus = platformStatus == null ? null : platformStatus.trim();\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_payinfo.platform_status\n     *\n     * @param platformStatus the value for neuedu_payinfo.platform_status\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Date getCreateTime() {\n        return createTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_payinfo.create_time\n     *\n     * @return the value of neuedu_payinfo.create_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setCreateTime(Date createTime) {\n        this.createTime = createTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_payinfo.create_time\n     *\n     * @param createTime the value for neuedu_payinfo.create_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Date getUpdateTime() {\n        return updateTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_payinfo.update_time\n     *\n     * @return the value of neuedu_payinfo.update_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setUpdateTime(Date updateTime) {\n        this.updateTime = updateTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_payinfo.update_time\n     *\n     * @param updateTime the value for neuedu_payinfo.update_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Integer getId() {\n        return id;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_product.id\n     *\n     * @return the value of neuedu_product.id\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setId(Integer id) {\n        this.id = id;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_product.id\n     *\n     * @param id the value for neuedu_product.id\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Integer getCategoryId() {\n        return categoryId;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_product.category_id\n     *\n     * @return the value of neuedu_product.category_id\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setCategoryId(Integer categoryId) {\n        this.categoryId = categoryId;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_product.category_id\n     *\n     * @param categoryId the value for neuedu_product.category_id\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public String getName() {\n        return name;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_product.name\n     *\n     * @return the value of neuedu_product.name\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setName(String name) {\n        this.name = name == null ? null : name.trim();\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_product.name\n     *\n     * @param name the value for neuedu_product.name\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public String getSubtitle() {\n        return subtitle;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_product.subtitle\n     *\n     * @return the value of neuedu_product.subtitle\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setSubtitle(String subtitle) {\n        this.subtitle = subtitle == null ? null : subtitle.trim();\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_product.subtitle\n     *\n     * @param subtitle the value for neuedu_product.subtitle\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public String getMainImage() {\n        return mainImage;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_product.main_image\n     *\n     * @return the value of neuedu_product.main_image\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setMainImage(String mainImage) {\n        this.mainImage = mainImage == null ? null : mainImage.trim();\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_product.main_image\n     *\n     * @param mainImage the value for neuedu_product.main_image\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public BigDecimal getPrice() {\n        return price;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_product.price\n     *\n     * @return the value of neuedu_product.price\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setPrice(BigDecimal price) {\n        this.price = price;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_product.price\n     *\n     * @param price the value for neuedu_product.price\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Integer getStock() {\n        return stock;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_product.stock\n     *\n     * @return the value of neuedu_product.stock\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setStock(Integer stock) {\n        this.stock = stock;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_product.stock\n     *\n     * @param stock the value for neuedu_product.stock\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Integer getStatus() {\n        return status;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_product.status\n     *\n     * @return the value of neuedu_product.status\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setStatus(Integer status) {\n        this.status = status;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_product.status\n     *\n     * @param status the value for neuedu_product.status\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Date getCreateTime() {\n        return createTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_product.create_time\n     *\n     * @return the value of neuedu_product.create_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setCreateTime(Date createTime) {\n        this.createTime = createTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_product.create_time\n     *\n     * @param createTime the value for neuedu_product.create_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Date getUpdateTime() {\n        return updateTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_product.update_time\n     *\n     * @return the value of neuedu_product.update_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setUpdateTime(Date updateTime) {\n        this.updateTime = updateTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_product.update_time\n     *\n     * @param updateTime the value for neuedu_product.update_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public String getSubImages() {\n        return subImages;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_product.sub_images\n     *\n     * @return the value of neuedu_product.sub_images\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setSubImages(String subImages) {\n        this.subImages = subImages == null ? null : subImages.trim();\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_product.sub_images\n     *\n     * @param subImages the value for neuedu_product.sub_images\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public String getDetail() {\n        return detail;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_product.detail\n     *\n     * @return the value of neuedu_product.detail\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setDetail(String detail) {\n        this.detail = detail == null ? null : detail.trim();\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_product.detail\n     *\n     * @param detail the value for neuedu_product.detail\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Integer getId() {\n        return id;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_shipping.id\n     *\n     * @return the value of neuedu_shipping.id\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setId(Integer id) {\n        this.id = id;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_shipping.id\n     *\n     * @param id the value for neuedu_shipping.id\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Integer getUserId() {\n        return userId;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_shipping.user_id\n     *\n     * @return the value of neuedu_shipping.user_id\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setUserId(Integer userId) {\n        this.userId = userId;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_shipping.user_id\n     *\n     * @param userId the value for neuedu_shipping.user_id\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public String getReceiverName() {\n        return receiverName;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_shipping.receiver_name\n     *\n     * @return the value of neuedu_shipping.receiver_name\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setReceiverName(String receiverName) {\n        this.receiverName = receiverName == null ? null : receiverName.trim();\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_shipping.receiver_name\n     *\n     * @param receiverName the value for neuedu_shipping.receiver_name\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public String getReceiverPhone() {\n        return receiverPhone;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_shipping.receiver_phone\n     *\n     * @return the value of neuedu_shipping.receiver_phone\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setReceiverPhone(String receiverPhone) {\n        this.receiverPhone = receiverPhone == null ? null : receiverPhone.trim();\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_shipping.receiver_phone\n     *\n     * @param receiverPhone the value for neuedu_shipping.receiver_phone\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public String getReceiverMobile() {\n        return receiverMobile;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_shipping.receiver_mobile\n     *\n     * @return the value of neuedu_shipping.receiver_mobile\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setReceiverMobile(String receiverMobile) {\n        this.receiverMobile = receiverMobile == null ? null : receiverMobile.trim();\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_shipping.receiver_mobile\n     *\n     * @param receiverMobile the value for neuedu_shipping.receiver_mobile\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public String getReceiverProvince() {\n        return receiverProvince;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_shipping.receiver_province\n     *\n     * @return the value of neuedu_shipping.receiver_province\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setReceiverProvince(String receiverProvince) {\n        this.receiverProvince = receiverProvince == null ? null : receiverProvince.trim();\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_shipping.receiver_province\n     *\n     * @param receiverProvince the value for neuedu_shipping.receiver_province\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public String getReceiverCity() {\n        return receiverCity;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_shipping.receiver_city\n     *\n     * @return the value of neuedu_shipping.receiver_city\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setReceiverCity(String receiverCity) {\n        this.receiverCity = receiverCity == null ? null : receiverCity.trim();\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_shipping.receiver_city\n     *\n     * @param receiverCity the value for neuedu_shipping.receiver_city\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public String getReceiverDistrict() {\n        return receiverDistrict;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_shipping.receiver_district\n     *\n     * @return the value of neuedu_shipping.receiver_district\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setReceiverDistrict(String receiverDistrict) {\n        this.receiverDistrict = receiverDistrict == null ? null : receiverDistrict.trim();\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_shipping.receiver_district\n     *\n     * @param receiverDistrict the value for neuedu_shipping.receiver_district\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public String getReceiverAddress() {\n        return receiverAddress;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_shipping.receiver_address\n     *\n     * @return the value of neuedu_shipping.receiver_address\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setReceiverAddress(String receiverAddress) {\n        this.receiverAddress = receiverAddress == null ? null : receiverAddress.trim();\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_shipping.receiver_address\n     *\n     * @param receiverAddress the value for neuedu_shipping.receiver_address\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public String getReceiverZip() {\n        return receiverZip;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_shipping.receiver_zip\n     *\n     * @return the value of neuedu_shipping.receiver_zip\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setReceiverZip(String receiverZip) {\n        this.receiverZip = receiverZip == null ? null : receiverZip.trim();\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_shipping.receiver_zip\n     *\n     * @param receiverZip the value for neuedu_shipping.receiver_zip\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Date getCreateTime() {\n        return createTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_shipping.create_time\n     *\n     * @return the value of neuedu_shipping.create_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setCreateTime(Date createTime) {\n        this.createTime = createTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_shipping.create_time\n     *\n     * @param createTime the value for neuedu_shipping.create_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Date getUpdateTime() {\n        return updateTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_shipping.update_time\n     *\n     * @return the value of neuedu_shipping.update_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setUpdateTime(Date updateTime) {\n        this.updateTime = updateTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_shipping.update_time\n     *\n     * @param updateTime the value for neuedu_shipping.update_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Integer getId() {\n        return id;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_user.id\n     *\n     * @return the value of neuedu_user.id\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setId(Integer id) {\n        this.id = id;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_user.id\n     *\n     * @param id the value for neuedu_user.id\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public String getUsername() {\n        return username;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_user.username\n     *\n     * @return the value of neuedu_user.username\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setUsername(String username) {\n        this.username = username == null ? null : username.trim();\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_user.username\n     *\n     * @param username the value for neuedu_user.username\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public String getPassword() {\n        return password;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_user.password\n     *\n     * @return the value of neuedu_user.password\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setPassword(String password) {\n        this.password = password == null ? null : password.trim();\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_user.password\n     *\n     * @param password the value for neuedu_user.password\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public String getEmail() {\n        return email;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_user.email\n     *\n     * @return the value of neuedu_user.email\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setEmail(String email) {\n        this.email = email == null ? null : email.trim();\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_user.email\n     *\n     * @param email the value for neuedu_user.email\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public String getPhone() {\n        return phone;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_user.phone\n     *\n     * @return the value of neuedu_user.phone\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setPhone(String phone) {\n        this.phone = phone == null ? null : phone.trim();\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_user.phone\n     *\n     * @param phone the value for neuedu_user.phone\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public String getQuestion() {\n        return question;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_user.question\n     *\n     * @return the value of neuedu_user.question\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setQuestion(String question) {\n        this.question = question == null ? null : question.trim();\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_user.question\n     *\n     * @param question the value for neuedu_user.question\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public String getAnswer() {\n        return answer;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_user.answer\n     *\n     * @return the value of neuedu_user.answer\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setAnswer(String answer) {\n        this.answer = answer == null ? null : answer.trim();\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_user.answer\n     *\n     * @param answer the value for neuedu_user.answer\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Integer getRole() {\n        return role;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_user.role\n     *\n     * @return the value of neuedu_user.role\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setRole(Integer role) {\n        this.role = role;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_user.role\n     *\n     * @param role the value for neuedu_user.role\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Date getCreateTime() {\n        return createTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_user.create_time\n     *\n     * @return the value of neuedu_user.create_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setCreateTime(Date createTime) {\n        this.createTime = createTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_user.create_time\n     *\n     * @param createTime the value for neuedu_user.create_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public Date getUpdateTime() {\n        return updateTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_user.update_time\n     *\n     * @return the value of neuedu_user.update_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setUpdateTime(Date updateTime) {\n        this.updateTime = updateTime;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_user.update_time\n     *\n     * @param updateTime the value for neuedu_user.update_time\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public String getIp() {\n        return ip;\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method returns the value of the database column neuedu_user.ip\n     *\n     * @return the value of neuedu_user.ip\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    public void setIp(String ip) {\n        this.ip = ip == null ? null : ip.trim();\n    }", "comment": "/**\n     * This method was generated by MyBatis Generator.\n     * This method sets the value of the database column neuedu_user.ip\n     *\n     * @param ip the value for neuedu_user.ip\n     *\n     * @mbggenerated\n     */"}}
{"code": {"body": "    private CartVO getCartVOLimit(Integer userId){\n        CartVO cartVO = new CartVO();\n        \n        List<Cart> cartList = cartMapper.selectCartByUserId(userId);\n        \n        List<CartProductVO> cartProductVOList = Lists.newArrayList();\n        \n        BigDecimal carttotalprice=new BigDecimal(\"\");\n        if (cartList!=null||cartList.size()>0){\n            for (Cart cart:cartList){\n                CartProductVO cartProductVO = new CartProductVO();\n                cartProductVO.setId(cart.getId());\n                cartProductVO.setQuantity(cart.getQuantity());\n                cartProductVO.setUserId(cart.getUserId());\n                cartProductVO.setProductChecked(cart.getChecked());\n                \n                Product product = productMapper.selectByPrimaryKey(cart.getProductId());\n                if (product!=null){\n                    cartProductVO.setProductId(cart.getProductId());\n                    cartProductVO.setProductMainImage(product.getMainImage());\n                    cartProductVO.setProductName(product.getName());\n                    cartProductVO.setProductPrice(product.getPrice());\n                    cartProductVO.setProductStatus(product.getStatus());\n                    cartProductVO.setProductStock(product.getStock());\n                    cartProductVO.setProductSubtitle(product.getSubtitle());\n                    int stock = product.getStock();\n                    int limitProductCount=0;\n                    if (stock>=cart.getQuantity()){\n                        limitProductCount=cart.getQuantity();\n                        cartProductVO.setLimitQuantity(\"\");\n                    }else {\n                        \n                        limitProductCount=stock;\n                        \n                        Cart cart1 = new Cart();\n                        cart1.setId(cart.getId());\n                        cart1.setQuantity(stock);\n                        cart1.setProductId(cart.getProductId());\n                        cart1.setChecked(cart.getChecked());\n                        cart1.setUserId(userId);\n                        cartMapper.updateByPrimaryKey(cart1);\n                        cartProductVO.setLimitQuantity(\"\");\n                    }\n                    cartProductVO.setQuantity(limitProductCount);\n                    cartProductVO.setProductTotalPrice(BigDecimalUtils.mul(product.getPrice().doubleValue(),\n                            Double.valueOf(cartProductVO.getQuantity())));\n                }\n\n                \n                if (cartProductVO.getProductChecked()==Const.CartCheckedEnum.PRODUCT_CHECKED.getCode()){\n                   \n                    carttotalprice = BigDecimalUtils.add(carttotalprice.doubleValue(), cartProductVO.getProductTotalPrice().doubleValue());\n                }\n                cartProductVOList.add(cartProductVO);\n            }\n        }\n        cartVO.setCartProductVOList(cartProductVOList);\n        \n        cartVO.setCarttotalprice(carttotalprice);\n        \n        int count = cartMapper.isCheckedAll(userId);\n        if (count>0){\n            cartVO.setIsallchecked(false);\n        }else {\n            cartVO.setIsallchecked(true);\n        }\n        \n        return cartVO;\n    }", "comment": "/**\n     *\u5c01\u88c5\u9ad8\u590d\u7528\u5bf9\u8c61\n     */"}}
{"code": {"body": "    private Order createOrder(Integer userId, Integer shippingId, BigDecimal orderTotalPrice) {\n        Order order = new Order();\n        order.setOrderNo(generateOrderNo());\n        order.setUserId(userId);\n        order.setShippingId(shippingId);\n        order.setStatus(Const.OrderStatusEnum.ORDER_UN_PAY.getCode());\n        \n        order.setPayment(orderTotalPrice);\n        order.setPostage(0); \n        order.setPaymentType(Const.PaymentEnum.ONLINE.getCode());\n        \n        int insert = orderMapper.insert(order);\n        if (insert > 0) {\n            return order;\n        }\n        return null;\n    }", "comment": "/**\n     * \u5c01\u88c5\u521b\u5efa\u8ba2\u5355\u7684\u65b9\u6cd5\n     */"}}
{"code": {"body": "    private OrderVO assembleOrderVO(Order order, List<OrderItem> orderItemList, Integer shippingId) {\n        OrderVO orderVO = new OrderVO();\n        List<OrderItemVO> orderItemVOList = Lists.newArrayList();\n        for (OrderItem orderItem : orderItemList) {\n            OrderItemVO orderItemVO = assembleOrderItemVO(orderItem);\n            orderItemVOList.add(orderItemVO);\n        }\n        orderVO.setOrderItemVOList(orderItemVOList);\n        orderVO.setImageHost(PropertiesUtils.readByKey(\"\"));\n        Shipping shipping = shippingMapper.selectByPrimaryKey(shippingId);\n        if (shipping != null) {\n            orderVO.setShippingId(shippingId);\n            ShippingVO shippingVO = assembleShippingVO(shipping);\n            orderVO.setShippingVO(shippingVO);\n            orderVO.setReceiverName(shipping.getReceiverName());\n        }\n        orderVO.setStatus(order.getStatus());\n        Const.OrderStatusEnum orderStatusEnum = Const.OrderStatusEnum.codeof(order.getStatus());\n        if (orderStatusEnum != null) {\n            orderVO.setStatusDesc(orderStatusEnum.getDesc());\n\n            orderVO.setPostage(0);\n            orderVO.setPayment(order.getPayment());\n            orderVO.setPaymentType(order.getPaymentType());\n            Const.PaymentEnum paymentEnum = Const.PaymentEnum.codeof(order.getPaymentType());\n            if (paymentEnum != null) {\n                orderVO.setPaymentTypeDesc(paymentEnum.getDesc());\n            }\n            orderVO.setOrderNo(order.getOrderNo());\n        }\n        return orderVO;\n    }", "comment": "/**\n     * \u5411\u524d\u7aef\u8fd4\u56de\u7684\u65b9\u6cd5\n     */"}}
{"code": {"body": "    private void cleanCart(List<Cart> cartList) {\n        if (cartList != null && cartList.size() > 0) {\n            cartMapper.batchDelete(cartList);\n        }\n    }", "comment": "/**\n     * \u8d2d\u7269\u8f66\u4e2d\u6e05\u7a7a\u5df2\u4e0b\u5355\u7684\u5546\u54c1\n     */"}}
{"code": {"body": "    private void reduceProductStock(List<OrderItem> orderItemList) {\n        if (orderItemList != null && orderItemList.size() > 0) {\n            for (OrderItem orderItem : orderItemList) {\n                Integer productId = orderItem.getProductId();\n                Integer quantity = orderItem.getQuantity();\n                Product product = productMapper.selectByPrimaryKey(productId);\n                product.setStock(product.getStock() - quantity);\n                productMapper.updateByPrimaryKey(product);\n            }\n        }\n    }", "comment": "/**\n     * \u6263\u5e93\u5b58\n     */"}}
{"code": {"body": "    private BigDecimal getOrderPrice(List<OrderItem> orderItemList) {\n        BigDecimal bigDecimal = new BigDecimal(\"\");\n        for (OrderItem orderItem : orderItemList) {\n            bigDecimal = BigDecimalUtils.add(bigDecimal.doubleValue(), orderItem.getTotalPrice().doubleValue());\n        }\n        return bigDecimal;\n    }", "comment": "/**\n     * \u8ba1\u7b97\u8ba2\u5355\u7684\u603b\u4ef7\u683c\n     */"}}
{"code": {"body": "    private Long generateOrderNo() {\n        \n        return System.currentTimeMillis() + new Random().nextInt(100);\n        \n    }", "comment": "/**\n     * \u5c01\u88c5\u751f\u6210\u8ba2\u5355\u7f16\u53f7\u65b9\u6cd5\n     */"}}
{"code": {"body": "    private ServerResponse getCartOrderItem(Integer userId, List<Cart> cartList) {\n        if (cartList == null || cartList.size() == 0) {\n            return ServerResponse.createServerResponseByError(\"\");\n        }\n        List<OrderItem> orderItemList = Lists.newArrayList();\n        for (Cart cart : cartList) {\n            OrderItem orderItem = new OrderItem();\n            orderItem.setUserId(userId);\n            Product product = productMapper.selectByPrimaryKey(cart.getProductId());\n            if (product == null) {\n                return ServerResponse.createServerResponseByError(\"\" + cart.getProductId() + \"\");\n            }\n            if (product.getStatus() != Const.ProductStatusEnum.PRODUCT_ONLINE.getCode()) {\n                \n                return ServerResponse.createServerResponseByError(\"\" + product.getId() + \"\");\n            }\n            if (product.getStock() < cart.getQuantity()) {\n                \n                return ServerResponse.createServerResponseByError(\"\" + product.getId() + \"\");\n            }\n            orderItem.setQuantity(cart.getQuantity());\n            orderItem.setCurrentUnitPrice(product.getPrice());\n            orderItem.setProductId(product.getId());\n            orderItem.setProductImage(product.getMainImage());\n            orderItem.setProductName(product.getName());\n            orderItem.setTotalPrice(BigDecimalUtils.mul(product.getPrice().doubleValue(), cart.getQuantity().doubleValue()));\n\n            orderItemList.add(orderItem);\n        }\n        return ServerResponse.createServerResponseBySuccess(null, orderItemList);\n    }", "comment": "/**\n     * \u5c01\u88c5\u83b7\u5f97\u8d2d\u7269\u8f66\u5217\u8868\u7684\u65b9\u6cd5\n     */"}}
{"code": {"body": "    public ServerResponse login(String username, String password) {\n        \n        if(username==null||username.equals(\"\")){\n            return ServerResponse.createServerResponseByError(\"\");\n        }\n        if(password==null||password.equals(\"\")){\n            return ServerResponse.createServerResponseByError(\"\");\n        }\n        \n        int result = userInfoMapper.checkUsername(username);\n        if (result <= 0){\n            return ServerResponse.createServerResponseByError(\"\");\n        }\n        \n        UserInfo userInfo = userInfoMapper.selectUserInfoByUsernameAndPassword(username,MD5Utils.getMD5Code(password));\n        if(userInfo==null){\n            return ServerResponse.createServerResponseByError(\"\");\n        }\n        \n        userInfo.setPassword(\"\");\n        return ServerResponse.createServerResponseBySuccess(null,userInfo);\n    }", "comment": "/**\n     * \u63d0\u4ea4\u95ee\u9898\u7b54\u6848\n     */"}}
{"code": {"body": "    public ServerResponse register(UserInfo userInfo) {\n        \n        if (userInfo==null){\n            return ServerResponse.createServerResponseByError(\"\");\n        }\n        \n        int result = userInfoMapper.checkUsername(userInfo.getUsername());\n        if (result >0){\n            return ServerResponse.createServerResponseByError(\"\");\n        }\n        \n        int result_email = userInfoMapper.checkEmail(userInfo.getEmail());\n        if (result_email>0){ \n            return ServerResponse.createServerResponseByError(\"\");\n    }\n        \n        userInfo.setRole(Const.RoleEnum.ROLE_CUSTOMER.getCode());\n        userInfo.setPassword(MD5Utils.getMD5Code(userInfo.getPassword()));\n        int count = userInfoMapper.insert(userInfo);\n        if (count>0){\n            return ServerResponse.createServerResponseBySuccess(\"\");\n        }\n        \n        return ServerResponse.createServerResponseByError(\"\");\n    }", "comment": "/**\n     * \u63d0\u4ea4\u95ee\u9898\u7b54\u6848\n     */"}}
{"code": {"body": "    public ServerResponse forget_get_question(String username) {\n        \n        if (username==null||username.equals(\"\")){\n            return ServerResponse.createServerResponseByError(\"\");\n        }\n        \n        int result = userInfoMapper.checkUsername(username);\n        if (result==0){\n            \n            return ServerResponse.createServerResponseByError(\"\");\n        }\n        \n        String question = userInfoMapper.selectQuestionByUsername(username);\n        if (question==null||question.equals(\"\")){\n            return ServerResponse.createServerResponseByError(\"\");\n        }\n        return ServerResponse.createServerResponseBySuccess(question);\n    }", "comment": "/**\n     * \u63d0\u4ea4\u95ee\u9898\u7b54\u6848\n     */"}}
{"code": {"body": "    public static BigDecimal add(double d1,double d2){\n        BigDecimal bigDecimal = new BigDecimal(String.valueOf(d1));\n        BigDecimal bigDecimal1 = new BigDecimal(String.valueOf(d2));\n        return bigDecimal.add(bigDecimal1);\n    }", "comment": "/**\n     * \u52a0\u6cd5\u8fd0\u7b97\n     */"}}
{"code": {"body": "    public static BigDecimal sub(double d1,double d2){\n        BigDecimal bigDecimal = new BigDecimal(String.valueOf(d1));\n        BigDecimal bigDecimal1 = new BigDecimal(String.valueOf(d2));\n        return bigDecimal.subtract(bigDecimal1);\n    }", "comment": "/**\n     * \u51cf\u6cd5\u8fd0\u7b97\n     */"}}
{"code": {"body": "    public static BigDecimal mul(double d1,double d2){\n        BigDecimal bigDecimal = new BigDecimal(String.valueOf(d1));\n        BigDecimal bigDecimal1 = new BigDecimal(String.valueOf(d2));\n        return bigDecimal.multiply(bigDecimal1);\n    }", "comment": "/**\n     * \u4e58\u6cd5\u8fd0\u7b97\n     */"}}
{"code": {"body": "    public static BigDecimal div(double d1,double d2){\n        BigDecimal bigDecimal = new BigDecimal(String.valueOf(d1));\n        BigDecimal bigDecimal1 = new BigDecimal(String.valueOf(d2));\n        return bigDecimal.divide(bigDecimal1,2,BigDecimal.ROUND_HALF_UP);\n    }", "comment": "/**\n     * \u9664\u6cd5\u8fd0\u7b97\n     * \u4fdd\u7559\u4e24\u4f4d\u5c0f\u6570\uff0c\u56db\u820d\u4e94\u5165\n     */"}}
{"code": {"body": "    public boolean uploadFile(String remotePath,List<File> fileList,FTPUtils ftpUtils) throws IOException {\n        InputStream inputStream =null;\n        \n        if(connectFTPServer(ftpUtils)){\n            try {\n                ftpClient.changeWorkingDirectory(remotePath);\n                ftpClient.setBufferSize(1024);\n                ftpClient.setControlEncoding(\"\");\n                ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE);\n                ftpClient.enterLocalPassiveMode();\n                for (File file:fileList) {\n                    inputStream = new FileInputStream(file);\n                    ftpClient.storeFile(file.getName(),inputStream);\n                }\n                System.out.println(\"\");\n                return true;\n            } catch (IOException e) {\n                e.printStackTrace();\n                System.out.println(\"\");\n            }finally {\n                if(null != inputStream){\n                    inputStream.close();\n                }\n                if(null != ftpClient){\n                    ftpClient.disconnect();\n                }\n            }\n        }\n        return false;\n    }", "comment": "/**\n     * \u8fde\u63a5ftp\n     * @param remotePath:\u8fde\u63a5ftp\u7684\u8fdc\u7a0b\u5730\u5740\n     * @param fileList\uff1a\u8981\u4f20\u9001\u7684\u6587\u4ef6\u96c6\u5408\n     * @param ftpUtils\uff1a\n     * @return\n     */"}}
{"code": {"body": "  public static String getMD5Code(String strObj) {\n    String resultString = null;\n    try {\n      \n      resultString = new String(strObj+\"\");\n      MessageDigest md = MessageDigest.getInstance(\"\");\n      \n      resultString = byteToString(md.digest(strObj.getBytes()));\n    } catch (NoSuchAlgorithmException ex) {\n      ex.printStackTrace();\n    }\n    return resultString;\n  }", "comment": "/**\n   * \u52a0\u5bc6\n   *\n   * */"}}
{"code": {"body": "    public static String readByKey(String key){\n        return properties.getProperty(key);\n    }", "comment": "/**\n     * \u8bfb\u53d6\u914d\u7f6e\u6587\u4ef6\u7684\u5185\u5bb9\n     */"}}
{"code": {"body": "public static ArrayList<InsuranceScore> memberScoreAsessor(ArrayList<Health> memberData)\n{\n\tArrayList<InsuranceScore> assessment = new ArrayList<InsuranceScore>();\n\t\n\tfor (Health h: memberData) \n\t{\n\t\t\n\t\tInsuranceScore assess = new InsuranceScore(h.getFname().trim(),h.getLname().trim(),addScoreForMembers(h)); \n\t\tassessment.add(assess);\n\t}\n\t\n\treturn assessment;\n}", "comment": "/**memberScoreAssessor will assess risk score for each member. \n * \n * @param memberData\n * @return\n */"}}
{"code": {"body": "public static int addScoreForMembers(Health h) \n{\n\t\nint riskLevel =0; \ndouble bmi=0;\n\nbmi = ((double)(h.getWeight())/ (h.getHeight()* h.getHeight()))*703;\n\n{\n\tif (bmi>=18.5 && bmi <= 24.9)\n\t  {\n\t\t\triskLevel = riskLevel +0;\t\n\t  }\n\t\t\t\n\telse if (bmi>=25.0 && bmi <= 29.9) \n\t  {\n\t\t\t\triskLevel = riskLevel +30;\n\t  }\n\telse \n\t  {\n\t\t\t\triskLevel = riskLevel + 75;\n\t  }\n\t}\t     \n\t    \n\t\n{   \t\n\tif (h.getBpSystolic() < 120 && h.getBpDiastolic() <80)\n\t  {\n\t\triskLevel = riskLevel + 0;\n\t  }\n\telse if ((h.getBpSystolic() >= 120 && h.getBpSystolic() <=129) && h.getBpDiastolic() < 80)\n\t  {\n\t\t\n\t\triskLevel = riskLevel + 15;\n\t  }\n\telse if (h.getBpSystolic() >= 130 && h.getBpSystolic() <=139 || \n\t(h.getBpDiastolic() >=80 && h.getBpDiastolic() <=89))\n\t  {\n\t\triskLevel = riskLevel+ 30;\n\t  }\n\telse if (h.getBpSystolic() >= 140 || h.getBpDiastolic() >=90) \n\t  {\n\t\triskLevel = riskLevel+ 75;\n\t  }\n\n\telse if (h.getBpSystolic() >= 180 || h.getBpDiastolic() >=120)\n\t{\n\t\triskLevel = riskLevel+100;\n\t}\n\t     }\n\t     {\n\t    \t \n\t if(h.getAge() >= 30 && h.getAge() < 45) \n\t    {\n\t\triskLevel = riskLevel+10;\n\t    }\n\t else if (h.getAge() >= 45&& h.getAge() < 60) \n\t    {\n\t\t riskLevel = riskLevel+20;\n\t    }\n\t else if (h.getAge()>=60)\n\t    {\n\t\t riskLevel = riskLevel+30;\n\t     }\n\t     }\n\t     {\n\t  if (h.getCancer().contentEquals(\"\")) \n\t    \t {\n\t    \t\t riskLevel = riskLevel+10;\n\t    \t }\n\t   if (h.getDiabetes().contentEquals(\"\")) \n\t    \t {\n\t    \t\t riskLevel = riskLevel + 10;\n\t    \t }\n\t   if (h.getAlzheimers().contentEquals(\"\")) \n\t    \t {\n\t    \t\t riskLevel = riskLevel + 10;\n\t    \t } \n\t     }\n\t     return riskLevel;\n\t\t}", "comment": "/**\n * This addScoreForMembers will assign penalty points to members based on their age, blood pressure, BMI and disease in family (if any).\n * @\n */"}}
{"code": {"body": "public Health () {\n\t\t\tfname =\"\";\n\t\t\tlname =\"\";\n\t\t\tage =0;\n\t\t\theight=0;\n\t\t\tweight=0;\n\t\t\tbpSystolic=0;\n\t\t\tbpDiastolic=0;\n\t\t\tcancer=\"\";\n\t\t\tdiabetes=\"\";\n\t\t\talzheimers=\"\";\n\t\t\t\n\t\t}", "comment": "/**\n\t\t * This is a required default constructor to handle the Xml serialization.\n\t\t */"}}
{"code": {"body": "public Health(String fname, String lname, String age, String height, String weight, String bpSystolic, String bpDiastolic, String cancer, ", "comment": "/** Constructor used to set the values \n * \n * @param fname\n * @param lname\n * @param age\n * @param height\n * @param weight\n * @param bpSystolic\n * @param bpDiastolic\n * @param cancer\n * @param diabetes\n * @param alzheimers\n */"}}
{"code": {"body": "\t    public String getFname() {\n\t\t\treturn fname;\n\t\t}", "comment": "/** Getters and Setters used to access data\n * \n * @return\n */"}}
{"code": {"body": "public InsuranceScore(String fname, String lname, int score) {\n\t\tsetFname(fname);\n\t\tsetLname(lname);\n\t\tsetScore(score);\n\t\t\n    if (score <= 20) \n    {\n\t riskLevel = \"\";\n    }\n    else if (score > 20 && score <=50)\n    {\n\triskLevel = \"\";\n    }\n    else if (getScore() > 50 && score <=75)\n    {\n\triskLevel = \"\";\n    }\n    else {\n\triskLevel = \"\";\n    }\n\t\t\n\t}", "comment": "/**\n * Insurance score constructor that will calculate the riskLevel within itself.  \n * @param fname\n * @param lname\n * @param score\n */"}}
{"code": {"body": "public InsuranceScore() {\n\t\tfname=\"\";\n\t\tlname=\"\";\n\t\tscore=0;\n\t\triskLevel =\"\";\n\t}", "comment": "/**\n\t * Default constructor in case we need to serialize in Xml.\n\t */"}}
{"code": {"body": "\tpublic String toString() {\n\t\tString str = \"\";\n\t\tString firstLast = lname + \"\"+ fname;\n\t\t\n\t\tString scoreString = \"\" + score;\n\t\treturn String.format(\"\"\n\t\t\t\t\t\t\t+\"\" \n\t\t\t\t\t\t\t+\"\",\n\t\t\t\t\t\t\tfirstLast, scoreString, riskLevel);\n\t}", "comment": "/**\n * toString function will print the insurance details with risk assessment of members in a formatted way.\n */"}}
{"code": {"body": "\tpublic static void writeRiskInformation(ArrayList<InsuranceScore> assess) {\n\t\t\n\t\tfor (InsuranceScore ins: assess)\n\t\t{\n\t\t\tSystem.out.println(ins);\n\t\t}\t\n\t}", "comment": "/**writeRiskInformation function will write the risk assessment information for each member. \n * \n * @param assess\n */"}}
{"code": {"body": "\tpublic static boolean writeMembersToJSON(String fname, ArrayList<InsuranceScore> assessment) {\n    \ttry {\n    \t\t\n    \t\n    \t\tPrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(fname)));\n    \t\n    \t\tJSONObject memObj;\n    \t\tJSONArray jray= new JSONArray(); \n    \t\t\n    \t\tfor (InsuranceScore ins :assessment) {\n    \t\t\t\n    \t\t\tmemObj = new JSONObject();\n    \t\t\t\n    \t\t\t\n    \t\t\tmemObj.put(\"\",ins.getFname());\n    \t\t\tmemObj.put(\"\", ins.getLname());\n    \t\t\tmemObj.put(\"\", ins.getScore());\n    \t\t\tmemObj.put(\"\", ins.getRiskLevel());\n    \t\t\t\n    \t\t\tjray.add(memObj);\n    \t\t}\n          \n    \t\tJSONObject out = new JSONObject();\n    \t\tout.put(\"\", jray); \n    \t\t\n    \t\tpw.println(out.toJSONString());  \n    \t\tpw.close();\n    \t\treturn true;\n    \t}catch(Exception ex) {\n    \t\treturn false;\n    \t}\n}", "comment": "/**\n * WriteMembersToJSON function will allow the member risk assessment to be stored in a JSON file format. \n * @param fname\n * @param assessment\n * @return\n */"}}
{"code": {"body": "\t\tpublic static ArrayList<Health> insuranceFileReader(String fname) \n\t\t{\n\t\t\t\n\t\t\t \n\t\t\t    try {  \n\t\t\t    \tArrayList<Health> memberData = new ArrayList<Health>(); \n\t\t\t\t    \n\t\t\t        Scanner fsc = new Scanner(new File(fname)); \n\t\t\t       \n\t\t\t        String line;\n\t\t\t        \n\t\t\t        while (fsc.hasNextLine())  \n\t\t\t        {\n\t\t\t            line = fsc.nextLine().trim(); \n\t\t\t            String[] lineparts = line.split(\"\"); \n\t\t\t           \n\t\t\t           Health member = new Health( lineparts[0],lineparts[1],lineparts[2],lineparts[3],lineparts[4],lineparts[5],\n\t\t\t        \t\t   lineparts[6],lineparts[7],lineparts[8], lineparts[9]);\n\t\t\t           \n\t\t\t           memberData.add(member); \n\t\t\t        } \n\t\t\t        fsc.close(); \n\t\t\t        return memberData; \n\t\t\t        \n\t\t\t        } catch (Exception ex) \n\t\t\t    {\n\t\t\t        return null; \n\t\t\t    }\n\t\t}", "comment": "/** This function will read the tab delimited test file and store into an ArrayList.\n * \n * @param fname\n * @return\n */"}}
{"code": {"body": "\t\tpublic static ArrayList<Health> readMemberDataFromBinary(String fname){\n\t\t\ttry {\n\n\t\t\t\tObjectInputStream ois = new ObjectInputStream(new FileInputStream(fname));\n\t\t\n\t\t\t\tArrayList <Health> result = (ArrayList<Health>)ois.readObject();\n\t\t\t\tois.close();\n\t\t\t\t\n\t\t\t\treturn result;\n\t\t\t\t\n\t\t\t}catch (Exception ex) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}", "comment": "/**readDataFromBinary function will read back data from stored binary file, it will be used to count number of members read/stored from binary.\n *  \n * @param fname\n * @return\n */"}}
{"code": {"body": "\t\tpublic static ArrayList<Health> readMemberDataFromXml(String fname){\n\t\t\ttry {\n\n\t\t\t\tXMLDecoder xml = new XMLDecoder(new BufferedInputStream(new FileInputStream(fname)));\n\t\t\n\t\t\t\tArrayList <Health> result = (ArrayList<Health>)xml.readObject();\n\t\t\t\txml.close();\n\t\t\t\treturn result;\n\t\t\t} catch (Exception ex) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}", "comment": "/**readMemberDataFromXml function will read back data from stored XML file, it will be used to count/read number of members from the file. \n * \n * @param fname\n * @return\n */"}}
{"code": {"body": "\tpublic static void printMembers(ArrayList<Health> memberData) {\n\t\tfor (Health h: memberData) {\n\t\t\n\t\tSystem.out.println(h);\n\t}\n\t}", "comment": "/** this function will print members from file to the screen with formatting.\n * \n * @param memberData\n */"}}
{"code": {"body": "\tpublic static boolean saveMembertoText(String fname, ArrayList<Health> memberData) \n\t{\n\t\t\n\t\t    try \n\t\t\t\t{\n\n\t\t\tPrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(new File(fname))));\n\t\t\t\n\t\t\tfor (Health m:memberData) \n\t\t\t{\n\t\t\t\tpw.println(m.getFname()+\"\"+ m.getLname()+\"\" + m.getAge()+ \"\"+ m.getHeight()+ \"\"+m.getWeight()+\"\" +m.getBpSystolic() +\"\"\n\t\t\t\t+ m.getBpDiastolic() + \"\"\n\t\t\t\t+ m.getCancer()+\"\" +m.getDiabetes() +\"\"+m.getAlzheimers());\n\t\t\t}\n\t\t\tpw.close();  \n\t\t\treturn true;\n\t\t        } catch (Exception ex) \n\t\t\t\t{\n\t\t\t      return false;\n\t\t        }\n\t}", "comment": "/** This function will save member data from ArrayList to the text file in tab delimited file format.\n * \n * @param fname\n * @param memberData\n * @return\n */"}}
{"code": {"body": "\tpublic static boolean saveMembertoBinary(String fname, ArrayList<Health> memberData) \n    {\n\t\t    try {  \n\n\t            ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File(fname)));\n\t\n\t            oos.writeObject(memberData);  \n\t            oos.close();\n\t            return true; \n                } catch (Exception ex) \n\t\t    {\n\t              return false; \n            }\n    }", "comment": "/** This function will save member data from ArrayList into BinaryFile format\n * \n * @param fname\n * @param memberData\n * @return\n */"}}
{"code": {"body": "    public static boolean saveStudentsToXML(String fname, ArrayList<Health> memberData ) \n    {\n            try {\n\n                XMLEncoder xml = new XMLEncoder(new BufferedOutputStream(new FileOutputStream(fname)));\n                xml.writeObject(memberData);\n                xml.close();           \n                return true;           \n            } catch (Exception ex) \n            {\n                return false;\n            }\n        }", "comment": "/** This function will save members in Array List in a XML file format\n * \n * @param fname\n * @param memberData\n * @return\n */"}}
{"code": {"body": "public static void welcome() {\n\tSystem.out.println(\"\");\n\tSystem.out.println(\"\");\n\tSystem.out.println(\"\");\n\tSystem.out.println(\"\");\n\tSystem.out.println(\"\");\n\tSystem.out.println(\"\");\n\tSystem.out.println(\"\");\n\tSystem.out.println(\"\");\n\tSystem.out.println(\"\");\n\tSystem.out.println(\"\");\n}", "comment": "/*\n * Welcome function will print the greeting message to the screen.\n */"}}
{"code": {"body": "public static void showMenu() {\n\tSystem.out.println(\"\");\n\tSystem.out.println(\"\");\n\tSystem.out.println(\"\");\n\tSystem.out.println(\"\");\n\tSystem.out.println(\"\");\n\tSystem.out.println(\"\");\n\tSystem.out.println(\"\");\n\tSystem.out.println(\"\");\n\tSystem.out.print(\"\");\n}", "comment": "/**\n * This Show Menu function will print list of options that user can choose from.\n */"}}
{"code": {"body": "public static void addMember(ArrayList<Health> memberData) {\n\t\n\t\n\t\n\tScanner sc = new Scanner(System.in);\n\tString fname,lname,age,weight,height,bpSys,bpDias,cancer, diabetes, alzheimers;\n\t\n\tHealth hlt;\n\n\tSystem.out.print(\"\");\n\tfname = sc.nextLine().trim();\n\t\n\tSystem.out.print(\"\");\n\tlname = sc.nextLine().trim();\n\t\n\tSystem.out.print(\"\");\n\tage= sc.nextLine().trim();\n\t\n\tSystem.out.print(\"\");\n\theight = sc.nextLine().trim();\n\t\n\tSystem.out.print(\"\");\n\tweight = sc.nextLine().trim();\n\t\n\tSystem.out.print(\"\");\n\tbpSys= sc.nextLine();\n\tString [] lineparts = bpSys.split(\"\");\n\tbpSys = lineparts[0];\n\tbpDias= lineparts[1];\n\t\n\tSystem.out.println(\"\");\n    System.out.print(\"\");\n    cancer = sc.nextLine().trim();\n    \n    System.out.print(\"\");\n    diabetes = sc.nextLine().trim();\n    \n    System.out.print(\"\");\n    alzheimers = sc.nextLine().trim();\n\t\n\t\n\thlt = new Health(fname,lname,age,height, weight,bpSys, bpDias, cancer, diabetes, alzheimers );\n\tmemberData.add(hlt);\n\t\n\tSystem.out.println(\"\");\n}", "comment": "/**\n * \tThis addMember function will allow the user to enter a new member.\n */"}}
{"code": {"body": "public static void main (String[] args) {\n\tString fname;\n\tint choice;\n\tString type;\ntry {\t\n\tScanner sc = new Scanner(System.in);\n\twelcome();  \n\t\n\tSystem.out.print(\"\");   \n\tfname = sc.next();\n\tArrayList<Health> memberData = MemberReader.insuranceFileReader(fname);  \n\t\n\t\n\t\tArrayList<InsuranceScore> assessment = Assessor.memberScoreAsessor(memberData);\n\t\t\n\tif (memberData==null)  \n\t{\n\t\tSystem.out.println(\"\");\n\t}\n\t\n\telse {\n\t\t\n\t\tdo {\n\t\t\t\n\tshowMenu(); \n\tchoice = sc.nextInt();\n\n\n\tif (choice==1) \n\t{\n\t\n\tMemberWriter.printMembers(memberData); \n\t}\n\n\telse if (choice ==2 ) \n\t{\n\t\taddMember(memberData); \n\t}\n\n\telse if (choice==3)\n\t\t{\n\t\t\tSystem.out.print(\"\");\n\t\t\ttype = sc.next();\n\t\n\t\t\tif (type.equals(\"\") || type.equals(\"\")) \n\t\t\t{\n\t\t\t\tSystem.out.print(\"\");\n\t\t\t\tfname = sc.next();\n\t\n\t\t\t\tif (MemberWriter.saveMembertoText(fname, memberData)) \n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"\");\n\t\t\t\t}\n\t\t\t\telse \n\t\t\t\t\tSystem.out.println(\"\");\n\t\t\t}\n\t\n\t\t\telse if (type.contentEquals(\"\") || type.contentEquals(\"\"))\n\t\t\t{\n\t\t\t\tSystem.out.print(\"\");\n\t\t\t\tfname = sc.next();\n\t\n\t\t\t\tif (MemberWriter.saveMembertoBinary(fname, memberData))\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"\");\n\t\t\t\t}\n\t\t\t\telse \n\t\t\t\t\tSystem.out.println(\"\");\n\t\t\t}\n\t\n\t\t\telse if (type.contentEquals(\"\") || type.contentEquals(\"\"))\n\t\t\t{\n\t\t\t\tSystem.out.print(\"\");\n\t\t\t\tfname = sc.next();\n\t\n\t\t\t\tif (MemberWriter.saveStudentsToXML(fname, memberData)) {\n\t\t\t\t\tSystem.out.println(\"\");\n\t\t\t\t}\n\t\t\t\telse \n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"\");\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\t\n\t\telse if (choice==4) \n\t\t{\n\t\t\t\n\t\t\tSystem.out.print(\"\");\n\t\t\ttype = sc.next();\n\t\t\t\n\t\n\t\t\tif (type.contentEquals(\"\") || type.contentEquals(\"\")) \n\t\t\t{\n\t\t\t\tSystem.out.print(\"\");\n\t\t\t\tfname = sc.next();\n\t\n\t\t\tArrayList<Health> readBackBinary = MemberReader.readMemberDataFromBinary(fname);\n\t\t\t\n\t\t\tif (readBackBinary == null) \n\t\t\t{\n\t\t\t\tSystem.out.println(\"\");\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tSystem.out.println(readBackBinary.size()+\"\");\n\t\t\t}\n\t\t\t}\n\t\n\t\t\telse if (type.contentEquals(\"\") || type.contentEquals(\"\"))\n\t\t\t{\n\t\t\t\tSystem.out.print(\"\");\n\t\t\t\tfname = sc.next();\n\t\t\t\t\n\t\n\t\t\tArrayList<Health> readBackXml = MemberReader.readMemberDataFromXml(fname);\n\t\t\t\n\t\t\tif (readBackXml==null) \n\t\t\t{\n\t\t\t\tSystem.out.println(\"\");\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tSystem.out.println(readBackXml.size() +\"\");\n\t\t\t}\n\t\t\t}\n\t\n\t\t\telse if (type.equals(\"\") || type.equals(\"\"))\n\t\t\t{\n\t\t\t\tSystem.out.print(\"\");\n\t\t\t\tfname = sc.next();\n\t\t\t\t\n\t\n\t\t\t\tArrayList<Health> readBackText = MemberReader.insuranceFileReader(fname);\n\t\t\t\t\n\t\t\t\tif (readBackText== null) \n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"\");\n\t\t\t\t}\n\t\t\t\telse \n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(readBackText.size() + \"\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telse if (choice==5) \n\t\t{\n\t\t\tSystem.out.println(\"\");\n\t\t\t\n\t\t\tfor (InsuranceScore ins: Assessor.memberScoreAsessor(memberData)) \n\t\t\t{\n\t\t\t\tSystem.out.print(ins);\n\t\t\t}\n\t\t}\n\n\t\telse if (choice==6) \n\t\t{\n\t\t\tSystem.out.print(\"\");\n\t\t\tfname = sc.next();\n      \n\t\t\tif (InsuranceScoreWriter.writeMembersToJSON(fname, assessment)) {\n\t\t\t\tSystem.out.println(\"\");\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tSystem.out.println(\"\");\n\t\t\t}\n\t\t}\n\t\t} \n\t\t\twhile(choice!= 7 ); \n\t\t{\n\t\t\tSystem.out.println(\"\");\n\t\t\tSystem.out.println(\"\");\n\t\t\tSystem.out.println(\"\");\n\t\t\tSystem.out.println(\"\");\n\t\t\tSystem.out.println(\"\");\n\t\t\tSystem.out.println(\"\");\n\t\t}\n\t}\n\t} catch (Exception ex) \n      {\n\t\tSystem.out.println(\"\");\t\n      }\n\t}", "comment": "/*\n * Begin Main function ...\n */"}}
{"code": {"body": "    public static void geneseegame() {\n    \tPlaygame(hole_g, yardage_g, par_g);\t\n\t}", "comment": "/*This method(geneseegame()) uses the the above final values/arraylists \n    when calling the method Playgame(hole_g, yardage_g, par_g) from the class playgame.*/"}}
{"code": {"body": "\tpublic static void oldCoursegame() {\n\t\tPlaygame(hole_o, yardage_o, par_o);\n\t}", "comment": "/*This method(geneseegame()) uses the the above final values/arraylists \n     when calling the method Playgame(hole_o, yardage_o, par_o) from the class playgame.*/"}}
{"code": {"body": "    public static void mastergame() {\n    \tPlaygame(hole_m, yardage_m, par_m);\n\t}", "comment": "/*This method(geneseegame()) uses the the above final values/arraylists \n    when calling the method Playgame(hole_m, yardage_m, par_m) from the class playgame.*/"}}
{"code": {"body": "\tpublic static void lovegame() {\n\t\tScanner scnr = new Scanner(System.in);\n\t\t\n\t\tCourse play1 = new Course();\n\t\t\n\t\tSystem.out.print(\"\"+\"\"+\n\t\t\t\t\"\"+\"\" \n\t\t\t\t+\"\"+\"\"\n\t\t         +\"\");\n\t\t\n\t\tSystem.out.print(\"\");\n\t\tint courseNum = scnr.nextInt();\n\t\t\n\t\t\n\t\tif (courseNum == 1) {\n\t\t\tSystem.out.println(\"\");\n\t\t\tplay1.geneseegame();  \n\t\t}\n\t\telse if (courseNum == 2) {\n\t\t\tSystem.out.println(\"\");\n\t\t\tplay1.oldCoursegame();  \n\t\t}\n\t\telse if (courseNum == 3) {\n\t\t\tSystem.out.println(\"\");\n\t\t\tplay1.mastergame();  \n\t\t}\n\t\telse {\n\t\t\tSystem.out.print(\"\");\n\t\t}\n\t\t\n\t}", "comment": "/*This method has instances of type course and asks the user for Course Number and based on the user \n\tpreferences, it calls for the type of course the user chose to play. If the user chooses a course Number\n\twhich is not in the list, the program will quit executing a print line statement with information.*/"}}
{"code": {"body": "public Controller(Model model) {\n\t\tthis.model = model;\n\t\tthis.vue1 = new Map(this, model.getStations());\n\t\taddListenersToModel();\n\t}", "comment": "/**\n\t * A\u00f1ade un listener al modelo\n\t */"}}
{"code": {"body": "\tprivate void addListenersToModel() {\n\t\tthis.model.addListener(vue1);\n\t}", "comment": "/**\n\t * A\u00f1ade un listener al modelo\n\t */"}}
{"code": {"body": "\tpublic void notifyWayChanged(String origin, String destination)\n\t\t\tthrows Exception {\n\t\tmodel.ok(origin, destination);\n\t}", "comment": "/**\n\t * Si pinchamos en ok, este m\u00e9todo est\u00e1 llamado para empezar a buscar el\n\t * camino\n\t * \n\t * @param origin\n\t * @param destination\n\t * @throws Exception\n\t */"}}
{"code": {"body": "public AlgoA(int[][] distances) {\n\t\tthis.distances = distances;\n\t\t\n\t\tthis.openedList = new ArrayList<>();\n\t\tthis.closedList = new ArrayList<>();\n\t\tthis.way = new ArrayList<>();\n\t\t\n\t\tthis.sf = null;\n\t}", "comment": "/* Devuelve el camino m\u00e1s corto entre si y sf */"}}
{"code": {"body": "\tpublic ArrayList<Station> findWay(Station si, Station sf) {\n\t\tthis.sf = sf;\n\n\t\t\n\t\tthis.openedList.clear();\n\t\tthis.closedList.clear();\n\t\tthis.way.clear();\n\t\t\n\t\tthis.openedList.add(si);\n\t\tfind(si);\n\t\t\n\t\tif (si.equals(sf)) {\n\t\t\tArrayList<Station> a = new ArrayList<>();\n\t\t\ta.add(sf);\n\t\t\treturn a;\n\t\t}\n\t\treturn this.way;\n\t}", "comment": "/* Devuelve el camino m\u00e1s corto entre si y sf */"}}
{"code": {"body": "\tprivate void find(Station padre) {\n\t\t\n\t\tfor (int i = 0; i < padre.getNeighbours().size(); i++) {\n\t\t\t\n\t\t\tint gPH = this.distances[padre.getId()][padre.getNeighbours()\n\t\t\t\t\t.get(i).getId()];\n\t\t\t\n\t\t\tint g = gPH + padre.getG();\n\t\t\t\n\t\t\tint f = g\n\t\t\t\t\t+ this.distances[padre.getNeighbours().get(i).getId()][this.sf\n\t\t\t\t\t\t\t.getId()];\n\t\t\t\n\n\t\t\t\n\t\t\tif ((f < padre.getNeighbours().get(i).getF() && padre\n\t\t\t\t\t.getNeighbours().get(i).getF() != 0)\n\t\t\t\t\t|| padre.getNeighbours().get(i).getF() == 0) {\n\t\t\t\t\n\t\t\t\tpadre.getNeighbours().get(i).setG(g);\n\t\t\t\tpadre.getNeighbours().get(i).setF(f);\n\t\t\t\t\n\t\t\t\tpadre.getNeighbours().get(i).addWayToHere(padre.getWayToHere());\n\t\t\t\tpadre.getNeighbours().get(i).addWayToHere(padre);\n\t\t\t}\n\t\t}\n\n\t\t\n\t\talmacenar(padre.getNeighbours());\n\n\t\t\n\t\tArrayList<Station> stationClone = (ArrayList<Station>) this.openedList\n\t\t\t\t.clone();\n\t\tthis.openedList.clear();\n\t\treordenar(stationClone);\n\n\t\t\n\t\tthis.closedList.add(this.openedList.get(0));\n\t\tthis.openedList.remove(0);\n\n\t\t\n\t\tStation padre1 = this.closedList.get(this.closedList.size() - 1);\n\t\t\n\t\tif (!padre1.equals(sf)) {\n\t\t\t\n\t\t\tfind(padre1);\n\t\t} else {\n\t\t\tthis.way.addAll(padre1.getWayToHere());\n\t\t\tthis.way.add(sf);\n\t\t}\n\t}", "comment": "/**\n\t * Encuentra recursivamente el mejor camino con el algo A*, almacena en los\n\t * atributos, almacena en wayToHere de cada nodo el camino m\u00e1s corto para ir\n\t * al nodo desde si\n\t * \n\t * @param padre\n\t */"}}
{"code": {"body": "\tpublic void almacenar(ArrayList<Station> s) {\n\t\tfor (int i = 0; i < s.size(); i++) {\n\t\t\tif (!this.openedList.contains(s.get(i))\n\t\t\t\t\t&& !this.closedList.contains(s.get(i))) {\n\t\t\t\tthis.openedList.add(s.get(i));\n\t\t\t}\n\t\t}\n\t}", "comment": "/**\n\t * Pone en la lista abierta todos las estaciones de s que no ya est\u00e1n en la\n\t * lista abierta ni en la lista cerrada\n\t * \n\t * @param s\n\t */"}}
{"code": {"body": "\tpublic void reordenar(ArrayList<Station> stationClone) {\n\t\tif (stationClone.size() > 0) {\n\t\t\tfor (int i = 0; i < stationClone.size(); i++) {\n\t\t\t\tint j = findMin(stationClone);\n\t\t\t\tthis.openedList.add(stationClone.get(j));\n\t\t\t\tstationClone.remove(j);\n\t\t\t\treordenar(stationClone);\n\t\t\t}\n\t\t}\n\t}", "comment": "/**\n\t * Reordena la lista de estaci\u00f3n por m\u00ednimo de f, almacena la nueva lista en\n\t * la lista abierta : openedList\n\t * \n\t * @param stationClone\n\t */"}}
{"code": {"body": "\tpublic int findMin(ArrayList<Station> s) {\n\t\tint j = 0;\n\t\tint min = s.get(0).getF();\n\t\tfor (int i = 1; i < s.size(); i++) {\n\t\t\tif (min > s.get(i).getF()) {\n\t\t\t\tmin = s.get(i).getF();\n\t\t\t\tj = i;\n\t\t\t}\n\t\t}\n\t\treturn j;\n\t}", "comment": "/**\n\t * Devuelve el id de la estaci\u00f3n que tiene el f m\u00ednimo en toda la lista\n\t * \n\t * @param s\n\t * @return\n\t */"}}
{"code": {"body": "public Model() {\n\t\tthis.parser = new ParserData();\n\t\tthis.distance = this.parser.getDistances();\n\t\tthis.stations = this.parser.getStation();\n\t\tthis.way = new ArrayList<>();\n\n\t\tthis.algo = new AlgoA(this.distance);\n\n\t\tthis.ecouteurs = new EventListenerList();\n\t}", "comment": "/**\n\t * Busca los objetos estaciones correspondientes al origen y destino, y\n\t * llama al algoritmo para encontrar el camino\n\t * \n\t * @param origin\n\t * @param destination\n\t */"}}
{"code": {"body": "\tpublic void ok(String origin, String destination) {\n\t\t\n\t\tclearAllStation();\n\t\tStation si = null, sf = null;\n\t\tfor (int i = 0; i < stations.length; i++) {\n\t\t\tif (stations[i].getName().equals(origin)) {\n\t\t\t\tsi = stations[i];\n\t\t\t}\n\t\t\tif (stations[i].getName().equals(destination)) {\n\t\t\t\tsf = stations[i];\n\t\t\t}\n\t\t\tif (sf != null && si != null)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (sf == null || si == null) {\n\t\t\tSystem.out.println(\"\");\n\t\t\tSystem.out.println(\"\" + si + \"\" + sf);\n\t\t}\n\t\tthis.way = algo.findWay(si, sf);\n\t\tfireWayChanged();\n\t}", "comment": "/**\n\t * Busca los objetos estaciones correspondientes al origen y destino, y\n\t * llama al algoritmo para encontrar el camino\n\t * \n\t * @param origin\n\t * @param destination\n\t */"}}
{"code": {"body": "\tprivate void clearAllStation() {\n\t\tfor (int i = 0; i < this.stations.length; i++) {\n\t\t\tthis.stations[i].clear();\n\t\t}\n\t}", "comment": "/**\n\t * Limpia todas las estaciones de los posibles g, h, f y caminos registrados\n\t */"}}
{"code": {"body": "\tpublic void addListener(FindWayListener ecouteur) {\n\t\tecouteurs.add(FindWayListener.class, ecouteur);\n\t}", "comment": "/**\n\t * A\u00f1ade listener\n\t * \n\t * @param ecouteur\n\t */"}}
{"code": {"body": "public ParserData() {\n\t\tread();\n\t}", "comment": "/**\n\t * Lee el fichero, y rellena distances y stations\n\t */"}}
{"code": {"body": "\tprivate void read() {\n\n\t\t\n\t\ttry {\n\t\t\t\tClass c = Class.forName(\"\");\n\t\t\t\tInputStream ips = c.getResourceAsStream(FILENAME);\n\t            InputStreamReader ipsr = new InputStreamReader(ips);\n\t            BufferedReader br = new BufferedReader(ipsr);\n\t\t\t\n\t\t\tString s;\n\t\t\twhile ((s = br.readLine()) != null) {\n\t\t\t\t\n\t\t\t\tswitch (s) {\n\t\t\t\tcase \"\":\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"\":\n\t\t\t\t\ts = br.readLine();\n\t\t\t\t\tparseStations(s);\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tcase \"\":\n\t\t\t\t\tint i = 0;\n\t\t\t\t\twhile ((s = br.readLine()) != null) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (s.charAt(0) == '') {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparseLinks(s, i);\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t\n\t\t\te.printStackTrace();\n\t\t}catch (ClassNotFoundException e){\n\t\t\te.printStackTrace();\n\t\t} \n\t}", "comment": "/**\n\t * Lee el fichero, y rellena distances y stations\n\t */"}}
{"code": {"body": "\tprivate void parseStations(String s) {\n\t\tString[] station = s.split(\"\");\n\t\tint n = station.length;\n\t\tthis.distances = new int[n][n];\n\t\tthis.stations = new Station[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstations[i] = new Station(station[i], i);\n\t\t}\n\t}", "comment": "/**\n\t * Rellena station con todas la estaciones encontradas en el fichero\n\t * \n\t * @param s\n\t */"}}
{"code": {"body": "\tprivate void parseLinks(String s, int stationTreat) {\n\t\tString[] block = s.split(\"\");\n\t\tparseDistance(block[0], stationTreat);\n\t\tparseNeighbours(block[1], stationTreat);\n\t}", "comment": "/**\n\t * Rellena las distancias entre las estaciones y a\u00f1ade las estaciones\n\t * vecinas a las estaciones encontrados en s\n\t * \n\t * @param s\n\t * @param stationTreat\n\t */"}}
{"code": {"body": "\tprivate void parseDistance(String s, int stationTreat) {\n\t\tString[] block = s.split(\"\");\n\t\tfor (int i = 0; i < this.distances.length; i++) {\n\t\t\tthis.distances[stationTreat][i] = Integer.parseInt(block[i]);\n\t\t}\n\t}", "comment": "/**\n\t * Rellena distances[][] con s por la estaci\u00f3n stationTreat\n\t * \n\t * @param s\n\t * @param stationTreat\n\t */"}}
{"code": {"body": "\tprivate void parseNeighbours(String s, int stationTreat) {\n\t\tString[] block = s.split(\"\");\n\t\tfor (int i = 0; i < block.length; i++) {\n\t\t\tthis.stations[stationTreat]\n\t\t\t\t\t.addStationNeighbours(this.stations[Integer\n\t\t\t\t\t\t\t.parseInt(block[i])]);\n\t\t}\n\t}", "comment": "/**\n\t * A\u00f1ade los vecinos a la estaci\u00f3n stationTreat\n\t * \n\t * @param s\n\t * @param stationTreat\n\t */"}}
{"code": {"body": "public Map(Controller controleur, Station[] stations){\n\t\tthis.controleur = controleur;\n\t\tthis.stations = stations;\n\t\tthis.positionStation = new HashMap<>();\n\t\tfor (int i = 0; i < stations.length; i++) {\n\t\t\tthis.positionStation.put(stations[i], POSITIONS.get(i));\n\t\t}\n\t\ttry {\n\t\t\tthis.drawCombo();\n\t\t\tthis.draw(new ArrayList<Station>(), 0, 0);\n\t\t} catch (IOException e) {\n\t\t\t\n\t\t\te.printStackTrace();\n\t\t}\n\t}", "comment": "/**\n\t * Inicializa los JCombobox\n\t */"}}
{"code": {"body": "\tprivate void drawCombo() {\n\t\tthis.comboOrigin = new JComboBox<String>();\n\t\tthis.comboDestination = new JComboBox<String>();\n\t\t\n\t\tfor (int i = 0; i < stations.length; i++) {\n\t\t\tthis.comboOrigin.addItem(stations[i].getName());\n\t\t\tthis.comboDestination.addItem(stations[i].getName());\n\t\t}\n\t\tthis.buttonOk = new JButton(\"\");\n\t\tbuttonOk.addActionListener(this);\n\t}", "comment": "/**\n\t * Inicializa los JCombobox\n\t */"}}
{"code": {"body": "\tprivate void drawCamino(ArrayList<Station> stations) {\n\t\t\n\t\tfor (Station s : stations) {\n\t\t\tg.setColor(Color.RED);\n\t\t\tg.fillOval(positionStation.get(s).getX() - 5, positionStation\n\t\t\t\t\t.get(s).getY() - 5, RADIUS, RADIUS);\n\t\t}\n\t}", "comment": "/**\n\t * Dibuja un c\u00edrculo a cada estaci\u00f3n en par\u00e1metro\n\t * \n\t * @param stations\n\t */"}}
{"code": {"body": "\tpublic void wayChanged(FindWayEvent event) {\n\t\tArrayList<Station> s = event.getStationsWay();\n\t\ttry {\n\t\t\tthis.draw(s, s.get(0).getId(), s.get(s.size() - 1).getId());\n\t\t} catch (IOException e) {\n\t\t\t\n\t\t\te.printStackTrace();\n\t\t}\n\t}", "comment": "/**\n\t * Una vez encontrado el camino, el modelo se\u00f1ala al mapa por este m\u00e9todo\n\t */"}}
{"code": {"body": "public AppRevJPATest(String testName )", "comment": "/**\n     * Create the test case\n     *\n     * @param testName name of the test case\n     */"}}
{"code": {"body": "    public static Test suite()\n    {\n        return new TestSuite( AppRevJPATest.class );\n    }", "comment": "/**\n     * @return the suite of tests being tested\n     */"}}
{"code": {"body": "    public void testApp()\n    {\n        assertTrue( true );\n    }", "comment": "/**\n     * Rigourous Test :-)\n     */"}}
{"code": {"body": "public AdminServlet() {\n        super();\n        \n    }", "comment": "/**\n     * @see HttpServlet#HttpServlet()\n     */"}}
{"code": {"body": "\tprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\t\n\t}", "comment": "/**\n\t * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)\n\t */"}}
{"code": {"body": "\tprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\t\n\t}", "comment": "/**\n\t * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)\n\t */"}}
{"code": {"body": "\tprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\t\n\t\tdoPost(request,response);\n\t}", "comment": "/**\n\t * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)\n\t */"}}
{"code": {"body": "\tprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\t\n\t\trequest.setCharacterEncoding(\"\");\n        response.setContentType(\"\");\n        response.setCharacterEncoding(\"\");\n\n        \n\t\tString method=request.getParameter(\"\");\n\t\tif(method.endsWith(\"\")){\n\n\t\t\tlogin(request, response);\n\t\t\t\n\t\t}\n\t\telse if(method.endsWith(\"\")){\n\n\t\t\taddT(request,response);\n\t\t}\n\t\telse if(method.endsWith(\"\")){\n\n\t\t\taddS(request,response);\n\t\t}\n\t\telse if(method.endsWith(\"\")){\n\t\t\tmodifyT(request, response);\n\t\t}\n\t\telse if(method.endsWith(\"\")){\n\t\t\tmodifyS1(request, response);\n\t\t}\n\t\telse if(method.endsWith(\"\")){\n\t\t\tmodifyS2(request, response);\n\t\t}\n\t\t\n\t\telse if(method.endsWith(\"\")){\n\t\t\tdeleteS(request, response);\n\t\t}\n\t\telse if(method.endsWith(\"\")){\n\t\t\tdeleteT(request, response);\n\t\t}\n\t}", "comment": "/**\n\t * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)\n\t */"}}
{"code": {"body": "\tpublic static List<Student> selectStu_All()throws SQLException{\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\n\t\tResultSet rs = null;\n\t\t\n\t\tList<Student> stu = new ArrayList<Student>();\n\t\t\n\t\ttry {\n\t\t\tconn = DBcon.getConnection();\n\t\t\tString sql = \"\";\n\t\t\tps = conn.prepareStatement(sql);\n\t\t\trs = ps.executeQuery();\n\t\t\twhile(rs.next()) {\n\t\t\t\tString sno = rs.getString(\"\");\n\t\t\t\tString spasswd = rs.getString(\"\");\n\t\t\t\tString sname = rs.getString(\"\");\n\t\t\t\tString course = rs.getString(\"\");\n\t\t\t\tint grade = rs.getInt(\"\");\n\t\t\t\tStudent st = new Student(sno,sname,spasswd,course,grade);\n\t\t\t\tstu.add(st);\n\t\t\t}\n\t\t}catch(SQLException e) {\n\t\t\te.printStackTrace();\n\t\t}finally {\n\t\t\tif(rs != null) {\n\t\t\t\ttry {\n\t\t\t\t\trs.close();\n\t\t\t\t} catch (SQLException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ps != null) {\n\t\t\t\ttry {\n\t\t\t\t\tps.close();\n\t\t\t\t} catch (SQLException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(conn != null) {\n\t\t\t\ttry {\n\t\t\t\t\tconn.close();\n\t\t\t\t} catch (SQLException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn stu;\n\t}", "comment": "/**\n\t * \u67e5\u8be2\u5168\u90e8\n\t * @return\n\t */"}}
{"code": {"body": "\tpublic static Student selectStu_Sno(String sno) throws SQLException{\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\tResultSet rs = null;\n\t\tStudent st = null;\n\t\ttry {\n\t\t\tconn = DBcon.getConnection();\n\t\t\tString sql = \"\";\n\t\t\tps = conn.prepareStatement(sql);\n\t\t\tps.setNString(1, sno);\n\t\t\trs = ps.executeQuery();\n\t\t\twhile(rs.next()) {\n\t\t\t\tString sno1 = rs.getString(\"\");\n\t\t\t\tString sname = rs.getString(\"\");\n\t\t\t\tString spasswd = rs.getString(\"\");\n\t\t\t\tString course = rs.getString(\"\");\n\t\t\t\tint grade = rs.getInt(\"\");\n\t\t\t\tst = new Student(sno1,sname,spasswd,course,grade);\n\t\t\t}\n\t\t}catch(SQLException e) {\n\t\t\te.printStackTrace();\n\t\t}finally {\n\t\t\tif(rs != null) {\n\t\t\t\ttry {\n\t\t\t\t\trs.close();\n\t\t\t\t} catch (SQLException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ps!= null) {\n\t\t\t\ttry {\n\t\t\t\t\tps.close();\n\t\t\t\t} catch (SQLException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(conn != null) {\n\t\t\t\ttry {\n\t\t\t\t\tconn.close();\n\t\t\t\t} catch (SQLException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn st;\n\t}", "comment": "/**\n\t *\u6839\u636e\u5b66\u53f7\u67e5\u8be2\n\t * @param sno\n\t * @return\n\t */"}}
{"code": {"body": "\tpublic static String insertStu(Student stu)throws SQLException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = DBcon.getConnection();\n\t\t\tString sql = \"\";\n\t\t\tps = conn.prepareStatement(sql);\n\t\t\t\n\t\t\tps.setString(1, stu.getSno());\n\t\t\tps.setString(2, stu.getSpasswd());\n\t\t\tps.setString(3, stu.getSname());\n\t\t\tps.setString(4, stu.getCourse());\n\t\t\tps.setInt(5, stu.getGrade());\n\t\t\tint insertCount = ps.executeUpdate();\n\t\t\tSystem.out.println(isSuccess(insertCount));\n\t\t\treturn isSuccess(insertCount);\n\t\t}catch(SQLException e) {\n\t\t\treturn \"\"+e;\n\t\t}finally {\n\t\t\tif(ps != null) {\n\t\t\t\ttry {\n\t\t\t\t\tps.close();\n\t\t\t\t} catch (SQLException e) {\n\t\t\t\t\treturn \"\"+e;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(conn != null) {\n\t\t\t\ttry {\n\t\t\t\t\tconn.close();\n\t\t\t\t} catch (SQLException e) {\n\t\t\t\t\treturn \"\"+e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "comment": "/**\n\t * \u63d2\u5165\n\t * @param stu\n\t */"}}
{"code": {"body": "\tpublic static String deleteStu(String sno)throws SQLException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = DBcon.getConnection();\n\t\t\tString sql = \"\";\n\t\t\tps = conn.prepareStatement(sql);\n\t\t\tps.setString(1, sno);\n\t\t\tint deleteCount = ps.executeUpdate();\n\t\t\tSystem.out.println(isSuccess(deleteCount));\n\t\t\treturn isSuccess(deleteCount);\n\t\t}catch(SQLException e) {\n\t\t\treturn \"\"+e;\n\t\t}finally {\n\t\t\tif(ps != null) {\n\t\t\t\ttry {\n\t\t\t\t\tps.close();\n\t\t\t\t} catch (SQLException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\treturn \"\"+e;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(conn != null) {\n\t\t\t\ttry {\n\t\t\t\t\tconn.close();\n\t\t\t\t} catch (SQLException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\treturn \"\"+e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "comment": "/**\n\t * \u5220\u9664\n\t * @param sno\n\t */"}}
{"code": {"body": "\tpublic static String modifyStu(Student stu) throws SQLException{\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = DBcon.getConnection();\n\t\t\tString sql = \"\";\n\t\t\tps = conn.prepareStatement(sql);\n\n\t\t\tps.setString(1, stu.getSpasswd());\n\t\t\tps.setString(2, stu.getSname());\n\t\t\tps.setString(3, stu.getCourse());\n\t\t\tps.setInt(4, stu.getGrade());\n\t\t\tps.setString(5, stu.getSno());\n\t\t\t\n\t\t\tint count = ps.executeUpdate();\n\t\t\tSystem.out.println(isSuccess(count));\n\t\t\treturn isSuccess(count);\n\t\t}catch(SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn \"\"+e;\n\t\t}finally {\n\t\t\tif(ps != null) {\n\t\t\t\ttry {\n\t\t\t\t\tps.close();\n\t\t\t\t} catch (SQLException e) {\n\t\t\t\t\t\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\treturn \"\"+e;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(conn != null) {\n\t\t\t\tconn.close();\n\t\t\t}\n\t\t}\n\t}", "comment": "/**\n\t * \u4fee\u6539\u4fe1\u606f\n\t * @param stu\n\t * @throws SQLException\n\t */"}}
{"code": {"body": "\tpublic static String resetPasswd(String sno) throws SQLException{\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = DBcon.getConnection();\n\t\t\tString sql = \"\";\n\t\t\tps = conn.prepareStatement(sql);\n\n\t\t\tps.setString(1, \"\");\n\t\t\tps.setString(2,sno);\n\t\t\t\n\t\t\tint count = ps.executeUpdate();\n\t\t\tSystem.out.println(isSuccess(count));\n\t\t\treturn isSuccess(count);\n\t\t}catch(SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn \"\"+e;\n\t\t}finally {\n\t\t\tif(ps != null) {\n\t\t\t\ttry {\n\t\t\t\t\tps.close();\n\t\t\t\t} catch (SQLException e) {\n\t\t\t\t\t\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\treturn \"\"+e;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(conn != null) {\n\t\t\t\tconn.close();\n\t\t\t}\n\t\t}\n\t}", "comment": "/**\n\t * \u91cd\u7f6e\u5bc6\u7801\n\t * @param sno\n\t * @throws SQLException\n\t */"}}
{"code": {"body": "\tpublic static String isSuccess(int count){\n\t\tif(count > 0) {\n\t\t\treturn \"\";\n\t\t}else {\n\t\t\treturn \"\";\n\t\t}\n\t}", "comment": "/**\n\t * \u5224\u65ad\u662f\u5426\u6267\u884c\u6210\u529f\n\t * @param count\n\t * @return\n\t */"}}
{"code": {"body": "\tpublic static List<Teacher> selectTea_All(){\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\n\t\tResultSet rs = null;\n\t\t\n\t\tList<Teacher> tea = new ArrayList<Teacher>();\n\t\t\n\t\ttry {\n\t\t\tconn = DBcon.getConnection();\n\t\t\tString sql = \"\";\n\t\t\tps = conn.prepareStatement(sql);\n\t\t\trs = ps.executeQuery();\n\t\t\twhile(rs.next()) {\n\t\t\t\tString tno = rs.getString(\"\");\n\t\t\t\tString tpasswd = rs.getString(\"\");\n\t\t\t\tString tname = rs.getString(\"\");\n\t\t\t\tString course = rs.getString(\"\");\n\t\t\t\tTeacher st = new Teacher(tno,tname,tpasswd,course);\n\t\t\t\ttea.add(st);\n\t\t\t}\n\t\t}catch(Exception e) {\n\t\t\te.printStackTrace();\n\t\t}finally {\n\t\t\tif(rs != null) {\n\t\t\t\ttry {\n\t\t\t\t\trs.close();\n\t\t\t\t} catch (SQLException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ps != null) {\n\t\t\t\ttry {\n\t\t\t\t\tps.close();\n\t\t\t\t} catch (SQLException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(conn != null) {\n\t\t\t\ttry {\n\t\t\t\t\tconn.close();\n\t\t\t\t} catch (SQLException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn tea;\n\t}", "comment": "/**\n\t *\u67e5\u627e\u5168\u90e8\n\t * @return\n\t */"}}
{"code": {"body": "\tpublic static Teacher selectTea_Tno(String tno) {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\tResultSet rs = null;\n\t\tTeacher st = null;\n\t\ttry {\n\t\t\tconn = DBcon.getConnection();\n\t\t\tString sql = \"\";\n\t\t\tps = conn.prepareStatement(sql);\n\t\t\tps.setNString(1, tno);\n\t\t\trs = ps.executeQuery();\n\t\t\twhile(rs.next()) {\n\t\t\t\tString tno1 = rs.getString(\"\");\n\t\t\t\tString tname = rs.getString(\"\");\n\t\t\t\tString tpasswd = rs.getString(\"\");\n\t\t\t\tString course = rs.getString(\"\");\n\t\t\t\tst = new Teacher(tno1,tname,tpasswd,course);\n\t\t\t}\n\t\t}catch(Exception e) {\n\t\t\te.printStackTrace();\n\t\t}finally {\n\t\t\tif(rs != null) {\n\t\t\t\ttry {\n\t\t\t\t\trs.close();\n\t\t\t\t} catch (SQLException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ps!= null) {\n\t\t\t\ttry {\n\t\t\t\t\tps.close();\n\t\t\t\t} catch (SQLException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(conn != null) {\n\t\t\t\ttry {\n\t\t\t\t\tconn.close();\n\t\t\t\t} catch (SQLException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn st;\n\t}", "comment": "/**\n\t * \u6839\u636e\u6559\u5de5\u53f7\u67e5\u627e\n\t * @param tno\n\t * @return\n\t */"}}
{"code": {"body": "\tpublic static String insertTea(Teacher tea) {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = DBcon.getConnection();\n\t\t\tString sql = \"\";\n\t\t\tps = conn.prepareStatement(sql);\n\t\t\t\n\t\t\tps.setString(1, tea.getTno());\n\t\t\tps.setString(2, tea.getTpasswd());\n\t\t\tps.setString(3, tea.getTname());\n\t\t\tps.setString(4, tea.getCourse());\n\t\t\tint insertCount = ps.executeUpdate();\n\t\t\tSystem.out.println(isSuccess(insertCount));\n\t\t\treturn isSuccess(insertCount);\n\t\t}catch(Exception e) {\n\t\t\te.printStackTrace();\n\t\t\treturn \"\"+e;\n\t\t}finally {\n\t\t\tif(ps != null) {\n\t\t\t\ttry {\n\t\t\t\t\tps.close();\n\t\t\t\t} catch (SQLException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\treturn \"\"+e;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(conn != null) {\n\t\t\t\ttry {\n\t\t\t\t\tconn.close();\n\t\t\t\t} catch (SQLException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\treturn \"\"+e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "comment": "/**\n\t * \u63d2\u5165\n\t * @param tea\n\t */"}}
{"code": {"body": "\tpublic static String deleteTea(String tno) {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = DBcon.getConnection();\n\t\t\tString sql = \"\";\n\t\t\tps = conn.prepareStatement(sql);\n\t\t\tps.setString(1, tno);\n\t\t\tint deleteCount = ps.executeUpdate();\n\t\t\tSystem.out.println(isSuccess(deleteCount));\n\t\t\treturn isSuccess(deleteCount);\n\t\t}catch(Exception e) {\n\t\t\te.printStackTrace();\n\t\t\treturn \"\"+e;\n\t\t}finally {\n\t\t\tif(ps != null) {\n\t\t\t\ttry {\n\t\t\t\t\tps.close();\n\t\t\t\t} catch (SQLException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\treturn \"\"+e;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(conn != null) {\n\t\t\t\ttry {\n\t\t\t\t\tconn.close();\n\t\t\t\t} catch (SQLException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\treturn \"\"+e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "comment": "/**\n\t * \u5220\u9664\n\t * @param tno\n\t */"}}
{"code": {"body": "\tpublic static String modifyTea(Teacher tea) throws SQLException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = DBcon.getConnection();\n\t\t\tString sql = \"\";\n\t\t\tps = conn.prepareStatement(sql);\n\t\t\t\n\t\t\t\n\t\t\tps.setString(1, tea.getTpasswd());\n\t\t\tps.setString(2, tea.getTname());\n\t\t\tps.setString(3, tea.getCourse());\n\t\t\tps.setString(4, tea.getTno());\n\t\t\t\n\t\t\tint count = ps.executeUpdate();\n\t\t\tSystem.out.println(isSuccess(count));\n\t\t\treturn isSuccess(count);\n\t\t}catch(Exception e) {\n\t\t\te.printStackTrace();\n\t\t\treturn \"\"+e;\n\t\t}finally {\n\t\t\tif(ps != null) {\n\t\t\t\ttry {\n\t\t\t\t\tps.close();\n\t\t\t\t} catch (SQLException e) {\n\t\t\t\t\t\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\treturn \"\"+e;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(conn != null) {\n\t\t\t\tconn.close();\n\t\t\t}\n\t\t}\n\t}", "comment": "/**\n\t * \u4fee\u6539\u4fe1\u606f\n\t * @param tea\n\t * @throws SQLException\n\t */"}}
{"code": {"body": "\tpublic static String resetPasswd(String tno) throws SQLException{\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = DBcon.getConnection();\n\t\t\tString sql = \"\";\n\t\t\tps = conn.prepareStatement(sql);\n\n\t\t\tps.setString(1, \"\");\n\t\t\tps.setString(2,tno);\n\t\t\t\n\t\t\tint count = ps.executeUpdate();\n\t\t\tSystem.out.println(isSuccess(count));\n\t\t\treturn isSuccess(count);\n\t\t}catch(SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn \"\"+e;\n\t\t}finally {\n\t\t\tif(ps != null) {\n\t\t\t\ttry {\n\t\t\t\t\tps.close();\n\t\t\t\t} catch (SQLException e) {\n\t\t\t\t\t\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\treturn \"\"+e;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(conn != null) {\n\t\t\t\tconn.close();\n\t\t\t}\n\t\t}\n\t}", "comment": "/**\n\t * \u91cd\u7f6e\u5bc6\u7801\n\t * @param sno\n\t * @throws SQLException\n\t */"}}
{"code": {"body": "\tpublic static String isSuccess(int count) {\n\t\tif(count > 0) {\n\t\t\treturn \"\";\n\t\t}else {\n\t\t\treturn \"\";\n\t\t}\n\t}", "comment": "/**\n\t * \u5224\u65ad\u662f\u5426\u6210\u529f\n\t * @param count\n\t * @return\n\t */"}}
{"code": {"body": "    public Optional<Client> get(long id) {\n        return Optional.ofNullable(clients.get((int)id));\n    }", "comment": "/*client.setNumClient(Object.requireNonNull(params[0], \"Le num\u00e9ro client ne peut etre null\"));   //   Numero Client\n        client.setNomClient(Object.requireNonNull(params[1], \"Le nom client ne peut etre null\"));   // Nom du client\n        client.setNom(Object.requireNonNull(params[2], \"L'adresse client ne peut etre null\"));    // Adresse\n\n        clients.add(client);*/"}}
{"code": {"body": "    public List<Client> getAll() {\n        return clients;\n    }", "comment": "/*client.setNumClient(Object.requireNonNull(params[0], \"Le num\u00e9ro client ne peut etre null\"));   //   Numero Client\n        client.setNomClient(Object.requireNonNull(params[1], \"Le nom client ne peut etre null\"));   // Nom du client\n        client.setNom(Object.requireNonNull(params[2], \"L'adresse client ne peut etre null\"));    // Adresse\n\n        clients.add(client);*/"}}
{"code": {"body": "    public void save(Client client) {\n        clients.add(client);\n    }", "comment": "/*client.setNumClient(Object.requireNonNull(params[0], \"Le num\u00e9ro client ne peut etre null\"));   //   Numero Client\n        client.setNomClient(Object.requireNonNull(params[1], \"Le nom client ne peut etre null\"));   // Nom du client\n        client.setNom(Object.requireNonNull(params[2], \"L'adresse client ne peut etre null\"));    // Adresse\n\n        clients.add(client);*/"}}
{"code": {"body": "    public void update(Client client, String[] params) {\n        \n    }", "comment": "/*client.setNumClient(Object.requireNonNull(params[0], \"Le num\u00e9ro client ne peut etre null\"));   //   Numero Client\n        client.setNomClient(Object.requireNonNull(params[1], \"Le nom client ne peut etre null\"));   // Nom du client\n        client.setNom(Object.requireNonNull(params[2], \"L'adresse client ne peut etre null\"));    // Adresse\n\n        clients.add(client);*/"}}
{"code": {"body": "    public Optional<Compte> get(long id) {\n        return Optional.ofNullable(comptes.get((int)id));\n    }", "comment": "/*compte.setSolde(Object.requireNonNull(params[0], \"Le solde de compte ne peut etre null\"));\n        compte.setNumCompte(Object.requireNonNull(params[1], \"Le num\u00e9ro de compte ne peut etre null\"));\n        compte.setMontant(Object.requireNonNull(params[2], \"Le num\u00e9ro de compte ne peut etre null\"));*/"}}
{"code": {"body": "    public List<Compte> getAll() {\n        return comptes;\n    }", "comment": "/*compte.setSolde(Object.requireNonNull(params[0], \"Le solde de compte ne peut etre null\"));\n        compte.setNumCompte(Object.requireNonNull(params[1], \"Le num\u00e9ro de compte ne peut etre null\"));\n        compte.setMontant(Object.requireNonNull(params[2], \"Le num\u00e9ro de compte ne peut etre null\"));*/"}}
{"code": {"body": "    public void save(Compte compte) {\n        comptes.add(compte);\n    }", "comment": "/*compte.setSolde(Object.requireNonNull(params[0], \"Le solde de compte ne peut etre null\"));\n        compte.setNumCompte(Object.requireNonNull(params[1], \"Le num\u00e9ro de compte ne peut etre null\"));\n        compte.setMontant(Object.requireNonNull(params[2], \"Le num\u00e9ro de compte ne peut etre null\"));*/"}}
{"code": {"body": "    public void update(Compte compte, String[] params) {\n        \n    }", "comment": "/*compte.setSolde(Object.requireNonNull(params[0], \"Le solde de compte ne peut etre null\"));\n        compte.setNumCompte(Object.requireNonNull(params[1], \"Le num\u00e9ro de compte ne peut etre null\"));\n        compte.setMontant(Object.requireNonNull(params[2], \"Le num\u00e9ro de compte ne peut etre null\"));*/"}}
{"code": {"body": "public Banque() {\n\t\tsuper();\n\t\t\n\t\tlisteClient.add(new Client( \"\", \"\",\"\"));\n\t\tlisteClient.add(new Client( \"\", \"\",\"\"));\n\t\tCompte compte1 = new Compte();\n\t\tCompte compte2= new Compte();\n\n\t}", "comment": "/*@Override\n\tpublic String toString() {\n\t\t\treturn \"Bank [compte=\" + compte + \", client=\" + client + \"]\";\n\t\t}*/"}}
{"code": {"body": "\tpublic ArrayList getListeClient(){\n\t\treturn listeClient;\n\t}", "comment": "/*@Override\n\tpublic String toString() {\n\t\t\treturn \"Bank [compte=\" + compte + \", client=\" + client + \"]\";\n\t\t}*/"}}
{"code": {"body": "\tpublic static Image loadImage(String path) {\n\t\tURL imgUrl = Utils.class.getClassLoader().getResource(path);\n\t\treturn Toolkit.getDefaultToolkit().createImage(imgUrl);\n\t}", "comment": "/**\n\t * Reads an image from a file inside the current classpath.\n\t * \n\t * @return the image; can be displayed and used in ImageIcons.\n\t */"}}
{"code": {"body": "\tpublic static String extractMatch(String pattern, String source) {\n\t\tMatcher m = Pattern.compile(pattern).matcher(source);\n\t\tif (m.find()) {\n\t\t\treturn m.group(1);\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException(\"\" + pattern + \"\" + source);\n\t\t}\n\t}", "comment": "/**\n\t * Extracts the first match of a pattern against a string.\n\t * \n\t * @param pattern\n\t *            to use, which MUST contain parenthesis. For example, to\n\t *            extract 15 from <code>\"a: 12, b: 15, c: -8\"</code>, the\n\t *            pattern <code>\"b: ([0-9-]+)\"</code> could be used.\n\t * @param source\n\t *            string, which is expected to contain the pattern\n\t * @return the first match; or an exception if no matches are found.\n\t */"}}
{"code": {"body": "\tpublic static Iterator<Color> colorsGenerator() {\n\n\t\tIterator<Color> i = new Iterator<Color>() {\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tprivate Random r = new Random(314159265);\n\n\t\t\t@Override\n\t\t\tpublic Color next() {\n\t\t\t\treturn new Color(r.nextInt(256), r.nextInt(256), r.nextInt(256));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void remove() {\n\t\t\t\tthrow new UnsupportedOperationException(\"\");\n\t\t\t}\n\t\t};\n\n\t\treturn i;\n\n\t}", "comment": "/**\n\t * Generates an iterator for generating random colors. It generates the same\n\t * sequences of colors over different runs since it always uses the same\n\t * seed.\n\t * \n\t * \n\t * @return An iterator for generating random colors.\n\t */"}}
{"code": {"body": "public GameError(String msg) {\n\t\tsuper(msg);\n\t}", "comment": "/**\n\t * A game error\n\t * @param msg that describes the error\n\t */"}}
{"code": {"body": "public GameError(String msg, Throwable cause) {\n\t\tsuper(msg, cause);\n\t}", "comment": "/**\n\t * A game error that wraps an exception\n\t * @param msg that describes the error\n\t * @param cause of the error\n\t */"}}
{"code": {"body": "\tpublic int getPlayerCount() {\n\t\treturn playerCount;\n\t}", "comment": "/**\n\t * @return the current number of players\n\t */"}}
{"code": {"body": "\tpublic String getGameDescreption() {\n\t\treturn this.getClass().getName();\n\t}", "comment": "/**\n\t * @return the name of the game, by defualt the name of the class\n\t */"}}
{"code": {"body": "\tpublic double evaluate(int playerNumber) {\n\t\treturn isFinished() ? (playerNumber == getWinner() ? 1 : -1) :\n\t\t\n\t\t\t\t0;\n\t}", "comment": "/**\n\t * Evaluates how close playerNumber is to winning (1) or losing (-1). A draw\n\t * or game that has not started is considered neutral.\n\t *\n\t * @param playerNumber\n\t *            to evaluate for\n\t * @return 0 if the game is a draw, or not yet in play and not won, 1 (-1)\n\t *         if the game is a win (loss) for that player, intermediate values\n\t *         for other scenarios.\n\t */"}}
{"code": {"body": "\tpublic void save(File file) throws IOException {\n\t\tFileOutputStream fout = new FileOutputStream(file);\n\t\ttry (ObjectOutputStream oos = new ObjectOutputStream(fout)) {\n\t\t\toos.writeObject(this);\n\t\t} catch (IOException ioe) {\n\t\t\tthrow new IOException(\"\" + file.getAbsolutePath() + \"\", ioe);\n\t\t}\n\t}", "comment": "/**\n\t * @param file\n\t *            to save to; can later be loaded via <code>load</code>\n\t */"}}
{"code": {"body": "\tpublic static GameState<?, ?> load(File file) throws IOException {\n\t\tFileInputStream fin = new FileInputStream(file);\n\t\ttry (ObjectInputStream ois = new ObjectInputStream(fin)) {\n\t\t\treturn (GameState<?, ?>) ois.readObject();\n\t\t} catch (ClassNotFoundException cnfe) {\n\t\t\tthrow new IOException(\"\" + file.getAbsolutePath() + \"\", cnfe);\n\t\t}\n\t}", "comment": "/**\n\t * @param file\n\t *            written in a previous call to <code>save()</code>\n\t */"}}
{"code": {"body": "public ConcurrentDeepeningMinMax(int threads) {\n        this.threads = threads;\n    }", "comment": "/**\n     * Constructor.\n     * @param threads to run concurrently. The actual number of concurrently running\n     *                threads can be calculated as\n     *                Min(threads, actualProcessors, validMovesInInitialState)\n     */"}}
{"code": {"body": "    public int getEvaluationCount() {\n        return evaluationCount.get();\n    }", "comment": "/**\n     * @return the number of board evaluations performed during the last\n     *  chooseNode() search\n     */"}}
{"code": {"body": "public ChessAction(int player, int srcRow, int srcCol,", "comment": "/**\n     * Create a simple non-special move. Notice that the check\n     * field, if needed, must be set externally. This is because checking\n     * for check usually involves testing out the move.\n     *\n     * @param player that moves\n     * @param srcRow for moving piece\n     * @param srcCol for moving piece\n     * @param dstRow for moving piece\n     * @param dstCol for moving piece\n     */"}}
{"code": {"body": "public ChessBoard() {\n        board = new byte[DIM_WITH_BORDERS * DIM_WITH_BORDERS];\n\n        \n        for (int i=0; i<DIM_WITH_BORDERS; i++) {\n            for (int j=0; j<DIM_WITH_BORDERS; j++) {\n                board[i*DIM_WITH_BORDERS + j] =\n                        (i<BORDER || i>=DIM+BORDER || j<BORDER || j>=DIM+BORDER) ?\n                                OUTSIDE : EMPTY;\n            }\n        }\n\n        \n        for (int i=0; i<DIM; i++) {\n            set(1, i, Piece.Pawn.black());\n            set(6, i, Piece.Pawn.white());\n        }\n        set(0, 0, Piece.Rook.black());\n        set(0, 7, Piece.Rook.black());\n        set(7, 0, Piece.Rook.white());\n        set(7, 7, Piece.Rook.white());\n        set(0, 1, Piece.Knight.black());\n        set(0, 6, Piece.Knight.black());\n        set(7, 1, Piece.Knight.white());\n        set(7, 6, Piece.Knight.white());\n        set(0, 2, Piece.Bishop.black());\n        set(0, 5, Piece.Bishop.black());\n        set(7, 2, Piece.Bishop.white());\n        set(7, 5, Piece.Bishop.white());\n        set(0, 3, Piece.Queen.black());\n        set(7, 3, Piece.Queen.white());\n        set(0, 4, Piece.King.black());\n        set(7, 4, Piece.King.white());\n    }", "comment": "/**\n     * Initializes a chess-board with the pieces at their start positions.\n     */"}}
{"code": {"body": "    public static boolean sameTurn(byte p, int turn) {\n        return (p & NON_PIECE_MASK) == (turn << 3);\n    }", "comment": "/**\n     * checks if a piece has a given turn\n     * @param p board-piece\n     * @param turn (WHITE=0 or BLACK=1)\n     * @return true if and only if piece is of same turn as indicated\n     */"}}
{"code": {"body": "        public static String iconName(byte p) {\n            return \"\" + valueOf(p).getSymbol(false) + \"\"\n                    + (ChessBoard.black(p)  ? \"\" : \"\") + \"\";\n        }", "comment": "/**\n         * Returns icon-names for each piece.\n         * @param p (as obtained by ChessBoard.get())\n         * @return icon names such as \"p_b.png\" for a pawn that is black\n         */"}}
{"code": {"body": "public ChessState() {\n        super(2);\n        turn = WHITE;\n        winner = -1;\n        finished = false;\n        board = new ChessBoard();\n        canCastle = new int[]{\n                CASTLE_SHORT | CASTLE_LONG, CASTLE_SHORT | CASTLE_LONG};\n        enPassant = -1;\n        inCheck = false;\n        valid = null;\n        updateValid();\n\n    }", "comment": "/**\n     * Creates an empty chess board;\n     */"}}
{"code": {"body": "public ChessState(ChessState previous, ChessBoard board,", "comment": "/**\n     * Creates a chess board with a given position\n     * @param previous board (used mostly to look at turn)\n     * @param board to use\n     * @param canCastle representing the state of castling; canCastle[WHITE] is\n     *                  0 if not allowed,\n     *                  1 if only short castling still possible,\n     *                  2 if only long castling still possible\n     *                  3 if both types of castling are still possible\n     * @param enPassant with column where enemy pawn just finished a double-advance\n     * @param inCheck if king is currently in check\n     */"}}
{"code": {"body": "    public static int otherPlayer(int player) {\n        return player == BLACK ? WHITE : BLACK;\n    }", "comment": "/**\n     * @param player\n     * @return opposite player\n     */"}}
{"code": {"body": "    protected static boolean findKing(ChessBoard board, int turn, Point kingPos) {\n        for (int i = 0; i < DIM; i++) {\n            for (int j = 0; j < DIM; j++) {\n                byte p = board.get(i, j);\n                if (sameTurn(p, turn) && Piece.valueOf(p) == Piece.King) {\n                    kingPos.setLocation(j, i);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }", "comment": "/**\n     * @param board to search in\n     * @param turn of king to search for\n     * @param kingPos to write position into\n     * @return true if found, false if not\n     */"}}
{"code": {"body": "    private void updateValid() {\n        if (valid != null) {\n            return;\n        }\n\n        int otherTurn = otherPlayer(turn);\n\n        valid = new ArrayList<>();\n        ArrayList<ChessAction> candidates = new ArrayList<>();\n\n        \n        for (int i = 0; i < DIM; i++) {\n            for (int j = 0; j < DIM; j++) {\n                byte p = board.get(i, j);\n                if (sameTurn(p, turn)) {\n                    generateActions(p, turn, i, j, candidates);\n                }\n            }\n        }\n\n        \n        Point myKing = new Point();\n        Point kingPos = new Point();\n        Point otherKing = new Point();\n        if ( ! findKing(board, turn, myKing)) {\n            throw new IllegalStateException(\"\" + turn + \"\" + board);\n        }\n        if ( ! findKing(board, otherTurn, otherKing)) {\n            throw new IllegalStateException(\"\" + otherTurn + \"\" + board);\n        }\n        for (ChessAction a : candidates) {\n            ChessBoard next = new ChessBoard(board);\n            a.applyTo(next);\n            if (myKing.y == a.getSrcRow() && myKing.x == a.getSrcCol()) {\n                kingPos.setLocation(a.getDstCol(), a.getDstRow());\n            } else {\n                kingPos.setLocation(myKing);\n            }\n\n            if ( ! threatenedBy(next, otherTurn, kingPos.y, kingPos.x)) {\n                a.setCheck(threatenedBy(next, turn, otherKing.y, otherKing.x));\n                valid.add(a);\n            }\n        }\n    }", "comment": "/**\n     * Generates valid moves for current player.\n     * This can only be called once per state\n     * (as states are immutable, and results get cached).\n     */"}}
{"code": {"body": "    public List<ChessAction> validActions(int playerNumber) {\n        return valid;\n    }", "comment": "/**\n     * Returns a list of valid actions for the current player.\n     * @param playerNumber\n     *            to generate actions for\n     * @return\n     */"}}
{"code": {"body": "    public int at(int row, int col) {\n        return board.get(row, col);\n    }", "comment": "/**\n     * Returns the piece (see ChessBoard) at the given position.\n     * @param row\n     * @param col\n     * @return piece at the given position. Note that\n     *  chess piece codes are NOT player codes (there are many piece types).\n     *  See ChessBoard to make sense of the returned int:\n     *  ChessBoard.black(p) and ChessBoard.white(p) will tell you piece-color\n     *  ChessBoard.Piece.valueOf(p) will tell you piece-type.\n     */"}}
{"code": {"body": "    public ChessBoard getBoard() {\n        return new ChessBoard(board);\n    }", "comment": "/**\n     * @return a copy of the board\n     */"}}
{"code": {"body": "    protected void deltaActions(byte p, int turn,\n                                int row, int col, int dy, int dx, ArrayList<ChessAction> as,\n                                boolean multiple) {\n        int dRow = row, dCol = col;\n        byte target;\n        do {\n            dRow += dy;\n            dCol += dx;\n            target = board.get(dRow, dCol);\n            if (empty(target) || enemy(p, target)) {\n                as.add(new ChessAction(turn, row, col, dRow, dCol));\n            }\n        } while (multiple && empty(target));\n    }", "comment": "/**\n     * Used to generate non-pawn actions. Simply looks for empty-or-enemy squares\n     * along a given direction, given by row and column deltas. If 'multiple' is se to true,\n     * continues looking until non-empty square found (useful for rook, bishop, queen)\n     */"}}
{"code": {"body": "    protected static boolean threatenedBy(ChessBoard b, int turn, int row, int col) {\n        for (int i = 0; i < DIM; i++) {\n            for (int j = 0; j < DIM; j++) {\n                byte p = b.get(i, j);\n                if (sameTurn(p, turn) && canCapture(b, p, i, j, row, col)) {\n                    log.fine(\"\" + row +\"\"+col+\"\" + i+\"\"+j + \"\" + Piece.valueOf(p));\n                    return true;\n                }\n            }\n        }\n        return false;\n    }", "comment": "/**\n     * @param b board to check in\n     * @param turn of player that threatens\n     * @param row of victim\n     * @param col of victim\n     * @return true if there is at least 1 piece of turn that can capture the victim\n     */"}}
{"code": {"body": "    public boolean isInCheck() {\n        return inCheck;\n    }", "comment": "/**\n     * @return true if the current player is in check\n     */"}}
{"code": {"body": "\tpublic static void match(GameState<?, ?> initialState, GamePlayer a, GamePlayer b, int times) {\n\t\tint va = 0, vb = 0;\n\n\t\tList<GamePlayer> players = new ArrayList<GamePlayer>();\n\t\tplayers.add(a);\n\t\tplayers.add(b);\n\n\t\tfor (int i = 0; i < times; i++) {\n\t\t\tswitch (playGame(initialState, players)) {\n\t\t\tcase 0:\n\t\t\t\tva++;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tvb++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"\" + va + \"\" + a.getName() + \"\" + vb + \"\" + b.getName());\n\t}", "comment": "/**\n\t * Repeatedly plays a game-state with a vs b\n\t * \n\t * @param initialState\n\t * @param a\n\t *            player\n\t * @param b\n\t *            player\n\t * @param times\n\t *            to play\n\t */"}}
{"code": {"body": "\tpublic static void testTtt() {\n\t\ttry (Scanner s = new Scanner(System.in)) {\n\t\t\tList<GamePlayer> players = new ArrayList<GamePlayer>();\n\t\t\tGameState<?, ?> game = new TttState(3);\n\t\t\tplayers.add(new ConsolePlayer(\"\", s));\n\t\t\tplayers.add(new SmartPlayer(\"\", 5));\n\t\t\tplayGame(game, players);\n\t\t} \n\t}", "comment": "/**\n\t * Plays tick-tack-toe with a console player against a smart player. The\n\t * smart player should never lose.\n\t */"}}
{"code": {"body": "\tpublic static void main(String... args) {\n\t\ttestLobo();\n\t\ttestTtt();\n\t\t\n\t}", "comment": "/**\n\t * Main method.\n\t * \n\t * @param args\n\t */"}}
{"code": {"body": "\tprivate static GameTable<?, ?> createGame(String juego) {\n\t\t\n\t\tGameState<?, ?> initialState;\n\t\tGameTable<?, ?> gameTable;\n\t\tif(juego.equalsIgnoreCase(\"\")) {\n\t\t\tinitialState = new TttState(3);\n\t\t\tgameTable = new GameTable(initialState);\n\t\t}\n\t\telse if (juego.equalsIgnoreCase(\"\")){\n\t\t\tinitialState = new WolfAndSheepState();\n\t\t\tgameTable = new GameTable(initialState);\n\t\t}\n\t\telse return null;\n\t\treturn gameTable;\n\t}", "comment": "/**\n\t * Crea el estado inicial del juego\n\t * @param juego\n\t * @return initialState juego creado o null si no es valido\n\t */"}}
{"code": {"body": "\tpublic static GameState<?,?> createInitialState(String juego) {\n\t\tGameState<?, ?> initialState;\n\t\tif(juego.equalsIgnoreCase(\"\")) {\n\t\t\tSystem.out.println(\"\");\n\t\t\tint dim = in.nextInt();\n\t\t\tinitialState = new TttState(dim);\n\t\t}\n\t\telse if (juego.equalsIgnoreCase(\"\")) initialState = new WolfAndSheepState();\n\t\telse return null;\n\t\treturn initialState;\n\t}", "comment": "/**\n\t * Crea el estado inicial del juego\n\t * @param juego\n\t * @return initialState juego creado o null si no es valido\n\t */"}}
{"code": {"body": "\tpublic static GamePlayer createPlayer(String gameName, String playerType, String playerName) {\n\t\tGamePlayer jugador;\n\t\tif(playerType.equalsIgnoreCase(\"\")) jugador = new ConsolePlayer(playerName, in);\n\t\telse if (playerType.equalsIgnoreCase(\"\"))jugador = new SmartPlayer(playerName, 5);\n\t\telse if (playerType.equalsIgnoreCase(\"\")) jugador = new RandomPlayer(playerName);\n\t\telse return null;\n\t\treturn jugador;\n\t\t\n\t}", "comment": "/**\n\t * Crea el jugador\n\t * @param gameName nombre del juego\n\t * @param playerType tipo de jugador\n\t * @param playerName nombre del jugador\n\t * @return jugador creado o null si no es valido\n\t */"}}
{"code": {"body": "\tpublic static void main(String[] args) {\n\t\tif (args.length < 2) {\n\t\t\tusage();\n\t\t\tSystem.exit(1);\n\t\t}\n\t\tGameTable<?, ?> game = createGame(args[0]);\n\t\tif (game == null) {\n\t\t\tSystem.err.println(\"\");\n\t\t\tusage();\n\t\t\tSystem.exit(1);\n\t\t}\n\t\tString[] otherArgs = Arrays.copyOfRange(args, 2, args.length);\n\t\tswitch (args[1]) {\n\t\t case \"\":\n\t\t\tstartConsoleMode(args[0], game, otherArgs);\n\t\t\tbreak;\n\t\t case \"\":\n\t\t\tstartGuiMode(args[0],game);\n\t\t\tbreak;\n\t\t default:\n\t\t\tSystem.err.println(\"\"+args[1]);\n\t\t\tusage();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}", "comment": "/**\n\t * Main\n\t * @param args\n\t */"}}
{"code": {"body": "\tprivate static GameTable<?, ?> createGame(String juego) {\n\t\t\n\t\tGameState<?, ?> initialState;\n\t\tGameTable<?, ?> gameTable;\n\t\tif(juego.equalsIgnoreCase(\"\")) {\n\t\t\tinitialState = new TttState(3);\n\t\t\tgameTable = new GameTable(initialState);\n\t\t}\n\t\telse if (juego.equalsIgnoreCase(\"\")){\n\t\t\tinitialState = new WolfAndSheepState();\n\t\t\tgameTable = new GameTable(initialState);\n\t\t}\n\t\telse if (juego.equalsIgnoreCase(\"\")){\n\t\t\tinitialState = new ChessState();\n\t\t\tgameTable = new GameTable(initialState);\n\t\t}\n\t\telse return null;\n\t\treturn gameTable;\n\t}", "comment": "/**\n\t * Crea el estado inicial del juego\n\t * @param juego\n\t * @return initialState juego creado o null si no es valido\n\t */"}}
{"code": {"body": "public GameEvent(EventType type, A action, S state, GameError error, String description) {\n        this.type = type;\n        this.action = action;\n        this.state = state;\n        this.error = error;\n        this.description = description;\n    }", "comment": "/**\n     * Creates a new GameEvent. Not all fields are needed.\n     * @param type of action. Always present.\n     * @param action that caused this event. Can be null.\n     * @param state of the game when event was sent. Can be null if not yet started.\n     * @param error reported in an Error event. Must be null if not an error event.\n     * @param description intended for use in toString; must NOT be null\n     */"}}
{"code": {"body": "    public int[][] getBoard() {\n        int[][] copy = new int[board.length][];\n        for (int i=0; i<board.length; i++) copy[i] = board[i].clone();\n        return copy;\n    }", "comment": "/**\n     * @return a copy of the board\n     */"}}
{"code": {"body": "public WolfAndSheepAction(int player2, int originRow2, int originCol2, int finalRow2, int finalCol2) {\n\t\t\n\t\tthis.player = player2;\n\t\tthis.originRow = originRow2;\n\t\tthis.originCol = originCol2;\n\t\tthis.finalRow = finalRow2;\n\t\tthis.finalCol = finalCol2;\n\t}", "comment": "/**\n     * Constructora de la clase\n     * @param player2 jugador que tiene el turno\n     * @param originRow2 Fila de origen\n     * @param originCol2 Columna de origen\n     * @param finalRow2 Fila de destino\n     * @param finalCol2 Columna de destino\n     */"}}
{"code": {"body": "    public String toString() {\n        return \"\" + player + \"\" + originRow + \"\" + originCol + \"\" + \"\" + finalRow + \"\" + finalCol + \"\";\n    }", "comment": "/**\n\t * Metodo que devuelve un string para mostrar por pantalla un objeto de la clase\n\t * @return string de un objeto la clase\n\t */"}}
{"code": {"body": "public WolfAndSheepState() {\n\t\tsuper(2);\n\t\tboard = new int[DIM][];\n        for (int i=0; i<DIM; i++) {\n            board[i] = new int[DIM];\n            for (int j=0; j<DIM; j++) board[i][j] = EMPTY;\n        }\n        for(int i = 1; i < DIM; i =i+2) {\n        \tboard[0][i] = OVEJA;\n        }\n        board[DIM - 1][0] = LOBO;\n        this.turn = 0;\n        this.winner = -1;\n        this.finished = false;\n\t}", "comment": "/**\n     * Constructora sin parametros\n     */"}}
{"code": {"body": "public WolfAndSheepState(WolfAndSheepState prev, int[][] board, boolean finished, int winner) {\n    \tsuper(2);\n        this.board = board;\n        this.turn = (prev.turn + 1) % 2;\n        this.finished = finished;\n        this.winner = winner;\n    }", "comment": "/**\n\t * Constructora con parametros\n\t * @param prev Estado anterior\n\t * @param board tablero\n\t * @param finished terminado\n\t * @param winner ganador\n\t */"}}
{"code": {"body": "\tpublic static boolean isWinner(int[][] board2, int player) {\n\t\tboolean encontrado = false, posible = false; \n        if(player == OVEJA) {\n        \tint i = 0, j = 0;\n        \twhile(i < DIM && !encontrado) {\n        \t\tj = 0;\n\t\t\t\twhile(j <DIM && !encontrado) {\n\t\t\t\t\t if(board2[i][j] == LOBO){\n\t\t\t\t\t\t if(i - 1 >= 0 && j - 1  >= 0 && board2[i-1][j-1] == EMPTY) posible = true;\n\t\t\t\t\t\t else if (i - 1 >= 0 && j + 1 < DIM && board2 [i-1][j+1] == EMPTY) posible = true;\n\t\t\t\t\t\t else if (i + 1 < DIM && j - 1 >= 0 && board2[i+1][j - 1] == EMPTY) posible = true;\n\t\t\t\t\t\t else if( i + 1 < DIM && j + 1 < DIM && board2[i + 1][j + 1] == EMPTY) posible = true;\n\t\t\t\t\t\t encontrado = true;\n\t\t\t\t\t }\n\t\t\t\t\t else j++;\n\t\t\t\t }\n\t\t\t\t i++;\n\t\t\t }\n        \t if(!posible) return true; \n        \t else return false;\n        }\n        else {\n        \tfor(int j = 0; j < DIM && !encontrado; j++) {\n        \t\tif(board2[0][j] == LOBO) encontrado = true;\n        \t}\n        \tif (!encontrado){\n        \t\tint i = 0, j = 0, count = 0; \n        \t\twhile(i < DIM && count < DIM/2 && !posible) {\n   \t\t\t\t j = 0;\n   \t\t\t\t while(j <DIM && count < DIM/2 && !posible) {\n   \t\t\t\t\t if(board2[i][j] == OVEJA){\n   \t\t\t\t\t\t if (i + 1 < DIM && j - 1 >= 0 && board2[i+1][j - 1] == EMPTY) posible = true;\n   \t\t\t\t\t\t else if( i + 1 < DIM && j + 1 < DIM && board2[i + 1][j + 1] == EMPTY) posible = true;\n   \t\t\t\t\t\t count++;\n   \t\t\t\t\t }\n   \t\t\t\t\t j++;\n   \t\t\t\t }\n   \t\t\t\t i++;\n        \t\t}\n        \t\treturn !posible;\n        \t}\n        \telse return encontrado;\n        }\n    }", "comment": "/**\n\t * Busca si el jugador ha ganado\n\t * @param board2 tablero\n\t * @param player jugador\n\t * @return winner true si es ganador o false si no lo es\n\t */"}}
{"code": {"body": "\tpublic int[][] getBoard() {\n\t\t\n\t\tint[][] copy = new int[board.length][];\n        for (int i=0; i<board.length; i++) copy[i] = board[i].clone();\n        return copy;\n\t}", "comment": "/**\n\t *Devuelve el tablero\n\t *@return copy Tablero copiado\n\t */"}}
{"code": {"body": "    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"\" + 0);\n        for (int i=1; i<board.length; i++) {\n        \tif(i <= 10) sb.append(\"\" + i);\n        \telse sb.append(\"\" + i);\n        }\n        sb.append(\"\");\n        for (int i=0; i<board.length; i++) {\n            if (i < 10) sb.append(i + \"\");\n            else sb.append(i + \"\");\n            for (int j=0; j<board.length; j++) {\n            \tif (board[i][j] == EMPTY) {\n            \t\tif ((i % 2 == 0 && j % 2 == 1) || (i % 2 == 1 && j % 2 == 0)) sb.append(\"\");\n            \t\telse sb.append(\"\");\n            \t}\n            \telse if (board[i][j] == LOBO) sb.append(\"\");\n            \telse sb.append(\"\");\n            }\n            sb.append(\"\");\n        }\n        return sb.toString();\n    }", "comment": "/**\n\t * Metodo que devuelve un string para mostrar por pantalla un objeto de la clase\n\t * @return string de un objeto la clase\n\t */"}}
{"code": {"body": "\tpublic static String printArray(int[] arr){\n\t\tif(arr==null){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tStringBuffer sb = new StringBuffer();\n\t\tfor(int i=0;i<arr.length;i++){\n\t\t\tsb.append(arr[i]+\"\");\n\t\t}\n\t\t\n\t\treturn sb.toString();\n\t}", "comment": "/**\n\t * \u8f93\u51fa\u6570\u7ec4\u5143\u7d20\n\t * @param arr\n\t * @return\n\t */"}}
{"code": {"body": "public Stack(int maxSize){\n\t\tif(maxSize<=0){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn;\n\t\t}\n\t\tthis.maxSize = maxSize;\n\t\tdataArray = (T[]) new Object[maxSize];\n\t}", "comment": "/**\n\t * \u521d\u59cb\u5316\u6808\n\t * @param size \u6307\u5b9a\u6808\u7684\u6700\u5927\u5bb9\u91cf\n\t */"}}
{"code": {"body": "\tpublic boolean push(T obj){\n\t\t\n\t\tif(obj==null){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t\n\t\tif(curSize>=maxSize){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t\n\t\tdataArray[curSize++] = obj;\n\t\treturn true;\n\t}", "comment": "/**\n\t * \u5165\u6808\n\t * @param obj\n\t * @return\n\t */"}}
{"code": {"body": "\tpublic T pop(){\n\t\t\n\t\tif(curSize==0){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t\n\t\treturn dataArray[--curSize];\n\t}", "comment": "/**\n\t * \u51fa\u6808\n\t */"}}
{"code": {"body": "\tpublic T top(){\n\t\tif(curSize==0){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\treturn dataArray[curSize-1];\n\t}", "comment": "/**\n\t * \u83b7\u53d6\u6808\u9876\u5143\u7d20\n\t */"}}
{"code": {"body": "\tpublic int getMaxSize() {\n\t\treturn maxSize;\n\t}", "comment": "/**\n\t * \u83b7\u53d6\u6808\u7684\u6700\u5927\u5bb9\u91cf \n\t */"}}
{"code": {"body": "\tpublic int getCurSize() {\n\t\treturn curSize;\n\t}", "comment": "/**\n\t * \u83b7\u53d6\u6808\u7684\u5f53\u524d\u5bb9\u91cf\n\t */"}}
{"code": {"body": "\tpublic static void main(String[] args){\n\t\tStack<Integer> stack = new Stack<Integer>(10);\n\t\t\n\n\t\tstack.push(1);\n\t\tstack.push(2);\n\t\tstack.push(3);\n\t\tstack.push(4);\n\t\tstack.push(5);\n\t\tstack.push(6);\n\t\tstack.push(7);\n\t\tstack.push(8);\n\t\tstack.push(9);\n\t\tstack.push(10);\n\t\t\n\t\tstack.pop();\n\t\tstack.pop();\n\t\tstack.pop();\n\t\tstack.pop();\n\t\tstack.pop();\n\t\tstack.pop();\n\t\tstack.pop();\n\t\tstack.pop();\n\t\tstack.pop();\n\t\tstack.pop();\n\t\tstack.pop();\n\t\tstack.pop();\n\t\tstack.pop();\n\t\tstack.pop();\n\t\t\n\t\tstack.toString();\n\t}", "comment": "/**\n\t * \u6d4b\u8bd5\n\t */"}}
{"code": {"body": "\tpublic static int countBitOne_1(int n){\n\t\t\n\t\tint count = 0;\n\t\twhile(n!=0){\n\t\t\t\n\t\t\tif((n&1)==1)\n\t\t\t\tcount++;\n\t\t\t\n\t\t\tn = n >> 1;\n\t\t}\n\t\treturn count;\n\t}", "comment": "/**\n\t * \u8fd9\u9053\u9898\u6d89\u53ca\u5230\u4e8c\u8fdb\u5236\uff0c\u56e0\u6b64\u6211\u4eec\u5e94\u5f53\u654f\u9510\u5730\u5bdf\u89c9\u5230\u4f7f\u7528\u4f4d\u8fd0\u7b97\u6765\u89e3\u51b3\u95ee\u9898\uff01\n\t * \n\t * \u4f4d\u8fd0\u7b97\u5177\u6709\u5982\u4e0b\u7279\u6027\uff1a\n\t * 1\u4e0e\u4e00\u4e2a\u4e8c\u8fdb\u5236\u6570\u8fdb\u884c\u4e0e\u8fd0\u7b97\uff0c\u82e5\u6700\u4f4e\u4f4d\u662f1\uff0c\u5219\u8fd0\u7b97\u7684\u7ed3\u679c\u4e3a1\uff0c\u5426\u5219\u7ed3\u679c\u4e3a0\u3002\n\t * \n\t * \u56e0\u6b64\uff0c\u8ba9\u8f93\u5165\u7684\u6570\u4e0e1\u8fdb\u884c\u4e0e\u8fd0\u7b97\uff0c\u6bcf\u8fd0\u7b97\u4e00\u6b21\u4fbf\u7edf\u8ba1\u5f53\u524d\u7ed3\u679c\u662f\u5426\u4e3a1\uff0c\u5e76\u5c06\u6570\u53f3\u79fb\u4e00\u4f4d\uff0c\n\t * \u5f53\u8be5\u6570\u4e3a0\u65f6\u7edf\u8ba1\u7ed3\u675f\u3002\n\t * \n\t * \u4ee3\u7801\u5b9e\u73b0\u5982\u4e0b\uff1a\n\t */"}}
{"code": {"body": "\tpublic static int countBitOne_2(int n){\n\t\t\n\t\tint count = 0;\n\t\t\n\t\tint flag = 1;\n\t\t\n\t\twhile(flag!=0){\n\t\t\t\n\t\t\tif((n&flag) != 0)\n\t\t\t\tcount++;\n\t\t\t\n\t\t\tflag = flag << 1;\n\t\t}\n\t\treturn count;\n\t}", "comment": "/**\n\t * \u4e0a\u8ff0\u65b9\u6cd5\u6709\u4e2a\u4e25\u91cd\u7684bug\uff01\n\t * \u82e5\u4e00\u4e2a\u6b63\u6570\u53f3\u79fbn\u4f4d\uff0c\u5219\u9700\u8981\u7528n\u4e2a1\u6765\u8865\u9f50\u6700\u9ad8\u4f4d\u3002\n\t * \u56e0\u6b64\uff0c\u5f53\u4e00\u4e2a\u6b63\u6570\u53f3\u79fb\u4e86\u82e5\u5e72\u6b21\u4e4b\u540e\uff0c\u5b83\u7684\u6240\u6709\u4f4d\u7f6e\u90fd\u88ab1\u53d6\u4ee3\uff0c\n\t * \u6b64\u65f6\u4e0e1\u8fdb\u884c\u4e0e\u8fd0\u7b97\u7684\u7ed3\u679c\u6c38\u8fdc\u662f1\uff0c\u4ece\u800c\u51fa\u73b0\u4e86\u6b7b\u5faa\u73af\u3002\n\t * \n\t * \u5982\u4f55\u89e3\u51b3\u5462\uff1f\n\t * \n\t * \u51fa\u73b0\u4e0a\u8ff0\u60c5\u51b5\u7684\u539f\u56e0\u6709\u4e24\u4e2a\uff1a1.\u53f3\u79fb\u30012.\u6b63\u6570\uff0c\n\t * \u53ea\u8981\u7834\u574f\u4e86\u8fd9\u4e24\u4e2a\u6761\u4ef6\u4e2d\u7684\u4efb\u4f55\u4e00\u4e2a\uff0c\u5c31\u80fd\u907f\u514d\u6b7b\u5faa\u73af\u7684\u73b0\u8c61\u3002\n\t * \u7531\u4e8e\u672c\u9898\u7684\u8f93\u5165\u8981\u6c42\u4e2d\u5305\u542b\u4e86\u6b63\u6574\u6570\uff0c\u56e0\u6b64\u6211\u4eec\u53ea\u80fd\u7834\u574f\u7b2c\u4e00\u4e2a\u6761\u4ef6\u3002\n\t * \n\t * \u867d\u7136\u53f3\u79fb\u4e0e\u6b63\u8d1f\u6709\u5173\uff0c\u4f46\u5de6\u79fb\u4e0e\u6b63\u8d1f\u65e0\u5173\uff01\n\t * \u5e76\u4e14\u8981\u8fbe\u5230\u548c\u65b9\u6cd51\u4e00\u6837\u7684\u6548\u679c\uff0c\u6211\u4eec\u5c31\u8ba9\u201c00000001\u201d\u8fd9\u4e2a\u5e8f\u5217\u5de6\u79fb\u3002\n\t * \n\t * \u4ee3\u7801\u5982\u4e0b\uff1a\n\t */"}}
{"code": {"body": "\tpublic static int countBitOne_3(int n){\n\t\t\n\t\tint count = 0;\n\t\twhile(n!=0){\n\t\t\tn = n & (n-1);\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}", "comment": "/**\n\t * \u5982\u679c\u5c06\u4e00\u4e2a\u4e8c\u8fdb\u5236\u6570\uff0d1\uff0c\u90a3\u4e48\u8be5\u4e8c\u8fdb\u5236\u6570\u6700\u53f3\u4fa7\u76841\u5c06\u4f1a\u53d8\u62100\uff0c1\u540e\u9762\u76840\u5747\u53d8\u62101\uff0c1\u524d\u9762\u7684\u6570\u4fdd\u6301\u4e0d\u53d8\u3002\n\t * \u4e5f\u5c31\u662f\u8bf4\uff0c\u5982\u679c\u4e00\u4e2a\u4e8c\u8fdb\u5236\u6570\uff0d1\uff0c\u90a3\u4e48\u8be5\u6570\u6700\u53f3\u4fa7\u76841\u53ca1\u53f3\u4fa7\u7684\u6240\u6709\u6570\u5747\u53d8\u6210\u76f8\u53cd\u6570\u3002\n\t * \u5982\u679c\u628a\u8fd9\u4e2a\u6570\u548c\u539f\u6570\u4e0e\u8fd0\u7b97\uff0c\u90a3\u4e48\u6700\u53f3\u4fa7\u7684\u90a3\u4e2a1\u524d\u9762\u7684\u6570\u5c06\u4e0d\u53d8\uff0c1\u53ca1\u53f3\u4fa7\u7684\u6240\u6709\u6570\u5747\u53d8\u4e3a0\u3002\n\t * \u4e5f\u5c31\u662f\u8bf4\uff0c\u8fdb\u884c\u4e00\u6b21\u4e0a\u8ff0\u7684\u8fd0\u7b97\u540e\uff0c\u539f\u6570\u6700\u53f3\u4fa7\u7684\u90a3\u4e2a1\u5c06\u4f1a\u53d8\u62100\uff0c\n\t * \u90a3\u4e48\u53ea\u8981\u91cd\u590d\u4e0a\u8ff0\u64cd\u4f5c\uff0c\u5f53\u539f\u6570\u53d8\u62100\u65f6\uff0c\u5faa\u73af\u7684\u6b21\u6570\u5c31\u662f1\u7684\u4e2a\u6570\u3002\n\t * \n\t * \u4ee3\u7801\u5982\u4e0b\uff1a\n\t */"}}
{"code": {"body": "\tpublic static double power(double a,int b){\n\t\t\n\t\tif(Power.equal(a,0.0))\n\t\t\treturn 0;\n\t\t\n\t\t\n\t\tif(b==0)\n\t\t\treturn 1;\n\t\t\n\t\t\n\t\tdouble c = a;\n\t\tfor(int i=0; i<(b<0?-b:b)-1; i++){\n\t\t\tc *= a;\n\t\t}\n\t\t\n\t\t\n\t\tif(b<0)\n\t\t\treturn 1/c;\n\t\telse\n\t\t\treturn c;\n\t}", "comment": "/**\n\t * \u5206\u6790\uff1aa\u7684b\u6b21\u65b9\u5c31\u662f\u5c06a\u8fde\u4e58b\u6b21\uff0c\n\t * \u672c\u9898\u7684\u903b\u8f91\u6027\u4e0d\u96be\uff0c\u5173\u952e\u5728\u4e8e\u7a0b\u5e8f\u7684\u5065\u58ee\u6027\uff0c\n\t * \u9700\u8981\u5c06\u53ef\u80fd\u7684\u60c5\u51b5\u8003\u8651\u5168\u9762\u3002\n\t * @param a \u5e95\u6570\n\t * @param b \u6307\u6570\n\t * @return a\u7684b\u6b21\u65b9\n\t */"}}
{"code": {"body": "\tpublic static boolean equal(double a, double b){\n\t\tif(a-b<=0.0001 && a-b >=-0.0001)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}", "comment": "/**\n\t * \u6bd4\u8f83\u4e24\u4e2adouble\u662f\u5426\u8fd1\u4f3c\u76f8\u7b49\n\t * PS:\u82e5\u8bef\u5dee\u57280.0001\u5185\u5c31\u8ba4\u4e3a\u76f8\u7b49\n\t * @param a\n\t * @param b\n\t * @return \u662f\u5426\u8fd1\u4f3c\u76f8\u7b49\n\t */"}}
{"code": {"body": "\tpublic static int getMaxN_2(int n){\n\t\t\n\t\tif(n<=0){\n\t\t\tSystem.out.println(\"\");\n\t\t\tresult = false;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\t\n\t\tshort[] a = new short[n];\n\t\t\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = 0;\n\t\t}\n\t\ta[n-1] = 1;\n\t\t\n\t\t\n\t\tint index = n-1;\n\n\t\t\n\t\treturn 0;\n\t}", "comment": "/**\n\t * \u4e0a\u8ff0\u7a0b\u5e8f\u6709\u4e2a\u81f4\u547d\u7684\u7f3a\u70b9\uff1a\u7531\u4e8en\u662f\u4f4d\u6570\uff0c\u82e5n\u5f88\u5927\u65f6\uff0clong\u90fd\u65e0\u6cd5\u8868\u793a\u8fd9\u4e2a\u6570\u5b57\u8be5\u600e\u4e48\u529e\uff1f\n\t * \u60f3\u5230\u8fd9\u70b9\uff0c\u8fd9\u4e2a\u95ee\u9898\u5176\u5b9e\u5c31\u662f\u4e00\u9053\u5927\u6570\u95ee\u9898\u3002\n\t * \u89e3\u51b3\u65b9\u6cd5\uff1a\u91c7\u7528\u6570\u7ec4\u6765\u8868\u793a\u8fd9\u4e2a\u5927\u6570\uff0c\u6bcf\u4f4d\u5b58\u4e00\u4e2a0-9\u3002\n\t * \u7531\u4e8e\u6570\u7ec4\u7684\u5185\u5b58\u5927\u5c0f\u53ef\u4ee5\u65e0\u9650\u589e\u5927\uff0c\u56e0\u6b64\u4f7f\u7528\u6570\u7ec4\u5b58\u50a8\u5927\u6570\u975e\u5e38\u5408\u9002\u3002\n\t * \u4f46\u7528\u6570\u7ec4\u5b58\u50a8\u6709\u4e2a\u7f3a\u70b9\uff0c\u90a3\u5c31\u662f\u9700\u8981\u6211\u4eec\u81ea\u5df1\u5b9a\u4e49\u6570\u7ec4\u7684\u9012\u589e\u51fd\u6570\uff0c\u4ee5\u4fbf\u6253\u5370\u65f6\u4f7f\u7528\uff0c\u4ee3\u7801\u5982\u4e0b\uff1a\n\t */"}}
{"code": {"body": "\tpublic static boolean isLower(int i,char[] a){\n\t\t\n\t\tif(a==null || a.length<=0){\n\t\t\tSystem.out.println(\"\");\n\t\t\tresult = false;\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\treturn true;\n\t}", "comment": "/**\n\t * \u6bd4\u8f83i\u662f\u5426\u5c0f\u4e8e\u5b57\u7b26\u6570\u7ec4a\u8868\u793a\u7684\u503c\n\t * @param i \u6574\u6570\n\t * @param a \u5b57\u7b26\u6570\u7ec4\n\t * @return \u6bd4\u8f83\u7ed3\u679c\n\t */"}}
{"code": {"body": "\tpublic static <T> boolean deleteNode(Node<T> first, Node<T> p){\n\t\t\n\t\tif(first==null){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tif(p.next == null){\n\t\t\tNode<T> q = p;\n\t\t\twhile(p.next != null){\n\t\t\t\tq = p;\n\t\t\t\tp = p.next;\n\t\t\t}\n\t\t\tq.next = p.next;\n\t\t\tp = null;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tif(p.next != null){\n\t\t\tp.data = p.next.data;\n\t\t\tp.next = p.next.next;\n\t\t}\n\t\t\n\t\treturn true;\n\t}", "comment": "/**\n\t * \u5389\u5bb3\u7684\u65b9\u6cd5\u5982\u4e0b\uff1a\n\t * \u5c06p\u540e\u7ee7\u7ed3\u70b9\u7684\u6570\u636e\u590d\u5236\u5230p\u4e2d\uff0c\u518d\u5220\u9664p\u7684\u540e\u7ee7\u7ed3\u70b9\u5373\u53ef\uff01\u4ee3\u7801\u5982\u4e0b\uff1a\n\t */"}}
{"code": {"body": "\tpublic static boolean reorder(int[] a){\n\t\t\n\t\tif(a==null || a.length==0){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t\n\t\tif(a.length==1){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\t\n\t\tint i=0,j=a.length-1;\n\t\twhile(i<j){\n\t\t\t\n\t\t\twhile(a[i]%2==1)\n\t\t\t\ti++;\n\t\t\t\n\t\t\twhile(a[j]%2==0)\n\t\t\t\tj--;\n\t\t\t\n\t\t\tif(i<j){\n\t\t\t\tint temp = a[i];\n\t\t\t\ta[i] = a[j];\n\t\t\t\ta[j] = temp;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}", "comment": "/**\n\t * \u5206\u6790\uff1a\u672c\u9898\u53ea\u8981\u6c42\u524d\u534a\u6bb5\u4e3a\u5947\u6570\uff0c\u540e\u534a\u6bb5\u4e3a\u5076\u6570\uff0c\u6ca1\u6709\u8981\u6c42\u6709\u5e8f\uff0c\n\t * \u56e0\u6b64\u53ef\u4ee5\u91c7\u7528\u5feb\u901f\u6392\u5e8f\u4e2d\u4e00\u8d9f\u6392\u5e8f\u7684\u601d\u60f3\uff1a\n\t * \u4f7f\u7528\u4e24\u4e2a\u6307\u9488i\u3001j\uff0ci\u6307\u5411\u5934\u3001j\u6307\u5411\u5c3e\uff0c\u5206\u522b\u5411\u540e\u3001\u5411\u524d\u626b\u63cf\uff1b\n\t * \u82e5i\u9047\u5230\u5076\u6570\u5219\u505c\u4e0b\uff0cj\u9047\u5230\u5947\u6570\u5219\u505c\u4e0b\uff0c\u4ea4\u6362\u8fd9\u4e24\u4e2a\u6570\uff0c\n\t * \u7136\u540e\u7ee7\u7eed\u91cd\u590d\u4e0a\u8ff0\u64cd\u4f5c\uff0c\u76f4\u5230i\u3001j\u76f8\u9047\u4e3a\u6b62\u3002\u4ee3\u7801\u5982\u4e0b\uff1a\n\t * PS:\u5feb\u901f\u6392\u5e8f\u7b97\u6cd5\u8bf7\u770b\u6211\u7684\u535a\u5ba2\u300a\u5251\u6307 offer\u2014\u2014\u5feb\u901f\u6392\u5e8f\u300b\n\t */"}}
{"code": {"body": "\tpublic static boolean reorder_modify(int[] a){\n\t\t\n\t\tif(a==null || a.length==0){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t\n\t\tif(a.length==1){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\t\n\t\tint i=0,j=a.length-1;\n\t\twhile(i<j){\n\t\t\t\n\t\t\twhile(i<a.length-1 && a[i]%2==1)\n\t\t\t\ti++;\n\t\t\t\n\t\t\twhile(j>0 && a[j]%2==0)\n\t\t\t\tj--;\n\t\t\t\n\t\t\tif(i<j){\n\t\t\t\tint temp = a[i];\n\t\t\t\ta[i] = a[j];\n\t\t\t\ta[j] = temp;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}", "comment": "/**\n\t * \u4e0a\u8ff0\u4ee3\u7801\u8fd0\u884c\u8fc7\u540e\u4f1a\u51fa\u73b0\u6b7b\u5faa\u73af\uff01\n\t * \u5f53\u6570\u7ec4\u5168\u4e3a\u5947\u6570\u65f6\uff0ci\u65e0\u9650\u5411\u540e\u5bfb\u627e\uff0c\u56e0\u6b64\u51fa\u73b0\u6b7b\u5faa\u73af\u3002\n\t * \u56e0\u6b64\uff0c\u5728i\u5411\u540e\u3001j\u5411\u524d\u7684\u5faa\u73af\u4e2d\u5e94\u591a\u52a0\u4e00\u4e2a\u5224\u65ad\uff1a\u82e5i\u641c\u7d22\u5230\u672b\u5c3e\uff0c\u5219\u505c\u6b62\u3001\u82e5j\u641c\u7d22\u5230\u5f00\u5934\uff0c\u5219\u505c\u6b62\u3002\n\t * \u4fee\u6539\u540e\u7684\u4ee3\u7801\u5982\u4e0b\uff1a\n\t */"}}
{"code": {"body": "\tpublic static int getTailK(Node<Integer> first,int k){\n\t\t\n\t\tif(first==null){\n\t\t\tSystem.out.println(\"\");\n\t\t\tresult = false;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\t\n\t\tif(k<1){\n\t\t\tSystem.out.println(\"\");\n\t\t\tresult = false;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\t\n\t\tint length = 1;\n\t\tNode<Integer> p = first;\n\t\twhile(p.next!=null){\n\t\t\tlength++;\n\t\t\tp = p.next;\n\t\t}\n\t\t\n\t\t\n\t\tif(length<k){\n\t\t\tSystem.out.println(\"\"+k+\"\");\n\t\t\tresult = false;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\t\n\t\tNode<Integer> q = first;\n\t\tfor(int i=0;i<length-k;i++)\n\t\t\tq = q.next;\n\t\t\n\t\treturn q.data;\n\t}", "comment": "/**\n\t * @param first \u5355\u94fe\u8868\u7684\u9996\u7ed3\u70b9\n\t * @param k \u8981\u627e\u7684\u5012\u6570\u7b2c\u51e0\u4e2a\u5143\u7d20\n\t * @return \u8fd4\u56de\u5012\u6570\u7b2cK\u4e2a\u503c\n\t */"}}
{"code": {"body": "\tpublic static int getTailK_modify(Node<Integer> first,int k){\n\t\t\n\t\tif(first==null){\n\t\t\tSystem.out.println(\"\");\n\t\t\tresult = false;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\t\n\t\tif(k<1){\n\t\t\tSystem.out.println(\"\");\n\t\t\tresult = false;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\t\n\t\tNode<Integer> p = first;\n\t\tNode<Integer> q = first;\n\t\t\n\t\tfor(int i=0;i<k-1;i++){\n\t\t\t\n\t\t\tif(q.next==null){\n\t\t\t\tSystem.out.println(\"\"+k+\"\");\n\t\t\t\tresult = false;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tq = q.next;\n\t\t}\n\t\t\n\t\t\n\t\twhile(q.next!=null){\n\t\t\tp = p.next;\n\t\t\tq = q.next;\n\t\t}\n\t\t\n\t\treturn p.data;\n\t}", "comment": "/**\n\t * \u4e0a\u8ff0\u65b9\u6cd5\u80fd\u89e3\u51b3\u95ee\u9898\uff0c\u4f46\u9700\u8981\u904d\u5386\u94fe\u8868\u4e24\u6b21\uff0c\u80fd\u5426\u6709\u66f4\u9ad8\u6548\u7684\u529e\u6cd5\uff1f\n\t * \u53ef\u4ee5\u4f7f\u7528\u4e24\u4e2a\u6307\u9488i\u548cj\uff0c\u6307\u9488i\u4ece\u5934\u5f00\u59cb\u5148\u8d70k\u6b65\uff0c\u7136\u540ej\u6307\u5411\u7b2c\u4e00\u4e2a\u7ed3\u70b9\uff0c\u63a5\u4e0b\u6765\u4fdd\u6301i\u548cj\u4e4b\u95f4\u7684\u8ddd\u79bb\uff0c\u5f53j\u8d70\u5230\u5c3e\u65f6\uff0ci\u6307\u5411\u7684\u7ed3\u70b9\u5c31\u662f\u5012\u6570\u7b2ck\u4e2a\u7ed3\u70b9\u3002\n\t * \u4ee3\u7801\u5982\u4e0b\uff1a\n\t */"}}
{"code": {"body": "\tpublic static void main(String[] args){\n\t\tNode<Integer> node1 = new Node<Integer>();\n\t\tNode<Integer> node2 = new Node<Integer>();\n\t\tNode<Integer> node3 = new Node<Integer>();\n\t\tNode<Integer> node4 = new Node<Integer>();\n\t\tnode1.data = 1;\n\t\tnode2.data = 2;\n\t\tnode3.data = 3;\n\t\tnode4.data = 4;\n\t\tnode1.next = node2;\n\t\tnode2.next = node3;\n\t\tnode3.next = node4;\n\t\tSystem.out.println(getTailK_modify(node1,11));\n\t}", "comment": "/**\n\t * \u6d4b\u8bd5\n\t */"}}
{"code": {"body": "\tpublic static <T> Node<T> revertLink(Node<T> first){\n\t\t\n\t\tif(first==null){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t\n\t\tif(first.next==null){\n\t\t\treturn first;\n\t\t}\n\t\t\n\t\t\n\t\tif(first.next.next==null){\n\t\t\t\n\t\t\tNode<T> end = first.next;\n\t\t\t\n\t\t\tfirst.next.next = first;\n\t\t\t\n\t\t\tfirst.next = null;\n\t\t\treturn end;\n\t\t}\n\t\t\n\t\t\n\t\t{\n\t\t\tNode<T> a1 = first;\n\t\t\tNode<T> a2 = first.next;\n\t\t\tNode<T> a3 = first.next.next;\n\t\t\n\t\t\t\n\t\t\tfirst.next = null;\n\t\t\t\n\t\t\t\n\t\t\twhile(a3!=null){\n\t\t\t\t\n\t\t\t\ta2.next = a1;\n\t\t\t\t\n\t\t\t\ta1 = a2;\n\t\t\t\ta2 = a3;\n\t\t\t\ta3 = a3.next;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\ta2.next = a1;\n\t\t\treturn a2;\n\t\t}\n\t\t\n\t}", "comment": "/**\n\t * \u53cd\u8f6c\u94fe\u8868\n\t * @param first \u94fe\u8868\u7684\u5934\u7ed3\u70b9\n\t * @return \u8fd4\u56de\u53cd\u8f6c\u540e\u94fe\u8868\u7684\u5934\u7ed3\u70b9\n\t */"}}
{"code": {"body": "\tpublic static Node<Integer> mergeLink(Node<Integer> first1, Node<Integer> first2){\n\t\t\n\t\tif(first1==null && first2==null){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t\n\t\tif(first1==null && first2!=null)\n\t\t\treturn first2;\n\t\t\n\t\t\n\t\tif(first1!=null && first2==null)\n\t\t\treturn first1;\n\t\t\n\t\t\n\t\twhile(first2!=null){\n\t\t\t\n\t\t\tNode<Integer> p = first1;\n\t\t\t\n\t\t\t\n\t\t\tif(first2.data < p.data){\n\t\t\t\t\n\t\t\t\tNode<Integer> q = first2;\n\t\t\t\t\n\t\t\t\tfirst2 = first2.next;\n\t\t\t\t\n\t\t\t\tq.next = p;\n\t\t\t\tfirst1 = q;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tNode<Integer> p_pre = p;\n\t\t\twhile(p.data<=first2.data && p!=null){\n\t\t\t\tp_pre = p;\n\t\t\t\tp = p.next;\n\t\t\t}\n\t\t\t\n\t\t\tNode<Integer> q = first2;\n\t\t\t\n\t\t\tfirst2 = first2.next;\n\t\t\t\n\t\t\tq.next = p;\n\t\t\t\n\t\t\tp_pre.next = q;\n\t\t}\n\t\t\n\t\treturn first1;\n\t}", "comment": "/**\n\t * \u5408\u5e76\u4e24\u4e2a\u9012\u589e\u7684\u5355\u94fe\u8868\n\t * @param first1 \u7b2c\u4e00\u4e2a\u94fe\u8868\u7684\u5934\u7ed3\u70b9\n\t * @param first2 \u7b2c\u4e8c\u4e2a\u94fe\u8868\u7684\u5934\u7ed3\u70b9\n\t * @return \u8fd4\u56de\u5408\u5e76\u540e\u94fe\u8868\u7684\u5934\u7ed3\u70b9\n\t */"}}
{"code": {"body": "\tpublic static <T> void binaryTreeMirror(BinaryTreeNode<T> root){\n\t\t\n\t\tif(root==null)\n\t\t\treturn;\n\t\t\n\t\t\n\t\tif(root.left==null && root.right==null)\n\t\t\treturn;\n\t\t\n\t\t\n\t\t{\n\t\t\t\n\t\t\tBinaryTreeNode<T> temp = root.left;\n\t\t\troot.left = root.right;\n\t\t\troot.right = temp;\n\t\t}\n\t\t\n\t\t\n\t\t{\n\t\t\tif(root.left!=null)\n\t\t\t\tbinaryTreeMirror(root.left);\n\t\t\tif(root.right!=null)\n\t\t\t\tbinaryTreeMirror(root.right);\n\t\t}\n\t}", "comment": "/**\n\t * \u4e8c\u53c9\u6811\u955c\u50cf\u51fd\u6570\n\t * @param root \u8f93\u5165\u4e8c\u53c9\u6811\u7684\u6839\u7ed3\u70b9\n\t */"}}
{"code": {"body": "\tpublic static <T> void preOrder(BinaryTreeNode<T> root){\n\t\t\n\t\tif(root==null)\n\t\t\treturn;\n\t\t\n\t\t\n\t\t{\n\t\t\tpreOrder(root.left);\n\t\t\tSystem.out.print(root.data+\"\");\n\t\t\tpreOrder(root.right);\n\t\t}\n\t}", "comment": "/**\n\t * \u4e8c\u53c9\u6811\u7684\u4e2d\u5e8f\u904d\u5386\n\t * @param root \u8f93\u5165\u7684\u4e8c\u53c9\u6811\u7684\u6839\n\t */"}}
{"code": {"body": "public Stack(int max){\n\t\tthis.max = max;\n\t\t\n\t\tstack_a = new int[max];\n\t\t\n\t\tstack_b = new int[max];\n\t}", "comment": "/**\n\t * \u6784\u9020\u51fd\u6570\n\t * @param max \u6808\u5141\u8bb8\u7684\u6700\u5927\u6df1\u5ea6\n\t */"}}
{"code": {"body": "\tpublic boolean push(int t){\n\t\t\n\t\tif(top_a==max-1){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t\n\t\t{\n\t\t\t\n\t\t\tstack_a[++top_a] = t;\n\t\t\t\n\t\t\tif(top_b==-1 || t<stack_b[top_b])\n\t\t\t\tstack_b[++top_b]=t;\n\t\t\telse{\n\t\t\t\tstack_b[top_b+1]=stack_b[top_b];\n\t\t\t\ttop_b++;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}", "comment": "/**\n\t * \u5165\u6808\n\t * @param t \u5165\u6808\u7684\u5143\u7d20\n\t * @return \u8fd4\u56de\u5165\u6808\u64cd\u4f5c\u7684\u7ed3\u679c\n\t */"}}
{"code": {"body": "\tpublic int pop(){\n\t\t\n\t\tif(top_a==-1){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\t\n\t\t{\n\t\t\t\n\t\t\ttop_b--;\n\t\t\t\n\t\t\treturn stack_a[top_a--];\n\t\t}\n\t}", "comment": "/**\n\t * \u51fa\u6808\n\t * @return \u8fd4\u56de\u6808\u9876\u5143\u7d20\n\t */"}}
{"code": {"body": "\tpublic int min(){\n\t\t\n\t\tif(top_a==-1){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\t\n\t\treturn stack_b[top_b];\n\t}", "comment": "/**\n\t * \u83b7\u53d6\u6808\u4e2d\u7684\u6700\u5c0f\u503c\n\t * @return \u8fd4\u56de\u6808\u4e2d\u6700\u5c0f\u503c\n\t */"}}
{"code": {"body": "\tpublic static void main(String[] args){\n\t\t\n\t\tStack stack = new Stack(10);\n\t\t\n\t\t\n\t\tSystem.out.println(\"\");\n\t\tstack.pop();\n\t\t\n\t\t\n\t\tSystem.out.println(\"\");\n\t\tstack.push(5);\n\t\tstack.push(4);\n\t\tstack.push(3);\n\t\tstack.push(2);\n\t\tstack.push(1);\n\t\t\n\t\t\n\t\tSystem.out.println(\"\"+stack.min());\n\t\t\n\t\t\n\t\tSystem.out.println(\"\"+stack.pop());\n\n\t\t\n\t\tSystem.out.println(\"\"+stack.min());\n\t\t\n\t}", "comment": "/**\n\t * \u6d4b\u8bd5\n\t */"}}
{"code": {"body": "\tpublic static boolean isStackSequence(int[] a,int[] b){\n\t\t\n\t\tif(a==null || b==null || a.length<=0 || b.length<=0){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t\n\t\tif(a.length != b.length){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t\n\t\t{\n\t\t\t\n\t\t\tStack<Integer> stack = new Stack<Integer>();\n\t\t\tint i=0,j=0;\n\t\t\twhile(i<a.length){\n\t\t\t\t\n\t\t\t\tstack.add(a[i++]);\n\t\t\t\t\n\t\t\t\tif(stack.peek()==b[j]){\n\t\t\t\t\t\n\t\t\t\t\tstack.pop();\n\t\t\t\t\t\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\twhile(!stack.isEmpty()){\n\t\t\t\tif(stack.pop()!=b[j])\n\t\t\t\t\treturn false;\n\t\t\t\telse\n\t\t\t\t\tj++;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif(!stack.isEmpty())\n\t\t\t\treturn false; \n\t\t}\n\t\t\n\t\treturn true;\n\t}", "comment": "/**\n\t * \u5224\u65ad\u51fa\u6808\u5e8f\u5217\u662f\u5426\u7b26\u5408\u6307\u5b9a\u5165\u6808\u5e8f\u5217\u7684\u67d0\u4e00\u79cd\u51fa\u6808\u987a\u5e8f\n\t * @param a \u5165\u6808\u5e8f\u5217\n\t * @param b \u51fa\u6808\u5e8f\u5217\n \t * @return \u8fd4\u56de\u6267\u884c\u7ed3\u679c\n\t */"}}
{"code": {"body": "\tpublic static void main(String[] args){\n\t\t\n\t\tint[] a = {1,2,3,4,5};\n\t\t\n\t\tint[] b = {4,3,5,1,2};\n\t\tSystem.out.println(isStackSequence(a,b));\n\t}", "comment": "/**\n\t * \u6d4b\u8bd5\n\t */"}}
{"code": {"body": "\tpublic static boolean printBinaryTree(BinaryTreeNode<Integer> root){\n\t\t\n\t\tif(root==null){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t\n\t\tQueue<BinaryTreeNode<Integer>> queue = new LinkedBlockingQueue<BinaryTreeNode<Integer>>();\n\t\t\n\t\tqueue.add(root);\n\t\t\n\t\twhile(!queue.isEmpty()){\n\t\t\t\n\t\t\tBinaryTreeNode<Integer> first_node = queue.poll();\n\t\t\tSystem.out.println(first_node.data);\n\t\t\t\n\t\t\tif(first_node.left!=null)\n\t\t\t\tqueue.add(first_node.left);\n\t\t\tif(first_node.right!=null)\n\t\t\t\tqueue.add(first_node.right);\n\t\t}\n\t\treturn true;\n\t}", "comment": "/**\n\t * \u9996\u5148\u9700\u8981\u521b\u5efa\u4e00\u4e2a\u961f\u5217\uff0c\u7528\u4e8e\u5b58\u50a8\u5c1a\u672a\u6253\u5370\u7684\u7ed3\u70b9\u3002\n\t * \u9996\u5148\u8ba9\u6839\u7ed3\u70b9\u5165\u961f\uff0c\u7136\u540e\u91cd\u590d\u4e00\u4e0b\u64cd\u4f5c\uff0c\u76f4\u5230\u5bf9\u4e3a\u7a7a\u4e3a\u6b62\uff1a\n\t * \u4ece\u961f\u9996\u53d6\u51fa\u4e00\u4e2a\u7ed3\u70b9\uff0c\u5e76\u6253\u5370\u8be5\u7ed3\u70b9\uff0c\u82e5\u8be5\u7ed3\u70b9\u6709\u5b69\u5b50\uff0c\u5219\u6309\u7167\u5148\u5de6\u540e\u53f3\u7684\u987a\u5e8f\u5c06\u5de6\u53f3\u5b69\u5b50\u5165\u961f\u3002\n\t * \u91cd\u590d\u4e0a\u8ff0\u64cd\u4f5c\uff0c\u5f53\u961f\u4e3a\u7a7a\u65f6\uff0c\u904d\u5386\u7ed3\u675f\u3002\n\t */"}}
{"code": {"body": "\tpublic static void main(String[] args){\n\t\t\n\t\tBinaryTreeNode<Integer> root = new BinaryTreeNode<Integer>();\n\t\tBinaryTreeNode<Integer> node1 = new BinaryTreeNode<Integer>();\n\t\tBinaryTreeNode<Integer> node2 = new BinaryTreeNode<Integer>();\n\t\tBinaryTreeNode<Integer> node3 = new BinaryTreeNode<Integer>();\n\t\tBinaryTreeNode<Integer> node4 = new BinaryTreeNode<Integer>();\n\t\tBinaryTreeNode<Integer> node5 = new BinaryTreeNode<Integer>();\n\t\t\n\t\troot.data = 1;\n\t\tnode1.data = 2;\n\t\tnode2.data = 3;\n\t\tnode3.data = 4;\n\t\tnode4.data = 5;\n\t\tnode5.data = 6;\n\t\t\n\t\troot.left = node1;\n\t\troot.right = node2;\n\t\t\n\t\tnode1.left = node3;\n\t\tnode1.right = node4;\n\n\t\tnode2.right = node5;\n\t\t\n\t\tprintBinaryTree(root);\n\t}", "comment": "/**\n\t * \u6d4b\u8bd5\n\t */"}}
{"code": {"body": "\tpublic static boolean isSearchTree(int[] a,int start,int end){\n\t\t\n\t\tif(a==null || a.length<=0){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t\n\t\tif(start<0 || end>=a.length){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t\n\t\tif(end-start==2){\n\t\t\tSystem.out.println(\"\");\n\t\t\t\n\t\t\tif(a[start]>a[end] || a[start+1]<a[end])\n\t\t\t\treturn false;\n\t\t\telse\n\t\t\t\treturn true;\n\t\t}\n\t\t\n\t\t\n\t\telse if(end-start<=1){\n\t\t\tSystem.out.print(\"\");\n\t\t\tfor(int x=start;x<=end;x++)\n\t\t\t\tSystem.out.println(a[x]+\"\");\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\t\n\t\telse{\n\t\t\tSystem.out.print(\"\");\n\t\t\tfor(int x=start;x<=end;x++)\n\t\t\t\tSystem.out.println(a[x]+\"\");\n\t\t\t\n\t\t\tint root = a[end];\n\t\t\t\n\t\t\tint i=start;\n\t\t\twhile(i<end && a[i]<root)\n\t\t\t\ti++;\n\t\t\t\n\t\t\tfor(int j=i;j<end;j++){\n\t\t\t\tif(a[j]<root)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tboolean result_tail = true;\n\t\t\tboolean result_pre = true;\n\t\t\tif(start>end)\n\t\t\t\tresult_tail = isSearchTree(a,start,end-1);\n\t\t\telse{\n\t\t\t\tresult_pre = isSearchTree(a,start,i-1);\n\t\t\t\t\n\t\t\t\tresult_tail = isSearchTree(a,i,end);\n\t\t\t}\n\t\t\tif(result_pre && result_tail)\n\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}\n\t}", "comment": "/**\n\t * \u5224\u65ad\u8f93\u5165\u7684\u540e\u5e8f\u904d\u5386\u5e8f\u5217\u80fd\u5426\u6784\u6210\u4e00\u68f5\u4e8c\u53c9\u641c\u7d22\u6811\n\t * @param a \u540e\u5e8f\u904d\u5386\u5e8f\u5217\n\t * @param start \u5e8f\u5217\u8d77\u59cb\u4e0b\u6807\n\t * @param end \u5e8f\u5217\u7ed3\u675f\u4e0b\u6807\n\t * @return \u8fd4\u56de\u5224\u65ad\u7684\u7ed3\u679c\n\t */"}}
{"code": {"body": "\tpublic static void main(String[] args){\n\t\tint[] a = {5,7,6,9,11,10,8};\n\t\tSystem.out.println(\"\"+isSearchTree(a,0,a.length-1));\n\t}", "comment": "/**\n\t * \u6d4b\u8bd5\n\t */"}}
{"code": {"body": "\tprivate static void printBinaryPath(BinaryTreeNode<Integer> root, int n, Stack<Integer> stack) {\n\t\t\n\t\tif(root.left==null && root.right==null){\n\t\t\t\n\t\t\tstack.add(root.data);\n\t\t\t\n\t\t\t\n\t\t\tint sum = 0;\n\t\t\tIterator<Integer> it = stack.iterator();\n\t\t\twhile(it.hasNext())\n\t\t\t\tsum += it.next();\n\t\t\t\n\t\t\t\n\t\t\tif(sum==n){\n\t\t\t\tIterator<Integer> it2 = stack.iterator();\n\t\t\t\twhile(it2.hasNext())\n\t\t\t\t\tSystem.out.print(it2.next()+\"\");\n\t\t\t\tSystem.out.println(\"\");\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tstack.pop();\n\t\t\t\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t\n\t\telse{\n\t\t\t\n\t\t\tstack.add(root.data);\n\t\t\t\n\t\t\t\n\t\t\tif(root.left!=null)\n\t\t\t\tprintBinaryPath(root.left,n,stack);\n\t\t\t\n\t\t\t\n\t\t\tif(root.right!=null)\n\t\t\t\tprintBinaryPath(root.right,n,stack);\n\t\t\t\n\t\t\t\n\t\t\tstack.pop();\n\t\t\t\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t}", "comment": "/**\n\t * \u9012\u5f52\u5bfb\u627e\u8def\u5f84\u4e4b\u548c\u4e3an\u7684\u8def\u5f84\n\t * @param root \u4e8c\u53c9\u6811\u6839\u7ed3\u70b9\n\t * @param n \u6307\u5b9a\u6574\u6570\n\t * @param stack \u7528\u4e8e\u4fdd\u5b58\u5f53\u524d\u8def\u5f84\u7684\u6808\n\t */"}}
{"code": {"body": "\tpublic static void main(String[] args){\n\t\t\n\t\tBinaryTreeNode<Integer> node1 = new BinaryTreeNode<Integer>();\n\t\tBinaryTreeNode<Integer> node2 = new BinaryTreeNode<Integer>();\n\t\tBinaryTreeNode<Integer> node3 = new BinaryTreeNode<Integer>();\n\t\tBinaryTreeNode<Integer> node4 = new BinaryTreeNode<Integer>();\n\t\tBinaryTreeNode<Integer> node5 = new BinaryTreeNode<Integer>();\n\t\t\n\t\tnode1.data = 10;\n\t\tnode2.data = 5;\n\t\tnode3.data = 12;\n\t\tnode4.data = 4;\n\t\tnode5.data = 7;\n\t\t\n\t\tnode1.left = node2;\n\t\tnode1.right = node3;\n\n\t\tnode2.left = node4;\n\t\tnode2.right = node5;\n\t\t\n\t\tprintBinaryPath(node1,19);\n\t}", "comment": "/**\n\t * \u6d4b\u8bd5\n\t */"}}
{"code": {"body": "\tpublic static int countNumber(int[] a){\n\t\t\n\t\tif(a==null || a.length<=0){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\t\n\t\tQuickSort.QuickSort(a);\n\t\t\n\t\t\n\t\tint mid = a[a.length/2];\n\t\t\n\t\t\n\t\tint count = 0;\n\t\tfor(int i=0;i<a.length && a[i]<=mid;i++){\n\t\t\tif(a[i]==mid)\n\t\t\t\tcount++;\n\t\t}\n\t\t\n\t\t\n\t\tif(count>=a.length/2)\n\t\t\treturn mid;\n\t\telse\n\t\t\treturn -1;\n\t}", "comment": "/**\n\t * \u83b7\u53d6\u6570\u7ec4\u4e2d\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u534a\u7684\u90a3\u4e2a\u6570\n\t * @param a \u8f93\u5165\u7684\u6570\u7ec4\n\t * @return \u8fd4\u56de\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u534a\u7684\u90a3\u4e2a\u6570(\u8fd4\u56de\uff0d1\u8868\u793a\u51fd\u6570\u51fa\u9519)\n\t */"}}
{"code": {"body": "\tpublic static void main(String[] args){\n\t\tint[] a = {3,1,3,2,3,2,3,2,2,3,5,3,4,2,3,3};\n\t\tSystem.out.println(countNumber(a));\n\t}", "comment": "/**\n\t * \u6d4b\u8bd5\n\t */"}}
{"code": {"body": "\tpublic static boolean getMinKNumber(int[] a,int k){\n\t\t\n\t\tif(a==null || a.length<=0){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t\n\t\tif(k>a.length){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tTwoWayNode<Integer> first = new TwoWayNode<Integer>();\n\t\t{\n\t\t\tfirst.data = a[0];\n\t\t\t\n\t\t\tint link_node = 1;\n\t\t\t\n\t\t\tTwoWayNode<Integer> last = first;\n\t\t\t\n\t\t\tfor(int i=1;i<a.length;i++){\n\t\t\t\t\n\t\t\t\tif(a[i]<=last.data){\n\t\t\t\t\tSystem.out.println(\"\"+i+\"\"+a[i]+\"\");\n\t\t\t\t\t\n\t\t\t\t\tTwoWayNode<Integer> p = last.pre;\n\t\t\t\t\twhile(p!=null && p.data>a[i])\n\t\t\t\t\t\tp = p.pre;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tTwoWayNode<Integer> node = new TwoWayNode<Integer>();\n\t\t\t\t\tnode.data = a[i];\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tnode.next = p.next;\n\t\t\t\t\tnode.next.pre = node;\n\t\t\t\t\tp.next = node;\n\t\t\t\t\tnode.pre = p;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tlink_node++;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tif(link_node==4){\n\t\t\t\t\t\t\n\t\t\t\t\t\tlast.pre.next = null;\n\t\t\t\t\t\tlast.pre = null;\n\t\t\t\t\t\t\n\t\t\t\t\t\tlink_node--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tTwoWayNode<Integer> node = first;\n\t\t\twhile(node!=null){\n\t\t\t\tSystem.out.print(node.data+\"\");\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}", "comment": "/**\n\t * \u83b7\u53d6\u6570\u7ec4a\u4e2d\u6700\u5c0f\u7684k\u4e2a\u6574\u6570\n\t * @param a \u8f93\u5165\u7684\u6570\u7ec4\n\t * @param k \u9700\u8981\u6253\u5370\u7684\u6700\u5c0f\u6570\u7684\u4e2a\u6570\n\t * @return \u8fd4\u56de\u7b97\u6cd5\u6267\u884c\u7ed3\u679c\n\t */"}}
{"code": {"body": "\tpublic static boolean getMinKNumber2(int[] a,int k){\n\t\t\n\t\tif(a==null || a.length<=0){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t\n\t\tif(k>a.length){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t\n\t\tTwoWayNode<Integer> first = new TwoWayNode<Integer>();\n\t\tfirst.next = first.pre = null;\n\t\tfirst.data = a[0];\n\t\t\n\t\tint node_count = 1;\n\t\t\n\t\tTwoWayNode<Integer> last = first;\n\t\t\n\t\t\n\t\tfor(int i=1;i<a.length;i++){\n\t\t\t\n\t\t\tif(node_count<k){\n\t\t\t\t\n\t\t\t\tinsertNodeByOrder(a[i],first,last);\n\t\t\t\t\n\t\t\t\tnode_count++;\n\n\t\t\t}\n\t\t\t\n\t\t\telse if(node_count>=k && a[i]<=last.data){\n\t\t\t\t\n\t\t\t\tinsertNodeByOrder(a[i],first,last);\n\t\t\t\t\n\t\t\t\tnode_count++;\n\t\t\t\t\n\t\t\t\tif(node_count>k){\n\t\t\t\t\t\n\t\t\t\t\tlast.pre.next = null;\n\t\t\t\t\tlast.pre = null;\n\t\t\t\t\t\n\t\t\t\t\tnode_count--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tTwoWayNode<Integer> p = first;\n\t\twhile(p!=null){\n\t\t\tSystem.out.print(p.data+\"\");\n\t\t\tp = p.next;\n\t\t}\n\t\tSystem.out.println(\"\");\n\t\treturn true;\n\t}", "comment": "/**\n\t * \u83b7\u53d6\u6570\u7ec4a\u4e2d\u6700\u5c0f\u7684k\u4e2a\u6574\u6570\n\t * @param a \u8f93\u5165\u7684\u6570\u7ec4\n\t * @param k \u9700\u8981\u6253\u5370\u7684\u6700\u5c0f\u6570\u7684\u4e2a\u6570\n\t * @return \u8fd4\u56de\u7b97\u6cd5\u6267\u884c\u7ed3\u679c\n\t */"}}
{"code": {"body": "\tprivate static void insertNodeByOrder(int a, TwoWayNode<Integer> first, TwoWayNode<Integer> last) {\n\t\t\n\t\tTwoWayNode<Integer> node = new TwoWayNode<Integer>();\n\t\tnode.data = a;\n\t\t\n\t\t\n\t\tif(last==null){\n\t\t\tlast = node;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t\n\t\tTwoWayNode<Integer> p = last;\n\t\tSystem.out.println(\"\"+p!=null && p.data>a);\n\t\twhile(p!=null && p.data>a){\n\t\t\tp = p.pre;\n\t\t}\n\t\tSystem.out.println(\"\"+p.next);\n\t\t\n\t\t\n\t\tif(p==null){\n\t\t\tSystem.out.println(a+\"\"+first.data+\"\");\n\t\t\tfirst.pre = node;\n\t\t\tnode.next = first;\n\t\t\tfirst = node;\n\t\t}\n\t\t\n\t\t\n\t\telse if(p.next==null){\n\n\n\n\t\t\tnode.pre = last;\n\t\t\tlast.next = node;\n\t\t\tlast = node;\n\t\t\tSystem.out.println(\"\");\n\t\t}\n\t\t\n\t\t\n\t\telse{\n\t\t\tnode.next = p.next;\n\t\t\tp.next.pre = node;\n\t\t\tnode.pre = p;\n\t\t\tp.next = node;\n\t\t\tSystem.out.println(\"\");\n\t\t}\n\t\t\n\t\t\n\t\tTwoWayNode<Integer> t = first;\n\t\twhile(t!=null){\n\t\t\tSystem.out.print(t.data);\n\t\t\tt = t.next;\n\t\t}\n\t\tSystem.out.println(\"\");\n\n\t}", "comment": "/**\n\t * \u5411\u53cc\u5411\u94fe\u8868\u4e2d\u6309\u7167\u9012\u589e\u987a\u5e8f\u63d2\u5165\u4e00\u4e2a\u7ed3\u70b9\n\t * @param a \u5e26\u63d2\u5165\u7684\u7ed3\u70b9\u7684\u6570\u503c\n\t * @param first \u53cc\u5411\u94fe\u8868\u7684\u5934\u7ed3\u70b9\n\t * @param last \u53cc\u5411\u94fe\u8868\u7684\u5c3e\u7ed3\u70b9\n\t */"}}
{"code": {"body": "\tpublic static void main(String[] args){\n\t\tint[] a = {1,2,3,4,5,6,7};\n\t\tgetMinKNumber2(a,4);\n\t}", "comment": "/**\n\t * \u6d4b\u8bd5\n\t */"}}
{"code": {"body": "\tpublic static void main(String[] args){\n\t\tint[] a = {1,-2,3,10,-4,7,2,1,-5};\n\t\tSystem.out.println(\"\"+result);\n\t\tSystem.out.println(\"\"+getMaxSubArray(a));\n\t}", "comment": "/**\n\t * \u6d4b\u8bd5\n\t */"}}
{"code": {"body": "\tpublic static int countOne(int n){\n\t\t\n\t\tif(n<1){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\t\n\t\tint count = 0;\n\t\t\n\t\t\n\t\tfor(int i=1;i<=n;i++){\n\t\t\t\n\t\t\tint temp = i;\n\t\t\twhile(temp>0){\n\t\t\t\t\n\t\t\t\tif(temp%10==1)\n\t\t\t\t\tcount++;\n\t\t\t\t\n\t\t\t\ttemp /= 10;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn count;\n\t}", "comment": "/**\n\t * \u7edf\u8ba11-n\u4e2d\u201c1\u201d\u51fa\u73b0\u7684\u6b21\u6570\n\t * @param n\n\t * @return \u8fd4\u56de1\u51fa\u73b0\u7684\u6b21\u6570\uff08\u82e5\u8fd4\u56de\uff0d1\u8868\u793a\u7a0b\u5e8f\u51fa\u9519\uff09\n\t */"}}
{"code": {"body": "\tpublic static void main(String[] args){\n\t\tSystem.out.println(countOne(13));\n\t}", "comment": "/**\n\t * \u6d4b\u8bd5\n\t */"}}
{"code": {"body": "\tpublic static int uglyNumber(int n){\n\t\t\n\t\tif(n<=0){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\t\n\t\tint[] a = new int[n];\n\t\ta[0] = 1;\n\t\t\n\t\t\n\t\tint count = 1;\n\t\t\n\t\t\n\t\twhile(count<n){\n\t\t\tint i=0,j=0,z=0;\n\t\t\t\n\t\t\tfor(i=0;i<a.length && a[i]*2<=a[count-1];i++);\n\t\t\t\n\t\t\tfor(j=0;j<a.length && a[j]*3<=a[count-1];j++);\n\t\t\t\n\t\t\tfor(z=0;z<a.length && a[z]*5<=a[count-1];z++);\n\t\t\t\n\t\t\t\n\t\t\tint min = a[i]*2;\n\t\t\tif(a[j]*3<min)\n\t\t\t\tmin = a[j]*3;\n\t\t\tif(a[z]*5<min)\n\t\t\t\tmin = a[z]*5;\n\t\t\t\n\t\t\t\n\t\t\ta[count++] = min;\n\t\t}\n\t\t\n\t\treturn a[count-1];\n\t}", "comment": "/**\n\t * \u8ba1\u7b97\u7b2cn\u4e2a\u4e11\u6570\n\t * @param n\n\t * @return \u8fd4\u56de\u7b2cn\u4e2a\u4e11\u6570(\u8fd4\u56de\uff0d1\u8868\u793a\u7a0b\u5e8f\u51fa\u9519)\n\t */"}}
{"code": {"body": "\tpublic static void main(String[] args){\n\t\tSystem.out.println(uglyNumber(5));\n\t}", "comment": "/**\n\t * \u6d4b\u8bd5\n\t */"}}
{"code": {"body": "\tpublic static void main(String[] args){\n\t\tchar[] a = {'','','','','','','','',''};\n\t\tSystem.out.println(getFirstChar(a));\n\t}", "comment": "/**\n\t * \u6d4b\u8bd5\n\t */"}}
{"code": {"body": "\tpublic static int getKNumber(int[] a,int k){\n\t\t\n\t\tif(a==null || a.length<=0){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\t\n\t\tint start = 0;\n\t\t\n\t\tint end = a.length-1;\n\t\t\n\t\t\n\t\tint k_start = -1;\n\t\t\n\t\tint k_end = -1;\n\t\t\n\t\t\n\t\twhile(end-start >= 0){\n\t\t\t\n\t\t\tint mid = (start+end)/2;\n\t\t\t\n\t\t\t\n\t\t\tif(a[mid]>k){\n\t\t\t\tend = mid-1;\n\t\t\t}\n\t\t\t\n\t\t\telse if(a[mid]<k){\n\t\t\t\tstart = mid+1;\n\t\t\t}\n\t\t\t\n\t\t\telse{\n\t\t\t\t\n\t\t\t\tif(a[mid-1]==k){\n\t\t\t\t\tend = mid-1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\telse{\n\t\t\t\t\tk_start = mid;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tstart = 0;\n\t\tend = a.length-1;\n\t\t\n\t\twhile(end-start >= 0){\n\t\t\t\n\t\t\tint mid = (start+end)/2;\n\t\t\t\n\t\t\t\n\t\t\tif(a[mid]>k){\n\t\t\t\tend = mid-1;\n\t\t\t}\n\t\t\t\n\t\t\telse if(a[mid]<k){\n\t\t\t\tstart = mid+1;\n\t\t\t}\n\t\t\t\n\t\t\telse{\n\t\t\t\t\n\t\t\t\tif(a[mid+1]==k){\n\t\t\t\t\tstart = mid+1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\telse{\n\t\t\t\t\tk_end = mid;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tif(k_start==-1 || k_end==-1)\n\t\t\treturn 0;\n\t\t\n\t\t\n\t\treturn k_end-k_start+1;\n\t}", "comment": "/**\n\t * \u83b7\u53d6\u6570\u7ec4\u4e2dK\u51fa\u73b0\u7684\u4e2a\u6570\n\t * @param a \u6570\u7ec4\n\t * @param k\n\t * @return \u8fd4\u56deK\u51fa\u73b0\u7684\u4e2a\u6570(\u82e5\u4e3a\uff0d1\u8868\u793a\u83b7\u53d6\u5931\u8d25)\n\t */"}}
{"code": {"body": "\tpublic static void main(String[] args){\n\t\t\n\t\tint[] a = {0,1,2,3,4,6,7,7,7,7,7,7,8,9};\n\t\t\n\t\tSystem.out.println(getKNumber(a,7));\n\t}", "comment": "/**\n\t * \u6d4b\u8bd5\n\t */"}}
{"code": {"body": "\tpublic static <T> Node<T> getFirstCommonNode_1(Node<T> first1,Node<T> first2){\n\t\t\n\t\tif(first1==null || first2==null){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t\n\t\tStack<Node<T>> stack1 = new Stack<Node<T>>();\n\t\tStack<Node<T>> stack2 = new Stack<Node<T>>();\n\t\t\n\t\t\n\t\tNode<T> p = first1;\n\t\twhile(p!=null){\n\t\t\tstack1.push(p);\n\t\t\tp = p.next;\n\t\t}\n\t\t\n\t\tp = first2;\n\t\twhile(p!=null){\n\t\t\tstack2.push(p);\n\t\t\tp = p.next;\n\t\t}\n\t\t\n\t\t\n\t\tNode<T> commonNode = null;\n\t\twhile(stack1.peek() == stack2.peek()){\n\t\t\tcommonNode = stack1.peek();\n\t\t\tstack1.pop();\n\t\t\tstack2.pop();\n\t\t}\n\t\t\n\t\treturn commonNode;\n\t}", "comment": "/**\n\t * \u83b7\u53d6\u4e24\u6761\u94fe\u8868\u7684\u7b2c\u4e00\u4e2a\u516c\u5171\u7ed3\u70b9\n\t * @param first1\n\t * @param first2\n\t * @return\n\t */"}}
{"code": {"body": "\tpublic static <T> Node<T> getFirstCommonNode_2(Node<T> first1,Node<T> first2){\n\t\t\n\t\tif(first1==null || first2==null){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t\n\t\tint len1 = 0;\n\t\tNode<T> p = first1;\n\t\twhile(p!=null){\n\t\t\tlen1++;\n\t\t\tp = p.next;\n\t\t}\n\t\t\n\t\t\n\t\tint len2 = 0;\n\t\tp = first2;\n\t\twhile(p!=null){\n\t\t\tlen2++;\n\t\t\tp = p.next;\n\t\t}\n\n\t\t\n\t\tint diff = len1 - len2;\n\t\t\n\t\t\n\t\tif(diff > 0)\n\t\t\tfor(int i=0;i<diff;i++)\n\t\t\t\tfirst1 = first1.next;\n\t\t\n\t\telse\n\t\t\tfor(int i=0;i<diff;i++)\n\t\t\t\tfirst2 = first2.next;\n\t\t\n\t\t\n\t\tNode<T> p1 = first1;\n\t\tNode<T> p2 = first2;\n\t\twhile(p1 != p2 && p1!=null && p2!=null){\n\t\t\tp1 = p1.next;\n\t\t\tp2 = p2.next;\n\t\t}\n\t\t\n\t\treturn p1;\n\t}", "comment": "/**\n\t * \u4e0a\u8ff0\u65b9\u6cd5\u65f6\u95f4\u590d\u6742\u5ea6\u6709\u6240\u63d0\u5347\uff0c\u4f46\u9700\u8981\u989d\u5916\u7684\u5b58\u50a8\u7a7a\u95f4\uff0c\u662f\u5426\u6709\u9c7c\u548c\u718a\u638c\u517c\u5f97\u7684\u65b9\u6cd5\u5462\uff1f\n\t * \n\t * \u4e0a\u8ff0\u65b9\u5f0f\u4f7f\u7528\u4e86\u6808\uff0c\u56e0\u6b64\u9700\u8981\u989d\u5916\u7684\u5b58\u50a8\u7a7a\u95f4\uff1b\u800c\u4f7f\u7528\u6808\u662f\u56e0\u4e3a\u9700\u8981\u4ece\u540e\u5411\u524d\u904d\u5386\uff1b\u4e4b\u6240\u4ee5\u8981\u4ece\u540e\u5411\u524d\u904d\u5386\u662f\u56e0\u4e3a\u4e24\u6761\u5355\u94fe\u8868\u7684\u957f\u5ea6\u4e0d\u4e00\u6837\uff0c\u800c\u53d1\u751f\u91cd\u5408\u7684\u90e8\u5206\u662f\u5728\u94fe\u8868\u7684\u5c3e\u90e8\u3002\n\t * \u56e0\u6b64\uff0c\u5982\u679c\u6211\u4eec\u628a\u4e24\u6761\u957f\u5ea6\u4e0d\u7b49\u7684\u5355\u94fe\u8868\u4e2d\u957f\u7684\u90a3\u90e8\u5206\u5934\u5207\u6389\uff0c\u4f7f\u5f97\u4e24\u6761\u94fe\u8868\u4e00\u6837\u957f\uff0c\u7136\u540e\u4ece\u524d\u5411\u540e\u904d\u5386\uff0c\u53ea\u8981\u53d1\u73b0\u54ea\u4e2a\u7ed3\u70b9\u76f8\u540c\uff0c\u8be5\u7ed3\u70b9\u5c31\u662f\u6211\u4eec\u8981\u627e\u7684\u7b2c\u4e00\u4e2a\u516c\u5171\u7ed3\u70b9\u3002\n\t * \u4ee3\u7801\u5982\u4e0b\uff1a\n\t */"}}
{"code": {"body": "\tpublic static void main(String[] args){\n\t\t\n\t\tNode<Integer> first1 = new Node<Integer>();\n\t\tNode<Integer> node2 = new Node<Integer>();\n\t\tNode<Integer> node3 = new Node<Integer>();\n\t\tNode<Integer> first2 = new Node<Integer>();\n\t\tNode<Integer> node4 = new Node<Integer>();\n\t\tNode<Integer> node5 = new Node<Integer>();\n\t\t\n\t\tfirst1.data = 111;\n\t\tnode2.data = 2;\n\t\tnode3.data = 3;\n\t\tnode4.data = 4;\n\t\tnode5.data = 5;\n\t\tfirst2.data = 222;\n\t\t\n\t\t\n\t\tfirst1.next = node2;\n\t\tnode2.next = node3;\n\t\tnode3.next = node4;\n\t\tnode4.next = node5;\n\t\t\n\t\tfirst2.next = node3;\n\t\t\n\t\tSystem.out.println(getFirstCommonNode_2(first1, first2).data);\n\t}", "comment": "/**\n\t * \u6d4b\u8bd5\n\t */"}}
{"code": {"body": "\tpublic static <T> int getTreeHeight(Node<T> root){\n\t\t\n\t\tif(root==null){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\t\n\t\tif(root.left==null && root.right==null)\n\t\t\t\n\t\t\treturn 1;\n\t\t\n\t\t\n\t\telse if (root.right == null) \n\t\t\t\n\t\t\treturn getTreeHeight(root.right) + 1;\n\t\t\n\t\t\n\t\telse if (root.left == null) \n\t\t\treturn getTreeHeight(root.left) + 1;\n\t\t\n\t\t\n\t\telse {\n\t\t\t\n\t\t\tint left_height = getTreeHeight(root.left);\n\t\t\tint right_height = getTreeHeight(root.right);\n\t\t\treturn (left_height > right_height ? left_height : right_height) + 1;\n\t\t}\n\t\t\n\t}", "comment": "/**\n\t * \u8ba1\u7b97\u4e8c\u53c9\u6811\u7684\u6df1\u5ea6\n\t * @param root \u4e8c\u53c9\u6811\u7684\u6839\u7ed3\u70b9\n\t * @return \u8fd4\u56de\u6df1\u5ea6(\u8fd4\u56de\uff0d1\u8868\u793a\u7a0b\u5e8f\u51fa\u9519)\n\t */"}}
{"code": {"body": "public Queue(int maxSize){\n\t\t\n\t\tif(maxSize<=0){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t\n\t\tstack1 = new Stack<T>(maxSize);\n\t\tstack2 = new Stack<T>(maxSize);\n\t\tthis.maxSize = maxSize;\n\t}", "comment": "/**\n\t * \u521d\u59cb\u5316\u961f\u5217\n\t * @param maxSize \u8bbe\u7f6e\u6700\u5927\u5bb9\u91cf\n\t */"}}
{"code": {"body": "\tpublic boolean push(T obj){\n\t\t\n\t\tif(obj==null){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t\n\t\tif(stack1.getCurSize()>=maxSize){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t\n\t\tstack1.push(obj);\n\t\tcurSize++;\n\t\treturn true;\n\t}", "comment": "/**\n\t * \u5165\u961f \n\t * @param obj \u5165\u961f\u7684\u5143\u7d20\n\t */"}}
{"code": {"body": "\tpublic T pop(){\n\t\t\n\t\tif(curSize==0){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t\n\t\t\n\n\n\n\t\t\n\t\t\n\t\tif(stack2.getCurSize()>0){\n\t\t\tcurSize--;\n\t\t\treturn stack2.pop();\n\t\t}\n\t\t\n\t\telse{\n\t\t\twhile(stack1.getCurSize()>0){\n\t\t\t\tstack2.push(stack1.pop());\n\t\t\t}\n\t\t\t\n\t\t\tcurSize--;\n\t\t\treturn stack2.pop();\n\t\t}\n\t}", "comment": "/**\n\t * \u51fa\u961f\n\t */"}}
{"code": {"body": "\tpublic static void main(String[] args){\n\t\tQueue<Integer> queue = new Queue<Integer>(10);\n\t\tfor(int i=0;i<10;i++)\n\t\t\tqueue.push(i+1);\n\t\tqueue.toString();\n\t\tqueue.pop();\n\t\tqueue.toString();\n\t}", "comment": "/**\n\t * \u6d4b\u8bd5\n\t */"}}
{"code": {"body": "\tpublic static void ageSort(int[] ages){\n\t\t\n\t\tint[] countAge = new int[100];\n\t\t\n\t\t\n\t\tif(ages==null || ages.length<=0){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=0;i<ages.length;i++){\n\t\t\tif(ages[i]<0 || ages[i]>99){\n\t\t\t\tSystem.out.println(\"\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfor(int i=0;i<ages.length;i++)\n\t\t\tcountAge[ages[i]]++;\n\t\t\n\t\t\n\t\tint curIndex = 0;\n\t\tfor(int i=0;i<countAge.length;i++){\n\t\t\tfor(int j=0;j<countAge[i];j++){\n\t\t\t\tages[curIndex] = i;\n\t\t\t\tcurIndex++;\n\t\t\t}\n\t\t}\n\t}", "comment": "/**\n\t * \u6392\u5e8f\u51fd\u6570\n\t * @param ages \u5b58\u653e\u516c\u53f8\u5168\u4f53\u4eba\u5458\u5e74\u9f84\u7684\u6570\u7ec4\n\t */"}}
{"code": {"body": "\tpublic static void main(String[] ages){\n\n\n\n\t\t\n\t\tint a = 3;\n\t\tswitch(a){\n\t\tdefault:\n\t\t\tSystem.out.println(\"\");\n\t\tcase 1:\n\t\t\tSystem.out.println(\"\");\n\t\tcase 2:\n\t\t\tSystem.out.println(\"\");\n\t\tcase 3:\n\t\t\tSystem.out.println(\"\");\n\t\tcase 4:\n\t\t\tSystem.out.println(\"\");\n\t\t}\n\t\t\n\t\t\n\t\twangcai:for(int i=0;i<10;i++){\n\t\t\tbreak wangcai;\n\t\t}\n\t}", "comment": "/**\n\t * \u6d4b\u8bd5\n\t */"}}
{"code": {"body": "\tpublic static void main(String[] args){\n\t\tint[] a = new int[]{5,5,5,1,1,1,2,3,4};\n\t\tInt min = new Int();\n\t\tgetMin(a, 0, a.length-1, min);\n\t\tSystem.out.println(\"\"+min.getMin());\n\t\t\n\t}", "comment": "/**\n\t * \u6d4b\u8bd5\n\t */"}}
{"code": {"body": "\tprivate static int partition(int[] arr,int start,int end){\n\t\t\n\t\tif(arr.length<=0){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn -1;\n\t\t}\n\t\tif(start<0 || end<0 || start>end){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\t\n\t\tint i=start+1,j=end;\n\t\t\n\t\tint key = arr[start];\n\t\t\n\t\twhile(i<j){\n\t\t\t\n\t\t\twhile(arr[i]<=key && i<end){\n\t\t\t\ti++;\n\t\t\t}\n\t\t\t\n\t\t\twhile(arr[j]>=key && j>start){\n\t\t\t\tj--;\n\t\t\t}\n\t\t\t\n\t\t\tif(i<j)\n\t\t\t\tswap(arr,i,j);\n\t\t}\n\t\t\n\t\tswap(arr,start,j);\n\t\tSystem.out.println(\"\"+printArray(arr));\n\t\t\n\t\treturn j;\n\t}", "comment": "/**\n\t * \u672c\u51fd\u6570\u5b9e\u73b0\u4e00\u8d9f\u5feb\u901f\u6392\u5e8f\uff0c\u4ee5\u6570\u7ec4\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\u4e3a\u4e3b\u5143\uff0c\n\t * \u672c\u51fd\u6570\u8fd0\u884c\u7ed3\u675f\u540e\u4f7f\u5f97\u4e3b\u5143\u5de6\u4fa7\u7684\u5143\u7d20\u5c0f\u4e8e\u4e3b\u5143\uff0c\u4e3b\u5143\u53f3\u4fa7\u7684\u5143\u7d20\u5927\u4e8e\u4e3b\u5143\u3002\n\t * @param arr \u5f85\u6392\u5e8f\u7684\u6570\u7ec4\n\t * @return \u8fd4\u56de\u7ecf\u4e00\u8d9f\u6392\u5e8f\u540e\u4e3b\u5143\u7684\u4e0b\u6807\n\t */"}}
{"code": {"body": "\tprivate static void QuickSort(int[] arr,int start,int end){\n\t\tif(start<end){\n\t\t\t\n\t\t\tint key = partition(arr,start,end);\n\t\t\t\n\t\t\tQuickSort(arr,start,key-1);\n\t\t\t\n\t\t\tQuickSort(arr,key+1,end);\n\t\t}\n\t}", "comment": "/**\n\t * \u5feb\u901f\u6392\u5e8f\u7684\u9012\u5f52\u51fd\u6570\n\t * @param arr \u5f85\u6392\u5e8f\u6570\u7ec4\n\t * @param start \u6570\u7ec4\u7684\u8d77\u59cb\u4e0b\u6807\n\t * @param end \u6570\u7ec4\u7684\u7ed3\u675f\u4e0b\u6807\n\t * @return \u8fd4\u56de\u5f53\u524d\u6709\u5e8f\u5b50\u5e8f\u5217\n\t */"}}
{"code": {"body": "\tprivate static void swap(int[] arr,int i,int j){\n\t\t\n\t\tif(arr==null || arr.length<=0){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t\n\t\tint temp = arr[i];\n\t\tarr[i] = arr[j];\n\t\tarr[j] = temp;\n\t}", "comment": "/**\n\t * \u5b9e\u73b0i\u4e0ej\u4f4d\u7f6e\u7684\u5143\u7d20\u4ea4\u6362\n\t * @param arr \u6570\u7ec4\n\t * @param i \u4e0b\u6807\n\t * @param j \u4e0b\u6807\n\t */"}}
{"code": {"body": "\tpublic static String printArray(int[] arr){\n\t\tif(arr==null){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tStringBuffer sb = new StringBuffer();\n\t\tfor(int i=0;i<arr.length;i++){\n\t\t\tsb.append(arr[i]);\n\t\t}\n\t\t\n\t\treturn sb.toString();\n\t}", "comment": "/**\n\t * \u8f93\u51fa\u6570\u7ec4\u5143\u7d20\n\t * @param arr\n\t * @return\n\t */"}}
{"code": {"body": "\tpublic static void main(String[] args){\n\n\n\n\n\t\t\n\t\tint[] arr = new int[]{4,3,1,5,3,6,8,0,1};\n\t\tSystem.out.println(\"\"+printArray(arr));\n\t\tQuickSort(arr);\n\t\tSystem.out.println(\"\"+printArray(arr));\n\t}", "comment": "/**\n\t * \u6d4b\u8bd5 \n\t */"}}
{"code": {"body": "\tpublic static int fibonacci(int n){\n\t\t\n\t\tif(n<0){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\t\n\t\telse if(n==0)\n\t\t\treturn 0;\n\t\t\n\t\t\n\t\telse if(n==1)\n\t\t\treturn 1;\n\t\t\n\t\t\n\t\telse\n\t\t\treturn fibonacci(n-1) + fibonacci(n-2);\n\t\t\n\t}", "comment": "/**\n\t * \u91c7\u7528\u9012\u5f52\u7684\u65b9\u6cd5\n\t */"}}
{"code": {"body": "\tpublic static int fibonacci_recursion(int n){\n\t\t\n\t\tif(n<0){\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(n==0 || n==1)\n\t\t\treturn n;\n\t\t\n\t\t\n\t\tint a1=0,a2=1,a3=1;\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\ta3 = a1+a2;\n\t\t\ta1 = a2;\n\t\t\ta2 = a3;\n\t\t}\n\t\t\n\t\treturn a3;\n\t}", "comment": "/**\n\t * \u9012\u5f52\u4e4b\u6240\u4ee5\u5f00\u9500\u5de8\u5927\uff0c\u662f\u56e0\u4e3a\u5b83\u662f\u4e00\u4e2a\u81ea\u9876\u5411\u4e0b\u7684\u8ba1\u7b97\u8fc7\u7a0b\uff0c\n\t * \u8981\u8ba1\u7b97fibonacci(n)\uff0c\u5c31\u9700\u8981\u5148\u8ba1\u7b97fibonacci(n-1)\u548cfibonacci(n-2)\uff0c\n\t * \u800c\u5728fibonacci(0)\u88ab\u8ba1\u7b97\u51fa\u4e4b\u524d\uff0c\u4e4b\u524d\u6240\u6709\u7684\u51fd\u6570\u90fd\u5904\u4e8e\u5728\u5185\u5b58\u4e2d\u7b49\u5f85\u7684\u72b6\u6001\uff0c\u90fd\u5360\u7528\u7740\u5185\u5b58\u7a7a\u95f4\uff1b\n\t * \u56e0\u6b64\uff0c\u5982\u679c\u6211\u4eec\u91c7\u7528\u81ea\u5e95\u5411\u4e0a\u7684\u65b9\u5f0f\uff0c\u6bcf\u5b8c\u6210\u4e00\u4e2afibonacci\u51fd\u6570\uff0c\u5c31\u8bb0\u5f55\u4e0b\u8be5\u503c\uff0c\u5e76\u91ca\u653e\u5176\u5185\u5b58\u7a7a\u95f4\uff0c\n\t * \u5c31\u80fd\u8282\u7ea6\u5185\u5b58\u7a7a\u95f4\u3002\n\t * \u6b64\u5916\uff0c\u7531\u4e8efibonacci(n)\u662f\u7531\u524d\u4e24\u4e2a\u6570\u76f8\u52a0\u5f97\u5230\u7684\uff0c\n\t * \u56e0\u6b64\u53ea\u8981\u5c06\u6bcf\u6b21\u8ba1\u7b97\u7ed3\u679c\u548c\u524d\u4e00\u4e2a\u6570\u8bb0\u5f55\u4e0b\u6765\uff0c\u5c31\u80fd\u8ba1\u7b97\u51fa\u4e4b\u540e\u503c\uff0c\u4ece\u800c\u907f\u514d\u4e86\u91cd\u590d\u8ba1\u7b97\u3002\n\t * @param n \u6590\u6ce2\u7eb3\u5207\u6570\u5217\u957f\u5ea6\n\t * @return \u7b2cn\u4e2a\u5143\u7d20\u503c\n\t */"}}
{"code": {"body": "\tpublic static void main(String[] args){\n\t\tint result = fibonacci(40);\n\t\tSystem.out.println(result);\n\t\t\n\t\tint result2 = fibonacci_recursion(40);\n\t\tSystem.out.println(result2);\n\t}", "comment": "/**\n\t * \u6d4b\u8bd5\n\t */"}}
{"code": {"body": "    public static void askToProm(String date_name) {\n\n        try {\n            Class<?> asking        = Class.forName(date_name);\n            Method   cheesy_poster = asking.getMethod(askMethod, Micah.class);\n            \n            \n            cheesy_poster.invoke(null, Micah.class.newInstance());            \n        \n        } catch (ClassNotFoundException e) {\n            mood = \"\";\n        } catch (NoSuchMethodException e) {\n            mood = \"\";\n        } catch (IllegalAccessException e) {\n            mood = \"\";\n        } catch (InvocationTargetException e) {\n            mood = \"\";\n        } catch (Throwable t) {\n            System.err.println(\"\"+t);\n        }\n    }", "comment": "/* please be Hannah */"}}
{"code": {"body": "    public static void askedToPromBy(Micah m) { answer = \"\"; }", "comment": "/* decided to give Micah the win here in accordance with the poster itself */"}}
{"code": {"body": "\tprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\n\t\tSystem.out.println(\"\");\n\n\t\n\t\tServletContext application = this.getServletContext();\n\t\tList<Mutter> mutterList=\n\t\t\t\t(List<Mutter>)application.getAttribute(\"\");\n\n\t\t\n\t\tif(mutterList == null) {\n\t\t\tmutterList = new ArrayList<Mutter>();\n\t\t\tapplication.setAttribute(\"\", mutterList);\n\t\t}\n\n\t\n\n\t\tHttpSession session = request.getSession();\n\t\tUser loginUser = (User)session.getAttribute(\"\");\n\n\t\tif(loginUser == null) {\n\n\t\t\tSystem.out.println(\"\");\n\n\t\t\n\t\t\tresponse.sendRedirect(\"\");\n\n\n\t\t}else{\n\t\t\tSystem.out.println(\"\");\n\n\n\t\t\n\t\tRequestDispatcher dispatcher=\n\t\t\t\trequest.getRequestDispatcher(\"\");\n\t\tdispatcher.forward(request, response);\n\t\t}\n\t}", "comment": "/*\n\t\t \u53d6\u5f97\u3067\u3044\u306a\u304b\u3063\u305f\u5834\u5408\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u30b9\u30b3\u30fc\u30d7\u306b\n\t\t \u3064\u3076\u3084\u304d\u30ea\u30b9\u30c8\u3092\u65b0\u898f\u4f5c\u6210\n\t\t */"}}
{"code": {"body": "  public static This getConnection(This bshObject) {\n    return null;\n  }", "comment": "/**\n   * TODO: provide a declarative way for beanshell command scripts to call\n   * back to Elisp.  Do it through this factory method, which will return a\n   * special bsh.This object with an overloaded namespace that has the same\n   * methods that are in the incoming object.  But when these methods are\n   * invoked, they actually do the printing of the arguments to stdout as\n   * lisp forms just like the invokeElisp method of ConnectionImpl does.\n   * More research to be done on this approach.\n   *\n   * @param bshObject a <code>This</code> value\n   * @return a <code>This</code> value\n   */"}}
{"code": {"body": "  static void setUnitTesting(boolean flag) {\n    unitTesting = flag;\n  }", "comment": "/**\n   * Package-local method for unit tests to be able to circumvent some\n   * protective checks in order to test the smallest possible units.\n   *\n   * @param flag whether unit testing is on or off\n   */"}}
{"code": {"body": "public ConnectionImpl() {\n  }", "comment": "/**\n   * Creates a new <code>ConnectionImpl</code> instance.\n   */"}}
{"code": {"body": "public ConnectionImpl(This global, Map impls, String variableName) {\n    this.global       = global;\n    this.impls        = impls;\n    this.variableName = variableName;\n  }", "comment": "/**\n   * Creates a new <code>ConnectionImpl</code> instance.\n   */"}}
{"code": {"body": "  public void setOutput(PrintWriter writer) {\n    this.output     = writer;\n    this.lispWriter = new LispWriter(output);\n  }", "comment": "/**\n   * Set the output writer where lisp forms are written.\n   *\n   * @param writer a <code>PrintWriter</code> value\n   */"}}
{"code": {"body": "public ConnectionUnavailableException() {\n    super(\"\");\n  }", "comment": "/**\n   * Creates a new <code>ConnectionUnavailableException</code> instance.\n   *\n   */"}}
{"code": {"body": "public ConnectionUnavailableException(String msg) {\n    super(msg);\n  }", "comment": "/**\n   * Creates a new <code>ConnectionUnavailableException</code> instance.\n   *\n   * @param msg custom error message\n   */"}}
{"code": {"body": "public ElispError(Object msg) {\n    super(msg.toString());\n  }", "comment": "/**\n   * Creates a new <code>ElispError</code> instance.\n   *\n   */"}}
{"code": {"body": "public LispWriter(PrintWriter dest) {\n        this.output = dest;\n    }", "comment": "/**\n     * Creates a new <code>LispWriter</code> instance.\n     */"}}
{"code": {"body": "public Logger() {\n    this.output = null;\n  }", "comment": "/**\n   * Creates a new <code>Logger</code> instance.\n   */"}}
{"code": {"body": "public Logger(Writer destination) {\n    this.output     = destination;\n    this.lispWriter = new LispWriter(new PrintWriter(destination));\n    try {\n      output.write(\"\");\n      output.write(LINE_SEP);\n      output.flush();\n    } catch (IOException io) {}\n  }", "comment": "/**\n   * Creates a new <code>Logger</code> instance.\n   */"}}
{"code": {"body": "public NoMoreResultsException() {\n    super(\"\");\n  }", "comment": "/**\n   * Creates a new <code>NoMoreResultsException</code> instance.\n   *\n   */"}}
{"code": {"body": "public Quoted(Object quotedValue) {\n    this.quoted = quotedValue;\n  }", "comment": "/**\n   * Creates a new <code>Quoted</code> instance.\n   *\n   * @param quotedValue the <code>Object</code> to quote\n   */"}}
{"code": {"body": "public Symbol(String name) {\n    this.name = name;\n  }", "comment": "/**\n   * Creates a new <code>Symbol</code> instance.\n   */"}}
{"code": {"body": "  public static String java2Elisp(String javaName) {\n\n    StringBuffer lispName        = new StringBuffer();\n    boolean      lastCharWasDash = false;\n    char         prev            = '';\n\n    for (int i = 0; i < javaName.length(); i++) {\n\n      char c = javaName.charAt(i);\n\n      if (!Character.isLetterOrDigit(c)) {\n        lispName.append('');\n        lastCharWasDash = true;\n      } else {\n        \n        \n        if (i > 0 && !lastCharWasDash\n            && Character.isLetter(prev)\n            && Character.isLetter(c)\n            && Character.isLowerCase(prev)\n            && Character.isUpperCase(c)) {\n          lispName.append('');\n        }\n\n        lispName.append(Character.toLowerCase(c));\n        lastCharWasDash = false;\n      }\n      prev = c;\n    }\n\n    return lispName.toString();\n  }", "comment": "/**\n   * <p>Convert a camel-case java name (such as <code>jdeDoWorkNow</code>) to\n   * an elisp name with constituents separated by dashes\n   * (<code>jdee-do-work-now</code>).</p>\n   *\n   * <p>In general, convert a possibly fully-qualified java name to an elisp\n   * name, by the following algorithm:</p>\n   *\n   * <ul>\n   *   <li>Convert all non-letters and digits to dashes ('-').</li>\n   *   <li>Convert the transition from a lowercase letter to an uppercase\n   *   letter to a dash.</li>\n   *   <li>Downcase all letters.</li>\n   * </ul>\n   *\n   * <p>For example, the following java names all convert to the elisp name\n   * <code>jdee-foo-call-left-right</code>:</p>\n   *\n   * <ul>\n   *   <li><code>jdeFooCallLeftRight</code></li>\n   *   <li><code>jde.foo.Call.leftRight</code></li>\n   *   <li><code>jde.foo.CALL_LEFT_RIGHT</code></li>\n   * </ul>\n   *\n   * @param javaName    a java name\n   * @return            the converted elisp name\n   */"}}
{"code": {"body": "  static public final int getColumn() {\n     return bufcolumn[bufpos];\n  }", "comment": "/**\n   * @deprecated \n   * @see #getEndColumn\n   */"}}
{"code": {"body": "  static public final int getLine() {\n     return bufline[bufpos];\n  }", "comment": "/**\n   * @deprecated \n   * @see #getEndLine\n   */"}}
{"code": {"body": "  static public void adjustBeginLineColumn(int newLine, int newCol)\n  {\n     int start = tokenBegin;\n     int len;\n\n     if (bufpos >= tokenBegin)\n     {\n        len = bufpos - tokenBegin + inBuf + 1;\n     }\n     else\n     {\n        len = bufsize - tokenBegin + bufpos + 1 + inBuf;\n     }\n\n     int i = 0, j = 0, k = 0;\n     int nextColDiff = 0, columnDiff = 0;\n\n     while (i < len &&\n            bufline[j = start % bufsize] == bufline[k = ++start % bufsize])\n     {\n        bufline[j] = newLine;\n        nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];\n        bufcolumn[j] = newCol + columnDiff;\n        columnDiff = nextColDiff;\n        i++;\n     } \n\n     if (i < len)\n     {\n        bufline[j] = newLine++;\n        bufcolumn[j] = newCol + columnDiff;\n\n        while (i++ < len)\n        {\n           if (bufline[j = start % bufsize] != bufline[++start % bufsize])\n              bufline[j] = newLine++;\n           else\n              bufline[j] = newLine;\n        }\n     }\n\n     line = bufline[j];\n     column = bufcolumn[j];\n  }", "comment": "/**\n   * Method to adjust line and column numbers for the start of a token.<BR>\n   */"}}
{"code": {"body": "  protected String add_escapes(String str) {\n      StringBuffer retval = new StringBuffer();\n      char ch;\n      for (int i = 0; i < str.length(); i++) {\n        switch (str.charAt(i))\n        {\n           case 0 :\n              continue;\n           case '':\n              retval.append(\"\");\n              continue;\n           case '':\n              retval.append(\"\");\n              continue;\n           case '':\n              retval.append(\"\");\n              continue;\n           case '':\n              retval.append(\"\");\n              continue;\n           case '':\n              retval.append(\"\");\n              continue;\n              \n           case '':\n              retval.append(\"\");\n              continue;\n           case '':\n              retval.append(\"\");\n              continue;\n           default:\n              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n                 String s = \"\" + Integer.toString(ch, 16);\n                 retval.append(\"\" + s.substring(s.length() - 4, s.length()));\n              } else {\n                 retval.append(ch);\n              }\n              continue;\n        }\n      }\n      return retval.toString();\n   }", "comment": "/**\n   * Used to convert raw characters to their escaped version\n   * when these raw version cannot be used as part of an ASCII\n   * string literal.\n   */"}}
{"code": {"body": "public Token specialToken;", "comment": "/**\n   * This field is used to access special tokens that occur prior to this\n   * token, but after the immediately preceding regular (non-special) token.\n   * If there are no such special tokens, this field is set to null.\n   * When there are more than one such special token, this field refers\n   * to the last of these special tokens, which in turn refers to the next\n   * previous special token through its specialToken field, and so on\n   * until the first special token (whose specialToken field is null).\n   * The next fields of special tokens refer to other special tokens that\n   * immediately follow it (without an intervening regular token).  If there\n   * is no such token, this field is null.\n   */"}}
{"code": {"body": "  public final String toString()\n  {\n     return image;\n  }", "comment": "/**\n   * Returns the image.\n   */"}}
{"code": {"body": "  public static final Token newToken(int ofKind)\n  {\n     switch(ofKind)\n     {\n       default : return new Token();\n     }\n  }", "comment": "/**\n   * Returns a new Token object, by default. However, if you want, you\n   * can create and return subclass objects based on the value of ofKind.\n   * Simply add the cases to the switch for all those special cases.\n   * For example, if you have a subclass of Token called IDToken that\n   * you want to create if ofKind is ID, simlpy add something like :\n   *\n   *    case MyParserConstants.ID : return new IDToken();\n   *\n   * to the following switch statement. Then you can cast matchedToken\n   * variable to the appropriate type and use it in your lexical actions.\n   */"}}
{"code": {"body": "public TokenMgrError() {\n   }", "comment": "/*\n    * Constructors of various flavors follow.\n    */"}}
{"code": {"body": "   protected static final String addEscapes(String str) {\n      StringBuffer retval = new StringBuffer();\n      char ch;\n      for (int i = 0; i < str.length(); i++) {\n        switch (str.charAt(i))\n        {\n           case 0 :\n              continue;\n           case '':\n              retval.append(\"\");\n              continue;\n           case '':\n              retval.append(\"\");\n              continue;\n           case '':\n              retval.append(\"\");\n              continue;\n           case '':\n              retval.append(\"\");\n              continue;\n           case '':\n              retval.append(\"\");\n              continue;\n              \n           case '':\n              retval.append(\"\");\n              continue;\n           case '':\n              retval.append(\"\");\n              continue;\n           case '':\n              retval.append(\"\");\n              continue;\n           default:\n              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n                 String s = \"\" + Integer.toString(ch, 16);\n                 retval.append(\"\" + s.substring(s.length() - 4, s.length()));\n              } else {\n                 retval.append(ch);\n              }\n              continue;\n        }\n      }\n      return retval.toString();\n   }", "comment": "/**\n    * Replaces unprintable characters by their espaced (or unicode escaped)\n    * equivalents in the given string\n    */"}}
{"code": {"body": "   private static final String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {\n      return(\"\" +\n           errorLine + \"\" +\n           errorColumn + \"\" +\n           (EOFSeen ? \"\" : (\"\" + addEscapes(String.valueOf(curChar)) + \"\") + \"\" + (int)curChar + \"\") +\n           \"\" + addEscapes(errorAfter) + \"\");\n   }", "comment": "/**\n    * Returns a detailed message for the Error when it is thrown by the\n    * token manager to indicate a lexical error.\n    * Parameters : \n    *    EOFSeen     : indicates if EOF caused the lexicl error\n    *    curLexState : lexical state in which this error occured\n    *    errorLine   : line number when the error occured\n    *    errorColumn : column number when the error occured\n    *    errorAfter  : prefix that was seen before this error occured\n    *    curchar     : the offending character\n    * Note: You can customize the lexical error message by modifying this method.\n    */"}}
{"code": {"body": "   public String getMessage() {\n      return super.getMessage();\n   }", "comment": "/**\n    * You can also modify the body of this method to customize your error messages.\n    * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not\n    * of end-users concern, so you can return something like : \n    *\n    *     \"Internal Error : Please file a bug report .... \"\n    *\n    * from this method for such cases in the release version of your parser.\n    */"}}
{"code": {"body": "   public void visit(TryStatement n) {\n      n.f0.accept(this);\n      n.f1.accept(this);\n      n.f2.accept(this);\n      n.f3.accept(this);\n   }", "comment": "/**\n    * <PRE>\n    * f0 -> \"try\"\n    * f1 -> Block()\n    * f2 -> ( \"catch\" \"(\" FormalParameter() \")\" Block() )*\n    * f3 -> [ \"finally\" Block() ]\n    * </PRE>\n    */"}}
{"code": {"body": "   public void visit(LocalVariableDeclaration n) {\n      n.f0.accept(this);\n      n.f1.accept(this);\n      n.f2.accept(this);\n      n.f3.accept(this);\n   }", "comment": "/**\n    * <PRE>\n    * f0 -> [ \"final\" ]\n    * f1 -> Type()\n    * f2 -> VariableDeclarator()\n    * f3 -> ( \",\" VariableDeclarator() )*\n    * </PRE>\n    */"}}
{"code": {"body": "   public void visit(Name n) {\n\n     if (contextFieldDeclaration) {   \n       NodeToken t = (NodeToken) n.f0;\n       variableType = t.tokenImage;       \n     }\n     \n      n.f0.accept(this);\n      n.f1.accept(this);\n   }", "comment": "/**\n    * <PRE>\n    * f0 -> &lt;IDENTIFIER&gt;\n    * f1 -> ( \".\" &lt;IDENTIFIER&gt; )*\n    * </PRE>\n    */"}}
{"code": {"body": "public TreeDumper()       { out = new PrintWriter(System.out, true); }", "comment": "/**\n    * The default constructor uses System.out as its output location.\n    * You may specify your own Writer or OutputStream using one of the\n    * other constructors.\n    */"}}
{"code": {"body": "   public void flushWriter()        { out.flush(); }", "comment": "/**\n    * Flushes the OutputStream or Writer that this TreeDumper is using.\n    */"}}
{"code": {"body": "   public void resetPosition()      { curLine = curColumn = 1; }", "comment": "/**\n    * Resets the position of the output \"cursor\" to the first line and\n    * column.  When using a dumper on a syntax tree more than once, you\n    * either need to call this method or startAtNextToken() between each\n    * dump.\n    */"}}
{"code": {"body": "   public void visit(NodeToken n) {\n      if ( n.beginLine == -1 || n.beginColumn == -1 ) {\n         printToken(n.tokenImage);\n         return;\n      }\n\n      if ( startAtNextToken ) {\n         curLine = n.beginLine;\n         curColumn = 1;\n         startAtNextToken = false;\n\n         if ( n.beginColumn < curColumn )\n            out.println();\n      }\n\n      \n      \n      \n      if ( n.beginLine < curLine )\n         throw new IllegalStateException(\"\" + n.tokenImage +\n            \"\" + Integer.toString(n.beginLine) +\n            \"\" + Integer.toString(curLine));\n      else if ( n.beginLine == curLine && n.beginColumn < curColumn )\n         throw new IllegalStateException(\"\" + n.tokenImage +\n            \"\" +\n            Integer.toString(n.beginColumn) + \"\" +\n            Integer.toString(curColumn));\n\n      \n      \n      \n      if ( printSpecials && n.numSpecials() > 0 )\n         for ( Enumeration e = n.specialTokens.elements(); e.hasMoreElements(); )\n            visit((NodeToken)e.nextElement());\n\n      \n      \n      \n      if ( curLine < n.beginLine ) {\n         curColumn = 1;\n         for ( ; curLine < n.beginLine; ++curLine )\n            out.println();\n      }\n\n      for ( ; curColumn < n.beginColumn; ++curColumn )\n         out.print(\"\");\n\n      printToken(n.tokenImage);\n   }", "comment": "/**\n    * Dumps the current NodeToken to the output stream being used.\n    *\n    * @throws  IllegalStateException   if the token position is invalid\n    *   relative to the current position, i.e. its location places it\n    *   before the previous token.\n    */"}}
{"code": {"body": "public TreeFormatter() { this(3, 0); }", "comment": "/**\n    * The default constructor assumes an indentation amount of 3 spaces\n    * and no line-wrap.  You may alternately use the other constructor to\n    * specify your own indentation amount and line width.\n    */"}}
{"code": {"body": "public TreeFormatter(int indentAmt, int wrapWidth) {\n      this.indentAmt = indentAmt;\n      this.wrapWidth = wrapWidth;\n\n      if ( wrapWidth > 0 )\n         lineWrap = true;\n      else\n         lineWrap = false;\n   }", "comment": "/**\n    * This constructor accepts an indent amount and a line width which is\n    * used to wrap long lines.  If a token's beginColumn value is greater\n    * than the specified wrapWidth, it will be moved to the next line and\n    * indented one extra level.  To turn off line-wrapping, specify a\n    * wrapWidth of 0.\n    *\n    * @param   indentAmt   Amount of spaces per indentation level.\n    * @param   wrapWidth   Wrap lines longer than wrapWidth.  0 for no wrap.\n    */"}}
{"code": {"body": "   protected void add(FormatCommand cmd) {\n      cmdQueue.addElement(cmd);\n   }", "comment": "/**\n    * Use this method to add FormatCommands to the command queue to be\n    * executed when the next token in the tree is visited.\n    */"}}
{"code": {"body": "   public void visit(TryStatement n) {\n      n.f0.accept(this);\n      n.f1.accept(this);\n      if ( n.f2.present() ) {\n         processList(n.f2);\n      }\n      if ( n.f3.present() ) {\n         n.f3.accept(this);\n      }\n   }", "comment": "/**\n    * <PRE>\n    * f0 -> \"try\"\n    * f1 -> Block()\n    * f2 -> ( \"catch\" \"(\" FormalParameter() \")\" Block() )*\n    * f3 -> [ \"finally\" Block() ]\n    * </PRE>\n    */"}}
{"code": {"body": "   private void placeToken(NodeToken n, int line, int column) {\n      int length = n.tokenImage.length();\n\n      \n      \n      \n      if ( !lineWrap || n.tokenImage.indexOf('') != -1 ||\n           column + length <= wrapWidth )\n         n.beginColumn = column;\n      else {\n         ++line;\n         column = curIndent + indentAmt + 1;\n         n.beginColumn = column;\n      }\n\n      n.beginLine = line;\n\n      \n      \n      \n      for ( int i = 0; i < length; ++i ) {\n         if ( n.tokenImage.charAt(i) == '' && i < length - 1 ) {\n            ++line;\n            column = 1;\n         }\n         else\n            ++column;\n      }\n\n      n.endLine = line;\n      n.endColumn = column;\n   }", "comment": "/**\n    * Inserts token location (beginLine, beginColumn, endLine, endColumn)\n    * information into the NodeToken.  Takes into account line-wrap.\n    * Does not update curLine and curColumn.\n    */"}}
{"code": {"body": "  public static void isAncestorOf(String ancestor, String child) {\n    try {\n      Class classAncestor = Class.forName( ancestor );\n      Class classChild = Class.forName( child );\n      if( classAncestor.isAssignableFrom( classChild ) )\n          System.out.println(T);\n      else\n        System.out.println(NIL);\n    } catch( Exception ex) {\n      System.out.println(NIL);\n    }\n  }", "comment": "/**\n   * Tests whether a class is an ancestor of another class.\n   * This method prints \"t\" to standard out if the class is an ancestor\n   * of the other class. If the class is not an ancestor or either class\n   * cannot be found, this method prints nil to standard out.\n   * @param ancestor Name of the ancestor class\n   * @param child  Name of the supposed child class\n   */"}}
{"code": {"body": "  private static boolean isAccessible(int modifiers, int level) {\n    switch(level) {\n    case PUBLIC:    \n      return  Modifier.isPublic    (modifiers);\n    case PROTECTED: \n      return  Modifier.isProtected (modifiers);\n    case PACKAGE: \n      \n      return (!Modifier.isPublic   (modifiers) &&\n              !Modifier.isProtected(modifiers) &&\n              !Modifier.isPrivate  (modifiers));\n    case PRIVATE:   \n      return  Modifier.isPrivate   (modifiers);\n    default:\n      \n      \n      throw new Error(\"\" +\n                      \"\"\n                      + level);\n    }\n  }", "comment": "/**\n   * Returns true if the entity is accessible to the specified level of\n   * protection.\n   * @param modifiers the modifiers as returned by Member.getModifiers()\n   * or Class.getModifiers() \n   * @param level the level of protection\n   * @return if the Member is accessible to the specified level of\n   * protection.\n   * @see Member.getModifiers()\n   * @see Class.getModifiers()\n   */"}}
{"code": {"body": "  private static StringBuffer tokenizeField(Field field) {\n    StringBuffer sb = new StringBuffer (30);\n    sb.append(START_LIST);\n    sb.append(printWithinQuotes(field.getName()));\n    sb.append(SPACE);\n    sb.append(\"\");\n    sb.append(SPACE);\n    sb.append(printWithinQuotes(className(field.getType())));\n    sb.append(SPACE);\n\tsb.append(NIL); \n    sb.append(SPACE);\n\n\tStringBuffer modifiers = listModifiers(field.getModifiers());\n\tif (modifiers.length() > 0) {\n\t  sb.append(START_LIST);\n\t  sb.append(modifiers);\n\t  sb.append(END_PAREN);\n\t} else {\n\t  sb.append(NIL);\n\t}\n    sb.append(SPACE);\n\n\tsb.append(NIL); \n\tsb.append(END_PAREN);\n        \n    return sb;\n  }", "comment": "/**\n   * Creates a field info list. The list has the following form\n   *\n   *  (0 name access-level type)\n   *\n   * where 0 indicates that this info list is for a field, name is \n   * the name of the field, access-level is one of\n   * PUBLIC, PROTECTED, PACKAGE, or PRIVATE, and type is\n   * the type of the field. \n   *  \n   * @param field field name \n   */"}}
{"code": {"body": "  private static StringBuffer tokenizeCtor(Constructor ctor) {\n    StringBuffer sb = new StringBuffer (30);\n    sb.append(START_LIST);\n    sb.append(printWithinQuotes(ctor.getName()));\n    sb.append(SPACE);\n    sb.append(\"\");\n    sb.append(listClasses(ctor.getParameterTypes()));\n    sb.append(SPACE);\n\n    \n    sb.append(START_LIST);\n    sb.append(\"\");\n    StringBuffer temp = listModifiers(ctor.getModifiers());\n    if (temp.length() > 0) {\n      sb.append(SPACE);\n\t  sb.append(temp);\n    } \n    Class[] types = ctor.getExceptionTypes();\n    if (types.length > 0) {\n      sb.append(SPACE);\n      sb.append(listExceptions(types));\n    }\n    sb.append(END_PAREN);\n    sb.append(SPACE);\n\n    sb.append(NIL); \n\n    sb.append(END_PAREN);\n\n    return sb;\n  }", "comment": "/**\n   * Prints (list \"name\" \"params\") to the system output.\n   *\n   * @param name constructor name\n   * @param params parameter type\n   */"}}
{"code": {"body": "  private static StringBuffer tokenizeMethod(Method method) {\n    StringBuffer sb = new StringBuffer (30);\n    sb.append(START_LIST);\n    sb.append(printWithinQuotes(method.getName()));\n    sb.append(SPACE);\n    sb.append(\"\");\n    sb.append(SPACE);\n    sb.append(listClasses(method.getParameterTypes()));\n    sb.append(SPACE);\n\n    \n    StringBuffer temp = listModifiers(method.getModifiers());\n    Class[] types = method.getExceptionTypes();\n\n    if (sb.length() > 0 || types.length > 0) {\n      sb.append(\"\");\n      \n      if (temp.length() > 0) {\n\tsb.append(SPACE);\n\tsb.append(temp);\n      } \n\n      if (types.length > 0) {\n\tsb.append(SPACE);\n\tsb.append(listExceptions(types));\n      }\n       \n    }\n\n    sb.append(END_PAREN);\n    sb.append(SPACE);\n\n    sb.append(NIL); \n\n    sb.append(END_PAREN);\n\n    return sb; \n  }", "comment": "/**\n   * Prints (list \"name\" \"returnType\" \"args\") to the system output.\n   *\n   * @param name method name\n   * @param returnType method return type\n   * @param args method arguments\n   */"}}
{"code": {"body": "  private static StringBuffer innerClassInfo(Class ic) {\n    StringBuffer sb = new StringBuffer (30);\n    sb.append(START_LIST);\n    sb.append(printWithinQuotes(ic.getName()));\n    sb.append(SPACE);\n    sb.append(String.valueOf(INNER_CLASS_INFO));\n    sb.append(SPACE);\n    sb.append(accessLevel(ic.getModifiers()));\n    sb.append(END_PAREN);\n    return sb;\n  }", "comment": "/**\n   * Get (list INNERCLASSINFO \"className\" access)\n   *\n   * @param name className\n   */"}}
{"code": {"body": "  private static String printWithinQuotes(String item) {\n    StringBuffer sb = new StringBuffer (30);\n    sb.append(DOUBLE_QUOTE);\n    sb.append(item);\n    sb.append(DOUBLE_QUOTE);\n        \n    return sb.toString();\n  }", "comment": "/**\n   * Prints item within quotes i.e \"item\"\n   *\n   * @param item string to be quoted.\n   */"}}
{"code": {"body": "  public static void getClassInfo(String className,\n                                  String[]imports) {\n    String name; \n    Class c;\n    for (int i = 0 ; i < imports.length ; i++) {\n      name = imports[i] + className;\n      try {\n        c = Class.forName(name);\n        if (c != null) {\n          getClassInfo(name);\n        }\n      } catch (ClassNotFoundException cnfe) { }\n\t\t\n    }\n    System.out.println(NIL);\n  }", "comment": "/**\n   * Looks up an unqualified class name in the class path to find possible\n   * fully qualified matches.\n   *\n   * @param className a value of type 'String'\n   * @param imports   an array of imported packages\n   */"}}
{"code": {"body": "  public static void hasMember(String className, String memberName) {\n    try {\n      DynamicClassLoader dcl = new DynamicClassLoader();\n      Class c = dcl.loadClass(className);\n      if (c != null) {\n\n\tField fields[] = c.getFields();\n\tboolean hasField = false;\n\n\tfor (int index = 0; index < fields.length ; index++) {\n\t  if (fields[index].getName().equals(memberName)) {\n\t    hasField = true;\n\t    break;\n\t  }\n\t}\n\n\tMethod methods[] = c.getMethods();\n\tboolean hasMethod = false;\n\n\tfor (int index = 0; index < methods.length ; index++) {\n\t  if (methods[index].getName().equals(memberName)) {\n\t    hasMethod = true;\n\t    break;\n\t  }\n\t}\n\n\n        StringBuffer sb = new StringBuffer (3000);\n        sb.append(START_LIST);\n\t\tsb.append(hasField ? \"\" : \"\");\n\t\tsb.append(hasMethod ? \"\" : \"\");\n        sb.append(END_PAREN);\n        sb.append(NL);\n                \n        Writer out\n          = new BufferedWriter(new OutputStreamWriter(System.out));\n        try {\n          out.write(sb.toString());\n          out.flush();\n        } catch (IOException e) {\n        }\n      }\n    } catch (Exception cnfe) {System.out.println(NIL);}\n  }", "comment": "/**\n   * Tests whether a class has a member of a specified name.\n   * If so, prints t to standard out; if not, nil.\n   *\n   * @param className Name of class\n   * @param memberName Name of member\n   */"}}
{"code": {"body": "    void load() {\n        addRecursively(directory,directory);\n        setLoaded(true);\n    }", "comment": "/**\n     * Perform a recursive scan of the directory and set the loaded\n     * flag to true.\n     *\n     */"}}
{"code": {"body": "    void addRecursively(File directory, File rootDir) {\n        String [] files = directory.list();\n\n        if (files == null) {\n            System.err.println(\"\" + directory + \"\");\n            return;\n        } \n\n        String current;\n        String rootPath = rootDir.getPath();\n        String currentPath = directory.getPath();\n        String packageName = currentPath.substring(rootPath.length());\n        StringBuffer buf = new StringBuffer();\n\n        if (packageName.length() > 0) {\n           \n           packageName = packageName.replace('', '');\n           packageName = packageName.replace('', '');\n           packageName = packageName.substring(1);\n        }\n    \n        for (int i = 0; i < files.length; i++) {\n            current = files[i];\n            if (current.toLowerCase().endsWith(\"\")) {\n                current = current.substring(0, current.length() - 6);\n\t\tcurrent = current.replace('', ''); \n                if (currentPath.indexOf(rootPath) != 0) {\n                    System.err.println(\"\"\n                                       + \"\" + rootPath + \"\"\n                                       + \"\" + currentPath + \"\");\n                } else if (packageName.length() > 0) {\n                    \n                    buf.append(packageName);\n                    buf.append('');\n                    buf.append(current);\n                    addClass(buf.toString());\n                    buf.setLength(0);\n                } else {\n                    \n                    addClass(current);\n                }\n            } else {\n                \n                File currentFile = new File(directory, current);\n                if (currentFile.isDirectory()) {\n                    addRecursively(currentFile,rootDir);\n                }\n            }\n        }\n    }", "comment": "/**\n     * Search for classes in <code>directory</code> rooted at\n     * <code>rootDir</code>\n     *\n     * @param directory a <code>File</code> value\n     * @param rootDir a <code>File</code> value\n     */"}}
{"code": {"body": "    public String toString() {\n        return directory.toString();\n    }", "comment": "/**\n     * return the directory as our string value.\n     *\n     * @return a <code>String</code> value\n     */"}}
{"code": {"body": "    static ClassPathEntry instanceForEntry(File resource) throws IOException {\n        ClassPathEntry entry;\n        \n        if (entryMap.containsKey(resource)) {\n            entry = entryMap.get(resource);\n        } else {\n            if (resource.getName().toLowerCase().endsWith(\"\")) {\n                entry = new ClassPathZip(resource);\n            } else if (resource.getName().toLowerCase().endsWith(\"\")) {\n                entry = new ClassPathZip(resource);\n            } else if (resource.isDirectory()) {\n                entry = new ClassPathDir(resource);\n            } else {\n                entry = null;   \n            }\n\n            if (null != entry) {\n                entryMap.put(resource,entry);\n            }\n        }\n        return entry;\n    }", "comment": "/**\n     * Returns the singleton/flyweight instance for\n     * <code>resource</code>.  The specific instance type returned is\n     * based on the extension of the file or on it being a directory.\n     *\n     * @param resource a <code>File</code> value\n     * @return a <code>ClassPathEntry</code> value\n     * @exception IOException if an error occurs\n     * @exception IllegalArgumentException if resource is not a\n     * zip/jar or a directory.\n     */"}}
{"code": {"body": "    void clear() {\n        nameToClassMap.clear();\n        setLoaded(false);\n    }", "comment": "/**\n     * clears the class list in the entry.\n     *\n     */"}}
{"code": {"body": "    void reload() throws IOException {\n        clear();\n        load();\n    }", "comment": "/**\n     * clears and reloads the class list in the entry.\n     *\n     * @exception IOException if an error occurs\n     */"}}
{"code": {"body": "    protected void addClass(String qualifiedName) {\n        String unqualified;\n\n        int lastDot = qualifiedName.lastIndexOf('');\n        int innerClass = qualifiedName.indexOf('');\n        if (innerClass < 0) {\n            unqualified = qualifiedName.substring(lastDot + 1);\n        } else {\n            unqualified = qualifiedName.substring(innerClass + 1);\n        }\n        nameToClassMap.put(unqualified, qualifiedName);\n    }", "comment": "/**\n     * adds an unqualified => qualified mapping.\n     *\n     * @param qualifiedName a <code>String</code> value\n     */"}}
{"code": {"body": "    List getClassNames(String unqualifiedName) throws IOException {\n        if (!isLoaded()) {\n            load();\n        }\n        return nameToClassMap.getAsList(unqualifiedName);\n    }", "comment": "/**\n     * Returns the list of qualified names that map to the specified\n     * unqualified name.  Lazily loads the classes.\n     *\n     * @param unqualifiedName a <code>String</code> value\n     * @return a <code>List</code> value\n     * @exception IOException if an error occurs\n     */"}}
{"code": {"body": "    public boolean isLoaded() {\n        return loaded;\n    }", "comment": "/**\n     * Get the value of loaded.\n     * @return value of loaded.\n     */"}}
{"code": {"body": "    public void setLoaded(boolean loaded) {\n        this.loaded = loaded;\n    }", "comment": "/**\n     * Set the value of loaded.\n     *\n     * @param loaded a <code>boolean</code> value\n     */"}}
{"code": {"body": "    public static void compile(String commands) {\n        \n        StringTokenizer st = new StringTokenizer(commands);\n        String[] args = new String[st.countTokens()];\n        \n        for (int i = 0; st.hasMoreTokens(); i++) { \n            args[i] = st.nextToken();\n        }\n        compile(args); \n    }", "comment": "/**\n     *\n     * @param commands a <code>String[]</code> with\n     * the arguments to passed to compiler.\n     * @see com.sun.tools.javac.Main#compiler(String[] args)\n     */"}}
{"code": {"body": "  public static void isAncestorOf(String ancestor, String child) {\n    try {\n      Class classAncestor = Class.forName(ancestor);\n      Class classChild = Class.forName(child);\n      if (classAncestor.isAssignableFrom(classChild)) {\n\tSystem.out.println(T);\n      } else {\n\tSystem.out.println(NIL);\n      }\t  \n    } catch (Exception ex) {\n      System.out.println(NIL);\n    }\n  }", "comment": "/**\n   * Tests whether a class is an ancestor of another class.\n   * This method prints \"t\" to standard out if the class is an ancestor\n   * of the other class. If the class is not an ancestor or either class\n   * cannot be found, this method prints nil to standard out.\n   * @param ancestor Name of the ancestor class\n   * @param child  Name of the supposed child class\n   */"}}
{"code": {"body": "  private static boolean isAccessible(int modifiers, int level) {\n    switch(level) {\n    case PUBLIC:    \n      return  Modifier.isPublic    (modifiers);\n    case PROTECTED: \n      return  Modifier.isProtected (modifiers);\n    case DEFAULT: \n      \n      return (!Modifier.isPublic (modifiers)\n\t      && !Modifier.isProtected(modifiers)\n\t      && !Modifier.isPrivate  (modifiers));\n    case PRIVATE:   \n      return  Modifier.isPrivate   (modifiers);\n    default:\n      \n      \n      throw new Error(\"\"\n\t\t      + \"\"\n                      + level);\n    }\n  }", "comment": "/**\n   * Returns true if the entity is accessible to the specified level of\n   * protection.\n   * @param modifiers the modifiers as returned by Member.getModifiers()\n   * or Class.getModifiers() \n   * @param level the level of protection\n   * @return if the Member is accessible to the specified level of\n   * protection.\n   * @see Member.getModifiers()\n   * @see Class.getModifiers()\n   */"}}
{"code": {"body": "  private static String printField(String name, String type) {\n    StringBuffer sb = new StringBuffer (30);\n    sb.append(START_LIST);\n    sb.append(printWithinQuotes(name));\n    sb.append(SPACE);\n    sb.append(printWithinQuotes(type));\n    sb.append(END_PAREN);\n        \n    return sb.toString();\n  }", "comment": "/**\n   * Prints (list \"name\" \"type\") to the system output.\n   *\n   * @param name field name \n   * @param type field type\n   */"}}
{"code": {"body": "  private static String printConstructor(String name, Class[] params) {\n    StringBuffer sb = new StringBuffer (30);\n    sb.append(START_LIST);\n    sb.append(printWithinQuotes(name));\n    sb.append(SPACE);\n    sb.append(listClassArray(params));\n    sb.append(SPACE);\n    \n    return sb.toString();\n  }", "comment": "/**\n   * Prints (list \"name\" \"params\") to the system output.\n   *\n   * @param name constructor name\n   * @param params parameter type\n   */"}}
{"code": {"body": "  private static String printMethod(String name,\n                                    String returnType,\n                                    Class[] args) {\n    StringBuffer sb = new StringBuffer (30);\n    sb.append(START_LIST);\n    sb.append(printWithinQuotes(name));\n    sb.append(SPACE);\n    sb.append(printWithinQuotes(returnType));\n    sb.append(SPACE);\n    sb.append(listClassArray(args));\n    sb.append(SPACE);\n        \n    return sb.toString(); \n  }", "comment": "/**\n   * Prints (list \"name\" \"returnType\" \"args\") to the system output.\n   *\n   * @param name method name\n   * @param returnType method return type\n   * @param args method arguments\n   */"}}
{"code": {"body": "  private static String printClass(String name) {\n    StringBuffer sb = new StringBuffer (30);\n    sb.append(START_LIST);\n    sb.append(printWithinQuotes(name));\n    sb.append(END_PAREN);\n    return sb.toString();\n  }", "comment": "/**\n   * Prints (list \"className\") to the system output.\n   *\n   * @param name className\n   */"}}
{"code": {"body": "  private static String printExceptions(Class[] exceptions) {\n    StringBuffer sb = new StringBuffer (30);\n    sb.append(START_LIST);\n    sb.append(listClassArray(exceptions));\n    sb.append(END_PAREN);\n    return sb.toString();\n  }", "comment": "/**\n   * <code>printExceptions</code>\n   *\n   * @param exceptions a <code>Class[]</code>\n   * @return a <code>String</code>\n   */"}}
{"code": {"body": "  private static void recursiveListFields(Class c,\n                                          int level,\n                                          StringBuffer sb)  {\n    \n    if (c == null) {\n      return;\n    }\n\n    Field[] fields;\n    Field   field;\n    String  f;\n\n    \n    if (level == PUBLIC) {\n      \n      \n      \n      fields = c.getFields();\n    } else {\n      fields = c.getDeclaredFields();\n    }\n    \n\n    for (int index = 0; index < fields.length ; index++) {\n      field = fields[index];\n      if (isAccessible(field.getModifiers(), level)) {\n        f = printField(field.getName(),\n                       className(field.getType()));\n        if (sb.toString().lastIndexOf(f) == -1) {\n          sb.append(f);\n        }\n      }\n    }\n\n    \n    \n    if (!c.isInterface()\n\t&& level != PRIVATE\n\t&& level != PUBLIC) {\n      \n      \n      \n      \n      \n      \n      recursiveListFields(c.getSuperclass(), level, sb);\n    }\n    \n  }", "comment": "/**\n   * Recursively finds fields of the specified access level in the\n   * supplied class and superclasses.\n   *\n   * @param c the class to start the search in - nothing is done if\n   * this is NULL\n   * @param level  the access level to look for\n   * @param sb the StringBuffer where the results should be added\n   */"}}
{"code": {"body": "  private static void listConstructors(Class c,\n                                       int level,\n                                       StringBuffer sb)  {\n    Constructor[] constrs = c.getDeclaredConstructors();\n    Constructor constructor;\n    Class[] exceptions;\n    StringBuffer cons;\n        \n    for (int index = 0; index < constrs.length; index++) {\n      constructor = constrs[index];\n      if (isAccessible(constructor.getModifiers(), level)) {\n        cons = new StringBuffer(100);\n        cons.append(printConstructor(constructor.getName(),\n                                     constructor.getParameterTypes()));\n        \n        exceptions = constructor.getExceptionTypes();\n                \n        if (exceptions.length > 0) {\n          cons.append(printExceptions(exceptions));\n        } else {\n          cons.append(NIL);\n        }\n        cons.append(END_PAREN);\n        if (sb.toString().lastIndexOf(cons.toString()) == -1) {\n          sb.append(cons);\n        }\n      }\n    }\n  }", "comment": "/**\n   * Finds constructors of the specified access level in the supplied class.\n   *\n   * @param c the class to search in\n   * @param level  the access level to look for\n   * @param sb the StringBuffer where the results should be added\n   */"}}
{"code": {"body": "  private static void recursiveListMethods(Class c,\n                                           int level,\n                                           StringBuffer sb)  {\n    \n    if (c == null) {\n      return;\n    }\n\t\n    Method[] methods;\n    Method method;\n    Class[] exceptions;\n    StringBuffer temp;\n\n    \n    if (level == PUBLIC) {\n      \n      \n      \n      methods = c.getMethods();\n    } else {\n      methods = c.getDeclaredMethods();\n    }\n    \n        \n    for (int index = 0; index < methods.length ; index++) {\n      method = methods[index];\n      if (isAccessible(method.getModifiers(), level)) {\n        temp = new StringBuffer(100);\n        temp.append(printMethod(method.getName(),\n                                className(method.getReturnType()),\n                                method.getParameterTypes()));\n        \n        exceptions = method.getExceptionTypes();\n                \n        if (exceptions.length > 0) {\n          temp.append(printExceptions(exceptions));\n        } else {\n          temp.append(NIL);\n        }\n        temp.append(END_PAREN);\n                \n        if (sb.toString().lastIndexOf(temp.toString()) == -1) {\n          sb.append(temp);\n        }\n      }\n    }\n\n\n    \n    \n    if (!c.isInterface()\n\t&& level != PRIVATE\n\t&& level != PUBLIC) {\n      \n      \n      \n      \n      \n      \n      recursiveListMethods(c.getSuperclass(), level, sb);\n    }\n    \n  }", "comment": "/**\n   * Recursively finds methods of the specified access level in the\n   * supplied class and superclasses.\n   *\n   * @param c the class to start the search in - nothing is done if this is\n   * NULL\n   * @param level  the access level to look for\n   * @param sb the StringBuffer where the results should be added\n   */"}}
{"code": {"body": "  private static void recursiveListInnerClasses(Class c,\n                                                int level,\n                                                StringBuffer sb) {\n    if (c == null) {\n      return;\n    }\n\n\t\n    Class[] innerClasses;\n    Class   innerClass;\n    String  clas;\n\n    \n    if (level == PUBLIC) {\n      \n      \n      \n      \n      \n      innerClasses = c.getClasses();\n    }\n    else {\n      innerClasses = c.getDeclaredClasses();\n    }\n    \n        \n    for (int index = 0; index < innerClasses.length ; index++) {\n      innerClass = innerClasses[index];\n      if (isAccessible(innerClass.getModifiers(), level)) {\n        clas = printClass(innerClass.getName());\n        if (sb.toString().lastIndexOf(clas) == -1) {\n          sb.append(clas);\n        }\n      }\n    }\n\n    \n    \n    if (!c.isInterface() &&\n        level != PRIVATE &&\n        level != PUBLIC) {\n      \n      \n      \n      \n      \n      \n      recursiveListInnerClasses(c.getSuperclass(), level, sb);\n    }\n    \n  }", "comment": "/**\n   * Recursively finds inner classes of the specified access level\n   * in the supplied class and superclasses.\n   *\n   * @param c the class to start the search in - nothing is done if this is\n   * NULL\n   * @param level  the access level to look for\n   * @param sb the StringBuffer where the results should be added\n   */"}}
{"code": {"body": "  public static void getClassInfo(String className,\n                                  String[]imports) {\n    String name; \n    Class c;\n    for (int i = 0 ; i < imports.length ; i++) {\n      name = imports[i] + className;\n      try {\n        c = Class.forName(name);\n        if (c != null) {\n          getClassInfo(name);\n        }\n      }  catch (ClassNotFoundException e) {\n        \n      } catch (Exception e) {\n\tSystem.out.println(\"\" + name +\n\t\t\t \"\" + e + \"\");       \n      } catch (NoClassDefFoundError e) {\n\tSystem.out.println(NIL);\n      } catch (UnsatisfiedLinkError e) {\n\t\n\t\n\tSystem.out.println(\"\" + name +\n\t\t\t \"\" + e + \"\");       \n      } catch (LinkageError e) {\n\tSystem.out.println(\"\" + name +\n\t\t\t \"\" + e + \"\");       \n      }    \t\t\n    }\n    System.out.println(NIL);\n  }", "comment": "/**\n   * Looks up an unqualified class name in the class path to find possible\n   * fully qualified matches.\n   *\n   * @param className a value of type 'String'\n   * @param imports   an array of imported packages\n   */"}}
{"code": {"body": "  public Class loadClass(String argClassName) throws ClassNotFoundException {\n    File file;\n    byte[] classBytes = null;\n    Class c;\n\n    \n    if ((argClassName.startsWith(\"\")) || \n        (argClassName.startsWith(\"\"))) {\n      return Class.forName(argClassName);\n    } \n    \n    \n    \n    String className = argClassName.replace(PACKAGE_SEPARATOR,\n                                            FILE_SEPARATOR.charAt(0));\n\n    \n    \n    className += PACKAGE_SEPARATOR + CLASS_FILE_TYPE;\n\n    \n    \n    ProjectClasses pc = JdeUtilities.getCurrentProjectClass();\n    String classpath = null;\n    if (pc != null) {\n        classpath = pc.getClassPath();\n    } \n    \n    if (classpath == null || classpath.equals(\"\")) {\n        classpath = CLASS_PATH;\n    } \n    \n    StringTokenizer st = new StringTokenizer(classpath, PATH_SEPARATOR);\n    ZipFile zf;\n    while (st.hasMoreTokens()) {\n      file = new File(st.nextToken());  \n\n      \n      \n      try {\n        if (file.isDirectory()) {\n          \n          \n          file = new File(file, className);\n          classBytes = loadFile(file);\n          if (classBytes != null) {\n            break;\n          } \n        } else {\n          zf = new ZipFile(file);\n          classBytes = loadFile(zf, className);\n          if (classBytes != null) {\n            break;\n          } \n        }\n      } catch (IOException e) {\n        \n      } \n    } \n    \n    if (classBytes != null) {\n      try {\n        c = defineClass(argClassName, classBytes, 0, classBytes.length);\n      } catch (SecurityException e) {\n        \n        c = Class.forName(argClassName);\n      } catch (ClassFormatError e) { \n        c = Class.forName(argClassName);\n      } catch (NoClassDefFoundError e) {\n        c = Class.forName(argClassName);\n      }\n      return c;\n    } else {\n      try {\n        return Class.forName(argClassName);\n      } catch (ClassNotFoundException e) {\n        throw new ClassNotFoundException(argClassName);\n      } \n    } \n  }", "comment": "/**\n   * Loads a class information from the file system,\n   * if it fails it tries Class.forName(argClassName)\n   *\n   * @param argClassName name of the class to be loaded.\n   * @return Class of the type argClassName\n   * @exception ClassNotFoundException if the class cannot be found.\n   */"}}
{"code": {"body": "    public void checkExit(int param1) {\n        if (param1 != 7) {\n            throw new SecurityException();\n        }\n    }", "comment": "/**\n     *\n     * @param param1 <description>\n     */"}}
{"code": {"body": "    public void checkExec(String param1) {\n    }", "comment": "/**\n     *\n     * @param param1 <description>\n     */"}}
{"code": {"body": "    public void checkRead(String param1) {\n    }", "comment": "/**\n     *\n     * @param param1 <description>\n     */"}}
{"code": {"body": "    public void checkPermission(Permission param1) {\n    }", "comment": "/**\n     *\n     * @param param1 <description>\n     */"}}
{"code": {"body": "    public void checkCreateClassLoader() {\n    }", "comment": "/**\n     *\n     */"}}
{"code": {"body": "    public void checkPropertiesAccess() {\n    }", "comment": "/**\n     *\n     */"}}
{"code": {"body": "    public void checkPropertyAccess(String param1) {\n    }", "comment": "/**\n     *\n     * @param param1 <description>\n     */"}}
{"code": {"body": "    public void checkAccept(String param1, int param2) {\n    }", "comment": "/**\n     *\n     * @param param1 <description>\n     * @param param2 <description>\n     */"}}
{"code": {"body": "    public void checkConnect(String param1, int param2, Object param3) {\n    }", "comment": "/**\n     *\n     * @param param1 <description>\n     * @param param2 <description>\n     * @param param3 <description>\n     */"}}
{"code": {"body": "    public void checkListen(int param1) {\n    }", "comment": "/**\n     *\n     * @param param1 <description>\n     */"}}
{"code": {"body": "  public static void setProjectValues(String projectName,\n                                      String projectClassPath) {\n    try {\n      currentProjectName = projectName;\n      ProjectClasses pc = new ProjectClasses(projectClassPath);\n      projectCache.put(projectName, pc);\n    } catch (IOException e) {\n      e.printStackTrace(System.err);\n    } \n  }", "comment": "/**\n   * Jde should call this everytime the project changes, or if the\n   * classpath needs to be updated.\n   *\n   * @param projectName a <code>String</code> value\n   * @param projectClassPath a <code>String</code> value\n   */"}}
{"code": {"body": "  public static String getCurrentProjectName() {\n    return currentProjectName;\n  }", "comment": "/* Convenience to get current project's name */"}}
{"code": {"body": "  public static void classExists(String fqn) {\n    DynamicClassLoader dcl = new DynamicClassLoader();\n    while (fqn != null) {\n      try {\n        dcl.loadClass( fqn );\n        System.out.println( \"\" + fqn + \"\");\n        return;\n      } catch (ClassNotFoundException | NoClassDefFoundError e) {\n      } catch (Exception e) {\n        System.out.println(\"\" + fqn +\n                           \"\" + e + \"\");\n        return;\n      } catch (UnsatisfiedLinkError e) {\n        \n        \n        System.out.println(\"\" + fqn +\n                           \"\" + e + \"\");\n        return;\n      } catch (LinkageError e) {\n        System.out.println(\"\" + fqn +\n                           \"\" + e + \"\");\n        return;\n      }\n      \n      int index = fqn.lastIndexOf('');\n      if (index != -1) {\n        fqn = fqn.substring (0, index) + '' + fqn.substring (index + 1);\n      } else {\n        fqn = null;\n      }\n    }\n    System.out.println(NIL);              \n  }", "comment": "/**\n   * Determine whether a class exists on the JDEE classpath.\n   *\n   * @param fqn Fully qualified name of the class to be found.\n   */"}}
{"code": {"body": "  public static void updateClassList() {\n    updateClassList(null);\n  }", "comment": "/**\n   * Reload the current project's classpath.\n   */"}}
{"code": {"body": "  public static void getQualifiedName(String className) {\n    try {\n      ProjectClasses pc = projectCache.get(currentProjectName);\n\n      StringBuilder result = new StringBuilder(START_PAREN);\n      result.append(LIST);\n      for (String o : pc.getClassNames(className)) {\n        result.append(SPACE);\n        result.append(DOUBLE_QUOTE);\n        result.append(o);\n        result.append(DOUBLE_QUOTE);\n      }\n      result.append(END_PAREN);\n      System.out.println(result.toString());\n      System.out.flush();\n    } catch (IOException e) {\n      e.printStackTrace(System.err);\n    } \n  }", "comment": "/**\n   * Looks up an unqualified class name in the class path to find possible\n   * fully qualified matches.  Given `List,' this will find\n   * `java.util.List' and `java.awt.List'\n   *\n   * @param className a value of type 'String'\n   */"}}
{"code": {"body": "    public List getAsList(Object key) {\n        if (containsKey(key)) {\n            Object o = get(key);\n            if (o instanceof List) {\n                return (List)o;\n            } else {\n                return Arrays.asList(o);\n            }\n        } else {\n            return Collections.emptyList();\n        }\n    }", "comment": "/**\n     * Convenience method for retrieving the value for\n     * <code>key</code> as a List, even when there is only a single\n     * value for that key in the map.  The EMPTY_LIST is returned when\n     * no value is found for <code>key</code> making null checks\n     * unnecessary.\n     *\n     * @param key an <code>Object</code> value\n     * @return a <code>List</code> value\n     */"}}
{"code": {"body": "    public Object put(Object key, Object value) {\n        if (containsKey(key)) {\n            Object other = get(key);\n            if (other instanceof List) {\n                ((List)other).add(value);\n            } else {\n                List l = new ArrayList();\n                l.add(other);\n                l.add(value);\n                super.put(key, l);\n            } \n        } else {\n            super.put(key,value);\n        }\n        return null;\n    }", "comment": "/**\n     * inserts value into the map for key as a single element or, if\n     * values already exist, as an entry in key's list.\n     *\n     * @param key an <code>Object</code> value\n     * @param value an <code>Object</code> value\n     * @return null\n     */"}}
{"code": {"body": "  void reloadClasses() throws IOException {\n    for (ClassPathEntry cpe : classPathEntries) {\n      cpe.reload();\n    }\n  }", "comment": "/**\n   * Reload all classes in classpath.\n   *\n   * @exception IOException if an error occurs\n   */"}}
{"code": {"body": "  public String getClassPath() {\n    return classPath;\n  }", "comment": "/**\n   * Get the classpath represented by this project.\n   *\n   * @return a <code>String</code> value\n   */"}}
{"code": {"body": "  List<String> getClassNames(String unqualifiedName) throws IOException {\n    List<String> rv = new ArrayList<>();\n    for (ClassPathEntry cpe : classPathEntries) {\n      @SuppressWarnings(\"\")\n      List<String> classNames = (List<String>) cpe.getClassNames(unqualifiedName);\n      for (String className : classNames) {\n        if (!rv.contains(className)) {\n          rv.add(className);\n        }\n      }\n    }\n    return rv;\n  }", "comment": "/**\n   * Get fully qualified classnames in this classpath that\n   * matching the specified unqualified name.\n   *\n   * @param unqualifiedName Unqualified name for which matching\n   * qualified names are to be found.\n   * @return list of qualified names.\n   * @exception IOException if an error occurs\n   */"}}
{"code": {"body": "  static void loadBootClassPathEntries() throws IOException {\n    String bootClassPath = System.getProperty(\"\");\n    String extDirs = System.getProperty(\"\");\n\n    if (bootClassPath != null) {\n      StringTokenizer st = new StringTokenizer(bootClassPath, File.pathSeparator);\n      while (st.hasMoreTokens()) {\n        File file = new File(st.nextToken());\n        addToBootClassPath(file);\n      }\n    }\n        \n    if (extDirs != null) {\n      StringTokenizer st = new StringTokenizer(extDirs,File.pathSeparator);\n\t\t\t \n      \n      while (st.hasMoreTokens()) {\n        File[] extFiles = new File(st.nextToken()).listFiles();\n\t\t\t\t \n        if (extFiles != null) {\n          \n          for (int i = 0; i < extFiles.length; i++) {\n            addToBootClassPath(extFiles[i]);\n          }\n        }\n      }\n    }\n  }", "comment": "/**\n   * loads the boot classpath entries.\n   *\n   * @exception IOException if an error occurs\n   */"}}
{"code": {"body": "public AbstractClassFactory(NameFactory factory) {\n        super(factory);\n    }", "comment": "/** \n     * Creates an AbstractClassFactory that uses the specified NameFactory for\n     * generating parameter names\n     *\n     * @param factory Factory for generating parameter names\n     */"}}
{"code": {"body": "    public void process(String name, boolean truncate)\n        throws ClassNotFoundException, NotAnAbstractClassException {\n        if (null == namefactory)\n            namefactory = new DefaultNameFactory();\n    \n        Class aclass = Class.forName(name);\n        int iModifiers = aclass.getModifiers();\n        if (!Modifier.isAbstract(iModifiers))\n            throw new NotAnAbstractClassException(name);\n    \n        Vector methods = new Vector();\n        getAbstractMethods(aclass, methods);\n        int size = methods.size();\n        for (int i = 0; i < size; i++)\n            sortByDeclaringClass(new Signature((Method)methods.get(i),\n                                               this,\n                                               truncate));\n    }", "comment": "/**\n     * Generates signatures based on introspection of the specified class.\n     *\n     * @param name the abstract class to process for signatures.\n     * @param truncate toggles truncation of package specifiers in signatures.\n     *\n     * @exception NotAnAbstractClassException the requested class isn't an\n     * abstract class\n     * @exception java.lang.ClassNotFoundException the requested class cannot\n     * be loaded\n     */"}}
{"code": {"body": "    private void getAbstractMethods(Class argClass, Vector abstractMethods) {\n        Method[] methods = argClass.getMethods();\n        Method[] declaredMethods = argClass.getDeclaredMethods();\n        addMethods(methods, abstractMethods);\n        addMethods(declaredMethods, abstractMethods);\n    }", "comment": "/**\n     * Creates a list of the abstract methods in argClass\n     *\n     * @param argClass Class to obtained the abstract methods from\n     * @param abstractMethods Contains a list of the abstract methods.\n     * @return a <code>Methods[]</code> containing abstract methods\n     */"}}
{"code": {"body": "    private void addMethods(Method[] methods, Vector abstractMethods) {\n        Method method;\n        int modifiers;\n        for (int i = 0; i < methods.length; i++) {\n            method = methods[i];\n            modifiers = method.getModifiers();\n            \n            if (Modifier.isAbstract(modifiers)\n                && !abstractMethods.contains(method)) {\n                abstractMethods.add(method);\n            } \n        } \n    }", "comment": "/**\n     * Adds the abstract methods in <code>methods</code> into abstractMethods.\n     *\n     * @param methods a <code>Method[]</code> to be added\n     * @param abstractMethods a <code>Vector</code> to add abstract methods.\n     */"}}
{"code": {"body": "    public static void makeAbstractClassExpression \n        (String name, boolean truncate) {\n    \n        if (abstractClassFactory == null)\n            abstractClassFactory = new AbstractClassFactory();\n    \n        abstractClassFactory.flush();\n        abstractClassFactory.makeAbstractClassExpressionInternal(name,\n                                                                 truncate);\n    }", "comment": "/**\n     * Makes an implementation of the abstract methods of an abstract class.\n     * This method delegates the creation of the implementation to\n     * makeAbstractClassInternal.\n     *\n     * @param name Name of abstract class to be implemented.\n     * @param truncate If <code>true</code>, truncate package specifier\n     * when generating code.\n     */"}}
{"code": {"body": "    private void makeAbstractClassExpressionInternal \n        (String name, boolean truncate) {\n        try {\n            process(name, truncate);\n        } catch (ClassNotFoundException e) {\n            println(\"\" \n                    + name + \"\" + \"\");\n            return;\n        } catch (NotAnAbstractClassException e) {\n            println(\"\" + name\n                    + \"\");\n            return;\n        } catch (Exception e) {\n            e.printStackTrace();\n            println(\"\");\n            return;\n        }\n\n        dumpExpression(new PrintWriter(System.out, true), truncate);\n    }", "comment": "/**\n     * Makes an implementation of the abstract methods of an abstract class.\n     *\n     * @param name Name of abstract class to be implemented.\n     * @param truncate If <code>true</code>, truncate package specifier\n     * when generating code.\n     */"}}
{"code": {"body": "  public String getParameterName(Signature sig, int num) {\n    Method method = sig.getMethod();\n    String  methodName = method.getName();\n    Class[] parameters = method.getParameterTypes();\n    Class   type = parameters[num];\n\n    \n    String  className = type.getName().replace('', ''); \n\n    \n    if (methodName.length() > 3) {\n      if (methodName.startsWith(\"\")) {\n        if (parameters.length == 2) {\n          \n          if (num == 1 && className.equals(\"\")) {\n            return \"\";\n          }\n\n          if (num == 2) {\n            return methodToParamName(methodName, 3);\n          }\n        }\n      \n        \n        if (parameters.length == 1 && num == 1) {\n          return methodToParamName(methodName, 3);\n        }\n      }\n\n      if (methodName.startsWith(\"\")) {\n        \n        if (parameters.length == 1 && num == 1 && className.equals(\"\"))\n          return \"\";\n      }\n    }\n\n    return unique(parameters, type, num, getNameFromClass(className));\n  }", "comment": "/**\n   * Make up a name for the nth parameter of a method.\n   * First this method tries to recognize bean methods, if the method is named\n   * \"setName\" and has one parameter, the parameter returned is the\n   * lowercased method name with \"set\" stripped: \"name\".\n   *\n   * Index Bean Properties are methods starting with \"set\" and having two\n   * parameters, the first one of which is an int, or methods starting with\n   * \"get\" and having only one int parameter. In both cases the first\n   * parameter is given the name \"index\". \n   *     \n   * Examples:\n   *\n   *   void setName(String name);\n   *   void setNames(String[] names);\n   *   void setName(int index, String name);\n   *   String getName(int index);\n   *\n   * For other method names the parameters are named according to their\n   * type. \n   *\n   * Primitive types are named after the following mapping (now\n   * hardcoded, can perhaps be made configurable):\n   *\n   *   boolean: flag\n   *   byte: b\n   *   char: c\n   *   short: s\n   *   int: n\n   *   long: l\n   *   float: f\n   *   double: d\n   * \n   * Array types are named like their base type with the String \"Array\"\n   * appended, so a \"byte[]\" parameter will be named \"byteArray\":\n   *\n   *    void fill(char[] charArray);\n   *\n   * All other parameters will be named according to their type's unqualified\n   * lowercased classname:\n   *\n   *    void actionPerformed(ActionEvent actionEvent);\n   *\n   * To avoid any name clashes, the parameters will have a number appended\n   * if there is another parameter of the same type in the methods\n   * parameterlist:\n   *\n   *   void write(byte[] byteArray, int n, int n1);\n   *   void put(String string, String string1);\n   *\n   * @param sig  - signature of the declaring method\n   * @param num     - the parameter number whose name we want.\n   * @return a name for the n'th parameter of the method.\n   */"}}
{"code": {"body": "  private final String getNameFromClass(String className) {\n\n        \n    \n    \n    \n    int i = className.lastIndexOf('')+1;      \n    if (Character.isUpperCase(className.charAt(i))) {\n      className = Introspector.decapitalize(className.substring(i));\n\n      \n      \n      if (className.endsWith(\"\")) {\n        className = className.substring(0, className.length()-1) + \"\";\n      }\n      if (className.equals(\"\")) className = \"\";\n\n      return className;\n    }\n\n    \n    if (className.equals(\"\")) {\n      return \"\";\n    }\n        \n    if (className.equals(\"\")) {\n      return \"\";\n    }\n        \n    if (className.equals(\"\"))\n      return \"\";\n    if (className.equals(\"\"))\n      return \"\";\n    if (className.equals(\"\"))\n      return \"\";\n    if (className.equals(\"\"))\n      return \"\";\n    if (className.equals(\"\"))\n      return \"\";\n    if (className.equals(\"\"))\n      return \"\";\n\n    \n    if (className.equals(\"\"))\n      return \"\";\n    if (className.equals(\"\"))\n      return \"\";\n    if (className.equals(\"\"))\n      return \"\";\n    if (className.equals(\"\"))\n      return \"\";\n    if (className.equals(\"\"))\n      return \"\";\n    if (className.equals(\"\"))\n      return \"\";\n    if (className.equals(\"\"))\n      return \"\";\n    if (className.equals(\"\"))\n      return \"\";\n\n    \n    return \"\";\n  }", "comment": "/**\n   * Generate a name for a parameter from the type of the parameter.\n   *\n   * @param className  the parameters type\n   * @return a more or less fitting name.\n   */"}}
{"code": {"body": "  private final String unique(Class[] parameters, Class type, int num, String name) {\n    if (parameters.length > 1) {\n      int i = 0;\n      for (int j = 0; j < num; ++j)\n        if (parameters[j] == type)\n          ++i;\n\n      if (i != 0)\n        name += i;\n    }\n\n    return name;    \n  }", "comment": "/**\n   * Make name unique, look if there a more parameters of this type\n   * before us. In this case append a number.\n   *\n   * @param parameters all parameter types of the method\n   * @param type the type of the current parameter\n   * @param num the position of the current parameter\n   * @param name parameter basename\n   * @return a unique parameter name\n   */"}}
{"code": {"body": "  private final String methodToParamName(String name, int strip) {\n    return Introspector.decapitalize(name.substring(strip));\n  }", "comment": "/**\n   * Strip the first characters from the string and decapitalize\n   * the rest.\n   *\n   * @param name the original name.\n   * @param strip number of characters to strip from the front of the name.\n   * @return the decapitalized and shortened name.\n   */"}}
{"code": {"body": "public DelegateFactory() { }", "comment": "/**\n   * Creates a new <code>DelegateFactory</code> instance.\n   *\n   */"}}
{"code": {"body": "public DelegateFactory(NameFactory factory) {\n    super(factory);\n  }", "comment": "/** \n   * Creates a DelegateFactory that uses the specified NameFactory\n   * for generating parameter names \n   *\n   * @param factory Factory for generating parameter names\n   */"}}
{"code": {"body": "  public SignatureContainer getSignatures()  {\n    return this.signatures;\n  }", "comment": "/**\n   * Gets a container containing the signatures of the delegation\n   * methods.\n   *\n   * @return the value of signatures\n   */"}}
{"code": {"body": "  public void setSignatures(SignatureContainer argSignatures) {\n    this.signatures = argSignatures;\n  }", "comment": "/**\n   * Specifies a container to hold the signatures of the\n   * delegator methods.\n   *\n   * @param argSignatures signature container\n   */"}}
{"code": {"body": "  public static DelegateFactory getTheFactory()  {\n    return DelegateFactory.delegateFactory;\n  }", "comment": "/**\n   * Gets the Delegate Factory\n   *\n   * @return the Delegate Factory\n   */"}}
{"code": {"body": "  public static void setTheFactory(DelegateFactory argDelegateFactory) {\n    DelegateFactory.delegateFactory = argDelegateFactory;\n  }", "comment": "/**\n   * Sets the Delegate Factory\n   *\n   * @param argDelegateFactory the Delegate Factory\n   */"}}
{"code": {"body": "  public String getDelegee()  {\n    return this.delegee;\n  }", "comment": "/**\n   * Gets the name of the delegator field that references the delegee.\n   *\n   * @return name of the delegee\n   */"}}
{"code": {"body": "  public void setDelegee(String argDelegee) {\n    this.delegee = argDelegee;\n  }", "comment": "/**\n   * Specifies the name of the delegator field that references the delegee.\n   *\n   * @param argDelegee the delegee\n   */"}}
{"code": {"body": "  public void flush() {\n    super.flush();\n    signatures.clear();\n  }", "comment": "/** \n   * Clears the method signatures container.\n   */"}}
{"code": {"body": "  public void process(String delegeeClassName, boolean truncate)\n    throws ClassNotFoundException {\n    \n    if (null == namefactory) {\n      namefactory = new DefaultNameFactory();\n    }\n    \n    Class aclass = Class.forName(delegeeClassName);\n    \n    Method[] methods = aclass.getMethods();\n    for (int i = 0; i < methods.length; i++) {\n      if (!(methods[i].getDeclaringClass().getName().equals(\"\")\n            && Modifier.isFinal(methods[i].getModifiers()))) {\n        signatures.add(new Signature(methods[i], this, truncate, true));\n      }\n    }\n  }", "comment": "/**\n   * Generates signatures for the public methods of the delegee\n   * class. \n   *\n   * @param delegeeClassName name of the delegee's class\n   * @param truncate toggles truncation of package specifiers in signatures.\n   *\n   * @exception ClassNotFoundException the requested class cannot\n   * be loaded \n   */"}}
{"code": {"body": "  private void makeDelegatorMethodsInternal(String delegeeFieldName,\n                                            String delegeeClassName,\n                                            boolean truncate) {\n    delegee = delegeeFieldName;\n    \n    try {\n      process(delegeeClassName, truncate);\n    } catch (ClassNotFoundException e) {\n      println(\"\"\n              + delegeeClassName + \"\"\n              + \"\");\n      return;\n    } catch (Exception e) {\n      println(\"\");\n      return;\n    }\n\n    outputMethods(new PrintWriter(System.out, true), truncate);\n  }", "comment": "/**\n   * Generate delegator methods.\n   *\n   * @param delegeeFieldName Name of delagator field that reference\n   * the delegee.\n   * @param delegeeClassName  Name of delegee class.\n   * @param truncate If <code>true</code>, truncate package specifier\n   * when generating code.\n   * \n   */"}}
{"code": {"body": "  public static void makeDelegatorMethods(String delegeeFieldName,\n                                          String delegeeClassName, \n                                          boolean truncate) {\n\n    if (delegateFactory == null) {\n      delegateFactory = new DelegateFactory();\n    }\n\n    delegateFactory.flush();\n    delegateFactory.makeDelegatorMethodsInternal(delegeeFieldName,\n                                                 delegeeClassName,\n                                                 truncate);\n  }", "comment": "/**\n   * Generates delegator methods.\n   *\n   * @param delegeeFieldName Name of delegator field that\n   * references the delegee.\n   * @param delegeeClassName Name of delegee's class.\n   * @param truncate If <code>true</code>, truncate package specifier\n   * when generating code.\n   */"}}
{"code": {"body": "  public static void getImportedClasses() {\n    println(delegateFactory.getImportsAsList());\n  }", "comment": "/**\n   * Describe <code>getImportedClasses</code> method here.\n   *\n   */"}}
{"code": {"body": "  protected String getDefaultBody (Signature sig) {\n    Method m = sig.getMethod();\n    Class cl = m.getReturnType();\n    String defBody = \"\";\n\n    defBody = delegee + \"\" + m.getName() \n      + \"\" + sig.getParameterNames() + \"\";\n    if (!cl.getName().equals(\"\")) {\n      defBody = \"\" + defBody;\n    }\n    return defBody;\n  }", "comment": "/**\n   * Return a default body for the implementation of the method described\n   * by <code>sig</code>.\n   *\n   * @param sig a <code>Signature</code> value\n   * @return a <code>String</code> value\n   */"}}
{"code": {"body": "  public void outputMethods(PrintWriter out, boolean truncate) {\n    final StringBuffer buf = new StringBuffer\n      (\"\");\n\n    signatures.visit(new SignatureVisitor() {\n        public void visit(Signature sig , boolean firstOfClass) {\n          if (firstOfClass) {\n            buf.append (\"\");\n            buf.append(\"\");\n            buf.append(sig.getDeclaringClass().getName());\n            buf.append(\"\");\n            buf.append(delegee);\n            buf.append(\"\");\n          }\n          buf.append (\"\");\n          buf.append(getMethodSkeletonExpression(sig));\n          buf.append (\"\");\n        }\n      });\n    \n    buf.append(\"\");\n    println(buf.toString());\n  }", "comment": "/**\n   * Prints delegator methods to the standard out of\n   * the current process, i.e., to Emacs.\n   *\n   * @param out a <code>PrintWriter</code> value\n   * @param truncate a <code>boolean</code> value\n   */"}}
{"code": {"body": "public EventSourceFactory(NameFactory factory)", "comment": "/** \n   * Creates an EventSourceFactory that uses the specified NameFactory\n   * for generating parameter names \n   *\n   * @param factory Factory for generating parameter names\n   */"}}
{"code": {"body": "  public static void makeEventSourceSupportExpression\n      (String listenerName, boolean truncate) {\n\n    if (eventSourceFactory == null) {\n      eventSourceFactory = new EventSourceFactory();\n    }\n\n    eventSourceFactory.flush();\n    eventSourceFactory.makeEventSourceSupportExpressionInternal\n\t(listenerName, truncate);\n  }", "comment": "/**\n   * Makes an implementation of an interface. This method delegates\n   * the creation of the implementation to makeInterfaceInternal.\n   *\n   * @param name Name of interface to be implemented.\n   * @param truncate If <code>true</code>, truncate package specifier\n   * when generating code.\n   */"}}
{"code": {"body": "  private void makeEventSourceSupportExpressionInternal\n      (String name, boolean truncate) \n  {\n    try \n    {\n      listenerClass = Class.forName( name );\n      listenerClassNameFQN= listenerClass.getName();\n      listenerClassName = listenerClass.getName().substring( listenerClass.getName().lastIndexOf('')+1);\n      StringBuffer buf = new StringBuffer( listenerClassName );\n      buf.setCharAt( 0, Character.toLowerCase(listenerClassName.charAt( 0 )) );\n      listenerVectorName = buf.toString()+\"\";\n    }\n    catch (ClassNotFoundException e) {\n      println(\"\" + name + \"\"\n\t      + \"\");\n      return;\n    }\n    super.implementInterface(name, truncate);\n\n  }", "comment": "/**\n   * Makes an implementation of an interface.\n   *\n   * @param name Name of interface to be implemented.\n   * @param truncate If <code>true</code>, truncate package specifier\n   * when generating code.\n   */"}}
{"code": {"body": "  public static void addClassesFromZip(Vector classList,\n\t\t\t\t       File classPathFile) {\n    \n    \n    try {\n      ZipFile zipFile = new ZipFile(classPathFile);\n      Enumeration en = zipFile.entries();\n      while (en.hasMoreElements()) {\n\tZipEntry zipEntry = (ZipEntry)en.nextElement();\n\tString current = zipEntry.getName();\n\tif (current.toLowerCase().endsWith(\"\")) {\n\t  current = current.substring(0, current.length() - 6);\n\t  current = current.replace('', '');\n\t  current = current.replace('', '');\n\t  classList.addElement(current);\n\t}\n      }\n    } catch (Exception ex) {\n      System.err.println(\"\" + classPathFile + \"\");\n    }\n  }", "comment": "/**\n   * Adds the classes from the supplied Zip file to the class list.\n   *\n   * @param classList the Vector to add the classes to\n   * @param classPathFile the File to scan as a zip file\n   */"}}
{"code": {"body": "  public static void addClassesFromDir(Vector classList,\n\t\t\t\t       File rootDir,\n\t\t\t\t       File currentDir) {\n    \n    String [] files = currentDir.list();\n    for (int i = 0; i < files.length; i++) {\n      String current = files[i];\n      if (current.toLowerCase().endsWith(\"\")) {\n\tcurrent = current.substring(0, current.length() - 6);\n\tString rootPath = rootDir.getPath();\n\tString currentPath = currentDir.getPath();\n\tif (currentPath.indexOf(rootPath) != 0) {\n\t  System.err.println(\"\"\n\t\t\t     + \"\" + rootPath + \"\"\n\t\t\t     + \"\" + currentPath + \"\");\n\t} else {\n\t  String packageName = currentPath.substring(rootPath.length());\n\t  if (packageName.length() > 0) {\n\t    \n\t    packageName = packageName.replace('', '');\n\t    packageName = packageName.replace('', '');\n\t    classList.addElement(packageName.substring(1) + '' + current);\n\t  } else {\n\t    \n\t    classList.addElement(current);\n\t  }\n\t}\n      } else {\n\t\n\tFile currentFile = new File(currentDir, current);\n\tif (currentFile.isDirectory()) {\n\t  addClassesFromDir(classList, rootDir, currentFile);\n\t}\n      }\n    }\n  }", "comment": "/**\n   * Adds the classes from the supplied directory to the class list.\n   *\n   * @param classList the Vector to add the classes to\n   * @param classPathFile the File to recursively scan as a directory\n   */"}}
{"code": {"body": "  public static void makeImportStatement(String className) {\n\n    String importList = \"\";\n    \n    for (int i = 0; i < CLASS_LIST.size(); i++) {\n      String testName = (String) CLASS_LIST.elementAt(i);\n      \n      if ((testName.length() > className.length() && testName.endsWith(className) &&\n\t   testName.charAt(testName.length() - className.length() - 1) == '') ||\n\t  (testName.length() == className.length()) && testName.equals(className)) {\n\t\n\t\n\ttestName = \"\" +  testName + \"\";\n\tif (importList.indexOf(testName) == -1)\n          importList += testName;\n      }\n    }\n\n    importList += \"\";\n    \n\n    System.out.println(importList);\n    System.out.flush();\n\n  }", "comment": "/**\n   * Looks up an unqualified class name in the class path to find possible\n   * fully qualified matches.\n   *\n   * @param className a value of type 'String'\n   */"}}
{"code": {"body": "  public static void main(String[] args) {\n\n    if (args.length == 0) {\n      System.out.println(\"\");\n    } else {\n      for (int i = 0; i < args.length; i++) {\n\tSystem.out.println(\"\" + args[i] + \"\");\n\tmakeImportStatement(args[i]);\n      }\n    }\n  }", "comment": "/**\n   * Tests the ImportWizard from the command line\n   *\n   * @param args an array of strings containing class names to look up\n   */"}}
{"code": {"body": "public InterfaceFactory(NameFactory factory) {\n    super(factory);\n  }", "comment": "/** \n   * Creates an InterfaceFactory that uses the specified NameFactory\n   * for generating parameter names \n   *\n   * @param factory Factory for generating parameter names\n   */"}}
{"code": {"body": "  public SignatureContainer getSignatures()  {\n    return this.signatures;\n  }", "comment": "/**\n   * Gets the value of signatures\n   *\n   * @return the value of signatures\n   */"}}
{"code": {"body": "  public void setSignatures(SignatureContainer argSignatures) {\n    this.signatures = argSignatures;\n  }", "comment": "/**\n   * Sets the value of signatures\n   *\n   * @param argSignatures Value to assign to this.signatures\n   */"}}
{"code": {"body": "  public static InterfaceFactory getTheFactory()  {\n    return InterfaceFactory.interfaceFactory;\n  }", "comment": "/**\n   * Gets the value of interfaceFactory\n   *\n   * @return the value of interfaceFactory\n   */"}}
{"code": {"body": "  public static void setTheFactory(InterfaceFactory argInterfaceFactory) {\n    InterfaceFactory.interfaceFactory = argInterfaceFactory;\n  }", "comment": "/**\n   * Sets the value of interfaceFactory\n   *\n   * @param argInterfaceFactory Value to assign to this.interfaceFactory\n   */"}}
{"code": {"body": "  protected final void sortByDeclaringClass(Signature sig) {\n    signatures.add(sig);\n  }", "comment": "/** \n   * Adds a signature to signature container.\n   *\n   * @param sig Signature to be stored in the signature table.\n   */"}}
{"code": {"body": "  public void flush() {\n    super.flush();\n    signatures.clear();\n  }", "comment": "/** \n   * Clears import hashtable and interface container for this factory so they\n   * can be re-used to process a new set of interfaces.\n   */"}}
{"code": {"body": "  public void process(String name, boolean truncate)\n    throws ClassNotFoundException, NotAnInterfaceException {\n    \n    if (null == namefactory) {\n      namefactory = new DefaultNameFactory();\n    }\n    \n    Class aclass = Class.forName(name);\n    if (false == aclass.isInterface()) {\n      throw new NotAnInterfaceException(name);\n    }\n    \n    Method[] methods = aclass.getMethods();\n    \n    for (int i = 0; i < methods.length; i++) {\n      sortByDeclaringClass(new Signature(methods[i], this, truncate));\n    }\n  }", "comment": "/**\n   * Generates signatures based on introspection of the specified class. \n   *\n   * @param name the interface to process for signatures.\n   * @param truncate toggles truncation of package specifiers in signatures..\n   *\n   * @exception NotAnInterfaceException the requested class isn't an interface\n   * @exception ClassNotFoundException Cannot find requested class\n   */"}}
{"code": {"body": "  protected void implementInterface(String name, boolean truncate) {\n    \n    try {\n      process(name, truncate);\n    } catch (ClassNotFoundException e) {\n      println(\"\" + name + \"\"\n              + \"\");\n      return;\n    } catch (NotAnInterfaceException e) {\n      println(\"\" + name + \"\");\n      return;\n    } catch (Exception e) {\n      println(\"\");\n      return;\n    }\n\n    dumpExpression(new PrintWriter(System.out, true), truncate);\n  }", "comment": "/**\n   * Makes an implementation of an interface.\n   *\n   * @param name Name of interface to be implemented.\n   * @param truncate If <code>true</code>, truncate package specifier\n   * when generating code.\n   */"}}
{"code": {"body": "  public static void makeInterfaceExpression(String name, boolean truncate) {\n\n    InterfaceFactory theFactory = getTheFactory();\n\n    if (theFactory == null) {\n      theFactory = new InterfaceFactory();\n      setTheFactory(theFactory);\n    }\n\n    theFactory.flush();\n    theFactory.implementInterface(name, truncate);\n\n  }", "comment": "/**\n   * Makes an expression for generating the implementation of an\n   * interface. This method delegates the creation of the\n   * implementation to makeInterfaceExpressionInternal.\n   *\n   * @param name Name of interface to be implemented.\n   * @param truncate If <code>true</code>, truncate package specifier\n   * when generating code.\n   */"}}
{"code": {"body": "  public static void getImportedClasses() {\n    println(interfaceFactory.getImportsAsList());\n  }", "comment": "/**\n   * Prints imported classes to standard out.\n   *\n   */"}}
{"code": {"body": "  public void dumpExpression(PrintWriter out, boolean truncate) {\n    \n    final StringBuffer buf =\n      new StringBuffer(\"\");\n    \n    signatures.visit(new SignatureVisitor() {\n        public void visit(Signature sig , boolean firstOfClass) {\n          if (firstOfClass) {\n            buf.append (\"\");\n            buf.append(\"\");\n            buf.append(sig.getDeclaringClass().getName());\n            buf.append(\"\");\n          }\n          buf.append (\"\");\n          buf.append(getMethodSkeletonExpression(sig));\n          buf.append (\"\");\n        }\n      }\n                     );\n\n    buf.append(\"\");\n    println(buf.toString());\n  }", "comment": "/**\n   * Describe <code>dumpExpression</code> method here.\n   *\n   * @param out a <code>PrintWriter</code> value\n   * @param truncate a <code>boolean</code> value\n   */"}}
{"code": {"body": "public MethodFactory() {\n    this(new DefaultNameFactory());\n  }", "comment": "/**\n   * Constructs a default method factory.\n   */"}}
{"code": {"body": "public MethodFactory(NameFactory factory) {\n    namefactory = factory;\n  }", "comment": "/** \n   * Creates a method factory that uses the specified NameFactory\n   * for generating parameter names \n   *\n   * @param factory Factory for generating parameter names\n   */"}}
{"code": {"body": "  public void setNameFactory(NameFactory factory) {\n    namefactory = factory;\n  }", "comment": "/** \n   * Sets the factory for generating parameter names.\n   *\n   * @param factory Factory for generating parameter names.\n   */"}}
{"code": {"body": "  public NameFactory getNameFactory() {\n    return namefactory;\n  }", "comment": "/** \n   * Gets the factory used to generating parameter names for \n   * methods generated by this interface factory.\n   *\n   * @return Name factory\n   */"}}
{"code": {"body": "  public Hashtable getImports() {\n    return imports;\n  }", "comment": "/** \n   * Gets a table containing the classes that must be imported to\n   * implement an interface generated by this factory.\n   *\n   * @return Classes required to implement the current interface.\n   */"}}
{"code": {"body": "  public String getImportsAsList() {\n    StringBuffer res = new StringBuffer (\"\");\n    Enumeration i = imports.keys();\n    while (i.hasMoreElements()) {\n      Class c = (Class) i.nextElement();\n      String className = c.getName();\n      \n      \n      \n      \n      \n      \n      \n      \n      int idx = className.indexOf('');\n      if (idx > -1) {\n        className = className.substring(0, idx);\n      }\n      \n      res.append (\"\" + className + \"\");\n    }\n    res.append (\"\");\n    return res.toString();\n  }", "comment": "/**\n   * Return the fully qualified names of classes that\n   * need to be imported to compile this interface\n   * implementation.\n   *\n   * @return Class names as elisp list of strings.\n   */"}}
{"code": {"body": "  public void registerImport(Class register) {\n    if (register.isArray()) {\n      try {\n        Class cl = register;\n        \n        while (cl.isArray()) {\n          cl = cl.getComponentType();\n        }\n        \n        register = cl;\n      } catch (Throwable t) {\n        throw new RuntimeException(\"\"\n                                   + t);\n      }\n    }\n    \n    if (shouldImport(register)) {\n      imports.put(register, \"\");\n    }\n  }", "comment": "/** \n   * Registers a class that needs to be imported by the interface \n   * implementation generated by this factory. Store the class in the \n   * import hashtable if it passes the shouldImport test.  \n   * Arrays have to be handled differently here. \n   *\n   * @param register Imported class candidate\n   */"}}
{"code": {"body": "  private final boolean shouldImport(Class c) {        \n    return ! c.isPrimitive();                \n  }", "comment": "/**\n   * Tests whether a specified class needs to be imported by the interface\n   * implementation generated by this factory.\n   * We don't import primitives.\n   * \n   * @param c the <code>Class</code> object to be tested\n   * @return <code>true</code> if the class should be imported\n   */"}}
{"code": {"body": "  protected String getDefaultBody (Signature sig) {\n    Method m = sig.getMethod();\n    Class cl = m.getReturnType();\n    if (numericTypesList.contains(cl.getName())) {\n      return \"\";\n    } else if (cl.getName().equals(\"\")) {\n      return \"\";\n    } else if (!cl.getName().equals(\"\")) {\n      return \"\";\n    }\n    return \"\";\n  }", "comment": "/**\n   * Return a default body for the implementation of the method described\n   * by <code>sig</code>.\n   *\n   * @param sig a <code>Signature</code> value\n   * @return a <code>String</code> value\n   */"}}
{"code": {"body": "  public String getMethodSkeletonExpression (Signature sig)  {\n    StringBuffer res = new StringBuffer();\n\n    res.append (\"\");\n    res.append (\"\" + sig.getModifiers() + \"\");\n    res.append (\"\" + sig.getReturnBaseType() + \"\");\n    res.append (\"\" + sig.getMethod().getName() + \"\");\n    res.append (\"\" + sig.getParameters() + \"\");\n    res.append (\"\" + sig.getExceptionList() + \"\");\n    res.append (\"\" + getDefaultBody (sig) + \"\");\n    return res.toString();\n  }", "comment": "/**\n   * Get a Lisp form that generates a skeleton\n   * implementation of a specified method. The\n   * List form is of the form\n   *\n   *   <code>(jdee-wiz-gen-method ... )</code>\n   *\n   * where <code>jdee-wiz-gen-method</code> is a\n   * function defined by the JDEE's jdee-wiz package.\n   *\n   * @param sig a <code>Signature</code> value\n   * @return a <code>String</code> value\n   */"}}
{"code": {"body": "  public void flush() {\n    imports.clear();\n  }", "comment": "/** \n   * Clears the import hashtables for this factory so it\n   * can be re-used to process a new set of methods.\n   */"}}
{"code": {"body": "  public static void println(String s) {\n    System.out.print(s + \"\");\n    System.out.flush();\n  }", "comment": "/**\n   * Print a string and flush the output buffer to\n   * ensure that the string reaches Emacs immediately.\n   *\n   * @param s a <code>String</code> value\n   */"}}
{"code": {"body": "public MethodOverrideFactory(NameFactory factory)", "comment": "/** \n   * Creates a MethodOverrideFactory that uses the specified NameFactory\n   * for generating parameter names \n   *\n   * @param factory Factory for generating parameter names\n   */"}}
{"code": {"body": "  private Vector getOverrideableMethods(Class cl, String methodName) {\n    \n    Vector m = new Vector();\n    Class baseClass = cl;\n\n    while (baseClass != null) {\n      Method[] methods = baseClass.getDeclaredMethods();\n      for (int i = 0; i < methods.length; i++) {\n        if (methods[i].getName().equals(methodName)) {\n          int methodModifiers = methods[i].getModifiers();\n          if ((Modifier.isPublic(methodModifiers) ||\n               Modifier.isProtected(methodModifiers)) &&\n              !Modifier.isFinal(methodModifiers))\n            m.addElement(methods[i]);\n        }\n      }\n      baseClass = baseClass.getSuperclass();\n    }\n\n    return m;\n  }", "comment": "/**\n   * Return a <code>Vector</code> containing all <code>Method</code>\n   * objects for the argument class and methodName which can be\n   * overridden.\n   *\n   * @param cl the <code>Class</code> for which all methods that can\n   * be overridden will be returned.\n   * @param methodName the name of the Method to be returned.\n   * @return a <code>Vector</code> of <code>Method</code> objects.\n   */"}}
{"code": {"body": "  public static void getCandidateSignatures(String baseClassName, String methodName) {\n\n    if (overrideFactory == null) \n      overrideFactory = new MethodOverrideFactory();\n    else\n      overrideFactory.flush();\n\n    overrideFactory.baseClassName = baseClassName;\n    overrideFactory.methodName = methodName;\n\n    try {\n\n      DynamicClassLoader dcl = new DynamicClassLoader();\n      Vector methods = overrideFactory.getOverrideableMethods\n          (dcl.loadClass(baseClassName), methodName);\n\n      for (int i = 0; i < methods.size(); ++i) {\n        Method m = (Method) methods.elementAt(i);\n        Signature s = new Signature(m, overrideFactory);\n        boolean containsSignature = false;\n        for (int j = 0; j < overrideFactory.candidates.size(); ++j) \n          if (s.equals(overrideFactory.candidates.elementAt(j))) {\n            containsSignature = true;\n            break;\n          }\n        if (! containsSignature) \n          overrideFactory.candidates.addElement(s);\n      }\n\n      int n = overrideFactory.candidates.size();\n\n      if (n > 0) {\n\tString res = \"\";\n\tfor (int i = 0; i < n; ++i) {\n\t  Signature s = (Signature) overrideFactory.candidates.elementAt(i);\n          s.setTruncating(false);\n\t  String p = s.getParameters(s.getMethod().getParameterTypes(), false);\n          s.setTruncating(true);\n\t  res = res + \"\" + methodName + \"\" + p +  \"\";\n\t}\n\tres = res + \"\";\n\tprintln(res);\n      }\n      else\n\tprintln(\"\" +\n\t\tmethodName + \"\" + baseClassName + \n\t\t\"\");\n\n    }\n    catch (ClassNotFoundException ee) {\n      println(\"\" + \n\t      baseClassName + \"\");\n    }\n\n  }", "comment": "/**\n   * Get a list of signatures for all methods of a specified name defined\n   * or inherited by a specified class. The signatures returned by this method\n   * including only the types of the method parameters as the generated names\n   * are unnecessary for signature matching. This method prints the signature\n   * list to standard out as a Lisp list form.\n   *\n   * @param baseClassName a <code>String</code> value that specifies the name of\n   * the class that defines or inherits the methods whose signatures are to be\n   * returned.\n   * @param methodName a <code>String</code> value that specifies the name of the\n   * methods whose signatures are to be returned.\n   */"}}
{"code": {"body": "  public void flush()\n  {\n    super.flush();\n    candidates.removeAllElements();\n  }", "comment": "/** \n   * Clears the import and candidate hashtables for this factory so they\n   * can be re-used to process a new set of interfaces.\n   */"}}
{"code": {"body": "  public static void main (String[] args) {\n\n    String className = \"\";\n    String methodName = \"\";\n    \n    if (args.length == 2) {\n\n      className = args[0];\n      methodName = args[1];\n\n    }\n\n    System.out.println(\"\" + className);\n    System.out.println(\"\" + methodName);\n\n    getCandidateSignatures(className, methodName);\n\n\n    \n     \n  }", "comment": "/**\n   * Gets the candidate signatures for the class and method\n   * passed as arguments on the command line.\n   *\n   * @param args a <code>String[]</code> value\n   */"}}
{"code": {"body": "public Signature (Method meth, ClassRegistry aregistry) {\n    this(meth, aregistry, true);\n  }", "comment": "/** \n   * Creates a signature for the specified method and register\n   * its types with the specified registry (which may be null).\n   * Removes package info from generated signatures.\n   *\n   * @param meth Method represented by this signature\n   * @param aregistry Registry containing this signature\n   */"}}
{"code": {"body": "public Signature (Method meth, ClassRegistry aregistry, boolean truncate) {\n    this(meth, aregistry, truncate, false);\n  }", "comment": "/** \n   * Creates a signature for the specified method and register its\n   * types with the specified registry (which may be null).\n   *\n   * @param meth Method represented by thi signature\n   * @param aregistry Registry containing this signature\n   * @param truncate toggles removal of package info from generated signatures \n   */"}}
{"code": {"body": "public Signature (Method meth, ClassRegistry aregistry, boolean truncate)", "comment": "/** \n   * Creates a signature for the specified method and register its\n   * types with the specified registry (which may be null).\n   *\n   * @param meth Method represented by thi signature\n   * @param aregistry Registry containing this signature\n   * @param truncate toggles removal of package info from generated signatures \n   */"}}
{"code": {"body": "  public void setTruncating(boolean b) {\n    truncate = b;\n  }", "comment": "/** \n   * Toggles truncation of package info .\n   * \n   * @param b Truncation toggle\n   */"}}
{"code": {"body": "  public void setRegistry(ClassRegistry registry) {\n    this.registry = registry;\n  }", "comment": "/** \n   * Sets the registry used to register this signature's types.\n   * \n   * @param registry Registry used to register this signature's type.\n   */"}}
{"code": {"body": "  public Class getDeclaringClass () {\n    return declaring;\n  }", "comment": "/** \n   * Gets the class that declared the method represented by this signature.\n   *\n   * @return The class this method was declared in \n   */"}}
{"code": {"body": "  public String toJavaDoc() {\n    NameFactory factory = registry.getNameFactory();\n    StringBuffer buf = new StringBuffer(\"\");\n    \n    for (int i = 0; i < parameters.length; i++) {\n      buf.append(\"\"\n                 + factory.getParameterName(this, i)\n                 + \"\");\n    }\n\n    if (!\"\".equals(returnValue.getName())) {\n      buf.append(\"\" + \"\");\n    }\n    \n    for (int i = 0; i < exceptions.length; i++) {\n      buf.append(\"\" + exceptions[i].getName()\n                 + \"\");\n    }\n    \n    if (see) {\n      buf.append(\"\");\n      buf.append(method.getDeclaringClass().getName());\n      buf.append('');\n      buf.append(method.getName());\n      buf.append('');\n      buf.append(getParameters(method.getParameterTypes(), false));\n      buf.append('');\n      buf.append(\"\");\n    }\n    \n    buf.append(\"\");\n    \n    return buf.toString();\n  }", "comment": "/** \n   * Generates a javadoc string for this signature.\n   * \n   * @return A javadoc for this method\n   */"}}
{"code": {"body": "  public String toString() {\n    String m    = getModifiers();\n    String r    = baseName(returnValue);\n    String meth = method.getName();\n\n    String p    = getParameters(parameters);\n    String e    = getExceptions(exceptions);\n\n    return m + \"\" + r + \"\" + meth + \"\" + p + \"\" + e;\n  }", "comment": "/** \n   * Gets the signature as a string.\n   *\n   * @return Signature of this method.\n   */"}}
{"code": {"body": "  public boolean paramsEqual(Class[] p) {\n    int n = parameters.length;\n    boolean res = (p.length == n);\n    if (res) {\n      for (int i = 0; i < n; ++i) {\n        if (!p[i].equals(parameters[i])) {\n          res = false;\n          break;\n       }\n      }\n    }\n    return res;\n  }", "comment": "/**\n   * Describe <code>paramsEqual</code> method here.\n   *\n   * @param p a <code>Class[]</code> value\n   * @return a <code>boolean</code> value\n   */"}}
{"code": {"body": "  public boolean equals(Object compare) {\n    if (compare instanceof Signature) {\n      Signature sig = (Signature) compare;\n      return method.getName().equals(sig.getMethod().getName())\n        && paramsEqual(sig.getMethod().getParameterTypes());\n    }\n    return false;\n  }", "comment": "/**\n   * Tests whether a given object equals this signature.\n   * The object is considered equal if it is a signature\n   * and it has the same method name and parameter list.\n   *\n   * @param compare Test object\n   * @return <code>true</code> if the test object equals this signature.\n   */"}}
{"code": {"body": "  public Method getMethod() {\n    return method;\n  }", "comment": "/**\n   * Gets the method of which this is a signature.\n   *\n   * @return Method of which this is a signature.\n   */"}}
{"code": {"body": "  public final String baseName(Class type) {\n    String name = null;\n    if (type.isArray()) {\n      try {\n        \n        Class cl       = type;\n        int dimensions = 0;\n        \n        while (cl.isArray()) {\n          cl = cl.getComponentType();\n          dimensions++;\n        }\n        \n        StringBuffer sb = new StringBuffer();\n        sb.append(cl.getName());\n        \n        for (int i = 0; i < dimensions; i++) {\n          sb.append(\"\");\n        }\n        \n        name = sb.toString();\n      } catch (Throwable e) {\n        name = type.getName();\n      }\n    } else {\n         name = type.getName();    \n    }\n    \n\n    \n    \n    \n    \n    \n    \n    \n    if (truncate) {\n      int idx = name.lastIndexOf('');\n      \n      if (idx > -1) {\n        name = name.substring(idx + 1);\n      }\n    }  \n\n    \n    \n    \n    \n    \n    \n    \n    \n    name =  name.replace('', '');\n\n    return name;\n  }", "comment": "/** \n   *  Computes the basename of the specified class.  This returns\n   *  \"Object\" from \"java.lang.Object.\"  It returns the \"single\"\n   *  form of an Array object.\n   *\n   *  In the case of inner classes, the base name includes\n   *  the outer class name, e.g.,\n   *\n   *    mypackage.OuterClass$InnerClass\n   *\n   *  is returned as\n   *\n   *    OuterClass.InnerClass\n   *\n   * @param type Class whose basename is required\n   * \n   * @return basename\n   */"}}
{"code": {"body": "  public final String getExceptionList(Class[] except) {\n    \n    if ((null == except) || (except.length == 0)) {\n      return \"\";\n    }\n\n    StringBuffer buf = new StringBuffer();\n    \n    for (int i = 0; i < except.length; i++) {\n      String type = baseName(except[i]);\n\n      buf.append(type);\n      if (i < except.length - 1) {\n        buf.append(\"\");\n      }\n      \n    }\n    \n    return buf.toString();\n  }", "comment": "/**\n   * Make a list of all given exceptions separated by commas.\n   *\n   * @param except Array of exception types\n   * @return Comma-separated list of exceptions\n   */"}}
{"code": {"body": "  private final String getExceptions(Class[] except) {\n    String res = getExceptionList (except);\n    \n    if (res.length() == 0) {\n      return res;\n    }\n    \n    return \"\" + res;\n  }", "comment": "/** \n   * Gets a throw clause listing the exceptions thrown by this method.\n   * \n   * @param except Vector of exceptions\n   *\n   * @return Exceptions thrown by this method.\n   */"}}
{"code": {"body": "  public final String getParameters (Class[] params, boolean withName) {\n    \n    if ((null == params) || (params.length == 0)) {\n      return \"\";\n    }\n    \n    StringBuffer buf = new StringBuffer();\n    NameFactory factory = registry.getNameFactory();\n\n    for (int i = 0; i < params.length; i++) {\n      String type = baseName(params[i]);\n      String name = factory.getParameterName(this, i);\n\n      buf.append(type);\n      if (withName) {\n        buf.append('');\n        buf.append(name);\n      }\n\n      if (i < params.length - 1) {\n        buf.append(\"\");\n      }\n      \n    }\n\n    return buf.toString();\n  }", "comment": "/** \n   * Gets a parameter list for this method; parameters are named\n   * by the NameFactory whose default implementation uses param1\n   * .. paramn \n   *\n   * @param params Parameters of this method\n   * @param withName toggles parameter names\n   *\n   * @return Parameter list in string form\n   */"}}
{"code": {"body": "  public final String getParameterNames (Class[] params) {\n    \n    if ((null == params) || (params.length == 0)) {\n      return \"\";\n    }\n    \n    StringBuffer buf = new StringBuffer();\n    NameFactory factory = registry.getNameFactory();\n\n    for (int i = 0; i < params.length; i++) {\n      String type = baseName(params[i]);\n      String name = factory.getParameterName(this, i);\n\n      buf.append(name);\n\n      if (i < params.length - 1) {\n        buf.append(\"\");\n      }\n      \n    }\n\n    return buf.toString();\n  }", "comment": "/** \n   * Gets a list of parameter names for this method; parameters are\n   * named by the NameFactory whose default implementation uses param1\n   * .. paramn.  Class type names are not included in the result\n   * Contributed by Charles Hart <cfhart@Z-TEL.com>\n   *\n   * @param params Parameters of this method\n   *\n   * @return Parameter list in string form */"}}
{"code": {"body": "  public final String getModifiers () {\n    StringBuffer buf = new StringBuffer(\"\");\n    int mod = method.getModifiers();\n\n    if (Modifier.isSynchronized(mod)) {\n      buf.append(\"\");\n    }\n    \n    return buf.toString();\n  }", "comment": "/**\n   * Gets list of modifiers for this method.\n   * Interface methods are always public and may be synchronized \n   *\n   * @return a <code>String</code> containing a list of modifiers\n   */"}}
{"code": {"body": "  public String getReturnBaseType () {\n    return baseName(returnValue);\n  }", "comment": "/** \n   * Gets the base type of the return value.\n   *\n   * @return Base type of return value.\n   */"}}
{"code": {"body": "  private final void register() {\n    if (null != registry) {\n      registry.registerImport(declaring);\n      registry.registerImport(returnValue);\n    \n      for (int i = 0; i < parameters.length; i++) {\n        registry.registerImport(parameters[i]);\n      }\n\n      for (int i = 0; i < exceptions.length; i++) {\n        registry.registerImport(exceptions[i]);\n      }\n    }\n  }", "comment": "/** \n   * Register this Signature's types with the SignatureRegistry\n   */"}}
{"code": {"body": "  public final void add(Signature sig) {\n    \n    \n    if (!alreadyStored(sig)) {\n      \n      String declaring = sig.getDeclaringClass().getName();\n      \n      if (classes.containsKey(declaring)) {\n          ((Vector) classes.get(declaring)).addElement(sig);\n      } else {    \n        Vector v = new Vector();\n        v.addElement(sig);\n        classes.put(declaring, v);\n      }\n    \n    }\n  }", "comment": "/** \n   * Adds a signature to the container. Signatures are not\n   * added if they're already registered because we do not want\n   * duplicate method implementations even though a class might\n   * implement interfaces that inherit from some common\n   * super-interface.\n   *\n   * @param sig Signature to be stored in the signature table.\n   */"}}
{"code": {"body": "  private final boolean alreadyStored(Signature sig) {\n    Enumeration declaringClasses = classes.keys();\n    boolean found = false;\n    \n    while (declaringClasses.hasMoreElements() && !found) {\n      String interf = (String) declaringClasses.nextElement();\n      Vector v = (Vector) classes.get(interf);\n      found = v.contains(sig);\n    }\n\n    return found;\n  }", "comment": "/**\n   * Check whether container already contains signature.\n   *\n   * @param sig a <code>Signature</code> value\n   * @return a <code>boolean</code> value\n   */"}}
{"code": {"body": "  public void clear() {\n    classes.clear();\n  }", "comment": "/** \n   * Clear the signature container.\n   */"}}
{"code": {"body": "  public boolean isEmpty() {\n    return classes.isEmpty();\n  }", "comment": "/**\n   * True if this container is empty of signatures.\n   *\n   * @return a <code>boolean</code> value\n   */"}}
{"code": {"body": "  public void visit(SignatureVisitor visitor) {\n    \n    Enumeration declaringClasses = classes.keys();\n    while (declaringClasses.hasMoreElements()) {\n      \n      String className = (String) declaringClasses.nextElement();\n      Vector v = (Vector) classes.get(className);\n      boolean firstOfClass = true;\n      Enumeration e = v.elements();\n      \n      while (e.hasMoreElements()) {\n        Signature sig = (Signature) e.nextElement();\n        visitor.visit(sig, firstOfClass);\n        firstOfClass = false;\n      }\n    }\n  }", "comment": "/**\n   * Visit each signature in the container.\n   *\n   * @param visitor the SignatureVisitor object visiting the signatures\n   */"}}
{"code": {"body": "public CallbackImpl() {\n    }", "comment": "/**\n     * Creates a new <code>CallbackImpl</code> instance.\n     */"}}
{"code": {"body": "public LinkList(){\n        head=new Node();\n    }", "comment": "/**\n     * \u6e05\u7a7a\u94fe\u8868\n     */"}}
{"code": {"body": "    public void clear() {\n        head.data=null;\n        head.next=null;\n    }", "comment": "/**\n     * \u6e05\u7a7a\u94fe\u8868\n     */"}}
{"code": {"body": "    public boolean isEmpty() {\n        return head.next==null;\n    }", "comment": "/**\n     * \u5224\u65ad\u7ebf\u6027\u8868\u662f\u5426\u4e3a\u7a7a\n     * @return\n     */"}}
{"code": {"body": "    public int length() {\n        int length=0;\n        Node p=head.next;\n        while(p!=null){\n            length++;\n            p=p.next;\n        }\n        return length;\n    }", "comment": "/**\n     * \u5f97\u5230\u7ebf\u6027\u8868\u7684\u957f\u5ea6\n     * @return\n     */"}}
{"code": {"body": "    public Object get(int i) throws Exception {\n\n        int j=0;\n        Node p=head.next;\n        while(p!=null&&j<i){\n            j++;\n            p=p.next;\n        }\n        if(i<0||p==null){\n            throw new Exception(\"\"+i+\"\");\n        }\n        return p.data;\n    }", "comment": "/**\n     * \u83b7\u53d6\u94fe\u8868\u7b2ci\u4e2a\u503c\n     * @param i\n     * @return\n     * @throws Exception\n     */"}}
{"code": {"body": "    public void insert(int i, Object x) throws Exception {\n        Node p=this.head;\n        int j=-1;\n        while(p.next!=null&&j<i-1){\n            p=p.next;\n            j++;\n        }\n\n        \n        if(j>i-1||p==null){\n            throw new Exception(\"\");\n        }\n        Node s=new Node(x);\n        s.next=p.next;\n        p.next=s;\n\n    }", "comment": "/**\n     * \u5e26\u5934\u8282\u70b9\u7684\u63d2\u5165\u7b97\u6cd5\n     * i\u7684\u53d6\u503c\u4e3a0\u5230n\n     */"}}
{"code": {"body": "    public void remove(int i) throws Exception {\n        int j=0;\n        Node p=head;\n        \n        while(p!=null&&j<i){\n            p=p.next;\n            j++;\n        }\n        if(j>i||p==null){\n            throw new Exception(\"\");\n        }\n        \n        p.next=p.next.next;\n        \n    }", "comment": "/**\n     * \u5e26\u5934\u8282\u70b9\u7684\u5220\u9664\u64cd\u4f5c\n     */"}}
{"code": {"body": "    public int indexOf(Object x)  {\n        Node p=head.next;\n        int j=0;\n        while(p!=null&&!p.data.equals(x)){\n            p=p.next;\n            j++;\n        }\n        if(p==null){\n            return -1;\n        }\n        return j;\n    }", "comment": "/**\n     * \u67e5\u8be2\u8282\u70b9 x\u5728\u94fe\u8868\u4e2d\u7684\u4f4d\u7f6e\n     * @param x\n     * @return\n     */"}}
{"code": {"body": "    public void display() {\n        Node p=head.next;\n        while(p!=null){\n            System.out.print(p.data+\"\");\n            p=p.next;\n        }\n        System.out.println();\n    }", "comment": "/**\n     * \u8f93\u51fa\u5404\u4e2a\u5143\u7d20\u7684\u503c\n     */"}}
{"code": {"body": "    public void insertf(int i,Object x) throws Exception{\n        Node p=head;\n        int j=-1;\n        while(p!=null&&j<i-1){\n            p=p.next;\n            j++;\n        }\n        if(j>=i||p==null){\n            throw new Exception(\"\");\n        }\n        Node s=new Node(x);\n        if(i==0){\n            s.next=head;\n            head=s;\n        }else{\n            s.next=p.next;\n            p.next=s;\n        }\n    }", "comment": "/**\n     * \u4e0d\u5e26\u5934\u8282\u70b9\u7684\u63d2\u5165\u7b97\u6cd5\n     * @param i\n     * @param x\n     */"}}
{"code": {"body": "    public void delete(int i,Object x) throws Exception{\n        Node q,p=head;\n\t\t\n        int j=0;\n        while(p!=null&&j<i-1){\n            p=p.next;\n            j++;\n        }\n        if(j>i||p==null){\n            throw new Exception(\"\");\n        }\n        if(i==0){\n            head=p.next;\n            p=null;\n        }else{\n            q=p.next;\n            p.next=p.next;\n            q=null;\n        }\n\n    }", "comment": "/**\n     * \u4e0d\u5e26\u5934\u8282\u70b9\u7684\u5220\u9664\u64cd\u4f5c\n     */"}}
{"code": {"body": "    public void insert1(int x){\n        Node p=head;\n        Node q=head.next;\n        while(q!=null){\n            int temp=((Integer)q.data).intValue();\n            if(temp<x){\n                p=q;\n                q=q.next;\n            }else{\n                break;\n            }\n        }\n        Node s=new Node(x);\n        p.next=s;\n        s.next=q;\n    }", "comment": "/**\n     * \u5728\u6709\u5e8f\u7684\u7ebf\u6027\u8868\u4e2d\u63d2\u5165\u4e00\u4e2a\u8282\u70b9\u503c\u4e3ax\n     * @param x\n     */"}}
{"code": {"body": "    public void insert2(int x){\n        Node p=head;\n        while(p.next!=null&&(Integer)p.next.data<x){\n            p=p.next;\n        }\n        Node s=new Node(x);\n        s.next=p.next;\n        p.next=s;\n    }", "comment": "/**\n     * \u65b9\u6cd52\n     * @param x\n     */"}}
{"code": {"body": "    public static void rervse(LinkList L){\n        Node q=L.head.next;\n        Node p;\n        L.head.next=null;\n        while(q!=null){\n            p=q.next;\n            q=L.head.next;\n            L.head.next=q;\n            q=p;\n        }\n    }", "comment": "/**\n     * \u5c06\u4e00\u4e2a\u5e26\u5934\u8282\u70b9\u7684\n     * \u94fe\u8868\u7684\u5143\u7d20\u53cd\u8f6c\n     * @param L\n     */"}}
{"code": {"body": "    private LinkStack numSplit(String str) throws Exception {\n        LinkStack stack = new LinkStack();\n\n        if (StringUtils.isBlank(str)){\n            throw new Exception(\"\"+str+\"\");\n        }\n\n        StringBuffer sb = new StringBuffer(str);\n\n        int length = sb.length();\n\n        char c = 0;\n\n        for (int i = 0;i < length;i++){\n           c = sb.charAt(i);\n           \n           if('' == c){\n               continue;\n           }\n           \n           if(Character.isDigit(c)){\n               stack.push(Integer.valueOf(String.valueOf(c)));\n           }else {\n               throw new Exception(\"\");\n           }\n        }\n\n        return stack;\n    }", "comment": "/**\n     * \u5c06\u5927\u6574\u6570\u5b57\u7b26\u4e32\u8fdb\u6808(\u5e76\u9a8c\u8bc1\u6570\u5b57\u5b57\u7b26\u4e32\u7684\u6b63\u786e\u6027)\n     * @param str\n     */"}}
{"code": {"body": "    public String add(String x1,String x2) throws Exception{\n        \n        int a = 0;\n        int b = 0;\n        int sum = 0;\n        int partialSum = 0;\n        String result = \"\";\n\n        \n        LinkStack sA = numSplit(x1);\n        LinkStack sB = numSplit(x2);\n        LinkStack sumC = new LinkStack();\n        LinkStack temp = null;\n\n        \n\n        \n        while (!sA.isEmpty() && !sB.isEmpty()){\n            a = (Integer) sA.pop();\n            b = (Integer) sB.pop();\n            \n            sum = a+b+partialSum;\n            \n            sumC.push(sum%10);\n            partialSum = sum/10;\n        }\n\n        \n        temp = sA.isEmpty() ? sB : sA;\n\n        \n        while (!temp.isEmpty() && partialSum != 0){\n            a = (Integer) temp.pop();\n            sum = a + partialSum;\n            sumC.push(sum%10);\n            partialSum = sum/10;\n        }\n\n        \n        while (!temp.isEmpty()){\n           sumC.push(temp.pop());\n        }\n\n        \n        if(partialSum != 0){\n            sumC.push(partialSum);\n        }\n\n        \n        while (!sumC.isEmpty()){\n            result =  result.concat(String.valueOf(sumC.pop()));\n        }\n        return result;\n    }", "comment": "/**\n     * \u5927\u6574\u6570\u76f8\u52a0\n     * @param x1\n     * @param x2\n     * @return\n     * @throws Exception\n     */"}}
{"code": {"body": "    private int judgeStringNum(LinkStack sA,LinkStack sB) throws Exception {\n        int result = -1;\n\n        if(sA.isEmpty() || sB.isEmpty()){\n            throw new Exception(\"\");\n        }\n        \n        String num1 = sA.toString();\n        String num2 = sB.toString();\n        int lengthSA = sA.length();\n        int lengthSB = sB.length();\n        result = lengthSA - lengthSB;\n        if (result == 0){\n            result = num1.compareTo(num2);\n        }\n        return result;\n    }", "comment": "/**\n     * \u4e24\u4e2a\u5927\u6574\u6570\u7684\u5927\u5c0f\n     * @param sA\n     * @param sB\n     * @return\n     */"}}
{"code": {"body": "    public String minus(String x1,String x2) throws Exception{\n        \n        int a = 0;\n        int b = 0;\n        int sum = 0;\n        int partialSum = 0;\n        String result = \"\";\n        String symbol = \"\";\n\n        \n        LinkStack sA = numSplit(x1);\n        LinkStack sB = numSplit(x2);\n        LinkStack sumC = new LinkStack();\n        LinkStack temp = null;\n\n        \n        int compare = judgeStringNum(sA, sB);\n        if(compare < 0){\n            \n            symbol = symbol.concat(\"\");\n            \n            temp = sA;\n            sA = sB;\n            sB = temp;\n        }\n        \n        if(compare != 0){\n            \n            while (!sB.isEmpty()){\n                a = (Integer) sA.pop();\n                b = (Integer) sB.pop();\n                \n                sum = a-b+partialSum;\n                \n                if(sum < 0){\n                    \n                    sum += 10;\n                    partialSum = -1;\n                }else {\n                    partialSum = 0;\n                }\n                sumC.push(sum);\n            }\n\n            \n            temp = sA;\n\n            \n            while (!temp.isEmpty() && partialSum != 0){\n                a = (Integer) temp.pop();\n                sum = a + partialSum;\n                \n                if(sum < 0){\n                    sum += 10;\n                    partialSum = -1;\n                }else {\n                    partialSum = 0;\n                }\n                sumC.push(sum);\n            }\n\n            \n            while (!temp.isEmpty()){\n                sumC.push(temp.pop());\n            }\n\n            \n            while (!sumC.isEmpty()){\n                result =  result.concat(String.valueOf(sumC.pop()));\n            }\n\n            \n            int length = result.length();\n            char c = '';\n            \n            int index = 0;\n            for(int i = 0; i< length;i++){\n                c = result.charAt(i);\n                if (c == ''){\n                    index ++;\n                }else {\n                    break;\n                }\n            }\n\n            if(index > 0){\n                result = result.substring(index);\n            }\n\n            \n            result = symbol + result;\n        }else {\n            result = \"\";\n        }\n\n\n        return result;\n    }", "comment": "/**\n     * \u5927\u6574\u6570\u76f8\u51cf\n     * @param x1\n     * @param x2\n     * @return\n     * @throws Exception\n     */"}}
{"code": {"body": "    private int verifyFlag(String str){\n\n        int result = OTHER;\n\n        if(\"\".equals(str) || \"\".equals(str) ||\n        \"\".equals(str) || \"\".equals(str)){\n            result = LEFT;\n        }else if(\"\".equals(str) || \"\".equals(str) ||\n                \"\".equals(str) || \"\".equals(str)){\n            result = RIGHT;\n        }\n\n        return result;\n    }", "comment": "/**\n     * \u5224\u65ad\u5206\u5272\u7b26\u7c7b\u578b\n     * @param str\n     * @return\n     */"}}
{"code": {"body": "    private boolean matches(String str1,String str2){\n        boolean flag = false;\n\n        if(\"\".equals(str1) && \"\".equals(str2) || \"\".equals(str1) && \"\".equals(str2) ||\n                \"\".equals(str1) && \"\".equals(str2) || \"\".equals(str1) && \"\".equals(str2)){\n            flag = true;\n        }\n\n        return flag;\n    }", "comment": "/**\n     * \u5224\u65ad\u62ec\u53f7\u662f\u5426\u5339\u914d\n     * @param str1\n     * @param str2\n     * @return\n     */"}}
{"code": {"body": "    public boolean isLeagal(String str) throws Exception {\n        boolean flag = false;\n        \n        if (StringUtils.isNotBlank(str)){\n            SqStack S = new SqStack(100);\n            StringBuffer sb = new StringBuffer(str);\n            int length = sb.length();\n            char c = 0;\n            String t = null;\n            int verify = 0;\n            Object obj = null;\n            for(int i = 0; i< length;i++){\n                c = sb.charAt(i);\n                t = String.valueOf(c);\n                if(i != length){\n                    if('' == c && '' == sb.charAt(i+1) ||\n                            '' == c && '' == sb.charAt(i+1)){\n                        t = t.concat(String.valueOf(sb.charAt(i+1)));\n                        ++i;\n                    }\n                }\n                \n                verify = verifyFlag(t);\n                \n                if(LEFT == verify){\n                    \n                    S.push(t);\n                }else if(RIGHT == verify){\n                    \n                    obj = S.pop();\n                    \n                    if(obj == null || !matches(obj.toString(),t)){\n                        flag = true;\n                        break;\n                    }\n                }\n            }\n\n            \n            if(!S.isEmpty()){\n                flag = true;\n            }\n        }else {\n            flag = true;\n        }\n\n        return !flag;\n    }", "comment": "/**\n     * \u5224\u65ad\u8868\u8fbe\u5f0f\u662f\u5426\u5408\u6cd5\n     * @param str\n     * @return\n     * @throws Exception\n     */"}}
{"code": {"body": "public BiTree() {\n        this.root = null;\n    }", "comment": "/**\n     * \u4e2d\u5e8f\u904d\u5386\u6811\u7ed3\u6784\n     * @param p\n     */"}}
{"code": {"body": "    public void inOrderTraverse(BiTreeNode p){\n        if(p != null){\n            inOrderTraverse(p.getLchild());\n            System.out.println(p);\n            inOrderTraverse(p.getRchild());\n        }\n    }", "comment": "/**\n     * \u4e2d\u5e8f\u904d\u5386\u6811\u7ed3\u6784\n     * @param p\n     */"}}
{"code": {"body": "    private Object searchBST(BiTreeNode p,Comparable key){\n        Object result = null;\n        \n        if(p != null){\n            \n            int count = key.compareTo(((RecordNode) p.getData()).getKey());\n            \n            if(count == 0){\n                result = p.getData();\n            }else if(count < 0){\n                result = searchBST(p.getLchild(),key);\n            }else {\n                result = searchBST(p.getRchild(),key);\n            }\n        }\n        return result;\n    }", "comment": "/**\n     * \u4e8c\u53c9\u6811\u67e5\u8be2\u65b9\u6cd5\n     * @param p\n     * @param key\n     * @return\n     */"}}
{"code": {"body": "    private Object removeBST(BiTreeNode p,Comparable key,BiTreeNode parent){\n        Object data = null;\n        \n        if(p != null){\n            \n            int count = key.compareTo(((RecordNode) p.getData()).getKey());\n            \n            if(count < 0){\n                data = removeBST(p.getLchild(),key,p);\n            }\n            \n            else if(count > 0){\n                data = removeBST(p.getRchild(),key,p);\n            }\n            \n            else {\n                \n                \n                if(null != p.getLchild() && null != p.getRchild()){\n                    \n                    BiTreeNode innext = p.getRchild();\n                    while (null != innext.getLchild()){\n                        innext = innext.getLchild();\n                    }\n                    p.setData(innext.getData());\n\n                    \n                    data = removeBST(p.getRchild(),((RecordNode)innext.getData()).getKey(),p);\n                }else {\n                    data = p.getData();\n                    if( null == parent){\n                        if(null != p.getLchild()){\n                            root = p.getLchild();\n                        }else {\n                            root = p.getRchild();\n                        }\n                    }else {\n                        if(p == parent.getLchild()){\n                            if(null != p.getLchild()){\n                                parent.setLchild(p.getLchild());\n                            }else {\n                                parent.setLchild(p.getRchild());\n                            }\n                        }else if(null != p.getLchild()){\n                            parent.setRchild(p.getLchild());\n                        }else {\n                            parent.setRchild(p.getRchild());\n                        }\n                    }\n                }\n            }\n        }\n\n        return data;\n\n    }", "comment": "/**\n     *\n     * @param p \u4e8c\u53c9\u6392\u5e8f\u6811\u6839\n     * @param key \u4e8c\u53c9\u6392\u5e8f\u6811\u952e\n     * @param parent \u4e8c\u53c9\u6392\u5e8f\u6811 p \u7236\u8282\u70b9\n     * @return\n     */"}}
{"code": {"body": "public HashTable(int size) {\n        this.table = new LinkList[size];\n\n        for(int i = 0; i< size;i++){\n            table[i] = new LinkList();\n        }\n    }", "comment": "/**\n     * \u83b7\u53d6\u5730\u5740\n     * @param key\n     * @return\n     */"}}
{"code": {"body": "    public LinkList[] getTable() {\n        return table;\n    }", "comment": "/**\n     * \u83b7\u53d6\u5730\u5740\n     * @param key\n     * @return\n     */"}}
{"code": {"body": "    public void setTable(LinkList[] table) {\n        this.table = table;\n    }", "comment": "/**\n     * \u83b7\u53d6\u5730\u5740\n     * @param key\n     * @return\n     */"}}
{"code": {"body": "    public int hash(int key){\n        return key % table.length;\n    }", "comment": "/**\n     * \u83b7\u53d6\u5730\u5740\n     * @param key\n     * @return\n     */"}}
{"code": {"body": "    public void insert(E element) throws Exception {\n        \n        int key = element.hashCode();\n        int index = hash(key);\n        this.table[index].insert(0,element);\n    }", "comment": "/**\n     * \u5411hash\u8868\u4e2d\u63d2\u5165\u6570\u636e\n     * @param element\n     */"}}
{"code": {"body": "    public void printHashTable(){\n        for(int i = 0; i< table.length;i++){\n            System.out.print(\"\"+i+\"\");\n            this.table[i].display();\n        }\n    }", "comment": "/**\n     * \u6253\u5370hash\u8868\u4e2d\u7684\u6570\u636e\n     */"}}
{"code": {"body": "    public Node search(E element) throws Exception {\n        int key = element.hashCode();\n        int i = hash(key);\n        int index = table[i].indexOf(element);\n\n        Node node = null;\n\n        if(index >=0){\n            node =(Node) table[i].get(index);\n        }\n\n        return node;\n    }", "comment": "/**\n     * \u5728hash\u8868\u4e2d\u67e5\u627e\u6307\u5b9a\u5bf9\u8c61\uff0c\u82e5\u67e5\u627e\u6210\u529f,\u6210\u529f\u8fd4\u56de\u8282\u70b9;\u5426\u5219\u8fd4\u56denull\n     * @param element\n     * @return\n     */"}}
{"code": {"body": "    public boolean contain(E element){\n        Boolean falg = false;\n        int key = element.hashCode();\n\n        int i = hash(key);\n\n        int index = this.table[i].indexOf(element);\n\n        return index >= 0;\n    }", "comment": "/**\n     * \u5224\u65ad\u8282\u70b9\u662f\u5426\u5b58\u5728\n     * @param element\n     * @return\n     */"}}
{"code": {"body": "    public boolean remove(E element) throws Exception {\n\n        boolean flag = false;\n\n        int key = element.hashCode();\n\n        int i = hash(key);\n\n        int index = this.table[i].indexOf(element);\n\n        if(index >= 0){\n            this.table[i].remove(index);\n            flag = true;\n        }\n\n        return flag;\n    }", "comment": "/**\n     * \u79fb\u9664\u5143\u7d20\n     * @param element\n     */"}}
{"code": {"body": "    public void testGetClass(){\n        System.out.println(Double.class.getName());\n        \n        System.out.println(Float.class.getName());\n        \n        System.out.println(Integer.class.getName());\n        \n        System.out.println(String.class.getName());\n        \n        Object mm = Double.valueOf(\"\");\n        \n        System.out.println(mm.getClass().getName());\n    }", "comment": "/*if (biTree.insertBST(key[i],elem[i])){\n                System.out.println(\"[\"+key[i]+\",\"+elem[i]+\"]\");\n            }*/"}}
{"code": {"body": "    public void initBitree(){\n        biTree = new BiTree();\n        \n        Integer [] k = {50,13,63,8,36,90,5,10,18,70};\n        \n        String[] item = {\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"};\n\n        KeyType [] key = new KeyType[k.length];\n\n        ElementType [] elem = new ElementType[item.length];\n        \n        System.out.println(\"\");\n        \n        for(int i = 0; i< k.length;i++){\n            key[i] = new KeyType(k[i]);\n            \n            elem[i] = new ElementType(item[i]);\n\n            biTree.insertBST(key[i],elem[i]);\n\n            \n        }\n\n        biTree.inOrderTraverse(biTree.root);\n    }", "comment": "/*if (biTree.insertBST(key[i],elem[i])){\n                System.out.println(\"[\"+key[i]+\",\"+elem[i]+\"]\");\n            }*/"}}
{"code": {"body": "    public void ChessBoard(int tr,int tc,int dr,int dc,int size){\n        \n        if(size == 1){\n            return;\n        }\n        \n        int t = tile++;\n        \n        int s = size/2;\n        \n\n        \n        \n        if(tr+s>dr && tc+s> dc){\n            \n            ChessBoard(tr,tc,dr,dc,s);\n        }else {\n            \n            Board[tr+s-1][tc+s-1] = t;\n            \n            ChessBoard(tr,tc,tr+s-1,tc+s-1,s);\n        }\n\n        \n        \n        if(tr+s>dr && tc+s<= dc){\n            \n            ChessBoard(tr,tc+s,dr,dc,s);\n        }else {\n            \n            Board[tr+s-1][tc+s] = t;\n            \n            ChessBoard(tr,tc+s,tr+s-1,tc+s,s);\n        }\n\n        \n        \n        if(tr+s<=dr && tc+s> dc){\n            \n            ChessBoard(tr+s,tc,dr,dc,s);\n        }else {\n            \n            Board[tr+s][tc+s-1] = t;\n            \n            ChessBoard(tr+s,tc,tr+s,tc+s-1,s);\n        }\n\n        \n        \n        if(tr+s<=dr && tc+s<= dc){\n            \n            ChessBoard(tr+s,tc+s,dr,dc,s);\n        }else {\n            \n            Board[tr+s][tc+s] = t;\n            \n            ChessBoard(tr+s,tc+s,tr+s,tc+s,s);\n        }\n\n    }", "comment": "/**\n     * \u8986\u76d6\u68cb\u76d8\u95ee\u9898\n     * @param tr \u68cb\u76d8\u5de6\u4e0a\u89d2\u884c\u53f7\n     * @param tc \u68cb\u76d8\u5de6\u4e0a\u89d2\u5217\u53f7\n     * @param dr \u7279\u6b8a\u5355\u5143\u683c\u884c\u53f7\n     * @param dc \u7279\u6b8a\u5355\u5143\u683c\u5217\u53f7\n     * @param size \u5c3a\u5bf8 2^k\n     */"}}
{"code": {"body": "    public void displayBoard(){\n        for(int i = 0; i< Board.length;i++){\n            for (int j = 0;j<Board[i].length;j++){\n                System.out.print(Board[i][j]+\"\");\n            }\n            \n            System.out.println();\n        }\n    }", "comment": "/**\n     * \u5c55\u793a\u68cb\u76d8\n     */"}}
{"code": {"body": "    public double capir2(PointX[] X,PointY a,PointY b,int n) throws Exception {\n        if(n<2){\n            throw new Exception(\"\");\n        }\n\n        \n        divideAndConquer.MergeSort(X);\n\n        \n        PointY[] Y = new PointY[n];\n        for(int i = 0; i< n;i++){\n            Y[i] = new PointY();\n            Y[i].setX(X[i].getX());\n            Y[i].setY(X[i].getY());\n            Y[i].setP(i);\n        }\n        \n        divideAndConquer.MergeSort(Y);\n\n        PointY [] Z = new PointY[n];\n        double closet = closet(X, Y, Z, a, b, 0, n - 1);\n        return closet;\n    }", "comment": "/**\n     * \u6c42\u89e3\u6700\u63a5\u8fd1\u70b9\u95ee\u9898\n     * @param X\n     * @param n\n     * @return\n     */"}}
{"code": {"body": "   private double closet(PointX[] X,PointY[] Y,PointY[] Z,\n                         PointY a,PointY b,int l,int r) throws Exception {\n\n        double minDistance = Double.MAX_VALUE;\n        \n        switch ((r-l)){\n            \n            case 1:{\n                minDistance = point.distance(X[l],X[r]);\n                a.setX(X[l].getX());\n                a.setY(X[l].getY());\n                a.setP(l);\n                b.setX(X[r].getX());\n                b.setY(X[r].getY());\n                b.setP(r);\n                logger.debug(\"\"+X[l].getID()+\"\"+X[r].getID()+\"\"+minDistance);\n                break;\n            }\n            \n            case 2:{\n                double d1 = point.distance(X[l],X[r]);\n                logger.debug(\"\"+X[l].getID()+\"\"+X[r].getID()+\"\"+d1);\n                double d2 = point.distance(X[l],X[l+1]);\n                logger.debug(\"\"+X[l].getID()+\"\"+X[l+1].getID()+\"\"+d2);\n                double d3 = point.distance(X[l+1],X[r]);\n                logger.debug(\"\"+X[l+1].getID()+\"\"+X[r].getID()+\"\"+d3);\n                minDistance = Math.min(d1,d2);\n                minDistance = Math.min(minDistance,d3);\n                if(minDistance == d1){\n                    a.setX(X[l].getX());\n                    a.setY(X[l].getY());\n                    a.setP(l);\n                    b.setX(X[r].getX());\n                    b.setY(X[r].getY());\n                    b.setP(r);\n                }else if(minDistance == d2){\n                    a.setX(X[l].getX());\n                    a.setY(X[l].getY());\n                    a.setP(l);\n                    b.setX(X[l+1].getX());\n                    b.setY(X[l+1].getY());\n                    b.setP(l+1);\n                }else {\n\n                    a.setX(X[l+1].getX());\n                    a.setY(X[l+1].getY());\n                    a.setP(l+1);\n                    b.setX(X[r].getX());\n                    b.setY(X[r].getY());\n                    b.setP(r);\n                }\n                break;\n            }\n            \n            default:{\n                int m = (l+r)/2;\n                int f = l,g = m+1;\n                PointY ar= new PointY(),br=new PointY();\n                double distanceX = Double.MAX_EXPONENT;\n                double distanceY = Double.MAX_EXPONENT;\n                \n                for(int i = l; i<=r;i++){\n                    if(Y[i].getP() > m){\n                        Z[g++] = Y[i];\n                    }else {\n                        Z[f++] = Y[i];\n                    }\n                }\n                \n                double minDsitance1 = closet(X, Z, Y,a,b, l, m);\n\n                double minDsitance2 = closet(X, Z, Y, ar,br,m+1, r);\n\n                if(minDsitance1<minDsitance2){\n                    minDistance = minDsitance1;\n                }else {\n                    minDistance = minDsitance2;\n                    a.setX(ar.getX());\n                    a.setY(ar.getY());\n                    a.setP(ar.getP());\n                    b.setX(br.getX());\n                    b.setY(br.getY());\n                    b.setP(br.getP());\n                }\n\n                \n                divideAndConquer.Merge(Z,Y,l,m,r);\n\n                \n                int k = l,e = r;\n                for(int i = l; i<=r;i++){\n                    distanceX = X[m].getX() - Y[i].getX();\n                    if(0<=distanceX && distanceX < minDistance){\n                        Z[k++] = Y[i];\n                    }else if(distanceX < 0 && distanceX >-minDistance){\n                        Z[e--] = Y[i];\n                    }\n                }\n\n                \n                for(int i = l; i<k;i++){\n                    for (int j = r;j>e;j--){\n                        distanceY = Math.abs((Z[i].getY()-Z[j].getY()));\n                        if(distanceY < minDistance){\n                            distanceX = point.distance(Z[i],Z[j]);\n                            if(minDistance > distanceX){\n                                minDistance = distanceX;\n                                a.setX(Z[i].getX());\n                                a.setY(Z[i].getY());\n                                a.setP(Z[i].getP());\n                                b.setX(Z[j].getX());\n                                b.setY(Z[j].getY());\n                                b.setP(Z[j].getP());\n                                logger.debug(\"\"+X[Z[i].getP()].getID()+\"\"+X[Z[j].getP()].getID()+\"\"+minDistance);\n                            }\n\n                        }\n                    }\n                }\n            }\n        }\n\n        return minDistance;\n    }", "comment": "/**\n     * \u5177\u4f53\u7684\u6700\u63a5\u8fd1\u70b9\u95ee\u9898\n     * @param X\n     * @param Y\n     * @param Z\n     * @param l\n     * @param r\n     * @return\n     */"}}
{"code": {"body": "    public <T> T cloneObj(T obj){\n\n        T object = null;\n        try {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            ObjectOutputStream oos = new ObjectOutputStream(baos);\n            oos.writeObject(obj);\n            ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n            ObjectInputStream ois = new ObjectInputStream(bais);\n            object = (T) ois.readObject();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n\n        return object;\n    }", "comment": "/**\n     * \u514b\u9686\u5bf9\u8c61\n     * @param obj\n     * @return\n     */"}}
{"code": {"body": "    public int comapareVaLues(T a,T b){\n        int result = 0;\n        \n        Comparator<? super T> cpr = comparator;\n        \n        if (cpr != null) {\n            result = cpr.compare(a,b);\n        }else {\n            Comparable<? super T> t = (Comparable<? super T>) a;\n            result = t.compareTo(b);\n        }\n        return result;\n    }", "comment": "/**\n     * \u6bd4\u8f83\u4e24\u4e2a\u6cdb\u578b\u7c7b\u7684\u5927\u5c0f\n     * @param a\n     * @param b\n     * @return\n     */"}}
{"code": {"body": "    public int binarySearch(T[] a,T x,int n){\n        \n        compare(x,x);\n        \n        int left = 0,right = n-1 ,middle = 0, compare = 0;\n        while (left <= right){\n            middle = (left+right)/2;\n            compare = comapareVaLues(a[middle],x);\n            if(compare == 0){\n                return middle;\n            }else if(compare > 0){\n                right = middle-1;\n            }else {\n                left = middle+1;\n            }\n        }\n        \n        return -1;\n    }", "comment": "/**\n     * \u4e8c\u5206\u641c\u7d22\u6cd5,T\u5fc5\u987b\u91cd\u5199equals\u65b9\u6cd5\n     * @param a(\u4ece\u6570\u7ec4 a 0-n\u4f4d\u7f6e\u67e5\u8be2\u5143\u7d20x)\n     * @param x\n     * @return\n     */"}}
{"code": {"body": "    public void MergeSort(T[] a) throws Exception{\n        \n        compare(a[0],a[0]);\n        log.debug(\"\");\n        T[] b = (T[]) Array.newInstance(a[0].getClass(), a.length);\n        \n        \n        int s = 1;\n        while (s<a.length){\n            \n            MergePass(a,b,s);\n            s+=s;\n            \n            MergePass(b,a,s);\n            s+=s;\n        }\n    }", "comment": "/**\n     * \u5408\u5e76\u6392\u5e8f\n     * @param a\n     */"}}
{"code": {"body": "    private void MergePass(T[] x, T[] y,int s) throws Exception{\n        \n        int i = 0;\n        while (i<=x.length-2*s){\n            Merge(x,y,i,i+s-1,i+2*s-1);\n            i=i+2*s;\n        }\n        if(i+s<x.length){\n            Merge(x,y,i,i+s-1,x.length-1);\n        }else {\n            for(int j = i; j< x.length;j++){\n                y[j] = x[j];\n            }\n        }\n    }", "comment": "/**\n     * \u5408\u5e76\u6392\u5e8f\u597d\u7684\u4e24\u4e2a\u76f8\u90bb\u7684\u6570\u7ec4\u6bb5\n     * @param x\n     * @param y\n     * @param s\n     */"}}
{"code": {"body": "    public void Merge(T[] c,T[] d,int l,int m,int r) throws Exception {\n        int i =l,j=m+1,k=l,compare=0,q=0,w=0;\n        while (i<=m && j<=r){\n            try {\n                compare = comapareVaLues(c[i],c[j]);\n            } catch (Exception e) {\n                \n                System.out.println(\"\"+i);\n                System.out.println(\"\"+j);\n                throw e;\n            }\n            if(compare <= 0){\n               d[k++] = c[i++];\n           }else {\n               d[k++] = c[j++];\n           }\n        }\n\n        if(i>m){\n            q = j;\n            w = r;\n        }else {\n            q = i;\n            w = m;\n        }\n        for(int x = q; x<=w;x++){\n            try {\n                d[k++] = c[x];\n            } catch (Exception e) {\n                \n                System.out.println(\"\"+x);\n                System.out.println(\"\"+k);\n                throw e;\n            }\n        }\n    }", "comment": "/**\n     * \u5c06\u6570\u7ec4c l:m m+1:r\u5408\u5e76\u5230\u6570\u7ec4d\u4e2d\n     * @param c\n     * @param d\n     * @param l\n     * @param m\n     * @param r\n     */"}}
{"code": {"body": "    public void quickSort(T[] a,int p,int r){\n        if(p < r){\n            int q = partition(a, p, r);\n            \n            quickSort(a,p,q-1);\n            \n            quickSort(a,q+1,r);\n        }\n    }", "comment": "/**\n     * \u5feb\u901f\u6392\u5e8f\n     * @param a\n     * @param p\n     * @param r\n     */"}}
{"code": {"body": "    private int partition(T[] a, int p,int r){\n        int i = p,j = r+1;\n        \n        T x = a[p];\n        while (true){\n            while (comapareVaLues(a[++i],x)<0 && i<r);\n            while (comapareVaLues(a[--j],x)>0);\n            if (i >= j) {\n                break;\n            }\n            Swap(a,i,j);\n        }\n        a[p] = a[j];\n        a[j] = x;\n\n        return j;\n    }", "comment": "/**\n     * \u6bcf\u6267\u884c\u4e00\u6b21\u90fd\u786e\u5b9a\u4e00\u4e2a\u5143\u7d20\u7684\u4f4d\u7f6e\n     * @param a\n     * @param p\n     * @param r\n     * @return\n     */"}}
{"code": {"body": "    private int randomizedParition(T[] a,int p,int r){\n        \n        int i = randomXAndY(p, r);\n        \n        \n        Swap(a,p,i);\n        return partition(a,p,r);\n    }", "comment": "/**\n     * \u968f\u673a\u4ea7\u751f\u57fa\u51c6\u4f4d\u7f6e\n     * @param a\n     * @param p\n     * @param r\n     * @return\n     */"}}
{"code": {"body": "    public void radomizedQuickSort(T[] a, int p,int r){\n        if(p<r){\n            int q = randomizedParition(a, p, r);\n            \n            radomizedQuickSort(a,p,q-1);\n            \n            radomizedQuickSort(a,q+1,r);\n        }\n    }", "comment": "/**\n     * \u968f\u673a\u5212\u5206\u5feb\u901f\u6392\u5e8f\n     * @param a\n     * @param p\n     * @param r\n     */"}}
{"code": {"body": "    public void Swap(T[] list,int a,int b){\n        T temp = list[a];\n        list[a] = list[b];\n        list[b] = temp;\n    }", "comment": "/**\n     * \u4ea4\u6362\u6570\u7ec4 a\u4e0eb\u7684\u4f4d\u7f6e\n     * @param list\n     * @param a\n     * @param b\n     */"}}
{"code": {"body": "    public int randomXAndY(int x,int y){\n        Random random = new Random();\n        return random.nextInt(y - x + 1) + x;\n    }", "comment": "/**\n     * \u4ea7\u751f\u3010x-y\u3011\u4e4b\u95f4\u7684\u968f\u673a\u6570\n     * @param x\n     * @param y\n     * @return\n     */"}}
{"code": {"body": "    public T randomizedSelect(T[] a,int p,int r,int k){\n        log.debug(\"\"+p+\"\"+r+\"\"+k);\n        \n        int i = randomizedParition(a,p,r);\n        log.debug(\"\"+(i+1)+\"\");\n        int j = i+1;\n        if(k<j){\n            return randomizedSelect(a,p,i-1,k);\n        }else if (k>j){\n            return randomizedSelect(a,i+1,r,k);\n        }else {\n            return a[i];\n        }\n    }", "comment": "/**\n     * \u4ece\u6570\u7ec4a\u4e2d\u67e5\u8be2\u51fa\u7b2ck\u4e2a\u5927\u5c0f\u5bf9\u8c61\n     * @param a\n     * @param p\n     * @param r\n     * @param k\n     * @return\n     */"}}
{"code": {"body": "    public T randomizedSelects(T[] a,int p,int r,int k){\n        log.debug(\"\"+p+\"\"+r+\"\"+k);\n        if(p == r){\n            return a[p];\n        }\n        int i = randomizedParition(a,p,r);\n        log.debug(\"\"+(i+1)+\"\");\n        int j = i-p+1;\n        if(k<=j){\n            return randomizedSelects(a,p,i,k);\n        }else {\n            return randomizedSelects(a,i+1,r,k-j);\n        }\n    }", "comment": "/**\n     * \u4ece\u6570\u7ec4a\u4e2d\u67e5\u8be2\u51fa\u7b2ck\u4e2a\u5927\u5c0f\u5bf9\u8c61\n     * @param a\n     * @param p\n     * @param r\n     * @param k\n     * @return\n     */"}}
{"code": {"body": "    public T Select(T[] a,int p,int r,int k){\n        int t=0,s=0;\n\n        \n        if(p-r<75){\n            \n            radomizedQuickSort(a,p,r);\n            return a[p+k-1];\n        }\n\n        \n        for(int i = 0; i<= (r-p-4)/5;i++){\n            \n            s = p+5*i;\n            t = s+4;\n            boolean flag = false;\n            for(int j=0; j<3; j++) {\n                for(int n=s; n<t-j; n++) {\n                    if(comapareVaLues(a[n],a[n+1])>0){\n                        Swap(a,n,n-1);\n                        flag = true;\n                    }\n                }\n\n                if(!flag){\n                    break;\n                }\n            }\n            \n            Swap(a,p+i,s+2);\n        }\n        \n        T x= Select(a,p,p+(r-p-4)/5,(r-p+1)/10);\n        int i=Partition(a,p,r,x),j=i-p+1;\n        if(k<=j)return Select(a,p,i,k);\n        else return Select(a,i+1,r,k-j);\n    }", "comment": "/**\n     * \u7ebf\u6027\u65f6\u95f4\u9009\u62e9\n     * @param a\n     * @param p\n     * @param r\n     * @param k\n     */"}}
{"code": {"body": "    public void insertSort(T[] a){\n        int low = 0,high=0,middle=0,index=0,j=0;\n        T x = null ;\n        \n        for(int i=1;i<a.length;i++){\n            \n            x= a[i];\n            low = 0;\n            high = i-1;\n            if(comapareVaLues(a[high],x)>0){\n                \n                index = binarySearchInsertIndex(a,x,high);\n                \n                j = i;\n                while (j>index){\n                    a[j] = a[--j];\n                }\n\n                \n                a[index] = x;\n            }\n        }\n    }", "comment": "/**\n     * \u63d2\u5165\u6392\u5e8f\u4e86\u5229\u7528\u76d1\u89c6\u5668\n     * \u6b64\u7b97\u6cd5\u662f\u4e0d\u7a33\u5b9a\u7684\n     * @param a\n     */"}}
{"code": {"body": "    public int binarySearchInsertIndex(T[] a,T x,int n){\n        \n        compare(x,x);\n        \n        int left = 0,right = n-1 ,middle = 0, compare = 0;\n        while (left <= right){\n            middle = (left+right)/2;\n            compare = comapareVaLues(a[middle],x);\n            if(compare == 0){\n                return middle+1;\n            }else if(compare > 0){\n                right = middle-1;\n            }else {\n                left = middle+1;\n            }\n        }\n        \n        return left;\n    }", "comment": "/**\n     * \u4e8c\u5206\u641c\u7d22\u6cd5,T\u5fc5\u987b\u91cd\u5199equals\u65b9\u6cd5\n     * @param a(\u4ece\u6570\u7ec4 a 0-n\u4f4d\u7f6e\u67e5\u8be2\u5143\u7d20x\u7684\u4f4d\u7f6e,\u82e5\u5b58\u5728\u8fd4\u56de\u4f4d\u7f6e+1,\u82e5\u4e0d\u5b58\u5728\u63d2\u5165\u6700\u7ec8high\u5904)\n     * @param x\n     * @return\n     */"}}
{"code": {"body": "    int Partition(T a[],int p,int r,T val)\n    {\n        int pos = p;\n        for(int q=p; q<=r; q++) {\n            if(comapareVaLues(a[q],val)==0) {\n                pos=q;\n                break;\n            }\n        }\n        Swap(a,p,pos);\n\n        int i = p,j = r+1;\n        \n        T x = a[p];\n        while (true){\n            while (comapareVaLues(a[++i],x)<0 && i<r);\n            while (comapareVaLues(a[--j],x)>0);\n            if (i >= j) {\n                break;\n            }\n            Swap(a,i,j);\n        }\n        a[p] = a[j];\n        a[j] = x;\n\n        return j;\n    }", "comment": "/**\n     * \u9009\u5b9a\u4f4d\u7f6e\u7684\u5feb\u901f\u6392\u5e8f\n     * @param a\n     * @param p\n     * @param r\n     * @param val\n     * @return\n     */"}}
{"code": {"body": "    public void combineArray(T[] a,int begin,int k,int end){\n        int i = begin,sm=k,index = k,len = 0;\n        for(int j = k; j<=end ;){\n            \n            while (i<sm&&comapareVaLues(a[i],a[j])<=0){\n                i++;\n            }\n            \n            if (i>= sm){\n                break;\n            }\n            \n            index = j++;\n            while (j<=end && comapareVaLues(a[i],a[j])>0){\n                j++;\n            }\n\n            \n            len=sm-i;\n            divideUtils.RightRotate(a,i,j-1,len);\n            \n            sm = j;\n            i=i+j-index+1;\n        }\n    }", "comment": "/**\n     * \u5408\u5e76\u4e24\u534a\u6709\u5e8f\u6570\u7ec4\n     * @param a\n     * @param begin\n     * @param k \uff08begin:k-1\uff09\uff08k\uff1aend\uff09 \u4e24\u7ec4\n     * @param end\n     */"}}
{"code": {"body": "    public Map<String,Object> calculateMode(T[] a, int begin, int end){\n        \n        Map<String,Object> result = new HashMap();\n        int count = 1;\n        int maxCount = 0;\n        T obj = null;\n        T mode = null;\n        quickSort(a,begin,end);\n\n        for(int i = begin; i<=end ;){\n            obj = a[i];\n            count = 1;\n            while (++i<=end&&comapareVaLues(obj,a[i]) == 0){\n                count++;\n            }\n            if(count>maxCount){\n                mode = obj;\n                maxCount = count;\n            }\n        }\n\n        result.put(\"\",mode);\n        result.put(\"\",maxCount);\n        return result;\n    }", "comment": "/**\n     * \u8ba1\u7b97\u6570\u7ec4a\u5185\u7684\u4f17\u6570\n     * @param a\n     * @param begin\n     * @param end\n     * @return\n     */"}}
{"code": {"body": "    public int fib(int n){\n        int result = 1;\n        if(n<=1){\n            result = 1;\n        }else {\n            for(int i =n; i>0;i--){\n                result*=i;\n            }\n        }\n\n        return result;\n    }", "comment": "/**\n     * \u6c42\u9636\u4e58\n     * @param n\n     * @return\n     */"}}
{"code": {"body": "    public int getOrder(T[] data,int n){\n        int result = 0;\n        int cnt = 0;\n        T item = null;\n        for(int i = 0; i< n;i++){\n            item = data[i];\n            cnt = 0;\n            for(int j = i+1; j< n;j++){\n                if(comapareVaLues(item,data[j])>0){\n                    cnt++;\n                }\n            }\n            result+=cnt*fib(n-i-1);\n        }\n\n        return result;\n    }", "comment": "/**\n     * \u6c42\u53d6\u5f53\u524d\u6392\u5217\u5728\u5b57\u5178\u6392\u5e8f\u4e2d\u7684\u4f4d\u7f6e\n     * @param data\n     * @param n\n     * @return\n     */"}}
{"code": {"body": "    public void reverse(Object [] arrays,int l,int r){\n        Object temp = null;\n        \n        int m = (r+l)/2,i=l,j=r;\n\n        while (i<=m){\n            temp = arrays[i];\n            arrays[i] = arrays[j];\n            arrays[j] = temp;\n            i++;\n            j--;\n        }\n    }", "comment": "/**\n     * \u53cd\u8f6c\u6570\u7ec4 arrays \u4ece\u4f4d\u7f6el-r\n     * @param arrays\n     * @param l\n     * @param r\n     */"}}
{"code": {"body": "    public void RightRotate(Object[] arrays,int begin,int end,int len){\n        \n        reverse(arrays,begin,begin+len-1);\n        logger.debug(StringUtils.join(ArrayUtils.subarray(arrays,begin,begin+len+1),\"\"));\n        \n        reverse(arrays,begin+len,end);\n        logger.debug(StringUtils.join(ArrayUtils.subarray(arrays,begin+len+1,end+1),\"\"));\n        \n        reverse(arrays,begin,end);\n    }", "comment": "/**\n     * \u5faa\u73af\u5c06\u6570\u7ec4 begin-end\u5faa\uff08\u8ba9begin:begin+len-1 \u4e0ebegin+len\uff1aend \u8fdb\u884c\u6362\u4f4d\uff09\n     * @param arrays\n     * @param begin\n     * @param len\n     */"}}
{"code": {"body": "    public double distance(Point u,Point v){\n        double dx = u.x - v.x;\n        double dy = u.y - v.y;\n        return Math.sqrt(dx*dx+dy*dy);\n    }", "comment": "/**\n     * \u6c42\u4e24\u70b9\u8ddd\u79bb\n     * @param u\n     * @param v\n     * @return\n     */"}}
{"code": {"body": "    public int getID() {\n        return ID;\n    }", "comment": "/**\n     * \u6bd4\u8f83\u51fd\u6570\n     * @param o\n     * @return\n     */"}}
{"code": {"body": "    public void setID(int ID) {\n        this.ID = ID;\n    }", "comment": "/**\n     * \u6bd4\u8f83\u51fd\u6570\n     * @param o\n     * @return\n     */"}}
{"code": {"body": "    public void Perm(T [] list, int k, int m, List<String>result){\n        \n        if(k == m){\n            result.add(StringUtils.join(list,\"\"));\n        }else{\n            \n            for(int i = k; i<=m;i++){\n                Swap(list,k,i);\n                Perm(list,k+1,m,result);\n                Swap(list,k,i);\n            }\n\n        }\n    }", "comment": "/**\n     * \u6392\u5217\u95ee\u9898(\u6ce8:\u6b64\u65b9\u6cd5\u4ea7\u751f\u7684\u662f \u96c6\u5408list\uff08K:M\uff09\u7684\u5168\u6392\u5217)\n     * @param list\n     * @param k\n     * @param m\n     */"}}
{"code": {"body": "    public void PermReption(T [] list, int k, int m, List<String>result) throws Exception {\n        \n        HashTable<T> tables = new HashTable<>(m-k+1);\n        if(k == m){\n            result.add(StringUtils.join(list,\"\"));\n        }else{\n            \n            for(int i = k; i<=m;i++){\n                \n                if (!tables.contain(list[i])){\n                    tables.insert(list[i]);\n                    Swap(list,k,i);\n                    PermReption(list,k+1,m,result);\n                    Swap(list,k,i);\n                }\n\n            }\n\n        }\n    }", "comment": "/**\n     * 2\u3001\u6392\u5217\u95ee\u9898(\u6ce8:\u6b64\u65b9\u6cd5\u4ea7\u751f\u7684\u662f \u96c6\u5408list\uff08K:M\uff09\u7684\u5168\u6392\u5217\u542b\u6709\u91cd\u590d\u503c)\n     * @param list\n     * @param k\n     * @param m\n     */"}}
{"code": {"body": "    public void Swap(T [] list,int a,int b){\n        T temp = list[a];\n        list[a] = list[b];\n        list[b] = temp;\n    }", "comment": "/**\n     * \u4ea4\u6362\u6570\u7ec4 a\u4e0eb\u7684\u4f4d\u7f6e\n     * @param list\n     * @param a\n     * @param b\n     */"}}
{"code": {"body": "public HttpClientUtil() {\n        \n        httpClient = HttpClients.createDefault();\n    }", "comment": "/* *\n     * get\u8bf7\u6c42\n     * @author slx\n     * @date 2019/03/13 16:51\n     * @param [url, map]\n     * @return HttpResult\n     */"}}
{"code": {"body": "    public HttpResult doGet(String url, Map<String, Object> map) throws Exception {\n\n        \n        URIBuilder uriBuilder = new URIBuilder(url);\n\n        \n        if (map != null) {\n            \n            for (Map.Entry<String, Object> entry : map.entrySet()) {\n                \n                uriBuilder.setParameter(entry.getKey(), entry.getValue().toString());\n            }\n        }\n\n        \n        HttpGet httpGet = new HttpGet(uriBuilder.build());\n\n        \n        CloseableHttpResponse response = null;\n        try {\n            response = httpClient.execute(httpGet);\n        } catch (IOException e) {\n            HttpResult httpResult = new HttpResult();\n            httpResult.setCode(404);\n            httpResult.setBody(\"\");\n            return httpResult;\n        }\n\n        \n        \n        \n        \n        \n        HttpResult httpResult = new HttpResult();\n        \n        if (response.getEntity() != null) {\n            \n            httpResult.setCode(response.getStatusLine().getStatusCode());\n            httpResult.setBody(EntityUtils.toString(response.getEntity(),\"\"));\n\n        } else {\n            \n            httpResult.setCode(response.getStatusLine().getStatusCode());\n            \n        }\n\n        \n        return httpResult;\n    }", "comment": "/* *\n     * get\u8bf7\u6c42\n     * @author slx\n     * @date 2019/03/13 16:51\n     * @param [url, map]\n     * @return HttpResult\n     */"}}
{"code": {"body": "    public HttpResult doPost(String url, Map<String, Object> map) throws Exception {\n        \n        HttpPost httpPost = new HttpPost(url);\n\n        \n        if (map != null) {\n            \n            List<NameValuePair> params = new ArrayList<NameValuePair>();\n\n            \n            for (Map.Entry<String, Object> entry : map.entrySet()) {\n                params.add(new BasicNameValuePair(entry.getKey(), entry.getValue().toString()));\n            }\n\n            \n            UrlEncodedFormEntity formEntity = new UrlEncodedFormEntity(params, \"\");\n\n            \n            httpPost.setEntity(formEntity);\n        }\n\n        \n        CloseableHttpResponse response = null;\n        try {\n            response = httpClient.execute(httpPost);\n        } catch (IOException e) {\n            HttpResult httpResult = new HttpResult();\n            httpResult.setCode(404);\n            httpResult.setBody(\"\");\n            return httpResult;\n        }\n\n        \n        HttpResult httpResult = new HttpResult();\n        \n        if (response.getEntity() != null) {\n            \n            httpResult.setCode(response.getStatusLine().getStatusCode());\n            httpResult.setBody(EntityUtils.toString(response.getEntity(),\"\"));\n\n        } else {\n            \n            httpResult.setCode(response.getStatusLine().getStatusCode());\n            \n        }\n\n        \n        return httpResult;\n    }", "comment": "/* *\n     * post\u8bf7\u6c42\n     * @author slx\n     * @date 2019/03/13 18:13\n     * @param [url, map]\n     * @return com.example.HttpClient.HttpResult\n     */"}}
{"code": {"body": "    public HttpResult doPut(String url, Map<String, Object> map) throws Exception {\n        \n        HttpPut httpPut = new HttpPut(url);\n\n        \n        if (map != null) {\n            \n            List<NameValuePair> params = new ArrayList<NameValuePair>();\n\n            \n            for (Map.Entry<String, Object> entry : map.entrySet()) {\n                params.add(new BasicNameValuePair(entry.getKey(), entry.getValue().toString()));\n            }\n\n            \n            UrlEncodedFormEntity formEntity = new UrlEncodedFormEntity(params, \"\");\n\n            \n            httpPut.setEntity(formEntity);\n        }\n\n        \n        CloseableHttpResponse response = null;\n        try {\n            response = httpClient.execute(httpPut);\n        } catch (IOException e) {\n            HttpResult httpResult = new HttpResult();\n            httpResult.setCode(404);\n            httpResult.setBody(\"\");\n            return httpResult;\n        }\n\n        \n        HttpResult httpResult = new HttpResult();\n        \n        if (response.getEntity() != null) {\n            \n            httpResult.setCode(response.getStatusLine().getStatusCode());\n            httpResult.setBody(EntityUtils.toString(response.getEntity(),\"\"));\n\n        } else {\n            \n            httpResult.setCode(response.getStatusLine().getStatusCode());\n            \n        }\n\n        \n        return httpResult;\n    }", "comment": "/* *\n     * Put\u8bf7\u6c42\n     * @author slx\n     * @date 2019/03/13 13:14\n     * @param [url, map]\n     * @return com.example.HttpClient.HttpResult\n     */"}}
{"code": {"body": "    public HttpResult doDelete(String url, Map<String, Object> map) throws Exception {\n\n        \n        URIBuilder uriBuilder = new URIBuilder(url);\n\n        \n        if (map != null) {\n            \n            for (Map.Entry<String, Object> entry : map.entrySet()) {\n                \n                uriBuilder.setParameter(entry.getKey(), entry.getValue().toString());\n            }\n        }\n\n        \n        HttpDelete httpDelete = new HttpDelete(uriBuilder.build());\n\n        \n        CloseableHttpResponse response = null;\n        try {\n            response = httpClient.execute(httpDelete);\n        } catch (IOException e) {\n            HttpResult httpResult = new HttpResult();\n            httpResult.setCode(404);\n            httpResult.setBody(\"\");\n            return httpResult;\n\n        }\n\n        \n        \n        \n        \n        \n        HttpResult httpResult = new HttpResult();\n        \n        if (response.getEntity() != null) {\n            \n            httpResult.setCode(response.getStatusLine().getStatusCode());\n            httpResult.setBody(EntityUtils.toString(response.getEntity(),\"\"));\n\n        } else {\n            \n            httpResult.setCode(response.getStatusLine().getStatusCode());\n            \n        }\n        \n        return httpResult;\n    }", "comment": "/* *\n     *  Delete\u8bf7\u6c42\n     * @author slx\n     * @date 2019/03/13 18:20\n     * @param [url, map]\n     * @return com.example.HttpClient.HttpResult\n     */"}}
{"code": {"body": "    public HttpResult uploadFile(String url, File file, Map<String, Object> map) throws IOException {\n        CloseableHttpResponse response = null;\n        RequestConfig requestConfig = RequestConfig.custom().setConnectTimeout(200000).setSocketTimeout(200000000).build();\n        HttpPost httpPost = new HttpPost(url);\n        httpPost.setConfig(requestConfig);\n        MultipartEntityBuilder multipartEntityBuilder = MultipartEntityBuilder.create();\n        \n\n        \n        \n\n        \n        \n        \n        multipartEntityBuilder.addBinaryBody(\"\",file);\n        \n        if (map != null) {\n            \n            for (Map.Entry<String, Object> entry : map.entrySet()) {\n                \n                multipartEntityBuilder.addTextBody(entry.getKey(), entry.getValue().toString());\n            }\n        }\n        HttpEntity httpEntity = multipartEntityBuilder.build();\n        httpPost.setEntity(httpEntity);\n        try {\n            response = httpClient.execute(httpPost);\n        } catch (IOException e) {\n            e.printStackTrace();\n            HttpResult httpResult = new HttpResult();\n            httpResult.setCode(404);\n            httpResult.setBody(\"\");\n            return httpResult;\n        }\n        HttpResult httpResult = new HttpResult();\n        \n        if (response.getEntity() != null) {\n            \n            httpResult.setCode(response.getStatusLine().getStatusCode());\n            httpResult.setBody(EntityUtils.toString(response.getEntity(),\"\"));\n\n        } else {\n            \n            httpResult.setCode(response.getStatusLine().getStatusCode());\n            \n        }\n        return httpResult;\n    }", "comment": "/**\n     * \u4f7f\u7528httpclient\u4e0a\u4f20\u6587\u4ef6\n     * @param url\n     * @param file\n     * @return\n     */"}}
{"code": {"body": "\tprivate void executeUpload(String uploadDir,MultipartFile file) throws Exception\n\t{\n\t\t\n\t\tString suffix = file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf(\"\"));\n\t\t\n\t\tString filename = UUID.randomUUID() + suffix;\n\t\t\n\t\tFile serverFile = new File(uploadDir + filename);\n\t\t\n\t\tfile.transferTo(serverFile);\n\t}", "comment": "/**\n\t * \u63d0\u53d6\u4e0a\u4f20\u65b9\u6cd5\u4e3a\u516c\u5171\u65b9\u6cd5\n\t * @param uploadDir \u4e0a\u4f20\u6587\u4ef6\u76ee\u5f55\n\t * @param file \u4e0a\u4f20\u5bf9\u8c61\n\t * @throws Exception\n\t */"}}
{"code": {"body": "    private <T> T getDAO(Class<T> clazz,HttpServletRequest request)\n    {\n        BeanFactory factory = WebApplicationContextUtils.getRequiredWebApplicationContext(request.getServletContext());\n        return factory.getBean(clazz);\n    }", "comment": "/**\n     * \u6839\u636e\u4f20\u5165\u7684\u7c7b\u578b\u83b7\u53d6spring\u7ba1\u7406\u7684\u5bf9\u5e94dao\n     * @param clazz \u7c7b\u578b\n     * @param request \u8bf7\u6c42\u5bf9\u8c61\n     * @param <T>\n     * @return\n     */"}}
{"code": {"body": "    public static String getCliectIp(HttpServletRequest request)\n    {\n        String ip = request.getHeader(\"\");\n        if (ip == null || ip.trim() == \"\" || \"\".equalsIgnoreCase(ip)) {\n            ip = request.getHeader(\"\");\n        }\n        if (ip == null || ip.trim() == \"\" || \"\".equalsIgnoreCase(ip)) {\n            ip = request.getHeader(\"\");\n        }\n        if (ip == null || ip.trim() == \"\" || \"\".equalsIgnoreCase(ip)) {\n            ip = request.getRemoteAddr();\n        }\n\n        \n        final String[] arr = ip.split(\"\");\n        for (final String str : arr) {\n            if (!\"\".equalsIgnoreCase(str)) {\n                ip = str;\n                break;\n            }\n        }\n        return ip;\n    }", "comment": "/**\n     * \u83b7\u53d6\u5ba2\u6237\u7aefip\u5730\u5740\n     * @param request\n     * @return\n     */"}}
{"code": {"body": "    public static String getRequestType(HttpServletRequest request) {\n        return request.getHeader(\"\");\n    }", "comment": "/**\n     * \u5224\u65ad\u662f\u5426\u4e3aajax\u8bf7\u6c42\n     * @param request\n     * @return\n     */"}}
{"code": {"body": "public MailSender title(String title){\n        mail.setTitle(title);\n        return this;\n    }", "comment": "/**\n     * \u8bbe\u7f6e\u90ae\u4ef6\u6807\u9898\n     * @param title \u6807\u9898\u4fe1\u606f\n     * @return\n     */"}}
{"code": {"body": "public MailSender content(String content)", "comment": "/**\n     * \u8bbe\u7f6e\u90ae\u4ef6\u5185\u5bb9\n     * @param content\n     * @return\n     */"}}
{"code": {"body": "public MailSender contentType(MailContentTypeEnum typeEnum)", "comment": "/**\n     * \u8bbe\u7f6e\u90ae\u4ef6\u683c\u5f0f\n     * @param typeEnum\n     * @return\n     */"}}
{"code": {"body": "public MailSender targets(List<String> targets)", "comment": "/**\n     * \u8bbe\u7f6e\u8bf7\u6c42\u76ee\u6807\u90ae\u4ef6\u5730\u5740\n     * @param targets\n     * @return\n     */"}}
{"code": {"body": "    public MailSender title(String title){\n        mail.setTitle(title);\n        return this;\n    }", "comment": "/**\n     * \u8bbe\u7f6e\u90ae\u4ef6\u6807\u9898\n     * @param title \u6807\u9898\u4fe1\u606f\n     * @return\n     */"}}
{"code": {"body": "    public MailSender content(String content)\n    {\n        mail.setContent(content);\n        return this;\n    }", "comment": "/**\n     * \u8bbe\u7f6e\u90ae\u4ef6\u5185\u5bb9\n     * @param content\n     * @return\n     */"}}
{"code": {"body": "    public MailSender contentType(MailContentTypeEnum typeEnum)\n    {\n        mail.setContentType(typeEnum.getValue());\n        return this;\n    }", "comment": "/**\n     * \u8bbe\u7f6e\u90ae\u4ef6\u683c\u5f0f\n     * @param typeEnum\n     * @return\n     */"}}
{"code": {"body": "    public MailSender targets(List<String> targets)\n    {\n        mail.setList(targets);\n        return this;\n    }", "comment": "/**\n     * \u8bbe\u7f6e\u8bf7\u6c42\u76ee\u6807\u90ae\u4ef6\u5730\u5740\n     * @param targets\n     * @return\n     */"}}
{"code": {"body": "    public void send() throws Exception\n    {\n        \n        if(mail.getContentType() == null)\n            mail.setContentType(MailContentTypeEnum.HTML.getValue());\n\n        if(mail.getTitle() == null || mail.getTitle().trim().length() == 0)\n        {\n            throw new Exception(\"\");\n        }\n\n        if(mail.getContent() == null || mail.getContent().trim().length() == 0)\n        {\n            throw new Exception(\"\");\n        }\n\n        if(mail.getList().size() == 0)\n        {\n            throw new Exception(\"\");\n        }\n\n        \n        final PropertiesUtil properties = new PropertiesUtil(\"\");\n        \n        final Properties props = new Properties();\n        \n        props.put(\"\", \"\");\n        \n        props.put(\"\", properties.getValue(\"\"));\n        \n        props.put(\"\", properties.getValue(\"\"));\n        \n        props.put(\"\", properties.getValue(\"\"));\n        \n        props.put(\"\", properties.getValue(\"\"));\n\n        \n        Authenticator authenticator = new Authenticator() {\n            protected PasswordAuthentication getPasswordAuthentication() {\n                \n                String userName = props.getProperty(\"\");\n                String password = props.getProperty(\"\");\n                return new PasswordAuthentication(userName, password);\n            }\n        };\n        \n        Session mailSession = Session.getInstance(props, authenticator);\n        \n        MimeMessage message = new MimeMessage(mailSession);\n        \n        String nickName = MimeUtility.encodeText(properties.getValue(\"\"));\n        InternetAddress form = new InternetAddress(nickName + \"\" + props.getProperty(\"\") + \"\");\n        message.setFrom(form);\n\n        \n        message.setSubject(mail.getTitle());\n        \n        if(mail.getContentType().equals(MailContentTypeEnum.HTML.getValue())) {\n            \n            message.setContent(mail.getContent(), mail.getContentType());\n        }\n        \n        else if(mail.getContentType().equals(MailContentTypeEnum.TEXT.getValue())){\n            message.setText(mail.getContent());\n        }\n        \n        List<String> targets = mail.getList();\n        for(int i = 0;i < targets.size();i++){\n            try {\n                \n                InternetAddress to = new InternetAddress(targets.get(i));\n                message.setRecipient(Message.RecipientType.TO, to);\n                \n                Transport.send(message);\n            }catch (Exception e)\n            {\n                continue;\n            }\n\n        }\n    }", "comment": "/**\n     * \u6267\u884c\u53d1\u9001\u90ae\u4ef6\n     * @throws Exception \u5982\u679c\u53d1\u9001\u5931\u8d25\u4f1a\u629b\u51fa\u5f02\u5e38\u4fe1\u606f\n     */"}}
{"code": {"body": "public PropertiesUtil(String fileName)", "comment": "/**\n     * \u6784\u9020\u51fd\u6570\u5b9e\u4f8b\u5316\u90e8\u5206\u5bf9\u8c61\uff0c\u83b7\u53d6\u6587\u4ef6\u8d44\u6e90\u5bf9\u8c61\n     *\n     * @param fileName\n     */"}}
{"code": {"body": "    public String getValue(String key)\n    {\n        String message = this.resource.getString(key);\n        return message;\n    }", "comment": "/**\n     * \u6839\u636e\u4f20\u5165\u7684key\u83b7\u53d6\u5bf9\u8c61\u7684\u503c 2016\u5e7412\u670817\u65e5 \u4e0a\u534810:19:55 getValue\n     *\n     * @param key properties\u6587\u4ef6\u5bf9\u5e94\u7684key\n     * @return String \u89e3\u6790\u540e\u7684\u5bf9\u5e94key\u7684\u503c\n     */"}}
{"code": {"body": "    public Enumeration<String> getKeys(){\n        return resource.getKeys();\n    }", "comment": "/**\n     * \u83b7\u53d6properties\u6587\u4ef6\u5185\u7684\u6240\u6709key\u503c<br>\n     * 2016\u5e7412\u670817\u65e5 \u4e0a\u534810:21:20 getKeys\n     *\n     * @return\n     */"}}
{"code": {"body": "    public void init() throws IOException, InterruptedException {\n        final CountDownLatch countDownLatch=new CountDownLatch(1);\n\n        Watcher watcher = new Watcher() {\n            @Override\n            public void process(WatchedEvent event) {\n                if (event.getState() == Event.KeeperState.SyncConnected && event.getType()== Watcher.Event.EventType.None){\n                    countDownLatch.countDown();\n                    logger.info(\"\");\n                }\n            }\n        };\n        zooKeeper = new ZooKeeper(ZK_ADDRESS,SESSION_TIMEOUT,watcher);\n        logger.info(\"\");\n        countDownLatch.await();\n    }", "comment": "/**\n     * \u6d4b\u8bd5\u521b\u5efa\u8def\u5f84\n     * @throws InterruptedException\n     */"}}
{"code": {"body": "            public void process(WatchedEvent event) {\n                if (event.getState() == Event.KeeperState.SyncConnected && event.getType()== Watcher.Event.EventType.None){\n                    countDownLatch.countDown();\n                    logger.info(\"\");\n                }\n            }", "comment": "/**\n     * \u6d4b\u8bd5\u521b\u5efa\u8def\u5f84\n     * @throws InterruptedException\n     */"}}
{"code": {"body": "\tpublic static Message deserialize(byte[] buffer) {\n\t\tint address = buffer[0];\n\t\tint endpoint = buffer[1];\n\t\tint value = buffer[2] << 24 | buffer[3] << 16 | buffer[4] << 8 | buffer[5]; \n\t\treturn new Message(address, endpoint, value);\n\t}", "comment": "/**\n\t * Construct message from array of bytes (e.g. received through socket).\n\t * The values are expected to be encoded in Network Byte Order.\n\t * \n\t * @param buffer Array of bytes (size `MESSAGE_SIZE`)\n\t * @return Parsed message\n\t */"}}
{"code": {"body": "\tpublic byte[] serialize() {\n\t\tbyte[] buf = new byte[MESSAGE_SIZE];\n\t\t\n\t\t\n\t\tbuf[0] = (byte) (m_device & 0xFF);\n\t\tbuf[1] = (byte) (m_endpoint & 0xFF);\n\t\t\n\t\t\n\t\tbuf[2] = (byte) ((m_value & 0xFF000000) >> 24);\n\t\tbuf[3] = (byte) ((m_value & 0x00FF0000) >> 16);\n\t\tbuf[4] = (byte) ((m_value & 0x0000FF00) >> 8);\n\t\tbuf[5] = (byte) ((m_value & 0x000000FF));\n\t\treturn buf;\n\t}", "comment": "/**\n\t * Serialize the message as a byte array. All values\n\t * are stored with MSB first, Network Byte Order.\n\t * \n\t * @return The message serialized as an array of bytes \n\t */"}}
{"code": {"body": "\tpublic void JKCement()\n\t{\n\t\t\n\t\tSystem.out.println(\"\");\n\t\t\n\t     \n\t\t\n\t\t\n\t\t\n\t\t\n\t}", "comment": "/* public void K3(){\n    \t\n    \tpublic void J3(){\n    \t\tSystem.out.println(\"J3\");//java doesnot support inner method\n    \t}\n    \t\n    \tSystem.out.println(\"K3\");\n    }*/"}}
{"code": {"body": "\tpublic static void UltraCement()\n\t{\n\t\tSystem.out.println(\"\");\t\n\t\t\n\t\tMethods mt=new Methods();\n\t\tmt.JKCement();\n\t\t\n\t\t\n\t\t\n\t\t\n\t}", "comment": "/* public void K3(){\n    \t\n    \tpublic void J3(){\n    \t\tSystem.out.println(\"J3\");//java doesnot support inner method\n    \t}\n    \t\n    \tSystem.out.println(\"K3\");\n    }*/"}}
{"code": {"body": "\tpublic void Methodpara(int a,String Casuals,String Username){\n\t\tSystem.out.println(\"\");\n\t\tSystem.out.println(a);\n\t\tSystem.out.println(Casuals+Username);\n\t\tSystem.out.println(Username);\n\t\tSystem.out.println(\"\");\n\t\t\n\t\t\n\t\t\n\t}", "comment": "/* public void K3(){\n    \t\n    \tpublic void J3(){\n    \t\tSystem.out.println(\"J3\");//java doesnot support inner method\n    \t}\n    \t\n    \tSystem.out.println(\"K3\");\n    }*/"}}
{"code": {"body": "    public static void printSum(int num1, int num2) {\n        int sum = num1 + num2;\n\n        System.out.printf(\"\", num1, num2, sum);\n    }", "comment": "/**\n     * Remember that float only stores a precision of 6-7 digits, if you need more use double\n     * <p>\n     * https://www.educba.com/java-float-vs-double/\n     */"}}
{"code": {"body": "    public static void printDivision(int num1, int num2) {\n        int division = num1 / num2;\n        int rest = num1 % num2;\n\n        System.out.printf(\"\", num1, num2, division, rest);\n    }", "comment": "/**\n     * Remember that float only stores a precision of 6-7 digits, if you need more use double\n     * <p>\n     * https://www.educba.com/java-float-vs-double/\n     */"}}
{"code": {"body": "    public static void printOperationsResult(int num1, int num2, int num3, int num4, int num5, int num6, int num7, int num8,\n                                             int num9, int num10, int num11, int num12, int num13, int num14, int num15, int num16) {\n        int op1 = num1 + num2 * num3;\n        int op2 = (num4 + num5) % num6;\n        int op3 = num7 + num8 * num9 / num10;\n        int op4 = num11 + num12 / num13 * num14 - num15 % num16;\n\n        System.out.printf(\"\", num1, num2, num3, op1);\n        System.out.printf(\"\", num4, num5, \"\", num6, op2);\n        System.out.printf(\"\", num7, num8, num9, num10, op3);\n        System.out.printf(\"\", num11, num12, num13, num14, num15, \"\", num16, op4);\n    }", "comment": "/**\n     * Remember that float only stores a precision of 6-7 digits, if you need more use double\n     * <p>\n     * https://www.educba.com/java-float-vs-double/\n     */"}}
{"code": {"body": "    public static void printExpressionOutput(double num1, double num2, double num3, double num4, double num5, double num6) {\n        double result = (num1 * num2 - num3 * num4) / (num5 - num6);\n\n        System.out.printf(\"\", num1, num2, num3, num4, num5, num6,\n                result);\n    }", "comment": "/**\n     * Remember that float only stores a precision of 6-7 digits, if you need more use double\n     * <p>\n     * https://www.educba.com/java-float-vs-double/\n     */"}}
{"code": {"body": "    public static void printCircleAreaAndPerimeter(double radius) {\n        double area = Math.PI * radius * radius;\n        double perimeter = Math.PI * 2 * radius;\n\n        System.out.printf(\"\", radius, area);\n        System.out.printf(\"\", radius, perimeter);\n    }", "comment": "/**\n     * Java has support for some of the mathematical constants\n     * <p>\n     * https://examples.javacodegeeks.com/core-java/math/using-math-constants/\n     */"}}
{"code": {"body": "    public static void calculateAcceleration(int startSpeed, int finalSpeed, int timeUsedInSeconds, int objectMass) {\n    \tdouble deltaSpeed = finalSpeed - startSpeed;\n    \tdouble speedInMetersPerSecond = deltaSpeed * 5 / 18;\n    \tSystem.out.printf(\"\", deltaSpeed, speedInMetersPerSecond);\n    \tSystem.out.println();\n    \tdouble acceleration = speedInMetersPerSecond / timeUsedInSeconds;\n    \tSystem.out.printf(\"\", acceleration);\n    \tSystem.out.println();\n    \tdouble distanceTraveled = speedInMetersPerSecond * timeUsedInSeconds;\n    \tSystem.out.printf(\"\", distanceTraveled);\n    }", "comment": "/**\n     * Calculate:\n     * 1. Acceleration - A = deltaV (difference in speed) / deltaT (difference in time)\n     * \t1.1 deltaV = finalSpeed - startSpeed\n     *  1.2 deltaT = finalTime - startTime (or time used in total)\n     * @param startSpeed\n     * @param finalSpeed\n     * @param timeUsedInSeconds\n     * @param objectMass\n     */"}}
{"code": {"body": "    public static void printHelloName(String name) {\n        System.out.println(\"\");\n\n        System.out.printf(\"\", name);\n    }", "comment": "/**\n     * Printing can be done in many different ways in java\n     *\n     * Check out format printing: https://www.baeldung.com/java-printstream-printf\n     */"}}
{"code": {"body": "    public static void printStringLowercase(String string) {\n        System.out.println(\"\" + string);\n\n        System.out.println(string.toLowerCase());\n    }", "comment": "/**\n     * String offers quite a few built in methods like toLowerCase, toUpperCase, trim, etc\n     *\n     * https://www.w3schools.com/java/java_ref_string.asp\n     */"}}
{"code": {"body": "    public static void printStringReversed(String string) {\n        System.out.println(\"\" + string);\n\n        StringBuilder stringBuilder = new StringBuilder();\n\n        stringBuilder.append(string);\n\n        stringBuilder.reverse();\n\n        System.out.println(stringBuilder.toString());\n    }", "comment": "/**\n     * StringBuilder is a utility class that offers additional functionality when working with strings\n     *\n     * https://www.javatpoint.com/StringBuilder-class\n     */"}}
{"code": {"body": "    public static void printFistHalfOfString(String string) {\n        System.out.println(\"\" + string);\n\n        int stringLength = string.length();\n        String firstHalf = string.substring(0, stringLength/2);\n\n        System.out.println(firstHalf);\n    }", "comment": "/**\n     * Length and substring are two of the very useful built in string methods\n     *\n     * https://beginnersbook.com/2013/12/java-string-substring-method-example/\n     */"}}
{"code": {"body": "    public static void printStringsConcatenatedWithoutFirstLetter(String string1, String string2) {\n        System.out.println(\"\" + string1 + \"\" + string2);\n\n        StringBuilder stringBuilder = new StringBuilder();\n\n        stringBuilder.append(string1.substring(1));\n        stringBuilder.append(string2.substring(1));\n\n        System.out.println(stringBuilder.toString());\n    }", "comment": "/**\n     * For simple string concatenations it's ok to use + but when concatenating in a loop always remember\n     * to use StringBuilder\n     *\n     * https://stackoverflow.com/questions/1532461/stringbuilder-vs-string-concatenation-in-tostring-in-java\n     */"}}
{"code": {"body": "    public static void printStringComparison(String string1, String string2) {\n        System.out.println(\"\" + string1 + \"\" + string2);\n\n        if (string1.equalsIgnoreCase(string2)) {\n            System.out.printf(\"\", string1, string2);\n        } else {\n            System.out.printf(\"\", string1, string2);\n        }\n    }", "comment": "/**\n     * Comparing string in java can be done with == or equals\n     * ==     - compares references (addresses in memory)\n     * equals - compares values\n     *\n     * https://www.javatpoint.com/string-comparison-in-java\n     */"}}
{"code": {"body": "    public static void printStringCharacterCount(String string) {\n        System.out.println(\"\" + string);\n\n        int lettersCount = 0;\n        int spacesCount = 0;\n        int numbersCount = 0;\n        int othersCount = 0;\n\n\n        for (int i=0; i<string.length(); i++) {\n            if (string.substring(i,i+1).matches(\"\")) {\n                lettersCount++;\n                continue;\n            }\n\n            if (string.substring(i,i+1).matches(\"\")) {\n                spacesCount++;\n                continue;\n            }\n\n            if (string.substring(i,i+1).matches(\"\")) {\n                numbersCount++;\n                continue;\n            }\n\n            othersCount++;\n        }\n\n        System.out.printf(\"\", string, lettersCount, spacesCount, numbersCount,\n                othersCount);\n    }", "comment": "/**\n     * Regexes help you identify certain patterns in a String\n     *\n     * https://www.vogella.com/tutorials/JavaRegularExpressions/article.html\n     */"}}
{"code": {"body": "    int countByExample(UserExample example);\n\n ", "comment": "/**\n     * \u6839\u636e\u7528\u6237\u8d26\u6237\u540d\u79f0\u83b7\u53d6\u8d44\u6e90\n     * @param account\n     * @return\n     */"}}
{"code": {"body": "    int deleteByExample(UserExample example);\n\n ", "comment": "/**\n     * \u6839\u636e\u7528\u6237\u8d26\u6237\u540d\u79f0\u83b7\u53d6\u8d44\u6e90\n     * @param account\n     * @return\n     */"}}
{"code": {"body": "    int deleteByPrimaryKey(Long userId);\n\n ", "comment": "/**\n     * \u6839\u636e\u7528\u6237\u8d26\u6237\u540d\u79f0\u83b7\u53d6\u8d44\u6e90\n     * @param account\n     * @return\n     */"}}
{"code": {"body": "    int insert(User record);\n\n ", "comment": "/**\n     * \u6839\u636e\u7528\u6237\u8d26\u6237\u540d\u79f0\u83b7\u53d6\u8d44\u6e90\n     * @param account\n     * @return\n     */"}}
{"code": {"body": "    int insertSelective(User record);\n\n ", "comment": "/**\n     * \u6839\u636e\u7528\u6237\u8d26\u6237\u540d\u79f0\u83b7\u53d6\u8d44\u6e90\n     * @param account\n     * @return\n     */"}}
{"code": {"body": "    List<User> selectByExample(UserExample example);\n\n ", "comment": "/**\n     * \u6839\u636e\u7528\u6237\u8d26\u6237\u540d\u79f0\u83b7\u53d6\u8d44\u6e90\n     * @param account\n     * @return\n     */"}}
{"code": {"body": "    User selectByPrimaryKey(Long userId);\n\n ", "comment": "/**\n     * \u6839\u636e\u7528\u6237\u8d26\u6237\u540d\u79f0\u83b7\u53d6\u8d44\u6e90\n     * @param account\n     * @return\n     */"}}
{"code": {"body": "    int updateByExampleSelective(@Param(\"record\") User record, @Param(\"example\") UserExample example);\n\n ", "comment": "/**\n     * \u6839\u636e\u7528\u6237\u8d26\u6237\u540d\u79f0\u83b7\u53d6\u8d44\u6e90\n     * @param account\n     * @return\n     */"}}
{"code": {"body": "    int updateByExample(@Param(\"record\") User record, @Param(\"example\") UserExample example);\n\n ", "comment": "/**\n     * \u6839\u636e\u7528\u6237\u8d26\u6237\u540d\u79f0\u83b7\u53d6\u8d44\u6e90\n     * @param account\n     * @return\n     */"}}
{"code": {"body": "    int updateByPrimaryKeySelective(User record);\n\n ", "comment": "/**\n     * \u6839\u636e\u7528\u6237\u8d26\u6237\u540d\u79f0\u83b7\u53d6\u8d44\u6e90\n     * @param account\n     * @return\n     */"}}
{"code": {"body": "    public static int binarySearch(int[] arr, int left, int right, int x) {\n        int mid;\n        if (right >= left) {\n            mid = (left + right) / 2;\n            if (x == arr[mid]) {\n                return mid;\n            } else {\n                if (x < arr[mid]) {\n                    \n                    return binarySearch(arr, left, mid - 1, x);\n                } else {\n                    \n                    return binarySearch(arr, mid + 1, right, x);\n                }\n            }\n        }\n        \n        return -1;\n    }", "comment": "/**\n     * @param arr   - the array in which the value is searhed\n     * @param left  - left index of the interval used for searching\n     * @param right - right index of the interval used for searching\n     * @param x     - the searched value\n     * @return - the index where the value was found or -1 in case the value is not found in the array\n     */"}}
{"code": {"body": "    static int factorial(int n) {\n        if (n == 0 || n == 1) {\n            return n;\n        }\n        return n * factorial(n - 1);\n    }", "comment": "/**\n     * Method that computes the factorial value of the parameter received.\n     */"}}
{"code": {"body": "    public static int fibonacci(int n){\n        if(n<=1){\n            return n;\n        }else{\n            return fibonacci(n-1) + fibonacci(n-2);\n        }\n    }", "comment": "/**\n     * Method that computes the fibonacci value.\n     * @return - the n(th) value from the fibonacci numbers.\n     */"}}
{"code": {"body": "    public void sort(int[] arr) {\n        int n = arr.length;\n\n        \n        int aux;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n - i - 1; j++) { \n                if (arr[j] > arr[j + 1]) {\n                    \n                    aux = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = aux;\n                }\n            }\n        }\n    }", "comment": "/**\n     * Sort the array using the bubble sort algorithm.\n     *\n     * @param arr - array to be sorted.\n     */"}}
{"code": {"body": "    public void sort(int[] arr) {\n        int n = arr.length;\n\n        \n        \n        for (int i = 1; i < n; i++) {\n            int element = arr[i];\n            int j = i-1;\n\n            \n            while (j >= 0 && arr[j] > element) {\n                arr[j + 1] = arr[j];\n                j--;\n            }\n            arr[j+1] = element;\n        }\n    }", "comment": "/**\n     * Sort the array using the insertion sort algorithm.\n     * @param arr - array to be sorted.\n     */"}}
{"code": {"body": "    public void sort(int[] arr) {\n        int n = arr.length;\n        int min_index;\n        int aux;\n\n        for (int i = 0; i < n; i++) {\n            \n            \n            min_index = i;\n            for (int j = i + 1; j < n; j++) {\n                if (arr[min_index] > arr[j]) {\n                    min_index = j;\n                }\n            }\n            \n            aux = arr[i];\n            arr[i] = arr[min_index];\n            arr[min_index] = aux;\n        }\n    }", "comment": "/**\n     * Sort the array using the selection sort algorithm.\n     *\n     * @param arr - array to be sorted.\n     */"}}
{"code": {"body": "public CustomLinkedList() {\n        head = null;\n        tail = null;\n    }", "comment": "/**\n     * Constructor to initialize an object of this class.\n     */"}}
{"code": {"body": "    public void insertFirst(Node newNode) {\n        \n        if(tail == null){\n            tail = newNode;\n        }\n        \n        newNode.next = head;\n        head = newNode;\n    }", "comment": "/**\n     * This method implements the functionality of adding a new element to the list.\n     * The element will be added in the beginning of the list.\n     * @param newNode - the node to be inserted.\n     */"}}
{"code": {"body": "    public void insertLast(Node newNode){\n        \n        newNode.next = null;\n        \n        tail.next = newNode;\n        tail = newNode;\n    }", "comment": "/**\n     * Inserts a new node at the end of the list.\n     * @param newNode - node to be added\n     */"}}
{"code": {"body": "    public void printList() {\n        if (head == null) {\n            System.out.println(\"\");\n        } else {\n            Node node = head;\n            System.out.print(\"\");\n            \n            while(node != null){\n                System.out.print(node.data + \"\");\n                node = node.next;\n            }\n        }\n    }", "comment": "/**\n     * Display in the console all the elements from the list.\n     */"}}
{"code": {"body": "public CustomQueue() {\n        front = null;\n        rear = null;\n    }", "comment": "/**\n     * Constructor to initialize the queue.\n     */"}}
{"code": {"body": "    public void enqueue(int value) {\n        Node newNode = new Node(value);\n        System.out.println(\"\" + value);\n        \n        if (rear == null) {\n            front = newNode;\n            rear = newNode;\n        } else {\n            \n            rear.next = newNode;\n            \n            rear = newNode;\n        }\n    }", "comment": "/**\n     * Method to add a new element to the queue.\n     *\n     * @param value - value to be added\n     */"}}
{"code": {"body": "    public Node dequeue() {\n        if (front == null) {\n            \n            System.out.println(\"\");\n            return null;\n        } else {\n            Node nodeToReturn = front;\n            \n            front = front.next;\n\n            \n            if (front == null) {\n                rear = null;\n            }\n            System.out.println(\"\" + nodeToReturn.data);\n            return nodeToReturn;\n        }\n    }", "comment": "/**\n     * @return - and remove the first node from the queue.\n     */"}}
{"code": {"body": "    public Node front() {\n        return front;\n    }", "comment": "/**\n     * @return - the front node without removing it.\n     */"}}
{"code": {"body": "public CustomStack(int s) {\n        arr = new int[s];\n        size = s;\n        \n        top = -1;\n    }", "comment": "/**\n     * Constructor to initialize the stack.\n     *\n     * @param s - the size of the stack\n     */"}}
{"code": {"body": "    public boolean push(int value) {\n        if (isFull()) {\n            System.out.println(\"\");\n            return false;\n        } else {\n            System.out.println(\"\" + value);\n            top++;\n            arr[top] = value;\n            return true;\n        }\n    }", "comment": "/**\n     * Method that adds a new element to the stack.\n     *\n     * @param value - the value to be added\n     * @return - true if the value was inserted successfully and false otherwise\n     */"}}
{"code": {"body": "    public int pop() {\n        if (isEmpty()) {\n            System.out.println(\"\");\n            return 0;\n        }\n        int valueToReturn = arr[top];\n        System.out.println(\"\" + valueToReturn);\n        top--;\n        return valueToReturn;\n    }", "comment": "/**\n     * Method that returns end removes the top element from the stack. Program will close if the stack is empty.\n     *\n     * @return - the top element from the stack\n     */"}}
{"code": {"body": "    public int peek() {\n        if (isEmpty()) {\n            System.out.println(\"\");\n            return 0;\n        } else {\n            return arr[top];\n        }\n    }", "comment": "/**\n     * @return - the top element from the stack without removing it.\n     */"}}
{"code": {"body": "    public boolean isEmpty() {\n        if (top < 0) {\n            return true;\n        }\n        return false;\n    }", "comment": "/**\n     * Method that checks if the stack is empty.\n     *\n     * @return - true if the stack is empty and false otherwise.\n     */"}}
{"code": {"body": "    public boolean isFull() {\n        if (top == size - 1) {\n            return true;\n        }\n        return false;\n    }", "comment": "/**\n     * Method that check if the stack is full.\n     *\n     * @return - true if the stack is full and false otherwise\n     */"}}
{"code": {"body": "\tpublic static void UltraCement()\n\t{\n\t\tSystem.out.println(\"\");\t\n\t\t\n\t\tMethods mt=new Methods();\n\t\tmt.JKCement();\n\t\t\n\t\t\n\t\t\n\t\t\n\t}", "comment": "/* public void K3(){\n    \t\n    \tpublic void J3(){\n    \t\tSystem.out.println(\"J3\");//java doesnot support inner method\n    \t}\n    \t\n    \tSystem.out.println(\"K3\");\n    }*/"}}
{"code": {"body": "\tpublic void Methodpara(int a,String Casuals,String Username){\n\t\tSystem.out.println(\"\");\n\t\tSystem.out.println(a);\n\t\tSystem.out.println(Casuals+Username);\n\t\tSystem.out.println(Username);\n\t\tSystem.out.println(\"\");\n\t\t\n\t\t\n\t\t\n\t}", "comment": "/* public void K3(){\n    \t\n    \tpublic void J3(){\n    \t\tSystem.out.println(\"J3\");//java doesnot support inner method\n    \t}\n    \t\n    \tSystem.out.println(\"K3\");\n    }*/"}}
{"code": {"body": "    public void doParentThings() {\n        System.out.println(\"\");\n    }", "comment": "/**\n    @Deprecated\n    reason - we will not be using this anymore\n     */"}}
{"code": {"body": "    public static void main(String[] args) {\n\n        \n        System.out.println(\"\");\n        System.out.println();\n        System.out.print(\"\");\n        List<Integer> listOfIntegers = new ArrayList<>();\n        listOfIntegers.add(2);\n        listOfIntegers.add(1);\n        listOfIntegers.add(3);\n        listOfIntegers.add(6);\n        listOfIntegers.add(6);\n        listOfIntegers.add(5);\n        System.out.println();\n        System.out.print(\"\");\n        listOfIntegers.forEach(value -> System.out.print(value + \"\"));\n        Collections.sort(listOfIntegers);\n        \n        System.out.println();\n        listOfIntegers.set(0, 555);\n        listOfIntegers.remove(4);\n        System.out.print(\"\");\n        System.out.println(Arrays.toString(listOfIntegers.toArray()));\n        System.out.println(\"\" + listOfIntegers.contains(3));\n        System.out.println();\n        System.out.println(\"\" + Collections.max(listOfIntegers));\n        System.out.println(\"\" + Collections.min(listOfIntegers));\n        System.out.println();\n        Collections.sort(listOfIntegers, Collections.reverseOrder());\n        System.out.print(\"\" + listOfIntegers);\n    }", "comment": "/*\n         * LIST - ordered collection of elements.\n         * Elements can be accessed by their index.\n         */"}}
{"code": {"body": "public ProductService(EmailService emailService) {\n        this.emailService = emailService;\n    }", "comment": "/*\n    If we had used inheritance and one of our other subclasses\n    had used this method but we wanted to remove it we would\n    have been locked in, composition keeps things flexible.\n     */"}}
{"code": {"body": "    public void sendPurchaseCompletedEmail() {\n        this.emailService.sendPurchaseCompletedEmail();\n    }", "comment": "/*\n    If we had used inheritance and one of our other subclasses\n    had used this method but we wanted to remove it we would\n    have been locked in, composition keeps things flexible.\n     */"}}
{"code": {"body": "    public void sendDeliverySendEmail() {\n        \n        this.emailService.sendDeliverySendEmail();\n    }", "comment": "/*\n    If we had used inheritance and one of our other subclasses\n    had used this method but we wanted to remove it we would\n    have been locked in, composition keeps things flexible.\n     */"}}
{"code": {"body": "\tpublic static void main(String[] args) {\n\t\t\n\t\tint arrayToTest[] = {3,5,2};\n\t\ttry {\n\t\t\tprintArrayElement(arrayToTest, 5);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}", "comment": "/*\n\tThe Java throws keyword is used to declare an exception.\n\tIt gives an information to the programmer that there may occur an exception\n\tso it is better for the programmer to provide the exception handling\n\tcode so that normal flow can be maintained. Exception Handling is\n\tmainly used to handle the checked exceptions.\n\t */"}}
{"code": {"body": "\tprivate static void printArrayElement(int[] array, int index) throws Exception {\n\t\tif(index < 0 || index >= array.length) {\n\t\t\tthrow new Exception(\"\");\n\t\t}\n\t\tSystem.out.println(array[index]);\n\t}", "comment": "/*\n\tThe Java throws keyword is used to declare an exception.\n\tIt gives an information to the programmer that there may occur an exception\n\tso it is better for the programmer to provide the exception handling\n\tcode so that normal flow can be maintained. Exception Handling is\n\tmainly used to handle the checked exceptions.\n\t */"}}
{"code": {"body": "\tpublic static void main(String[] args) {\n\n\t\tTicTacToe t = new TicTacToe();\n\t\tScanner s = new Scanner(System.in);\n\t\tint x = 0, y = 0;\n\t\tdo {\n\t\t\tSystem.out.println(t.player == t.X ? \"\" : \"\");\n\t\t\tSystem.out.println(\"\");\n\t\t\tx = s.nextInt();\n\t\t\ty = s.nextInt();\n\n\t\t\tt.putSign(x, y);\n\t\t\tSystem.out.println(t.toString());\n\t\t\tSystem.out.println(\"\");\n\t\t\tt.displayWinner();\n\n\t\t} while (t.isEmpty);\n\t}", "comment": "/** Puts an X or O mark at position i,j. */"}}
{"code": {"body": "\tpublic void putSign(int x, int y) {\n\t\tif (x < 0 || x > 2 || y < 0 || y > 2) {\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn;\n\t\t}\n\t\tif (board[x][y] != EMPTY) {\n\t\t\tSystem.out.println(\"\");\n\t\t\treturn;\n\t\t}\n\t\tboard[x][y] = player; \n\t\tplayer = -player; \n\t}", "comment": "/** Puts an X or O mark at position i,j. */"}}
{"code": {"body": "\tpublic boolean isWin(int player) {\n\t\treturn ((board[0][0] + board[0][1] + board[0][2] == player * 3)\n\t\t\t\t|| (board[1][0] + board[1][1] + board[1][2] == player * 3)\n\t\t\t\t|| (board[2][0] + board[2][1] + board[2][2] == player * 3)\n\t\t\t\t|| (board[0][0] + board[1][0] + board[2][0] == player * 3)\n\t\t\t\t|| (board[0][1] + board[1][1] + board[2][1] == player * 3)\n\t\t\t\t|| (board[0][2] + board[1][2] + board[2][2] == player * 3)\n\t\t\t\t|| (board[0][0] + board[1][1] + board[2][2] == player * 3)\n\t\t\t\t|| (board[2][0] + board[1][1] + board[0][2] == player * 3));\n\t}", "comment": "/** Checks whether the board configuration is a win for the given player. */"}}
{"code": {"body": "\tpublic void displayWinner() {\n\t\tif (isWin(X)) {\n\t\t\tSystem.out.println(\"\");\n\t\t\tisEmpty = false;\n\t\t} else if (isWin(O)) {\n\t\t\tSystem.out.println(\"\");\n\t\t\tisEmpty = false;\n\t\t} else {\n\t\t\tif (!isEmpty) {\n\t\t\t\tSystem.out.println(\"\");\n\t\t\t}\n\n\t\t}\n\t}", "comment": "/** display the winning player or indicate a tie (or unfinished game). */"}}
{"code": {"body": "public DbConn() {\n        this.connect(this.isTemple());\n    }", "comment": "/**\n     * Constructor - opens database connection to database, This version\n     * determines if the app is running locally or not (by checking if\n     * \"temple.edu\" is at the end of the hostname of the machine on which you\n     * are running your app).\n     */"}}
{"code": {"body": "public DbConn(boolean isTemple) {\n        this.connect(isTemple);\n    }", "comment": "/**\n     * Constructor - opens database connection to database, This version uses\n     * boolean input parameter to determine if the app is running locally or not\n     */"}}
{"code": {"body": "    private void connect(boolean isTemple) {\n\n        try {\n            String DRIVER = \"\";\n            Class.forName(DRIVER).newInstance();\n            try {\n                \n                String url = \"\";\n\n                \n                if (isTemple) {\n                    url = \"\";\n                }\n                this.conn = DriverManager.getConnection(url);\n\n            } catch (Exception e) { \n                this.errMsg = \"\" + e.getMessage();\n            }\n        } catch (Exception e) { \n            this.errMsg = \"\" + e.getMessage();\n        }\n    }", "comment": "/**\n     * Open a connection to your database either using the Temple connection\n     * string or the local connection string.\n     *\n     * @param isTemple: if this is true, it will use the Temple connection\n     * string (else it will use the local connection string).\n     */"}}
{"code": {"body": "    public Connection getConn() {\n        return this.conn;\n    }", "comment": "/* Returns database connection for use in SQL classes.  */"}}
{"code": {"body": "    public String getErr() {\n        return this.errMsg;\n    }", "comment": "/* Returns database connection error message or \"\" if there is none.  */"}}
{"code": {"body": "    public void close() {\n\n        if (conn != null) {\n            try {\n                conn.close();\n            } \n            catch (Exception e) {\n                \n            } \n        } \n    }", "comment": "/**\n     * Close database connection.\n     */"}}
{"code": {"body": "    private boolean isTemple() {\n        boolean temple = false;\n        try {\n            String hostName = java.net.InetAddress.getLocalHost().getCanonicalHostName();\n            hostName = hostName.toLowerCase();\n            if (hostName.endsWith(\"\")) {\n                temple = true;\n                System.out.println(\"\");\n            } else {\n                System.out.println(\"\");\n            }\n        } catch (Exception e) {\n            System.out.println(\"\" + e.getMessage());\n        }\n        return temple;\n    }", "comment": "/**\n     * Checks the hostname to see if app is running at Temple or not.\n     */"}}
{"code": {"body": "\tpublic static void main(String[] args) {\n\t\t\n\t\t\n\t\t\n\t\tSystem.out.println(\"\");\n\t\t\n\t}", "comment": "/**\n\t\t * Create a simple Java program PrintHometown.java (console application)\n\t\t * to print the name of your hometown, compile and run it. \n\t\t */"}}
{"code": {"body": "\tpublic static void main(String[] args) {\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tLocalDateTime dt = LocalDateTime.now();\n\t\tSystem.out.println(dt);\n\t\tSystem.out.printf(\n\t\t\t\t  \"\", LocalDate.now());\n\t}", "comment": "/**\n\t\t * Create a simple Java program CurrentDateTime.java to print\n\t\t * the current date and time.\n\t\t */"}}
{"code": {"body": "\tpublic static void main(String[] args) {\n\t\t\n\t\t\n\t\t\n\t\t@SuppressWarnings(\"\")\n\t\tScanner number = new Scanner(System.in);\n\t\t\n\t\tint a = number.nextInt();\n\t\t\n\t\tint b = number.nextInt();\n\t\tSystem.out.println(a+b);\n\t}", "comment": "/**\n\t\t * Write a program SumTwoNumbers.java that enters two integers from the console,\n\t\t * calculates and prints their sum. Search in Internet to learn how to read \n\t\t * numbers from the console. \n\t\t */"}}
{"code": {"body": "\tpublic static void main(String[] args) {\n\t\t\n\t\t\n\t\t\n\t\t@SuppressWarnings(\"\")\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tString[] allWords = new String[n]; \n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tallWords[i] = sc.next();\n\t\t}\n\t\tArrays.sort(allWords); \n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tSystem.out.println(allWords[i]);\n\t\t}\n\t}", "comment": "/**\n\t\t * Write a program that enters from the console number n and n strings,\n\t\t * then sorts them alphabetically and prints them. Note: you might need\n\t\t * to learn how to use loops and arrays in Java (search in Internet). \n\t\t */"}}
{"code": {"body": "\tpublic static void main(String[] args) {\n\t\t\n\t\t\n\t\t\n\t\ttry {\n\t\t\tDocument document = new Document();\n\t\t\tPdfWriter.getInstance(document, new FileOutputStream(\"\"));\t\t\t\n\t\t\tdocument.open();\n\t\t\t\n\t\t\t\n\t\t\tPdfPTable table = new PdfPTable(4);\n\t\t\ttable.setWidthPercentage(100);\n\t\t        table.getDefaultCell().setFixedHeight(180);\n\t\t    \n\t\t    \n\t\t\t\n\t\t\tBaseFont baseFont = BaseFont.createFont(\"\", BaseFont.IDENTITY_H, true);\n\t\t\tFont black = new Font(baseFont, 75f, 0, BaseColor.BLACK);\n\t\t\tFont red = new Font(baseFont, 75f, 0, BaseColor.RED);\n\t\t\t\n\t\t\t\n\t\t\tString card = \"\";\n\t\t\tchar color = '';\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tfor (int i = 2; i <= 14; i++) {\n\t\t\t\tswitch (i) {\n\t\t\t\tcase 10: card = \"\"; break;\n\t\t\t\tcase 11: card = \"\"; break;\n\t\t\t\tcase 12: card = \"\"; break;\n\t\t\t\tcase 13: card = \"\"; break;\n\t\t\t\tcase 14: card = \"\"; break;\n\t\t\t\tdefault: card = \"\" + i; break;\n\t\t\t\t}\n\t\t\t\tfor (int j = 1; j <= 4; j++) {\n\t\t\t\t\tswitch (j) {\n\t\t\t\t\tcase 1: color = ''; table.addCell(new Paragraph(card + color + \"\", black)); break;\n\t\t\t\t\tcase 2: color = ''; table.addCell(new Paragraph(card + color + \"\", red)); break;\n\t\t\t\t\tcase 3: color = ''; table.addCell(new Paragraph(card + color + \"\", black)); break;\n\t\t\t\t\tcase 4: color = ''; table.addCell(new Paragraph(card + color + \"\", red)); break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdocument.add(table);\n\t\t\tdocument.close();\t \n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}", "comment": "/**\n\t\t * Write a program to generate a PDF document called Deck-of-Cards.pdf and print \n\t\t * in it a standard deck of 52 cards, following one after another. \n\t\t * Each card should be a rectangle holding its face and suit. \n\t\t */"}}
{"code": {"body": "\tpublic static void main(String[] args) {\n\t\t@SuppressWarnings(\"\")\n\t\tScanner sc = new Scanner(System.in);\n\t\tString sides = sc.nextLine();\n\t\tString arr[] = sides.split(\"\");    \n\t\tint a = Integer.parseInt(arr[0]);\n\t\tint b = Integer.parseInt(arr[1]);\n\t\tSystem.out.println(a*b);\n\t}", "comment": "/**\n\t * Write a program that enters the sides of a rectangle (two integers a and b) \n\t * and calculates and prints the rectangle's area\n\t */"}}
{"code": {"body": "\tpublic static void main(String[] args) {\n\t\t@SuppressWarnings(\"\")\n\t\tScanner sc = new Scanner(System.in);\n\t\tString pointA = sc.nextLine();\n\t\tString ArrA[] = pointA.split(\"\");         \n\t\tint ax = Integer.parseInt(ArrA[0]);\n\t\tint ay = Integer.parseInt(ArrA[1]);\n\t\tString pointB = sc.nextLine();\n\t\tString ArrB[] = pointB.split(\"\");         \n\t\tint bx = Integer.parseInt(ArrB[0]);\n\t\tint by = Integer.parseInt(ArrB[1]);\n\t\tString pointC = sc.nextLine();\n\t\tString ArrC[] = pointC.split(\"\");         \n\t\tint cx = Integer.parseInt(ArrC[0]);\n\t\tint cy = Integer.parseInt(ArrC[1]);\n\t\t\n\t\tdouble area = (double)((ax*(by-cy) + bx*(cy-ay) + cx*(ay-by))/2);  \n\t\tif(area>=0) System.out.println(area);\n\t\telse System.out.println(area*-1);          \n\t}", "comment": "/**\n\t * Write a program that enters 3 points in the plane (as integer x and y coordinates),\n\t *  calculates and prints the area of the triangle composed by these 3 points.\n\t *  Round the result to a whole number. In case the three points do not form a triangle, \n\t *  print \"0\" as result.\n\t */"}}
{"code": {"body": "\tpublic static void main(String[] args) {\n\t\t@SuppressWarnings(\"\")\n\t\tScanner sc = new Scanner(System.in);\n\t\tString point = sc.nextLine();\n\t\tString arr[] = point.split(\"\");\n\t\tdouble x = Double.parseDouble(arr[0]);\n\t\tdouble y = Double.parseDouble(arr[1]);      \n\t\tif(y<6 || y> 13.5) System.out.println(\"\"); \n\t\telse\n\t\t{\n\t\t\tif(x<12.5 || x>22.5) System.out.println(\"\"); \n\t\t\telse\n\t\t\t{\n\t\t\t\tif(x>17.5&&x<20&&y>8.5) System.out.println(\"\"); \n\t\t\t\telse System.out.println(\"\");\n\t\t\t}\n\t\t}\n\t}", "comment": "/**\n\t * Write a program to check whether a point is inside or outside of the figure below.\n\t * The point is given as a pair of floating-point numbers, separated by a space. \n\t * Your program should print \"Inside\" or \"Outside\"\n\t */"}}
{"code": {"body": "\tpublic static void main(String[] args) {\n\t\t@SuppressWarnings(\"\")\n\t\tScanner sc = new Scanner(System.in);\n\t\tdouble first = Double.parseDouble(sc.next());\n\t\tdouble second = Double.parseDouble(sc.next());\n\t\tdouble third = Double.parseDouble(sc.next());\n\t\tdouble min = Math.min(first, Math.min(second, third)); \n\t\tSystem.out.println(min);\n\t}", "comment": "/**\n\t * Write a program that finds the smallest of three numbers. \n\t */"}}
{"code": {"body": "\tpublic static void main(String[] args) {\n\t\t@SuppressWarnings(\"\")\n\t\tScanner sc = new Scanner(System.in);\n\t\tint num = sc.nextInt();\n\t\tString hexnum = Integer.toHexString(num); \n\t\tSystem.out.println(hexnum.toUpperCase()); \n\t}", "comment": "/**\n\t * Write a program that enters a positive integer number num and converts \n\t * and prints it in hexadecimal form. You may use some built-in method from\n\t *  the standard Java libraries\n\t */"}}
{"code": {"body": "\tpublic static void main(String[] args) {\n\t\t@SuppressWarnings(\"\")\n\t\tScanner input = new Scanner(System.in);\n\t\tint a = input.nextInt();\n\t\tdouble b = input.nextDouble();\n\t\tdouble c = input.nextDouble();\n\t\t\n\t\tString aHexString = Integer.toHexString(a).toUpperCase();\n\t\tString aBinary = String.format(\"\", Integer.toBinaryString(a)).replace('', '');\n\t\t                             \n\t\tif (c%1 == 0) { \n\t\t\tSystem.out.printf(\"\",aHexString,aBinary,b,c);\n\t\t}else {\n\t\t\tSystem.out.printf(\"\",aHexString,aBinary,b,c);\n\t\t}\n\t\n\t}", "comment": "/**\n\t * Write a program that reads 3 numbers: an integer a (0 \u2264 a \u2264 500),\n\t * a floating-point b and a floating-point c and prints them in \n\t * 4 virtual columns on the console. Each column should have a width of 10 characters.\n\t * The number a should be printed in hexadecimal, left aligned;\n\t * then the number a should be printed in binary form, padded with zeroes,\n\t * then the number b should be printed with 2 digits after the decimal point, right aligned;\n\t * the number c should be printed with 3 digits after the decimal point, left aligned\n\t */"}}
{"code": {"body": "\tpublic static void main(String[] args) {\n\n\t\t@SuppressWarnings(\"\")\n\t\tScanner input = new Scanner(System.in);\n\n\t\tint number = input.nextInt();\n\t\tint count = 0;\n\n\t\tfor (int i = 0; i < 32; i++) {\n\t\t\tint bit = number & 1;\n\t\t\tif (bit == 1) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tnumber >>= 1; \n\t\t}\n\t\tSystem.out.println(count);\n\t}", "comment": "/**\n\t * Write a program to calculate the count of bits 1 in the binary\n\t * representation of given integer number n\n\t */"}}
{"code": {"body": "\tpublic static void main(String[] args) {\n\t\t@SuppressWarnings(\"\")\n\t\tScanner sc = new Scanner(System.in);\n\t\tint a = sc.nextInt();\n\t\tchar[] aToBin = String.format(\"\", Integer.toBinaryString(a)).toCharArray();\n\t\tint count = 0;\n\t\tfor (int i = 0; i < aToBin.length; i++) {\n\t\t\tif (aToBin[i] == '') count++;\n\t\t}\n\t\tSystem.out.println(count);\n\t}", "comment": "/**\n\t * Write a program to calculate the count of bits 1 in the binary\n\t * representation of given integer number n\n\t */"}}
{"code": {"body": "\tpublic static void main(String[] args) {\n\t\t@SuppressWarnings(\"\")\n\t\tScanner scan = new Scanner(System.in);\n\t\tSystem.out.println(\"\");\n\t\tint num = scan.nextInt();\n\t\tchar[] binary = Integer.toBinaryString(num).toCharArray();  \n\t\tint count = 0;\n\n\t\tfor (int i = 0; i < binary.length-1; i++) {\n\t\t\tif (binary[i]==binary[i+1]) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"\");\n\t\tSystem.out.print(count);\n\t}", "comment": "/**\n\t * Write a program to count how many sequences of two equal bits (\"00\" or \"11\") can be found \n\t * in the binary representation of given integer number n (with overlapping).\n\t */"}}
{"code": {"body": "\tpublic static void main(String[] args) {\n\t\t@SuppressWarnings(\"\")\n\t\tScanner scaner = new Scanner(System.in);\n\t\tBigInteger n = scaner.nextBigInteger();\n\t\tint counter = 0;\n\t\t\n\t\tfor (int i = 0; i < n.bitLength(); i++) {\n\t\t\tif(n.testBit(i)==n.testBit(i+1))\n\t\t\t{\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(counter);\n\t}", "comment": "/**\n\t * Write a program to count how many sequences of two equal bits (\"00\" or \"11\") can be found \n\t * in the binary representation of given integer number n (with overlapping).\n\t */"}}
{"code": {"body": "    public static void main(String[] args) {\n        \n            if ( args.length < 1 ) {\n                System.err.println(\"\");\n                usage();\n                System.exit(1);\n            }\n        \n        new DateTimeBrowser().go( args );\n    }", "comment": "/**\n     * This is the main swing application method.   It sets up and displays the\n     * initial GUI, and controls execution thereafter.  Everything else in\n     * this class is 'private', please read the code.\n     */"}}
{"code": {"body": "    private static void usage() {\n            System.err.println(\"\");\n            System.err.print(\"\");\n            System.err.print(DateTimeBrowser.class.getName());\n            System.err.println(\"\");\n            System.err.println(\"\");\n            System.err.println(\"\");\n            System.err.println(\"\");\n            System.err.println(\"\");\n            System.err.println(\"\");\n            System.err.println(\"\");\n            System.err.println(\"\");\n            System.err.println(\"\");\n            System.err.println(\"\");\n            System.err.println(\"\");\n            System.err.println(\"\");\n            System.err.println(\"\");\n    }", "comment": "/*\n     * usage A private static method to display usage information to\n     * the user before an error exit.\n     */"}}
{"code": {"body": "    private void go(String[] args) {\n\n        mainArgs = args;\n        setDefaultTimeZone();   \n        \n        setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);\n        \n        JMenuBar menuBar = new JMenuBar();\n        setJMenuBar( menuBar );\n        addMenus( menuBar );\n        \n\n        addWindowListener( new WindowAdapter() {\n                    public void windowClosing(WindowEvent e)\n                    {\n                        setVisible( false );\n                        dispose();\n                        System.exit(0);\n                    }\n                }\n            );\n\n        \n        \n        \n        currFile = new LoadedFile( mainArgs[0] );\n        TableView tView = getDefaultTableView();\n        resetDefaults( tView );\n        \n        \n        \n        Dimension screenMax = Toolkit.getDefaultToolkit().getScreenSize();\n        setSize ( screenMax );\n        setVisible(true);\n    }", "comment": "/*\n     * go This method reads the file, creates the table to display,\n     * the window to display it in, and displays the window.\n     * @param fileName the name of the file to read.\n     * @param tryLines An estimate of the number of lines in\n     * the file.\n     */"}}
{"code": {"body": "    private TableView getDefaultTableView() {\n        \n        String viewStr = System.getProperty(\"\");\n        if ( viewStr == null ) {\n            jmiGetter.setEnabled( false );\n            return new GetterTableView( currFile );\n        }\n        \n        if ( viewStr.equalsIgnoreCase(\"\") ) {\n            jmiHex.setEnabled( false );\n            return new HexTableView( currFile );\n        }\n        else if ( viewStr.equalsIgnoreCase(\"\") ) {\n            jmiDate.setEnabled( false );\n            return new DateTableView( currFile );\n        }\n        else if ( viewStr.equalsIgnoreCase(\"\") ) {\n            jmiCal.setEnabled( false );\n            return new CalTableView( currFile );\n        }\n        else if ( viewStr.equalsIgnoreCase(\"\") ) {\n            jmiGetter.setEnabled( false );\n            return new GetterTableView( currFile );\n        }\n        else { \n            System.err.println(\"\" + viewStr + \"\");\n            jmiGetter.setEnabled( false );\n            return new GetterTableView( currFile );\n        }\n    }", "comment": "/*\n     * getDefaultTableView\n     */"}}
{"code": {"body": "    private void setDefaultTableView(String newView) {\n        System.setProperty( \"\", newView );\n    }", "comment": "/*\n    * setDefaultTableView\n    */"}}
{"code": {"body": "    private void setDefaultTimeZone() {\n        String tzName = System.getProperty(\"\");\n        if ( tzName == null ) return;   \n        \n        \n        \n        \n        TimeZone toSet = TimeZone.getTimeZone( tzName );\n        \n        \n        \n        TimeZone.setDefault( toSet );\n    }", "comment": "/*\n     * setDefaultTimeZone\n     */"}}
{"code": {"body": "    private void addMenus( JMenuBar menuBar) {\n        \n        \n        \n        JMenu fileMenu = new JMenu(\"\");\n        JMenu viewMenu = new JMenu(\"\");\n        \n        \n        \n        menuBar.add( fileMenu );\n        menuBar.add( viewMenu );\n        \n        \n        \n        Action open = new OpenAction();\n        JMenuItem jmiOpen = new JMenuItem( open );\n        Action exit = new ExitAction();\n        JMenuItem jmiExit = new JMenuItem( exit );\n        \n        \n        \n        Action getter = new GetterAction();\n        jmiGetter = new JMenuItem( getter );\n        getter.setEnabled( true );\n        \n        Action hex = new HexAction();\n        jmiHex = new JMenuItem( hex );\n        hex.setEnabled( true );\n        \n        Action date = new DateAction();\n        jmiDate = new JMenuItem( date );\n        date.setEnabled( true );\n        \n        Action cal = new CalAction();\n        jmiCal = new JMenuItem( cal );\n        cal.setEnabled( true );\n        \n        \n        \n        fileMenu.add( jmiOpen );\n        fileMenu.addSeparator();\n        fileMenu.add( jmiExit );\n        \n        \n        \n        viewMenu.add( jmiGetter );\n        viewMenu.add( jmiHex );\n        viewMenu.add( jmiDate );\n        viewMenu.add( jmiCal );\n        \n        \n        \n        \n        \n        \n        \n        \n    }", "comment": "/*\n     * addMenus\n     */"}}
{"code": {"body": "    private void dumpObjs(Object[][] objs, PrintStream out ) {\n        for (int i = 0; i < objs.length; ++i) {\n            for (int j = 0; j < objs[i].length; ++j) {\n                out.println(i + \"\" + j + \"\"\n                    + objs[i][j]);\n            } \n        } \n    }", "comment": "/*\n     * A private method to dump the arrays of Object[][]\n     * if desired by the developer\n     * @param objs The array of arrays to be dumped.\n     */"}}
{"code": {"body": "    private void enableAllViews() {\n        jmiGetter.setEnabled( true );\n        jmiHex.setEnabled( true );\n        jmiDate.setEnabled( true );\n        jmiCal.setEnabled( true );\n    }", "comment": "/*\n     * enableAll\n     */"}}
{"code": {"body": "    private DateTime getADate(String s) {\n        DateTime retDT = null;\n        try\n        {\n            retDT = new DateTime( s );\n        } \n        catch(IllegalArgumentException pe)\n        {\n            \n        } \n        return retDT;\n    }", "comment": "/*\n     * getADate Returns a new DateTime object reference if possible,\n     * otherwise null.\n     * @return retDT A DateTime object reference.\n     */"}}
{"code": {"body": "    private String LPad(String inStr, int maxLen) {\n        if (inStr.length() >= maxLen) return inStr.toUpperCase();\n        String zeroes = PADCHARS.substring(0, maxLen - inStr.length());\n        String retVal = zeroes + inStr;\n        return retVal.toUpperCase();\n    }", "comment": "/*\n     * LPad Return a String, left padded with '0's as specified\n     * by the caller.\n     */"}}
{"code": {"body": "    private void resetDefaults( TableView tView ) {\n        Object[] colNames = tView.getColNames();\n        Object[][] tableValues = tView.getCalcdValues();\n        \n        JTable table = new JTable( tableValues, colNames );\n        tView.setViewColumnsWidth( table );\n        setTitle( tView.getViewTitle() );\n        \n        if ( mainSP != null ) getContentPane().remove( mainSP );\n        mainSP = new JScrollPane( table );\n        getContentPane().add( mainSP, \"\" );\n        validate();\n    }", "comment": "/*\n     * resetDefaults\n     */"}}
{"code": {"body": "        public String getFileName() { return fileName; }", "comment": "/*\n         * General getters.\n         */"}}
{"code": {"body": "        private void validateFile(String fileName) {\n            \n            File f = new File( fileName );\n            if ( !f.exists() || !f.canRead() ) {\n                System.err.println(\"\" + mainArgs[0]\n                    + \"\");\n                usage();\n                System.exit(2);\n            }\n            \n            \n            \n            \n            lineGuess = (int)(f.length() / (long)\"\".length());\n            lineGuess += (lineGuess / 10);\n            \n            \n            \n            if ( false ) {\n                System.out.println(\"\" + lineGuess);\n            }\n        }", "comment": "/*\n         * validateFile\n         */"}}
{"code": {"body": "        Object[] genColNames() {\n            Object[] retVal = {\n                \"\",\n                \"\",\n                \"\",\n                \"\",\n                \"\",\n                \"\",\n                \"\",\n                \"\",\n                \"\",\n                \"\",\n                \"\",\n                \"\",\n                \"\"\n            };\n            return retVal;\n        }", "comment": "/*\n         * genColNames is required by the base class.\n         */"}}
{"code": {"body": "        Object[][] genCalcdValues() {\n            Object[][] retValues = null;\n            \n            ArrayList fileStrings = lddFile.getFileStrings();\n            ArrayList dtObjects = lddFile.getDtObjects();\n            int numRows = fileStrings.size();\n            retValues = new Object[numRows][];\n            int numCols = colNames.length;\n            \n            \n            for (int nextStrNum = 0; nextStrNum < fileStrings.size(); ++ nextStrNum) {\n                retValues[nextStrNum] = new Object[numCols]; \n                \n                \n                \n                \n                int column = 0; \n                String fileString = (String)fileStrings.get(nextStrNum);\n                retValues[nextStrNum][column++] = fileString;\n                \n                DateTime adt = (DateTime)dtObjects.get(nextStrNum);\n                String adtStr = adt.toString();\n                retValues[nextStrNum][column++] = adtStr;\n                \n                \n                \n                retValues[nextStrNum][column++]  = new Integer( adt.getMillisOfSecond() );\n                retValues[nextStrNum][column++]  = new Integer( adt.getSecondOfMinute() );\n                retValues[nextStrNum][column++]  = new Integer( adt.getMinuteOfHour() );\n                retValues[nextStrNum][column++]  = new Integer( adt.getHourOfDay() );\n                retValues[nextStrNum][column++]  = new Integer( adt.getDayOfWeek() );\n                retValues[nextStrNum][column++]  = new Integer( adt.getDayOfMonth() );\n                retValues[nextStrNum][column++]  = new Integer( adt.getDayOfYear() );\n                retValues[nextStrNum][column++]  = new Integer( adt.getWeekOfWeekyear() );\n                retValues[nextStrNum][column++] = new Integer( adt.getWeekyear() );\n                retValues[nextStrNum][column++] = new Integer( adt.getMonthOfYear() );\n                retValues[nextStrNum][column++] = new Integer( adt.getYear() );\n                \n            } \n            if ( debugf ) dumpObjs( retValues, System.err );\n            return retValues;\n        }", "comment": "/*\n         * genCalcdValues is required by the base class.\n         */"}}
{"code": {"body": "        String getViewTitle() {\n            return \"\"\n                + \"\"\n                + TimeZone.getDefault().getDisplayName()\n                + \"\"\n                + \"\"\n                + currFile.getLoadedFileSize();\n        }", "comment": "/*\n         * getViewTitle\n         */"}}
{"code": {"body": "        void setViewColumnsWidth(JTable jt) {\n            \n            TableColumnModel colmodel = jt.getColumnModel();\n            TableColumn col0 = colmodel.getColumn(0);\n            col0.setPreferredWidth(200);\n            TableColumn col1 = colmodel.getColumn(1);\n            col1.setPreferredWidth(200);\n            return;\n        }", "comment": "/*\n         * setViewColumnLengths\n         */"}}
{"code": {"body": "        public void actionPerformed(ActionEvent e) {\n            int result = chooser.showOpenDialog( DateTimeBrowser.this );\n            String canPath = null;\n            if ( result == JFileChooser.APPROVE_OPTION ) {\n                File chosenFile = chooser.getSelectedFile();\n                try\n                {\n                    canPath = chosenFile.getCanonicalPath();\n                }\n                catch(IOException ioe)\n                {\n                    System.err.println( \"\"\n                        + chosenFile );\n                    \n                }\n                enableAllViews();\n                currFile = new LoadedFile( canPath );\n                TableView tView = getDefaultTableView();\n                resetDefaults( tView );\n            } \n        }", "comment": "/*\n         * actionPerformed\n         */"}}
{"code": {"body": "public DateTimePerformance() throws Exception {\n        checkJodaConstructor1();\n        checkJISOConstructor1();\n        checkGCalConstructor1();\n        checkDateConstructor1();\n        \n        checkJodaConstructor2();\n        checkJISOConstructor2();\n        checkGCalConstructor2();\n        checkDateConstructor2();\n        \n        checkJodaConstructor3();\n        checkJISOConstructor3();\n        checkGCalConstructor3();\n        checkDateConstructor3();\n        \n        checkJodaGetYear();\n        checkJISOGetYear();\n        checkGCalGetYear();\n        checkDateGetYear();\n        \n\n\n\n\n        \n\n\n\n\n        \n        checkJodaGetHour();\n        checkJISOGetHour();\n        checkGCalGetHour();\n        checkDateGetHour();\n        \n        checkJodaSetYear();\n        checkJISOSetYear();\n        checkGCalSetYear();\n        checkDateSetYear();\n        \n        checkJodaSetGetYear();\n        checkJISOSetGetYear();\n        checkGCalSetGetYear();\n        checkDateSetGetYear();\n        \n        checkJodaSetHour();\n        checkJISOSetHour();\n        checkGCalSetHour();\n        checkDateSetHour();\n        \n        checkJodaSetGetHour();\n        checkJISOSetGetHour();\n        checkGCalSetGetHour();\n        checkDateSetGetHour();\n        \n        checkJodaToString();\n        checkJISOToString();\n        checkGCalToString();\n        checkDateToString();\n        \n        System.out.println(\"\");\n        long jodaTotal = 0;\n        long jisoTotal = 0;\n        long gcalTotal = 0;\n        long dateTotal = 0;\n        for (Iterator it = resultList.iterator(); it.hasNext();) {\n            Result res = (Result) it.next();\n            System.out.println(res.object + \"\" + res.name + \"\" + res.avg + \"\");\n            if (res.object.equals(\"\")) {\n                jodaTotal += res.avg;\n            } else if (res.object.equals(\"\")) {\n                jisoTotal += res.avg;\n            } else if (res.object.equals(\"\")) {\n                gcalTotal += res.avg;\n            } else if (res.object.equals(\"\")) {\n                dateTotal += res.avg;\n                System.out.println(\"\");\n            }\n        }\n        System.out.println(\"\" + jodaTotal);\n        System.out.println(\"\" + jisoTotal);\n        System.out.println(\"\" + gcalTotal);\n        System.out.println(\"\" + dateTotal);\n    }", "comment": "/**\n     * Constructor\n     */"}}
{"code": {"body": "    public static void main(String[] args) {\n        try {\n            new DateTimePerformance();\n            \n        } catch (Throwable th) {\n            th.printStackTrace();\n        }\n    }", "comment": "/**\n     * Constructor\n     */"}}
{"code": {"body": "    private void start(String str1, String str2) {\n        result = (Result) results.get(str1 + str2);\n        if (result == null) {\n            result = new Result();\n            result.object = str1;\n            result.name = str2;\n            results.put(str1 + str2, result);\n            resultList.add(result);\n        }\n        start = System.currentTimeMillis();\n    }", "comment": "/**\n     * Start the stopwatch.\n     */"}}
{"code": {"body": "    private void end(int count) {\n        end = System.currentTimeMillis();\n        long time = (end - start);\n        result.time = result.time + time;\n        result.runs = result.runs + count;\n        result.avg = (result.time * 1000000) / result.runs;\n        System.out.print(\"\");\n    }", "comment": "/**\n     * End the stopwatch and print the result.\n     */"}}
{"code": {"body": "public DateMidnight() {\n        super();\n    }", "comment": "/**\n     * Constructs an instance set to the current system millisecond time\n     * using <code>ISOChronology</code> in the default time zone.\n     * The constructed object will have a local time of midnight.\n     * \n     * @see #now()\n     */"}}
{"code": {"body": "public DateMidnight(DateTimeZone zone) {\n        super(zone);\n    }", "comment": "/**\n     * Constructs an instance set to the current system millisecond time\n     * using <code>ISOChronology</code> in the specified time zone.\n     * The constructed object will have a local time of midnight.\n     * <p>\n     * If the specified time zone is null, the default zone is used.\n     *\n     * @param zone  the time zone, null means default zone\n     * @see #now(DateTimeZone)\n     */"}}
{"code": {"body": "public DateMidnight(Chronology chronology) {\n        super(chronology);\n    }", "comment": "/**\n     * Constructs an instance set to the current system millisecond time\n     * using the specified chronology.\n     * The constructed object will have a local time of midnight.\n     * <p>\n     * If the chronology is null, <code>ISOChronology</code>\n     * in the default time zone is used.\n     *\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     * @see #now(Chronology)\n     */"}}
{"code": {"body": "public DateMidnight(long instant) {\n        super(instant);\n    }", "comment": "/**\n     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n     * using <code>ISOChronology</code> in the default time zone.\n     * The constructed object will have a local time of midnight.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     */"}}
{"code": {"body": "public DateMidnight(long instant, DateTimeZone zone) {\n        super(instant, zone);\n    }", "comment": "/**\n     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n     * using <code>ISOChronology</code> in the specified time zone.\n     * The constructed object will have a local time of midnight.\n     * <p>\n     * If the specified time zone is null, the default zone is used.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     * @param zone  the time zone, null means default zone\n     */"}}
{"code": {"body": "public DateMidnight(long instant, Chronology chronology) {\n        super(instant, chronology);\n    }", "comment": "/**\n     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n     * using the specified chronology.\n     * The constructed object will have a local time of midnight.\n     * <p>\n     * If the chronology is null, <code>ISOChronology</code>\n     * in the default time zone is used.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     */"}}
{"code": {"body": "public DateMidnight(Object instant) {\n        super(instant, (Chronology) null);\n    }", "comment": "/**\n     * Constructs an instance from an Object that represents a datetime.\n     * The constructed object will have a local time of midnight.\n     * <p>\n     * If the object implies a chronology (such as GregorianCalendar does),\n     * then that chronology will be used. Otherwise, ISO default is used.\n     * Thus if a GregorianCalendar is passed in, the chronology used will\n     * be GJ, but if a Date is passed in the chronology will be ISO.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadableInstant, String, Calendar and Date.\n     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}.\n     *\n     * @param instant  the datetime object, null means now\n     * @throws IllegalArgumentException if the instant is invalid\n     */"}}
{"code": {"body": "public DateMidnight(Object instant, DateTimeZone zone) {\n        super(instant, zone);\n    }", "comment": "/**\n     * Constructs an instance from an Object that represents a datetime,\n     * forcing the time zone to that specified.\n     * The constructed object will have a local time of midnight.\n     * <p>\n     * If the object implies a chronology (such as GregorianCalendar does),\n     * then that chronology will be used, but with the time zone adjusted.\n     * Otherwise, ISO is used in the specified time zone.\n     * If the specified time zone is null, the default zone is used.\n     * Thus if a GregorianCalendar is passed in, the chronology used will\n     * be GJ, but if a Date is passed in the chronology will be ISO.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadableInstant, String, Calendar and Date.\n     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}.\n     *\n     * @param instant  the datetime object, null means now\n     * @param zone  the time zone, null means default time zone\n     * @throws IllegalArgumentException if the instant is invalid\n     */"}}
{"code": {"body": "public DateMidnight(Object instant, Chronology chronology) {\n        super(instant, DateTimeUtils.getChronology(chronology));\n    }", "comment": "/**\n     * Constructs an instance from an Object that represents a datetime,\n     * using the specified chronology.\n     * The constructed object will have a local time of midnight.\n     * <p>\n     * If the chronology is null, ISO in the default time zone is used.\n     * Any chronology implied by the object (such as GregorianCalendar does)\n     * is ignored.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadableInstant, String, Calendar and Date.\n     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}.\n     *\n     * @param instant  the datetime object, null means now\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     * @throws IllegalArgumentException if the instant is invalid\n     */"}}
{"code": {"body": "public DateMidnight(int year, int monthOfYear, int dayOfMonth) {\n        super(year, monthOfYear, dayOfMonth, 0, 0, 0, 0);\n    }", "comment": "/**\n     * Constructs an instance from datetime field values\n     * using <code>ISOChronology</code> in the default time zone.\n     * The constructed object will have a local time of midnight.\n     *\n     * @param year  the year\n     * @param monthOfYear  the month of the year, from 1 to 12\n     * @param dayOfMonth  the day of the month, from 1 to 31\n     */"}}
{"code": {"body": "public DateMidnight(int year, int monthOfYear, int dayOfMonth, DateTimeZone zone) {\n        super(year, monthOfYear, dayOfMonth, 0, 0, 0, 0, zone);\n    }", "comment": "/**\n     * Constructs an instance from datetime field values\n     * using <code>ISOChronology</code> in the specified time zone.\n     * The constructed object will have a local time of midnight.\n     * <p>\n     * If the specified time zone is null, the default zone is used.\n     *\n     * @param year  the year\n     * @param monthOfYear  the month of the year, from 1 to 12\n     * @param dayOfMonth  the day of the month, from 1 to 31\n     * @param zone  the time zone, null means default time zone\n     */"}}
{"code": {"body": "public DateMidnight(int year, int monthOfYear, int dayOfMonth, Chronology chronology) {\n        super(year, monthOfYear, dayOfMonth, 0, 0, 0, 0, chronology);\n    }", "comment": "/**\n     * Constructs an instance from datetime field values\n     * using the specified chronology.\n     * The constructed object will have a local time of midnight.\n     * <p>\n     * If the chronology is null, <code>ISOChronology</code>\n     * in the default time zone is used.\n     *\n     * @param year  the year, valid values defined by the chronology\n     * @param monthOfYear  the month of the year, valid values defined by the chronology\n     * @param dayOfMonth  the day of the month, valid values defined by the chronology\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     */"}}
{"code": {"body": "public DateMidnight withMillis(long newMillis) {\n        Chronology chrono = getChronology();\n        newMillis = checkInstant(newMillis, chrono);\n        return (newMillis == getMillis() ? this : new DateMidnight(newMillis, chrono));\n    }", "comment": "/**\n     * Returns a copy of this date with a different millisecond instant.\n     * The returned object will have a local time of midnight.\n     * <p>\n     * Only the millis will change, the chronology and time zone are kept.\n     * The returned object will be either be a new instance or <code>this</code>.\n     *\n     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z\n     * @return a copy of this instant with different millis\n     */"}}
{"code": {"body": "public DateMidnight withChronology(Chronology newChronology) {\n        return (newChronology == getChronology() ? this : new DateMidnight(getMillis(), newChronology));\n    }", "comment": "/**\n     * Returns a copy of this date with a different chronology, potentially\n     * changing the day in unexpected ways.\n     * <p>\n     * This method creates a new DateMidnight using the midnight millisecond value\n     * and the new chronology. If the same or similar chronology is specified, but\n     * with a different time zone, the day may change. This occurs because the new\n     * DateMidnight rounds down the millisecond value to get to midnight, and the\n     * time zone change may result in a rounding down to a different day.\n     * <p>\n     * For example, changing time zone from London (+00:00) to Paris (+01:00) will\n     * retain the same day, but changing from Paris to London will change the day.\n     * (When its midnight in London its the same day in Paris, but when its midnight\n     * in Paris its still the previous day in London)\n     * <p>\n     * To avoid these unusual effects, use {@link #withZoneRetainFields(DateTimeZone)}\n     * to change time zones.\n     *\n     * @param newChronology  the new chronology\n     * @return a copy of this instant with a different chronology\n     */"}}
{"code": {"body": "public DateMidnight withZoneRetainFields(DateTimeZone newZone) {\n        newZone = DateTimeUtils.getZone(newZone);\n        DateTimeZone originalZone = DateTimeUtils.getZone(getZone());\n        if (newZone == originalZone) {\n            return this;\n        }\n        \n        long millis = originalZone.getMillisKeepLocal(newZone, getMillis());\n        return new DateMidnight(millis, getChronology().withZone(newZone));\n    }", "comment": "/**\n     * Returns a copy of this date with a different time zone, preserving the day\n     * The returned object will have a local time of midnight in the new zone on\n     * the same day as the original instant.\n     *\n     * @param newZone  the new time zone, null means default\n     * @return a copy of this instant with a different time zone\n     */"}}
{"code": {"body": "public DateMidnight withFields(ReadablePartial partial) {\n        if (partial == null) {\n            return this;\n        }\n        return withMillis(getChronology().set(partial, getMillis()));\n    }", "comment": "/**\n     * Returns a copy of this date with the partial set of fields replacing those\n     * from this instance.\n     * <p>\n     * For example, if the partial is a <code>LocalDate</code> then the date fields\n     * would be changed in the returned instance.\n     * If the partial is null, then <code>this</code> is returned.\n     *\n     * @param partial  the partial set of fields to apply to this datetime, null ignored\n     * @return a copy of this datetime with a different set of fields\n     * @throws IllegalArgumentException if any value is invalid\n     */"}}
{"code": {"body": "public DateMidnight withField(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        long instant = fieldType.getField(getChronology()).set(getMillis(), value);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date with the specified field set to a new value.\n     * <p>\n     * For example, if the field type is <code>dayOfMonth</code> then the day of month\n     * field would be changed in the returned instance.\n     * If the field type is null, then <code>this</code> is returned.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * DateTime updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);\n     * DateTime updated = dt.dayOfMonth().setCopy(6);\n     * DateTime updated = dt.property(DateTimeFieldType.dayOfMonth()).setCopy(6);\n     * </pre>\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this datetime with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     */"}}
{"code": {"body": "public DateMidnight withFieldAdded(DurationFieldType fieldType, int amount) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (amount == 0) {\n            return this;\n        }\n        long instant = fieldType.getField(getChronology()).add(getMillis(), amount);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date with the value of the specified field increased.\n     * <p>\n     * If the addition is zero or the field is null, then <code>this</code> is returned.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * DateMidnight added = dt.withFieldAdded(DateTimeFieldType.year(), 6);\n     * DateMidnight added = dt.plusYears(6);\n     * DateMidnight added = dt.year().addToCopy(6);\n     * </pre>\n     * \n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this datetime with the field updated\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "public DateMidnight withDurationAdded(long durationToAdd, int scalar) {\n        if (durationToAdd == 0 || scalar == 0) {\n            return this;\n        }\n        long instant = getChronology().add(getMillis(), durationToAdd, scalar);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date with the specified duration added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * \n     * @param durationToAdd  the duration to add to this one\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this datetime with the duration added\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "public DateMidnight withDurationAdded(ReadableDuration durationToAdd, int scalar) {\n        if (durationToAdd == null || scalar == 0) {\n            return this;\n        }\n        return withDurationAdded(durationToAdd.getMillis(), scalar);\n    }", "comment": "/**\n     * Returns a copy of this date with the specified duration added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * \n     * @param durationToAdd  the duration to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this datetime with the duration added\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "public DateMidnight withPeriodAdded(ReadablePeriod period, int scalar) {\n        if (period == null || scalar == 0) {\n            return this;\n        }\n        long instant = getChronology().add(period, getMillis(), scalar);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date with the specified period added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to add multiple copies of complex\n     * period instances. Adding one field is best achieved using methods\n     * like {@link #withFieldAdded(DurationFieldType, int)}\n     * or {@link #plusYears(int)}.\n     * \n     * @param period  the period to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this datetime with the period added\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "public DateMidnight plus(long duration) {\n        return withDurationAdded(duration, 1);\n    }", "comment": "/**\n     * Returns a copy of this date with the specified duration added.\n     * <p>\n     * If the amount is zero, then <code>this</code> is returned.\n     * \n     * @param duration  the duration, in millis, to add to this one\n     * @return a copy of this datetime with the duration added\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "public DateMidnight plus(ReadableDuration duration) {\n        return withDurationAdded(duration, 1);\n    }", "comment": "/**\n     * Returns a copy of this date with the specified duration added.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * \n     * @param duration  the duration to add to this one, null means zero\n     * @return a copy of this datetime with the duration added\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "public DateMidnight plus(ReadablePeriod period) {\n        return withPeriodAdded(period, 1);\n    }", "comment": "/**\n     * Returns a copy of this date with the specified period added.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to add complex period instances.\n     * Adding one field is best achieved using methods\n     * like {@link #plusYears(int)}.\n     * \n     * @param period  the duration to add to this one, null means zero\n     * @return a copy of this datetime with the period added\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "public DateMidnight plusYears(int years) {\n        if (years == 0) {\n            return this;\n        }\n        long instant = getChronology().years().add(getMillis(), years);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date plus the specified number of years.\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateMidnight added = dt.plusYears(6);\n     * DateMidnight added = dt.plus(Period.years(6));\n     * DateMidnight added = dt.withFieldAdded(DurationFieldType.years(), 6);\n     * </pre>\n     *\n     * @param years  the amount of years to add, may be negative\n     * @return the new datetime plus the increased years\n     * @since 1.1\n     */"}}
{"code": {"body": "public DateMidnight plusMonths(int months) {\n        if (months == 0) {\n            return this;\n        }\n        long instant = getChronology().months().add(getMillis(), months);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date plus the specified number of months.\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateMidnight added = dt.plusMonths(6);\n     * DateMidnight added = dt.plus(Period.months(6));\n     * DateMidnight added = dt.withFieldAdded(DurationFieldType.months(), 6);\n     * </pre>\n     *\n     * @param months  the amount of months to add, may be negative\n     * @return the new datetime plus the increased months\n     * @since 1.1\n     */"}}
{"code": {"body": "public DateMidnight plusWeeks(int weeks) {\n        if (weeks == 0) {\n            return this;\n        }\n        long instant = getChronology().weeks().add(getMillis(), weeks);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date plus the specified number of weeks.\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateMidnight added = dt.plusWeeks(6);\n     * DateMidnight added = dt.plus(Period.weeks(6));\n     * DateMidnight added = dt.withFieldAdded(DurationFieldType.weeks(), 6);\n     * </pre>\n     *\n     * @param weeks  the amount of weeks to add, may be negative\n     * @return the new datetime plus the increased weeks\n     * @since 1.1\n     */"}}
{"code": {"body": "public DateMidnight plusDays(int days) {\n        if (days == 0) {\n            return this;\n        }\n        long instant = getChronology().days().add(getMillis(), days);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date plus the specified number of days.\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateMidnight added = dt.plusDays(6);\n     * DateMidnight added = dt.plus(Period.days(6));\n     * DateMidnight added = dt.withFieldAdded(DurationFieldType.days(), 6);\n     * </pre>\n     *\n     * @param days  the amount of days to add, may be negative\n     * @return the new datetime plus the increased days\n     * @since 1.1\n     */"}}
{"code": {"body": "public DateMidnight minus(long duration) {\n        return withDurationAdded(duration, -1);\n    }", "comment": "/**\n     * Returns a copy of this date with the specified duration taken away.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * \n     * @param duration  the duration, in millis, to reduce this instant by\n     * @return a copy of this datetime with the duration taken away\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "public DateMidnight minus(ReadableDuration duration) {\n        return withDurationAdded(duration, -1);\n    }", "comment": "/**\n     * Returns a copy of this date with the specified duration taken away.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * \n     * @param duration  the duration to reduce this instant by\n     * @return a copy of this datetime with the duration taken away\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "public DateMidnight minus(ReadablePeriod period) {\n        return withPeriodAdded(period, -1);\n    }", "comment": "/**\n     * Returns a copy of this date with the specified period taken away.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to subtract complex period instances.\n     * Subtracting one field is best achieved using methods\n     * like {@link #minusYears(int)}.\n     * \n     * @param period  the period to reduce this instant by\n     * @return a copy of this datetime with the period taken away\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "public DateMidnight minusYears(int years) {\n        if (years == 0) {\n            return this;\n        }\n        long instant = getChronology().years().subtract(getMillis(), years);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date minus the specified number of years.\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateTime subtracted = dt.minusYears(6);\n     * DateTime subtracted = dt.minus(Period.years(6));\n     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);\n     * </pre>\n     *\n     * @param years  the amount of years to subtract, may be negative\n     * @return the new datetime minus the increased years\n     * @since 1.1\n     */"}}
{"code": {"body": "public DateMidnight minusMonths(int months) {\n        if (months == 0) {\n            return this;\n        }\n        long instant = getChronology().months().subtract(getMillis(), months);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date minus the specified number of months.\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateMidnight subtracted = dt.minusMonths(6);\n     * DateMidnight subtracted = dt.minus(Period.months(6));\n     * DateMidnight subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);\n     * </pre>\n     *\n     * @param months  the amount of months to subtract, may be negative\n     * @return the new datetime minus the increased months\n     * @since 1.1\n     */"}}
{"code": {"body": "public DateMidnight minusWeeks(int weeks) {\n        if (weeks == 0) {\n            return this;\n        }\n        long instant = getChronology().weeks().subtract(getMillis(), weeks);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date minus the specified number of weeks.\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateMidnight subtracted = dt.minusWeeks(6);\n     * DateMidnight subtracted = dt.minus(Period.weeks(6));\n     * DateMidnight subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6);\n     * </pre>\n     *\n     * @param weeks  the amount of weeks to subtract, may be negative\n     * @return the new datetime minus the increased weeks\n     * @since 1.1\n     */"}}
{"code": {"body": "public DateMidnight minusDays(int days) {\n        if (days == 0) {\n            return this;\n        }\n        long instant = getChronology().days().subtract(getMillis(), days);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date minus the specified number of days.\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateMidnight subtracted = dt.minusDays(6);\n     * DateMidnight subtracted = dt.minus(Period.days(6));\n     * DateMidnight subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);\n     * </pre>\n     *\n     * @param days  the amount of days to subtract, may be negative\n     * @return the new datetime minus the increased days\n     * @since 1.1\n     */"}}
{"code": {"body": "public DateMidnight withEra(int era) {\n        return withMillis(getChronology().era().set(getMillis(), era));\n    }", "comment": "/**\n     * Returns a copy of this date with the era field updated.\n     * <p>\n     * DateMidnight is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * era changed.\n     *\n     * @param era  the era to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "public DateMidnight withCenturyOfEra(int centuryOfEra) {\n        return withMillis(getChronology().centuryOfEra().set(getMillis(), centuryOfEra));\n    }", "comment": "/**\n     * Returns a copy of this date with the century of era field updated.\n     * <p>\n     * DateMidnight is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * century of era changed.\n     *\n     * @param centuryOfEra  the centurey of era to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "public DateMidnight withYearOfEra(int yearOfEra) {\n        return withMillis(getChronology().yearOfEra().set(getMillis(), yearOfEra));\n    }", "comment": "/**\n     * Returns a copy of this date with the year of era field updated.\n     * <p>\n     * DateMidnight is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year of era changed.\n     *\n     * @param yearOfEra  the year of era to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "public DateMidnight withYearOfCentury(int yearOfCentury) {\n        return withMillis(getChronology().yearOfCentury().set(getMillis(), yearOfCentury));\n    }", "comment": "/**\n     * Returns a copy of this date with the year of century field updated.\n     * <p>\n     * DateMidnight is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year of century changed.\n     *\n     * @param yearOfCentury  the year of century to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "public DateMidnight withYear(int year) {\n        return withMillis(getChronology().year().set(getMillis(), year));\n    }", "comment": "/**\n     * Returns a copy of this date with the year field updated.\n     * <p>\n     * DateMidnight is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year changed.\n     *\n     * @param year  the year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "public DateMidnight withWeekyear(int weekyear) {\n        return withMillis(getChronology().weekyear().set(getMillis(), weekyear));\n    }", "comment": "/**\n     * Returns a copy of this date with the weekyear field updated.\n     * <p>\n     * The weekyear is the year that matches with the weekOfWeekyear field.\n     * In the standard ISO8601 week algorithm, the first week of the year\n     * is that in which at least 4 days are in the year. As a result of this\n     * definition, day 1 of the first week may be in the previous year.\n     * The weekyear allows you to query the effective year for that day.\n     * <p>\n     * DateMidnight is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * weekyear changed.\n     *\n     * @param weekyear  the weekyear to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "public DateMidnight withMonthOfYear(int monthOfYear) {\n        return withMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear));\n    }", "comment": "/**\n     * Returns a copy of this date with the month of year field updated.\n     * <p>\n     * DateMidnight is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * month of year changed.\n     *\n     * @param monthOfYear  the month of year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "public DateMidnight withWeekOfWeekyear(int weekOfWeekyear) {\n        return withMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear));\n    }", "comment": "/**\n     * Returns a copy of this date with the week of weekyear field updated.\n     * <p>\n     * This field is associated with the \"weekyear\" via {@link #withWeekyear(int)}.\n     * In the standard ISO8601 week algorithm, the first week of the year\n     * is that in which at least 4 days are in the year. As a result of this\n     * definition, day 1 of the first week may be in the previous year.\n     * <p>\n     * DateMidnight is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * week of weekyear changed.\n     *\n     * @param weekOfWeekyear  the week of weekyear to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "public DateMidnight withDayOfYear(int dayOfYear) {\n        return withMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear));\n    }", "comment": "/**\n     * Returns a copy of this date with the day of year field updated.\n     * <p>\n     * DateMidnight is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of year changed.\n     *\n     * @param dayOfYear  the day of year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "public DateMidnight withDayOfMonth(int dayOfMonth) {\n        return withMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth));\n    }", "comment": "/**\n     * Returns a copy of this date with the day of month field updated.\n     * <p>\n     * DateMidnight is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of month changed.\n     *\n     * @param dayOfMonth  the day of month to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "public DateMidnight withDayOfWeek(int dayOfWeek) {\n        return withMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek));\n    }", "comment": "/**\n     * Returns a copy of this date with the day of week field updated.\n     * <p>\n     * DateMidnight is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of week changed.\n     *\n     * @param dayOfWeek  the day of week to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "public DateMidnight getDateMidnight() {\n            return iInstant;\n        }", "comment": "/**\n         * Gets the datetime being used.\n         * \n         * @return the datetime\n         */"}}
{"code": {"body": "public DateMidnight addToCopy(int value) {\n            return iInstant.withMillis(iField.add(iInstant.getMillis(), value));\n        }", "comment": "/**\n         * Adds to this field in a copy of this DateMidnight.\n         * <p>\n         * The DateMidnight attached to this property is unchanged by this call.\n         * This operation is faster than converting a DateMidnight to a MutableDateTime\n         * and back again when setting one field. When setting multiple fields,\n         * it is generally quicker to make the conversion to MutableDateTime.\n         * \n         * @param value  the value to add to the field in the copy\n         * @return a copy of the DateMidnight with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "public DateMidnight addToCopy(long value) {\n            return iInstant.withMillis(iField.add(iInstant.getMillis(), value));\n        }", "comment": "/**\n         * Adds to this field in a copy of this DateMidnight.\n         * <p>\n         * The DateMidnight attached to this property is unchanged by this call.\n         * This operation is faster than converting a DateMidnight to a MutableDateTime\n         * and back again when setting one field. When setting multiple fields,\n         * it is generally quicker to make the conversion to MutableDateTime.\n         * \n         * @param value  the value to add to the field in the copy\n         * @return a copy of the DateMidnight with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "public DateMidnight addWrapFieldToCopy(int value) {\n            return iInstant.withMillis(iField.addWrapField(iInstant.getMillis(), value));\n        }", "comment": "/**\n         * Adds to this field, possibly wrapped, in a copy of this DateMidnight.\n         * A wrapped operation only changes this field.\n         * Thus 31st January addWrapField one day goes to the 1st January.\n         * <p>\n         * The DateMidnight attached to this property is unchanged by this call.\n         * This operation is faster than converting a DateMidnight to a MutableDateTime\n         * and back again when setting one field. When setting multiple fields,\n         * it is generally quicker to make the conversion to MutableDateTime.\n         * \n         * @param value  the value to add to the field in the copy\n         * @return a copy of the DateMidnight with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "public DateMidnight setCopy(int value) {\n            return iInstant.withMillis(iField.set(iInstant.getMillis(), value));\n        }", "comment": "/**\n         * Sets this field in a copy of the DateMidnight.\n         * <p>\n         * The DateMidnight attached to this property is unchanged by this call.\n         * This operation is faster than converting a DateMidnight to a MutableDateTime\n         * and back again when setting one field. When setting multiple fields,\n         * it is generally quicker to make the conversion to MutableDateTime.\n         * \n         * @param value  the value to set the field in the copy to\n         * @return a copy of the DateMidnight with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "public DateMidnight setCopy(String text, Locale locale) {\n            return iInstant.withMillis(iField.set(iInstant.getMillis(), text, locale));\n        }", "comment": "/**\n         * Sets this field in a copy of the DateMidnight to a parsed text value.\n         * <p>\n         * The DateMidnight attached to this property is unchanged by this call.\n         * This operation is faster than converting a DateMidnight to a MutableDateTime\n         * and back again when setting one field. When setting multiple fields,\n         * it is generally quicker to make the conversion to MutableDateTime.\n         * \n         * @param text  the text value to set\n         * @param locale  optional locale to use for selecting a text symbol\n         * @return a copy of the DateMidnight with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */"}}
{"code": {"body": "public DateMidnight setCopy(String text) {\n            return setCopy(text, null);\n        }", "comment": "/**\n         * Sets this field in a copy of the DateMidnight to a parsed text value.\n         * <p>\n         * The DateMidnight attached to this property is unchanged by this call.\n         * This operation is faster than converting a DateMidnight to a MutableDateTime\n         * and back again when setting one field. When setting multiple fields,\n         * it is generally quicker to make the conversion to MutableDateTime.\n         * \n         * @param text  the text value to set\n         * @return a copy of the DateMidnight with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */"}}
{"code": {"body": "public DateMidnight withMaximumValue() {\n            return setCopy(getMaximumValue());\n        }", "comment": "/**\n         * Returns a new DateMidnight with this field set to the maximum value\n         * for this field.\n         * <p>\n         * This operation is useful for obtaining a DateTime on the last day\n         * of the month, as month lengths vary.\n         * <pre>\n         * DateMidnight lastDayOfMonth = dt.dayOfMonth().withMaximumValue();\n         * </pre>\n         * <p>\n         * The DateMidnight attached to this property is unchanged by this call.\n         *\n         * @return a copy of the DateMidnight with this field set to its maximum\n         * @since 1.2\n         */"}}
{"code": {"body": "public DateMidnight withMinimumValue() {\n            return setCopy(getMinimumValue());\n        }", "comment": "/**\n         * Returns a new DateMidnight with this field set to the minimum value\n         * for this field.\n         * <p>\n         * The DateMidnight attached to this property is unchanged by this call.\n         *\n         * @return a copy of the DateMidnight with this field set to its minimum\n         * @since 1.2\n         */"}}
{"code": {"body": "public DateMidnight roundFloorCopy() {\n            return iInstant.withMillis(iField.roundFloor(iInstant.getMillis()));\n        }", "comment": "/**\n         * Rounds to the lowest whole unit of this field on a copy of this DateMidnight.\n         *\n         * @return a copy of the DateMidnight with the field value changed\n         */"}}
{"code": {"body": "public DateMidnight roundCeilingCopy() {\n            return iInstant.withMillis(iField.roundCeiling(iInstant.getMillis()));\n        }", "comment": "/**\n         * Rounds to the highest whole unit of this field on a copy of this DateMidnight.\n         *\n         * @return a copy of the DateMidnight with the field value changed\n         */"}}
{"code": {"body": "public DateMidnight roundHalfFloorCopy() {\n            return iInstant.withMillis(iField.roundHalfFloor(iInstant.getMillis()));\n        }", "comment": "/**\n         * Rounds to the nearest whole unit of this field on a copy of this DateMidnight,\n         * favoring the floor if halfway.\n         *\n         * @return a copy of the DateMidnight with the field value changed\n         */"}}
{"code": {"body": "public DateMidnight roundHalfCeilingCopy() {\n            return iInstant.withMillis(iField.roundHalfCeiling(iInstant.getMillis()));\n        }", "comment": "/**\n         * Rounds to the nearest whole unit of this field on a copy of this DateMidnight,\n         * favoring the ceiling if halfway.\n         *\n         * @return a copy of the DateMidnight with the field value changed\n         */"}}
{"code": {"body": "public DateMidnight roundHalfEvenCopy() {\n            return iInstant.withMillis(iField.roundHalfEven(iInstant.getMillis()));\n        }", "comment": "/**\n         * Rounds to the nearest whole unit of this field on a copy of this DateMidnight.\n         * If halfway, the ceiling is favored over the floor only if it makes this field's value even.\n         *\n         * @return a copy of the DateMidnight with the field value changed\n         */"}}
{"code": {"body": "    public static DateMidnight now(Chronology chronology) {\n        if (chronology == null) {\n            throw new NullPointerException(\"\");\n        }\n        return new DateMidnight(chronology);\n    }", "comment": "/**\n     * Obtains a {@code DateMidnight} set to the current system millisecond time\n     * using the specified chronology.\n     * The constructed object will have a local time of midnight.\n     *\n     * @param chronology  the chronology, not null\n     * @return the current date, not null\n     * @since 2.0\n     */"}}
{"code": {"body": "    public static DateMidnight parse(String str, DateTimeFormatter formatter) {\n        return formatter.parseDateTime(str).toDateMidnight();\n    }", "comment": "/**\n     * Parses a {@code DateMidnight} from the specified string using a formatter.\n     * \n     * @param str  the string to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @since 2.0\n     */"}}
{"code": {"body": "    protected long checkInstant(long instant, Chronology chronology) {\n        return chronology.dayOfMonth().roundFloor(instant);\n    }", "comment": "/**\n     * Rounds the specified instant to midnight.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n     * @param chronology  the chronology to use, not null\n     * @return the updated instant, rounded to midnight\n     */"}}
{"code": {"body": "    public DateMidnight withMillis(long newMillis) {\n        Chronology chrono = getChronology();\n        newMillis = checkInstant(newMillis, chrono);\n        return (newMillis == getMillis() ? this : new DateMidnight(newMillis, chrono));\n    }", "comment": "/**\n     * Returns a copy of this date with a different millisecond instant.\n     * The returned object will have a local time of midnight.\n     * <p>\n     * Only the millis will change, the chronology and time zone are kept.\n     * The returned object will be either be a new instance or <code>this</code>.\n     *\n     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z\n     * @return a copy of this instant with different millis\n     */"}}
{"code": {"body": "    public DateMidnight withChronology(Chronology newChronology) {\n        return (newChronology == getChronology() ? this : new DateMidnight(getMillis(), newChronology));\n    }", "comment": "/**\n     * Returns a copy of this date with a different chronology, potentially\n     * changing the day in unexpected ways.\n     * <p>\n     * This method creates a new DateMidnight using the midnight millisecond value\n     * and the new chronology. If the same or similar chronology is specified, but\n     * with a different time zone, the day may change. This occurs because the new\n     * DateMidnight rounds down the millisecond value to get to midnight, and the\n     * time zone change may result in a rounding down to a different day.\n     * <p>\n     * For example, changing time zone from London (+00:00) to Paris (+01:00) will\n     * retain the same day, but changing from Paris to London will change the day.\n     * (When its midnight in London its the same day in Paris, but when its midnight\n     * in Paris its still the previous day in London)\n     * <p>\n     * To avoid these unusual effects, use {@link #withZoneRetainFields(DateTimeZone)}\n     * to change time zones.\n     *\n     * @param newChronology  the new chronology\n     * @return a copy of this instant with a different chronology\n     */"}}
{"code": {"body": "    public DateMidnight withZoneRetainFields(DateTimeZone newZone) {\n        newZone = DateTimeUtils.getZone(newZone);\n        DateTimeZone originalZone = DateTimeUtils.getZone(getZone());\n        if (newZone == originalZone) {\n            return this;\n        }\n        \n        long millis = originalZone.getMillisKeepLocal(newZone, getMillis());\n        return new DateMidnight(millis, getChronology().withZone(newZone));\n    }", "comment": "/**\n     * Returns a copy of this date with a different time zone, preserving the day\n     * The returned object will have a local time of midnight in the new zone on\n     * the same day as the original instant.\n     *\n     * @param newZone  the new time zone, null means default\n     * @return a copy of this instant with a different time zone\n     */"}}
{"code": {"body": "    public DateMidnight withFields(ReadablePartial partial) {\n        if (partial == null) {\n            return this;\n        }\n        return withMillis(getChronology().set(partial, getMillis()));\n    }", "comment": "/**\n     * Returns a copy of this date with the partial set of fields replacing those\n     * from this instance.\n     * <p>\n     * For example, if the partial is a <code>LocalDate</code> then the date fields\n     * would be changed in the returned instance.\n     * If the partial is null, then <code>this</code> is returned.\n     *\n     * @param partial  the partial set of fields to apply to this datetime, null ignored\n     * @return a copy of this datetime with a different set of fields\n     * @throws IllegalArgumentException if any value is invalid\n     */"}}
{"code": {"body": "    public DateMidnight withField(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        long instant = fieldType.getField(getChronology()).set(getMillis(), value);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date with the specified field set to a new value.\n     * <p>\n     * For example, if the field type is <code>dayOfMonth</code> then the day of month\n     * field would be changed in the returned instance.\n     * If the field type is null, then <code>this</code> is returned.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * DateTime updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);\n     * DateTime updated = dt.dayOfMonth().setCopy(6);\n     * DateTime updated = dt.property(DateTimeFieldType.dayOfMonth()).setCopy(6);\n     * </pre>\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this datetime with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     */"}}
{"code": {"body": "    public DateMidnight withFieldAdded(DurationFieldType fieldType, int amount) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (amount == 0) {\n            return this;\n        }\n        long instant = fieldType.getField(getChronology()).add(getMillis(), amount);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date with the value of the specified field increased.\n     * <p>\n     * If the addition is zero or the field is null, then <code>this</code> is returned.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * DateMidnight added = dt.withFieldAdded(DateTimeFieldType.year(), 6);\n     * DateMidnight added = dt.plusYears(6);\n     * DateMidnight added = dt.year().addToCopy(6);\n     * </pre>\n     * \n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this datetime with the field updated\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "    public DateMidnight withDurationAdded(ReadableDuration durationToAdd, int scalar) {\n        if (durationToAdd == null || scalar == 0) {\n            return this;\n        }\n        return withDurationAdded(durationToAdd.getMillis(), scalar);\n    }", "comment": "/**\n     * Returns a copy of this date with the specified duration added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * \n     * @param durationToAdd  the duration to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this datetime with the duration added\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "    public DateMidnight withPeriodAdded(ReadablePeriod period, int scalar) {\n        if (period == null || scalar == 0) {\n            return this;\n        }\n        long instant = getChronology().add(period, getMillis(), scalar);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date with the specified period added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to add multiple copies of complex\n     * period instances. Adding one field is best achieved using methods\n     * like {@link #withFieldAdded(DurationFieldType, int)}\n     * or {@link #plusYears(int)}.\n     * \n     * @param period  the period to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this datetime with the period added\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "    public DateMidnight plus(ReadablePeriod period) {\n        return withPeriodAdded(period, 1);\n    }", "comment": "/**\n     * Returns a copy of this date with the specified period added.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to add complex period instances.\n     * Adding one field is best achieved using methods\n     * like {@link #plusYears(int)}.\n     * \n     * @param period  the duration to add to this one, null means zero\n     * @return a copy of this datetime with the period added\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "    public DateMidnight plusYears(int years) {\n        if (years == 0) {\n            return this;\n        }\n        long instant = getChronology().years().add(getMillis(), years);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date plus the specified number of years.\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateMidnight added = dt.plusYears(6);\n     * DateMidnight added = dt.plus(Period.years(6));\n     * DateMidnight added = dt.withFieldAdded(DurationFieldType.years(), 6);\n     * </pre>\n     *\n     * @param years  the amount of years to add, may be negative\n     * @return the new datetime plus the increased years\n     * @since 1.1\n     */"}}
{"code": {"body": "    public DateMidnight plusMonths(int months) {\n        if (months == 0) {\n            return this;\n        }\n        long instant = getChronology().months().add(getMillis(), months);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date plus the specified number of months.\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateMidnight added = dt.plusMonths(6);\n     * DateMidnight added = dt.plus(Period.months(6));\n     * DateMidnight added = dt.withFieldAdded(DurationFieldType.months(), 6);\n     * </pre>\n     *\n     * @param months  the amount of months to add, may be negative\n     * @return the new datetime plus the increased months\n     * @since 1.1\n     */"}}
{"code": {"body": "    public DateMidnight plusWeeks(int weeks) {\n        if (weeks == 0) {\n            return this;\n        }\n        long instant = getChronology().weeks().add(getMillis(), weeks);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date plus the specified number of weeks.\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateMidnight added = dt.plusWeeks(6);\n     * DateMidnight added = dt.plus(Period.weeks(6));\n     * DateMidnight added = dt.withFieldAdded(DurationFieldType.weeks(), 6);\n     * </pre>\n     *\n     * @param weeks  the amount of weeks to add, may be negative\n     * @return the new datetime plus the increased weeks\n     * @since 1.1\n     */"}}
{"code": {"body": "    public DateMidnight plusDays(int days) {\n        if (days == 0) {\n            return this;\n        }\n        long instant = getChronology().days().add(getMillis(), days);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date plus the specified number of days.\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateMidnight added = dt.plusDays(6);\n     * DateMidnight added = dt.plus(Period.days(6));\n     * DateMidnight added = dt.withFieldAdded(DurationFieldType.days(), 6);\n     * </pre>\n     *\n     * @param days  the amount of days to add, may be negative\n     * @return the new datetime plus the increased days\n     * @since 1.1\n     */"}}
{"code": {"body": "    public DateMidnight minus(ReadablePeriod period) {\n        return withPeriodAdded(period, -1);\n    }", "comment": "/**\n     * Returns a copy of this date with the specified period taken away.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to subtract complex period instances.\n     * Subtracting one field is best achieved using methods\n     * like {@link #minusYears(int)}.\n     * \n     * @param period  the period to reduce this instant by\n     * @return a copy of this datetime with the period taken away\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "    public DateMidnight minusYears(int years) {\n        if (years == 0) {\n            return this;\n        }\n        long instant = getChronology().years().subtract(getMillis(), years);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date minus the specified number of years.\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateTime subtracted = dt.minusYears(6);\n     * DateTime subtracted = dt.minus(Period.years(6));\n     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);\n     * </pre>\n     *\n     * @param years  the amount of years to subtract, may be negative\n     * @return the new datetime minus the increased years\n     * @since 1.1\n     */"}}
{"code": {"body": "    public DateMidnight minusMonths(int months) {\n        if (months == 0) {\n            return this;\n        }\n        long instant = getChronology().months().subtract(getMillis(), months);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date minus the specified number of months.\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateMidnight subtracted = dt.minusMonths(6);\n     * DateMidnight subtracted = dt.minus(Period.months(6));\n     * DateMidnight subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);\n     * </pre>\n     *\n     * @param months  the amount of months to subtract, may be negative\n     * @return the new datetime minus the increased months\n     * @since 1.1\n     */"}}
{"code": {"body": "    public DateMidnight minusWeeks(int weeks) {\n        if (weeks == 0) {\n            return this;\n        }\n        long instant = getChronology().weeks().subtract(getMillis(), weeks);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date minus the specified number of weeks.\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateMidnight subtracted = dt.minusWeeks(6);\n     * DateMidnight subtracted = dt.minus(Period.weeks(6));\n     * DateMidnight subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6);\n     * </pre>\n     *\n     * @param weeks  the amount of weeks to subtract, may be negative\n     * @return the new datetime minus the increased weeks\n     * @since 1.1\n     */"}}
{"code": {"body": "    public DateMidnight minusDays(int days) {\n        if (days == 0) {\n            return this;\n        }\n        long instant = getChronology().days().subtract(getMillis(), days);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date minus the specified number of days.\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateMidnight subtracted = dt.minusDays(6);\n     * DateMidnight subtracted = dt.minus(Period.days(6));\n     * DateMidnight subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);\n     * </pre>\n     *\n     * @param days  the amount of days to subtract, may be negative\n     * @return the new datetime minus the increased days\n     * @since 1.1\n     */"}}
{"code": {"body": "    public Property property(DateTimeFieldType type) {\n        if (type == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        DateTimeField field = type.getField(getChronology());\n        if (field.isSupported() == false) {\n            throw new IllegalArgumentException(\"\" + type + \"\");\n        }\n        return new Property(this, field);\n    }", "comment": "/**\n     * Gets the property object for the specified type, which contains many useful methods.\n     *\n     * @param type  the field type to get the chronology for\n     * @return the property object\n     * @throws IllegalArgumentException if the field is null or unsupported\n     */"}}
{"code": {"body": "    public LocalDate toLocalDate() {\n        return new LocalDate(getMillis(), getChronology());\n    }", "comment": "/**\n     * Converts this object to a <code>LocalDate</code> with the\n     * same date and chronology.\n     *\n     * @return a LocalDate with the same date and chronology\n     * @since 1.3\n     */"}}
{"code": {"body": "    public Interval toInterval() {\n        Chronology chrono = getChronology();\n        long start = getMillis();\n        long end = DurationFieldType.days().getField(chrono).add(start, 1);\n        return new Interval(start, end, chrono);\n    }", "comment": "/**\n     * Converts this object to an <code>Interval</code> encompassing\n     * the whole of this day.\n     * <p>\n     * The interval starts at midnight 00:00 and ends at 00:00 the following day,\n     * (which is not included in the interval, as intervals are half-open).\n     * \n     * @return an interval over the day\n     */"}}
{"code": {"body": "    public DateMidnight withEra(int era) {\n        return withMillis(getChronology().era().set(getMillis(), era));\n    }", "comment": "/**\n     * Returns a copy of this date with the era field updated.\n     * <p>\n     * DateMidnight is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * era changed.\n     *\n     * @param era  the era to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "    public DateMidnight withCenturyOfEra(int centuryOfEra) {\n        return withMillis(getChronology().centuryOfEra().set(getMillis(), centuryOfEra));\n    }", "comment": "/**\n     * Returns a copy of this date with the century of era field updated.\n     * <p>\n     * DateMidnight is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * century of era changed.\n     *\n     * @param centuryOfEra  the centurey of era to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "    public DateMidnight withYearOfEra(int yearOfEra) {\n        return withMillis(getChronology().yearOfEra().set(getMillis(), yearOfEra));\n    }", "comment": "/**\n     * Returns a copy of this date with the year of era field updated.\n     * <p>\n     * DateMidnight is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year of era changed.\n     *\n     * @param yearOfEra  the year of era to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "    public DateMidnight withYearOfCentury(int yearOfCentury) {\n        return withMillis(getChronology().yearOfCentury().set(getMillis(), yearOfCentury));\n    }", "comment": "/**\n     * Returns a copy of this date with the year of century field updated.\n     * <p>\n     * DateMidnight is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year of century changed.\n     *\n     * @param yearOfCentury  the year of century to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "    public DateMidnight withYear(int year) {\n        return withMillis(getChronology().year().set(getMillis(), year));\n    }", "comment": "/**\n     * Returns a copy of this date with the year field updated.\n     * <p>\n     * DateMidnight is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year changed.\n     *\n     * @param year  the year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "    public DateMidnight withWeekyear(int weekyear) {\n        return withMillis(getChronology().weekyear().set(getMillis(), weekyear));\n    }", "comment": "/**\n     * Returns a copy of this date with the weekyear field updated.\n     * <p>\n     * The weekyear is the year that matches with the weekOfWeekyear field.\n     * In the standard ISO8601 week algorithm, the first week of the year\n     * is that in which at least 4 days are in the year. As a result of this\n     * definition, day 1 of the first week may be in the previous year.\n     * The weekyear allows you to query the effective year for that day.\n     * <p>\n     * DateMidnight is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * weekyear changed.\n     *\n     * @param weekyear  the weekyear to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "    public DateMidnight withMonthOfYear(int monthOfYear) {\n        return withMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear));\n    }", "comment": "/**\n     * Returns a copy of this date with the month of year field updated.\n     * <p>\n     * DateMidnight is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * month of year changed.\n     *\n     * @param monthOfYear  the month of year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "    public DateMidnight withWeekOfWeekyear(int weekOfWeekyear) {\n        return withMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear));\n    }", "comment": "/**\n     * Returns a copy of this date with the week of weekyear field updated.\n     * <p>\n     * This field is associated with the \"weekyear\" via {@link #withWeekyear(int)}.\n     * In the standard ISO8601 week algorithm, the first week of the year\n     * is that in which at least 4 days are in the year. As a result of this\n     * definition, day 1 of the first week may be in the previous year.\n     * <p>\n     * DateMidnight is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * week of weekyear changed.\n     *\n     * @param weekOfWeekyear  the week of weekyear to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "    public DateMidnight withDayOfYear(int dayOfYear) {\n        return withMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear));\n    }", "comment": "/**\n     * Returns a copy of this date with the day of year field updated.\n     * <p>\n     * DateMidnight is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of year changed.\n     *\n     * @param dayOfYear  the day of year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "    public DateMidnight withDayOfMonth(int dayOfMonth) {\n        return withMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth));\n    }", "comment": "/**\n     * Returns a copy of this date with the day of month field updated.\n     * <p>\n     * DateMidnight is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of month changed.\n     *\n     * @param dayOfMonth  the day of month to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "    public DateMidnight withDayOfWeek(int dayOfWeek) {\n        return withMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek));\n    }", "comment": "/**\n     * Returns a copy of this date with the day of week field updated.\n     * <p>\n     * DateMidnight is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of week changed.\n     *\n     * @param dayOfWeek  the day of week to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "    public Property era() {\n        return new Property(this, getChronology().era());\n    }", "comment": "/**\n     * Get the era property which provides access to advanced functionality.\n     * \n     * @return the era property\n     */"}}
{"code": {"body": "    public Property centuryOfEra() {\n        return new Property(this, getChronology().centuryOfEra());\n    }", "comment": "/**\n     * Get the century of era property which provides access to advanced functionality.\n     * \n     * @return the year of era property\n     */"}}
{"code": {"body": "    public Property yearOfCentury() {\n        return new Property(this, getChronology().yearOfCentury());\n    }", "comment": "/**\n     * Get the year of century property which provides access to advanced functionality.\n     * \n     * @return the year of era property\n     */"}}
{"code": {"body": "    public Property yearOfEra() {\n        return new Property(this, getChronology().yearOfEra());\n    }", "comment": "/**\n     * Get the year of era property which provides access to advanced functionality.\n     * \n     * @return the year of era property\n     */"}}
{"code": {"body": "    public Property year() {\n        return new Property(this, getChronology().year());\n    }", "comment": "/**\n     * Get the year property which provides access to advanced functionality.\n     * \n     * @return the year property\n     */"}}
{"code": {"body": "    public Property weekyear() {\n        return new Property(this, getChronology().weekyear());\n    }", "comment": "/**\n     * Get the year of a week based year property which provides access to advanced functionality.\n     * \n     * @return the year of a week based year property\n     */"}}
{"code": {"body": "    public Property monthOfYear() {\n        return new Property(this, getChronology().monthOfYear());\n    }", "comment": "/**\n     * Get the month of year property which provides access to advanced functionality.\n     * \n     * @return the month of year property\n     */"}}
{"code": {"body": "    public Property weekOfWeekyear() {\n        return new Property(this, getChronology().weekOfWeekyear());\n    }", "comment": "/**\n     * Get the week of a week based year property which provides access to advanced functionality.\n     * \n     * @return the week of a week based year property\n     */"}}
{"code": {"body": "    public Property dayOfYear() {\n        return new Property(this, getChronology().dayOfYear());\n    }", "comment": "/**\n     * Get the day of year property which provides access to advanced functionality.\n     * \n     * @return the day of year property\n     */"}}
{"code": {"body": "    public Property dayOfMonth() {\n        return new Property(this, getChronology().dayOfMonth());\n    }", "comment": "/**\n     * Get the day of month property which provides access to advanced functionality.\n     * \n     * @return the day of month property\n     */"}}
{"code": {"body": "    public Property dayOfWeek() {\n        return new Property(this, getChronology().dayOfWeek());\n    }", "comment": "/**\n     * Get the day of week property which provides access to advanced functionality.\n     * \n     * @return the day of week property\n     */"}}
{"code": {"body": "        private void writeObject(ObjectOutputStream oos) throws IOException {\n            oos.writeObject(iInstant);\n            oos.writeObject(iField.getType());\n        }", "comment": "/**\n         * Writes the property in a safe serialization format.\n         */"}}
{"code": {"body": "        private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {\n            iInstant = (DateMidnight) oos.readObject();\n            DateTimeFieldType type = (DateTimeFieldType) oos.readObject();\n            iField = type.getField(iInstant.getChronology());\n        }", "comment": "/**\n         * Reads the property from a safe serialization format.\n         */"}}
{"code": {"body": "        public DateTimeField getField() {\n            return iField;\n        }", "comment": "/**\n         * Gets the field being used.\n         * \n         * @return the field\n         */"}}
{"code": {"body": "        protected long getMillis() {\n            return iInstant.getMillis();\n        }", "comment": "/**\n         * Gets the milliseconds of the datetime that this property is linked to.\n         * \n         * @return the milliseconds\n         */"}}
{"code": {"body": "        protected Chronology getChronology() {\n            return iInstant.getChronology();\n        }", "comment": "/**\n         * Gets the chronology of the datetime that this property is linked to.\n         * \n         * @return the chronology\n         * @since 1.4\n         */"}}
{"code": {"body": "        public DateMidnight getDateMidnight() {\n            return iInstant;\n        }", "comment": "/**\n         * Gets the datetime being used.\n         * \n         * @return the datetime\n         */"}}
{"code": {"body": "        public DateMidnight addToCopy(long value) {\n            return iInstant.withMillis(iField.add(iInstant.getMillis(), value));\n        }", "comment": "/**\n         * Adds to this field in a copy of this DateMidnight.\n         * <p>\n         * The DateMidnight attached to this property is unchanged by this call.\n         * This operation is faster than converting a DateMidnight to a MutableDateTime\n         * and back again when setting one field. When setting multiple fields,\n         * it is generally quicker to make the conversion to MutableDateTime.\n         * \n         * @param value  the value to add to the field in the copy\n         * @return a copy of the DateMidnight with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "        public DateMidnight addWrapFieldToCopy(int value) {\n            return iInstant.withMillis(iField.addWrapField(iInstant.getMillis(), value));\n        }", "comment": "/**\n         * Adds to this field, possibly wrapped, in a copy of this DateMidnight.\n         * A wrapped operation only changes this field.\n         * Thus 31st January addWrapField one day goes to the 1st January.\n         * <p>\n         * The DateMidnight attached to this property is unchanged by this call.\n         * This operation is faster than converting a DateMidnight to a MutableDateTime\n         * and back again when setting one field. When setting multiple fields,\n         * it is generally quicker to make the conversion to MutableDateTime.\n         * \n         * @param value  the value to add to the field in the copy\n         * @return a copy of the DateMidnight with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "        public DateMidnight setCopy(String text) {\n            return setCopy(text, null);\n        }", "comment": "/**\n         * Sets this field in a copy of the DateMidnight to a parsed text value.\n         * <p>\n         * The DateMidnight attached to this property is unchanged by this call.\n         * This operation is faster than converting a DateMidnight to a MutableDateTime\n         * and back again when setting one field. When setting multiple fields,\n         * it is generally quicker to make the conversion to MutableDateTime.\n         * \n         * @param text  the text value to set\n         * @return a copy of the DateMidnight with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */"}}
{"code": {"body": "        public DateMidnight withMaximumValue() {\n            return setCopy(getMaximumValue());\n        }", "comment": "/**\n         * Returns a new DateMidnight with this field set to the maximum value\n         * for this field.\n         * <p>\n         * This operation is useful for obtaining a DateTime on the last day\n         * of the month, as month lengths vary.\n         * <pre>\n         * DateMidnight lastDayOfMonth = dt.dayOfMonth().withMaximumValue();\n         * </pre>\n         * <p>\n         * The DateMidnight attached to this property is unchanged by this call.\n         *\n         * @return a copy of the DateMidnight with this field set to its maximum\n         * @since 1.2\n         */"}}
{"code": {"body": "        public DateMidnight withMinimumValue() {\n            return setCopy(getMinimumValue());\n        }", "comment": "/**\n         * Returns a new DateMidnight with this field set to the minimum value\n         * for this field.\n         * <p>\n         * The DateMidnight attached to this property is unchanged by this call.\n         *\n         * @return a copy of the DateMidnight with this field set to its minimum\n         * @since 1.2\n         */"}}
{"code": {"body": "        public DateMidnight roundFloorCopy() {\n            return iInstant.withMillis(iField.roundFloor(iInstant.getMillis()));\n        }", "comment": "/**\n         * Rounds to the lowest whole unit of this field on a copy of this DateMidnight.\n         *\n         * @return a copy of the DateMidnight with the field value changed\n         */"}}
{"code": {"body": "        public DateMidnight roundCeilingCopy() {\n            return iInstant.withMillis(iField.roundCeiling(iInstant.getMillis()));\n        }", "comment": "/**\n         * Rounds to the highest whole unit of this field on a copy of this DateMidnight.\n         *\n         * @return a copy of the DateMidnight with the field value changed\n         */"}}
{"code": {"body": "        public DateMidnight roundHalfFloorCopy() {\n            return iInstant.withMillis(iField.roundHalfFloor(iInstant.getMillis()));\n        }", "comment": "/**\n         * Rounds to the nearest whole unit of this field on a copy of this DateMidnight,\n         * favoring the floor if halfway.\n         *\n         * @return a copy of the DateMidnight with the field value changed\n         */"}}
{"code": {"body": "        public DateMidnight roundHalfCeilingCopy() {\n            return iInstant.withMillis(iField.roundHalfCeiling(iInstant.getMillis()));\n        }", "comment": "/**\n         * Rounds to the nearest whole unit of this field on a copy of this DateMidnight,\n         * favoring the ceiling if halfway.\n         *\n         * @return a copy of the DateMidnight with the field value changed\n         */"}}
{"code": {"body": "        public DateMidnight roundHalfEvenCopy() {\n            return iInstant.withMillis(iField.roundHalfEven(iInstant.getMillis()));\n        }", "comment": "/**\n         * Rounds to the nearest whole unit of this field on a copy of this DateMidnight.\n         * If halfway, the ceiling is favored over the floor only if it makes this field's value even.\n         *\n         * @return a copy of the DateMidnight with the field value changed\n         */"}}
{"code": {"body": "public DateTime() {\n        super();\n    }", "comment": "/**\n     * Constructs an instance set to the current system millisecond time\n     * using <code>ISOChronology</code> in the default time zone.\n     * \n     * @see #now()\n     */"}}
{"code": {"body": "public DateTime(DateTimeZone zone) {\n        super(zone);\n    }", "comment": "/**\n     * Constructs an instance set to the current system millisecond time\n     * using <code>ISOChronology</code> in the specified time zone.\n     * <p>\n     * If the specified time zone is null, the default zone is used.\n     *\n     * @param zone  the time zone, null means default zone\n     * @see #now(DateTimeZone)\n     */"}}
{"code": {"body": "public DateTime(Chronology chronology) {\n        super(chronology);\n    }", "comment": "/**\n     * Constructs an instance set to the current system millisecond time\n     * using the specified chronology.\n     * <p>\n     * If the chronology is null, <code>ISOChronology</code>\n     * in the default time zone is used.\n     *\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     * @see #now(Chronology)\n     */"}}
{"code": {"body": "public DateTime(long instant) {\n        super(instant);\n    }", "comment": "/**\n     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n     * using <code>ISOChronology</code> in the default time zone.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     */"}}
{"code": {"body": "public DateTime(long instant, DateTimeZone zone) {\n        super(instant, zone);\n    }", "comment": "/**\n     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n     * using <code>ISOChronology</code> in the specified time zone.\n     * <p>\n     * If the specified time zone is null, the default zone is used.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     * @param zone  the time zone, null means default zone\n     */"}}
{"code": {"body": "public DateTime(long instant, Chronology chronology) {\n        super(instant, chronology);\n    }", "comment": "/**\n     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n     * using the specified chronology.\n     * <p>\n     * If the chronology is null, <code>ISOChronology</code>\n     * in the default time zone is used.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     */"}}
{"code": {"body": "public DateTime(Object instant) {\n        super(instant, (Chronology) null);\n    }", "comment": "/**\n     * Constructs an instance from an Object that represents a datetime.\n     * <p>\n     * If the object implies a chronology (such as GregorianCalendar does),\n     * then that chronology will be used. Otherwise, ISO default is used.\n     * Thus if a GregorianCalendar is passed in, the chronology used will\n     * be GJ, but if a Date is passed in the chronology will be ISO.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadableInstant, String, Calendar and Date.\n     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}.\n     *\n     * @param instant  the datetime object, null means now\n     * @throws IllegalArgumentException if the instant is invalid\n     */"}}
{"code": {"body": "public DateTime(Object instant, DateTimeZone zone) {\n        super(instant, zone);\n    }", "comment": "/**\n     * Constructs an instance from an Object that represents a datetime,\n     * forcing the time zone to that specified.\n     * <p>\n     * If the object implies a chronology (such as GregorianCalendar does),\n     * then that chronology will be used, but with the time zone adjusted.\n     * Otherwise, ISO is used in the specified time zone.\n     * If the specified time zone is null, the default zone is used.\n     * Thus if a GregorianCalendar is passed in, the chronology used will\n     * be GJ, but if a Date is passed in the chronology will be ISO.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadableInstant, String, Calendar and Date.\n     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}.\n     *\n     * @param instant  the datetime object, null means now\n     * @param zone  the time zone, null means default time zone\n     * @throws IllegalArgumentException if the instant is invalid\n     */"}}
{"code": {"body": "public DateTime(Object instant, Chronology chronology) {\n        super(instant, DateTimeUtils.getChronology(chronology));\n    }", "comment": "/**\n     * Constructs an instance from an Object that represents a datetime,\n     * using the specified chronology.\n     * <p>\n     * If the chronology is null, ISO in the default time zone is used.\n     * Any chronology implied by the object (such as GregorianCalendar does)\n     * is ignored.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadableInstant, String, Calendar and Date.\n     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}.\n     *\n     * @param instant  the datetime object, null means now\n     * @param chronology  the chronology, null means ISO in default zone\n     * @throws IllegalArgumentException if the instant is invalid\n     */"}}
{"code": {"body": "public DateTime toDateTime() {\n        return this;\n    }", "comment": "/**\n     * Get this object as a DateTime by returning <code>this</code>.\n     * \n     * @return <code>this</code>\n     */"}}
{"code": {"body": "public DateTime toDateTimeISO() {\n        if (getChronology() == ISOChronology.getInstance()) {\n            return this;\n        }\n        return super.toDateTimeISO();\n    }", "comment": "/**\n     * Get this object as a DateTime using ISOChronology in the default zone,\n     * returning <code>this</code> if possible.\n     * \n     * @return a DateTime using the same millis\n     */"}}
{"code": {"body": "public DateTime toDateTime(DateTimeZone zone) {\n        zone = DateTimeUtils.getZone(zone);\n        if (getZone() == zone) {\n            return this;\n        }\n        return super.toDateTime(zone);\n    }", "comment": "/**\n     * Get this object as a DateTime, returning <code>this</code> if possible.\n     * \n     * @param zone time zone to apply, or default if null\n     * @return a DateTime using the same millis\n     */"}}
{"code": {"body": "public DateTime toDateTime(Chronology chronology) {\n        chronology = DateTimeUtils.getChronology(chronology);\n        if (getChronology() == chronology) {\n            return this;\n        }\n        return super.toDateTime(chronology);\n    }", "comment": "/**\n     * Get this object as a DateTime, returning <code>this</code> if possible.\n     * \n     * @param chronology chronology to apply, or ISOChronology if null\n     * @return a DateTime using the same millis\n     */"}}
{"code": {"body": "public DateTime withMillis(long newMillis) {\n        return (newMillis == getMillis() ? this : new DateTime(newMillis, getChronology()));\n    }", "comment": "/**\n     * Returns a copy of this datetime with different millis.\n     * <p>\n     * The returned object will be either be a new instance or <code>this</code>.\n     * Only the millis will change, the chronology and time zone are kept.\n     *\n     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z\n     * @return a copy of this datetime with different millis\n     */"}}
{"code": {"body": "public DateTime withChronology(Chronology newChronology) {\n        newChronology = DateTimeUtils.getChronology(newChronology);\n        return (newChronology == getChronology() ? this : new DateTime(getMillis(), newChronology));\n    }", "comment": "/**\n     * Returns a copy of this datetime with a different chronology.\n     * <p>\n     * The returned object will be either be a new instance or <code>this</code>.\n     * Only the chronology will change, the millis are kept.\n     *\n     * @param newChronology  the new chronology, null means ISO default\n     * @return a copy of this datetime with a different chronology\n     */"}}
{"code": {"body": "public DateTime withZone(DateTimeZone newZone) {\n        return withChronology(getChronology().withZone(newZone));\n    }", "comment": "/**\n     * Returns a copy of this datetime with a different time zone, preserving the\n     * millisecond instant.\n     * <p>\n     * This method is useful for finding the local time in another timezone.\n     * For example, if this instant holds 12:30 in Europe/London, the result\n     * from this method with Europe/Paris would be 13:30.\n     * <p>\n     * The returned object will be a new instance of the same implementation type.\n     * This method changes the time zone, and does not change the\n     * millisecond instant, with the effect that the field values usually change.\n     * The returned object will be either be a new instance or <code>this</code>.\n     *\n     * @param newZone  the new time zone\n     * @return a copy of this datetime with a different time zone\n     * @see #withZoneRetainFields\n     */"}}
{"code": {"body": "public DateTime withZoneRetainFields(DateTimeZone newZone) {\n        newZone = DateTimeUtils.getZone(newZone);\n        DateTimeZone originalZone = DateTimeUtils.getZone(getZone());\n        if (newZone == originalZone) {\n            return this;\n        }\n        \n        long millis = originalZone.getMillisKeepLocal(newZone, getMillis());\n        return new DateTime(millis, getChronology().withZone(newZone));\n    }", "comment": "/**\n     * Returns a copy of this datetime with a different time zone, preserving the\n     * field values.\n     * <p>\n     * This method is useful for finding the millisecond time in another timezone.\n     * For example, if this instant holds 12:30 in Europe/London (ie. 12:30Z),\n     * the result from this method with Europe/Paris would be 12:30 (ie. 11:30Z).\n     * <p>\n     * The returned object will be a new instance of the same implementation type.\n     * This method changes the time zone and the millisecond instant to keep\n     * the field values the same.\n     * The returned object will be either be a new instance or <code>this</code>.\n     *\n     * @param newZone  the new time zone, null means default\n     * @return a copy of this datetime with a different time zone\n     * @see #withZone\n     */"}}
{"code": {"body": "public DateTime withEarlierOffsetAtOverlap() {\n        long newMillis = getZone().adjustOffset(getMillis(), false);\n        return withMillis(newMillis);\n    }", "comment": "/**\n     * Returns a copy of this ZonedDateTime changing the zone offset to the earlier\n     * of the two valid offsets at a local time-line overlap.\n     * <p>\n     * This method only has any effect when the local time-line overlaps, such as at\n     * an autumn daylight savings cutover. In this scenario, there are two valid offsets\n     * for the local date-time. Calling this method will return a date-time with the\n     * earlier of the two selected.\n     * <p>\n     * If this method is called when it is not an overlap, this is returned.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return a copy of this datetime with the earliest valid offset for the local datetime\n     */"}}
{"code": {"body": "public DateTime withLaterOffsetAtOverlap() {\n        long newMillis = getZone().adjustOffset(getMillis(), true);\n        return withMillis(newMillis);\n    }", "comment": "/**\n     * Returns a copy of this ZonedDateTime changing the zone offset to the later\n     * of the two valid offsets at a local time-line overlap.\n     * <p>\n     * This method only has any effect when the local time-line overlaps, such as at\n     * an autumn daylight savings cutover. In this scenario, there are two valid offsets\n     * for the local date-time. Calling this method will return a date-time with the\n     * later of the two selected.\n     * <p>\n     * If this method is called when it is not an overlap, this is returned.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return a copy of this datetime with the latest valid offset for the local datetime\n     */"}}
{"code": {"body": "public DateTime withDate(int year, int monthOfYear, int dayOfMonth) {\n        Chronology chrono = getChronology();\n        long instant = getMillis();\n        instant = chrono.year().set(instant, year);\n        instant = chrono.monthOfYear().set(instant, monthOfYear);\n        instant = chrono.dayOfMonth().set(instant, dayOfMonth);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the specified date, retaining the time fields.\n     * <p>\n     * If the date is already the date passed in, then <code>this</code> is returned.\n     * <p>\n     * To set a single field use the properties, for example:\n     * <pre>\n     * DateTime set = monthOfYear().setCopy(6);\n     * </pre>\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param year  the new year value\n     * @param monthOfYear  the new monthOfYear value\n     * @param dayOfMonth  the new dayOfMonth value\n     * @return a copy of this datetime with a different date\n     * @throws IllegalArgumentException if any value if invalid\n     */"}}
{"code": {"body": "public DateTime withTime(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) {\n        Chronology chrono = getChronology();\n        long instant = getMillis();\n        instant = chrono.hourOfDay().set(instant, hourOfDay);\n        instant = chrono.minuteOfHour().set(instant, minuteOfHour);\n        instant = chrono.secondOfMinute().set(instant, secondOfMinute);\n        instant = chrono.millisOfSecond().set(instant, millisOfSecond);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the specified time, retaining the date fields.\n     * <p>\n     * If the time is already the time passed in, then <code>this</code> is returned.\n     * <p>\n     * To set a single field use the properties, for example:\n     * <pre>\n     * DateTime set = dt.hourOfDay().setCopy(6);\n     * </pre>\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hourOfDay  the hour of the day\n     * @param minuteOfHour  the minute of the hour\n     * @param secondOfMinute  the second of the minute\n     * @param millisOfSecond  the millisecond of the second\n     * @return a copy of this datetime with a different time\n     * @throws IllegalArgumentException if any value if invalid\n     */"}}
{"code": {"body": "public DateTime withTimeAtStartOfDay() {\n        return toLocalDate().toDateTimeAtStartOfDay(getZone());\n    }", "comment": "/**\n     * Returns a copy of this datetime with the time set to the start of the day.\n     * <p>\n     * The time will normally be midnight, as that is the earliest time on\n     * any given day. However, in some time zones when Daylight Savings Time\n     * starts, there is no midnight because time jumps from 11:59 to 01:00.\n     * This method handles that situation by returning 01:00 on that date.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return a copy of this datetime with the time set to the start of the day, not null\n     */"}}
{"code": {"body": "public DateTime withFields(ReadablePartial partial) {\n        if (partial == null) {\n            return this;\n        }\n        return withMillis(getChronology().set(partial, getMillis()));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the partial set of fields replacing those\n     * from this instance.\n     * <p>\n     * For example, if the partial is a <code>TimeOfDay</code> then the time fields\n     * would be changed in the returned instance.\n     * If the partial is null, then <code>this</code> is returned.\n     *\n     * @param partial  the partial set of fields to apply to this datetime, null ignored\n     * @return a copy of this datetime with a different set of fields\n     * @throws IllegalArgumentException if any value is invalid\n     */"}}
{"code": {"body": "public DateTime withField(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        long instant = fieldType.getField(getChronology()).set(getMillis(), value);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the specified field set to a new value.\n     * <p>\n     * For example, if the field type is <code>hourOfDay</code> then the hour of day\n     * field would be changed in the returned instance.\n     * If the field type is null, then <code>this</code> is returned.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * DateTime updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);\n     * DateTime updated = dt.dayOfMonth().setCopy(6);\n     * DateTime updated = dt.property(DateTimeFieldType.dayOfMonth()).setCopy(6);\n     * </pre>\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this datetime with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     */"}}
{"code": {"body": "public DateTime withFieldAdded(DurationFieldType fieldType, int amount) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (amount == 0) {\n            return this;\n        }\n        long instant = fieldType.getField(getChronology()).add(getMillis(), amount);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the value of the specified field increased.\n     * <p>\n     * If the addition is zero or the field is null, then <code>this</code> is returned.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * DateTime added = dt.withFieldAdded(DurationFieldType.years(), 6);\n     * DateTime added = dt.plusYears(6);\n     * DateTime added = dt.plus(Period.years(6));\n     * </pre>\n     * \n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this datetime with the field updated\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "public DateTime withDurationAdded(long durationToAdd, int scalar) {\n        if (durationToAdd == 0 || scalar == 0) {\n            return this;\n        }\n        long instant = getChronology().add(getMillis(), durationToAdd, scalar);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the specified duration added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * \n     * @param durationToAdd  the duration to add to this one\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this datetime with the duration added\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "public DateTime withDurationAdded(ReadableDuration durationToAdd, int scalar) {\n        if (durationToAdd == null || scalar == 0) {\n            return this;\n        }\n        return withDurationAdded(durationToAdd.getMillis(), scalar);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the specified duration added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * \n     * @param durationToAdd  the duration to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this datetime with the duration added\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "public DateTime withPeriodAdded(ReadablePeriod period, int scalar) {\n        if (period == null || scalar == 0) {\n            return this;\n        }\n        long instant = getChronology().add(period, getMillis(), scalar);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the specified period added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to add multiple copies of complex\n     * period instances. Adding one field is best achieved using methods\n     * like {@link #withFieldAdded(DurationFieldType, int)}\n     * or {@link #plusYears(int)}.\n     * \n     * @param period  the period to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this datetime with the period added\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "public DateTime plus(long duration) {\n        return withDurationAdded(duration, 1);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the specified duration added.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * This datetime instance is immutable and unaffected by this method call.\n     * \n     * @param duration  the duration, in millis, to add to this one\n     * @return a copy of this datetime with the duration added\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "public DateTime plus(ReadableDuration duration) {\n        return withDurationAdded(duration, 1);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the specified duration added.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * This datetime instance is immutable and unaffected by this method call.\n     * \n     * @param duration  the duration to add to this one, null means zero\n     * @return a copy of this datetime with the duration added\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "public DateTime plus(ReadablePeriod period) {\n        return withPeriodAdded(period, 1);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the specified period added.\n     * <p>\n     * This method will add each element of the period one by one, from largest\n     * to smallest, adjusting the datetime to be accurate between each.\n     * <p>\n     * Thus, adding a period of one month and one day to 2007-03-31 will\n     * work as follows:\n     * First add one month and adjust, resulting in 2007-04-30\n     * Then add one day and adjust, resulting in 2007-05-01.\n     * <p>\n     * This method is typically used to add complex period instances.\n     * Adding one field is best achieved using methods\n     * like {@link #plusYears(int)}.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * This datetime instance is immutable and unaffected by this method call.\n     * \n     * @param period  the duration to add to this one, null means zero\n     * @return a copy of this datetime with the period added\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "public DateTime plusYears(int years) {\n        if (years == 0) {\n            return this;\n        }\n        long instant = getChronology().years().add(getMillis(), years);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime plus the specified number of years.\n     * <p>\n     * The calculation will do its best to only change the year field\n     * retaining the same month of year.\n     * However, in certain circumstances, it may be necessary to alter\n     * smaller fields. For example, 2008-02-29 plus one year cannot result\n     * in 2009-02-29, so the day of month is adjusted to 2009-02-28.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateTime added = dt.plusYears(6);\n     * DateTime added = dt.plus(Period.years(6));\n     * DateTime added = dt.withFieldAdded(DurationFieldType.years(), 6);\n     * </pre>\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     *\n     * @param years  the amount of years to add, may be negative\n     * @return the new datetime plus the increased years\n     * @since 1.1\n     */"}}
{"code": {"body": "public DateTime plusMonths(int months) {\n        if (months == 0) {\n            return this;\n        }\n        long instant = getChronology().months().add(getMillis(), months);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime plus the specified number of months.\n     * <p>\n     * The calculation will do its best to only change the month field\n     * retaining the same day of month.\n     * However, in certain circumstances, it may be necessary to alter\n     * smaller fields. For example, 2007-03-31 plus one month cannot result\n     * in 2007-04-31, so the day of month is adjusted to 2007-04-30.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateTime added = dt.plusMonths(6);\n     * DateTime added = dt.plus(Period.months(6));\n     * DateTime added = dt.withFieldAdded(DurationFieldType.months(), 6);\n     * </pre>\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     *\n     * @param months  the amount of months to add, may be negative\n     * @return the new datetime plus the increased months\n     * @since 1.1\n     */"}}
{"code": {"body": "public DateTime plusWeeks(int weeks) {\n        if (weeks == 0) {\n            return this;\n        }\n        long instant = getChronology().weeks().add(getMillis(), weeks);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime plus the specified number of weeks.\n     * <p>\n     * The calculation operates as if it were adding the equivalent in days.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateTime added = dt.plusWeeks(6);\n     * DateTime added = dt.plus(Period.weeks(6));\n     * DateTime added = dt.withFieldAdded(DurationFieldType.weeks(), 6);\n     * </pre>\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the amount of weeks to add, may be negative\n     * @return the new datetime plus the increased weeks\n     * @since 1.1\n     */"}}
{"code": {"body": "public DateTime plusDays(int days) {\n        if (days == 0) {\n            return this;\n        }\n        long instant = getChronology().days().add(getMillis(), days);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime plus the specified number of days.\n     * <p>\n     * The calculation will do its best to only change the day field\n     * retaining the same time of day.\n     * However, in certain circumstances, typically daylight savings cutover,\n     * it may be necessary to alter the time fields.\n     * <p>\n     * In spring an hour is typically removed. If adding one day results in\n     * the time being within the cutover then the time is adjusted to be\n     * within summer time. For example, if the cutover is from 01:59 to 03:00\n     * and the result of this method would have been 02:30, then the result\n     * will be adjusted to 03:30.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateTime added = dt.plusDays(6);\n     * DateTime added = dt.plus(Period.days(6));\n     * DateTime added = dt.withFieldAdded(DurationFieldType.days(), 6);\n     * </pre>\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     *\n     * @param days  the amount of days to add, may be negative\n     * @return the new datetime plus the increased days\n     * @since 1.1\n     */"}}
{"code": {"body": "public DateTime plusHours(int hours) {\n        if (hours == 0) {\n            return this;\n        }\n        long instant = getChronology().hours().add(getMillis(), hours);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime plus the specified number of hours.\n     * <p>\n     * The calculation will add a duration equivalent to the number of hours\n     * expressed in milliseconds.\n     * <p>\n     * For example, if a spring daylight savings cutover is from 01:59 to 03:00\n     * then adding one hour to 01:30 will result in 03:30. This is a duration\n     * of one hour later, even though the hour field value changed from 1 to 3.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateTime added = dt.plusHours(6);\n     * DateTime added = dt.plus(Period.hours(6));\n     * DateTime added = dt.withFieldAdded(DurationFieldType.hours(), 6);\n     * </pre>\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the amount of hours to add, may be negative\n     * @return the new datetime plus the increased hours\n     * @since 1.1\n     */"}}
{"code": {"body": "public DateTime plusMinutes(int minutes) {\n        if (minutes == 0) {\n            return this;\n        }\n        long instant = getChronology().minutes().add(getMillis(), minutes);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime plus the specified number of minutes.\n     * <p>\n     * The calculation will add a duration equivalent to the number of minutes\n     * expressed in milliseconds.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateTime added = dt.plusMinutes(6);\n     * DateTime added = dt.plus(Period.minutes(6));\n     * DateTime added = dt.withFieldAdded(DurationFieldType.minutes(), 6);\n     * </pre>\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the amount of minutes to add, may be negative\n     * @return the new datetime plus the increased minutes\n     * @since 1.1\n     */"}}
{"code": {"body": "public DateTime plusSeconds(int seconds) {\n        if (seconds == 0) {\n            return this;\n        }\n        long instant = getChronology().seconds().add(getMillis(), seconds);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime plus the specified number of seconds.\n     * <p>\n     * The calculation will add a duration equivalent to the number of seconds\n     * expressed in milliseconds.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateTime added = dt.plusSeconds(6);\n     * DateTime added = dt.plus(Period.seconds(6));\n     * DateTime added = dt.withFieldAdded(DurationFieldType.seconds(), 6);\n     * </pre>\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the amount of seconds to add, may be negative\n     * @return the new datetime plus the increased seconds\n     * @since 1.1\n     */"}}
{"code": {"body": "public DateTime plusMillis(int millis) {\n        if (millis == 0) {\n            return this;\n        }\n        long instant = getChronology().millis().add(getMillis(), millis);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime plus the specified number of millis.\n     * <p>\n     * The calculation will add a duration equivalent to the number of milliseconds.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateTime added = dt.plusMillis(6);\n     * DateTime added = dt.plus(Period.millis(6));\n     * DateTime added = dt.withFieldAdded(DurationFieldType.millis(), 6);\n     * </pre>\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     *\n     * @param millis  the amount of millis to add, may be negative\n     * @return the new datetime plus the increased millis\n     * @since 1.1\n     */"}}
{"code": {"body": "public DateTime minus(long duration) {\n        return withDurationAdded(duration, -1);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the specified duration taken away.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * This datetime instance is immutable and unaffected by this method call.\n     * \n     * @param duration  the duration, in millis, to reduce this instant by\n     * @return a copy of this datetime with the duration taken away\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "public DateTime minus(ReadableDuration duration) {\n        return withDurationAdded(duration, -1);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the specified duration taken away.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * This datetime instance is immutable and unaffected by this method call.\n     * \n     * @param duration  the duration to reduce this instant by\n     * @return a copy of this datetime with the duration taken away\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "public DateTime minus(ReadablePeriod period) {\n        return withPeriodAdded(period, -1);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the specified period taken away.\n     * <p>\n     * This method will subtract each element of the period one by one, from\n     * largest to smallest, adjusting the datetime to be accurate between each.\n     * <p>\n     * Thus, subtracting a period of one month and one day from 2007-05-31 will\n     * work as follows:\n     * First subtract one month and adjust, resulting in 2007-04-30\n     * Then subtract one day and adjust, resulting in 2007-04-29.\n     * Note that the day has been adjusted by two.\n     * <p>\n     * This method is typically used to subtract complex period instances.\n     * Subtracting one field is best achieved using methods\n     * like {@link #minusYears(int)}.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * This datetime instance is immutable and unaffected by this method call.\n     * \n     * @param period  the period to reduce this instant by\n     * @return a copy of this datetime with the period taken away\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "public DateTime minusYears(int years) {\n        if (years == 0) {\n            return this;\n        }\n        long instant = getChronology().years().subtract(getMillis(), years);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime minus the specified number of years.\n     * <p>\n     * The calculation will do its best to only change the year field\n     * retaining the same month of year.\n     * However, in certain circumstances, it may be necessary to alter\n     * smaller fields. For example, 2008-02-29 minus one year cannot result\n     * in 2007-02-29, so the day of month is adjusted to 2007-02-28.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateTime subtracted = dt.minusYears(6);\n     * DateTime subtracted = dt.minus(Period.years(6));\n     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);\n     * </pre>\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     *\n     * @param years  the amount of years to subtract, may be negative\n     * @return the new datetime minus the increased years\n     * @since 1.1\n     */"}}
{"code": {"body": "public DateTime minusMonths(int months) {\n        if (months == 0) {\n            return this;\n        }\n        long instant = getChronology().months().subtract(getMillis(), months);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime minus the specified number of months.\n     * <p>\n     * The calculation will do its best to only change the month field\n     * retaining the same day of month.\n     * However, in certain circumstances, it may be necessary to alter\n     * smaller fields. For example, 2007-05-31 minus one month cannot result\n     * in 2007-04-31, so the day of month is adjusted to 2007-04-30.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateTime subtracted = dt.minusMonths(6);\n     * DateTime subtracted = dt.minus(Period.months(6));\n     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);\n     * </pre>\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     *\n     * @param months  the amount of months to subtract, may be negative\n     * @return the new datetime minus the increased months\n     * @since 1.1\n     */"}}
{"code": {"body": "public DateTime minusWeeks(int weeks) {\n        if (weeks == 0) {\n            return this;\n        }\n        long instant = getChronology().weeks().subtract(getMillis(), weeks);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime minus the specified number of weeks.\n     * <p>\n     * The calculation operates as if it were subtracting the equivalent in days.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateTime subtracted = dt.minusWeeks(6);\n     * DateTime subtracted = dt.minus(Period.weeks(6));\n     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6);\n     * </pre>\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the amount of weeks to subtract, may be negative\n     * @return the new datetime minus the increased weeks\n     * @since 1.1\n     */"}}
{"code": {"body": "public DateTime minusDays(int days) {\n        if (days == 0) {\n            return this;\n        }\n        long instant = getChronology().days().subtract(getMillis(), days);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime minus the specified number of days.\n     * <p>\n     * The calculation will do its best to only change the day field\n     * retaining the same time of day.\n     * However, in certain circumstances, typically daylight savings cutover,\n     * it may be necessary to alter the time fields.\n     * <p>\n     * In spring an hour is typically removed. If subtracting one day results\n     * in the time being within the cutover then the time is adjusted to be\n     * within summer time. For example, if the cutover is from 01:59 to 03:00\n     * and the result of this method would have been 02:30, then the result\n     * will be adjusted to 03:30.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateTime subtracted = dt.minusDays(6);\n     * DateTime subtracted = dt.minus(Period.days(6));\n     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);\n     * </pre>\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     *\n     * @param days  the amount of days to subtract, may be negative\n     * @return the new datetime minus the increased days\n     * @since 1.1\n     */"}}
{"code": {"body": "public DateTime minusHours(int hours) {\n        if (hours == 0) {\n            return this;\n        }\n        long instant = getChronology().hours().subtract(getMillis(), hours);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime minus the specified number of hours.\n     * <p>\n     * The calculation will subtract a duration equivalent to the number of\n     * hours expressed in milliseconds.\n     * <p>\n     * For example, if a spring daylight savings cutover is from 01:59 to 03:00\n     * then subtracting one hour from 03:30 will result in 01:30. This is a\n     * duration of one hour earlier, even though the hour field value changed\n     * from 3 to 1.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateTime subtracted = dt.minusHours(6);\n     * DateTime subtracted = dt.minus(Period.hours(6));\n     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.hours(), -6);\n     * </pre>\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the amount of hours to subtract, may be negative\n     * @return the new datetime minus the increased hours\n     * @since 1.1\n     */"}}
{"code": {"body": "public DateTime minusMinutes(int minutes) {\n        if (minutes == 0) {\n            return this;\n        }\n        long instant = getChronology().minutes().subtract(getMillis(), minutes);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime minus the specified number of minutes.\n     * <p>\n     * The calculation will subtract a duration equivalent to the number of\n     * minutes expressed in milliseconds.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateTime subtracted = dt.minusMinutes(6);\n     * DateTime subtracted = dt.minus(Period.minutes(6));\n     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.minutes(), -6);\n     * </pre>\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the amount of minutes to subtract, may be negative\n     * @return the new datetime minus the increased minutes\n     * @since 1.1\n     */"}}
{"code": {"body": "public DateTime minusSeconds(int seconds) {\n        if (seconds == 0) {\n            return this;\n        }\n        long instant = getChronology().seconds().subtract(getMillis(), seconds);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime minus the specified number of seconds.\n     * <p>\n     * The calculation will subtract a duration equivalent to the number of\n     * seconds expressed in milliseconds.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateTime subtracted = dt.minusSeconds(6);\n     * DateTime subtracted = dt.minus(Period.seconds(6));\n     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.seconds(), -6);\n     * </pre>\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the amount of seconds to subtract, may be negative\n     * @return the new datetime minus the increased seconds\n     * @since 1.1\n     */"}}
{"code": {"body": "public DateTime minusMillis(int millis) {\n        if (millis == 0) {\n            return this;\n        }\n        long instant = getChronology().millis().subtract(getMillis(), millis);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime minus the specified number of millis.\n     * <p>\n     * The calculation will subtract a duration equivalent to the number of\n     * milliseconds.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateTime subtracted = dt.minusMillis(6);\n     * DateTime subtracted = dt.minus(Period.millis(6));\n     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.millis(), -6);\n     * </pre>\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     *\n     * @param millis  the amount of millis to subtract, may be negative\n     * @return the new datetime minus the increased millis\n     * @since 1.1\n     */"}}
{"code": {"body": "public DateTime withEra(int era) {\n        return withMillis(getChronology().era().set(getMillis(), era));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the era field updated.\n     * <p>\n     * DateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * era changed.\n     *\n     * @param era  the era to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "public DateTime withCenturyOfEra(int centuryOfEra) {\n        return withMillis(getChronology().centuryOfEra().set(getMillis(), centuryOfEra));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the century of era field updated.\n     * <p>\n     * DateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * century of era changed.\n     *\n     * @param centuryOfEra  the centurey of era to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "public DateTime withYearOfEra(int yearOfEra) {\n        return withMillis(getChronology().yearOfEra().set(getMillis(), yearOfEra));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the year of era field updated.\n     * <p>\n     * DateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year of era changed.\n     *\n     * @param yearOfEra  the year of era to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "public DateTime withYearOfCentury(int yearOfCentury) {\n        return withMillis(getChronology().yearOfCentury().set(getMillis(), yearOfCentury));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the year of century field updated.\n     * <p>\n     * DateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year of century changed.\n     *\n     * @param yearOfCentury  the year of century to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "public DateTime withYear(int year) {\n        return withMillis(getChronology().year().set(getMillis(), year));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the year field updated.\n     * <p>\n     * DateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year changed.\n     *\n     * @param year  the year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "public DateTime withWeekyear(int weekyear) {\n        return withMillis(getChronology().weekyear().set(getMillis(), weekyear));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the weekyear field updated.\n     * <p>\n     * The weekyear is the year that matches with the weekOfWeekyear field.\n     * In the standard ISO8601 week algorithm, the first week of the year\n     * is that in which at least 4 days are in the year. As a result of this\n     * definition, day 1 of the first week may be in the previous year.\n     * The weekyear allows you to query the effective year for that day.\n     * <p>\n     * DateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * weekyear changed.\n     *\n     * @param weekyear  the weekyear to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "public DateTime withMonthOfYear(int monthOfYear) {\n        return withMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the month of year field updated.\n     * <p>\n     * DateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * month of year changed.\n     *\n     * @param monthOfYear  the month of year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "public DateTime withWeekOfWeekyear(int weekOfWeekyear) {\n        return withMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the week of weekyear field updated.\n     * <p>\n     * This field is associated with the \"weekyear\" via {@link #withWeekyear(int)}.\n     * In the standard ISO8601 week algorithm, the first week of the year\n     * is that in which at least 4 days are in the year. As a result of this\n     * definition, day 1 of the first week may be in the previous year.\n     * <p>\n     * DateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * week of weekyear changed.\n     *\n     * @param weekOfWeekyear  the week of weekyear to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "public DateTime withDayOfYear(int dayOfYear) {\n        return withMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the day of year field updated.\n     * <p>\n     * DateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of year changed.\n     *\n     * @param dayOfYear  the day of year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "public DateTime withDayOfMonth(int dayOfMonth) {\n        return withMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the day of month field updated.\n     * <p>\n     * DateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of month changed.\n     *\n     * @param dayOfMonth  the day of month to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "public DateTime withDayOfWeek(int dayOfWeek) {\n        return withMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the day of week field updated.\n     * <p>\n     * DateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of week changed.\n     *\n     * @param dayOfWeek  the day of week to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "public DateTime withHourOfDay(int hour) {\n        return withMillis(getChronology().hourOfDay().set(getMillis(), hour));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the hour of day field updated.\n     * <p>\n     * DateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * hour of day changed.\n     *\n     * @param hour  the hour of day to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "public DateTime withMinuteOfHour(int minute) {\n        return withMillis(getChronology().minuteOfHour().set(getMillis(), minute));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the minute of hour updated.\n     * <p>\n     * DateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * minute of hour changed.\n     *\n     * @param minute  the minute of hour to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "public DateTime withSecondOfMinute(int second) {\n        return withMillis(getChronology().secondOfMinute().set(getMillis(), second));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the second of minute field updated.\n     * <p>\n     * DateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * second of minute changed.\n     *\n     * @param second  the second of minute to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "public DateTime withMillisOfSecond(int millis) {\n        return withMillis(getChronology().millisOfSecond().set(getMillis(), millis));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the millis of second field updated.\n     * <p>\n     * DateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * millis of second changed.\n     *\n     * @param millis  the millis of second to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "public DateTime withMillisOfDay(int millis) {\n        return withMillis(getChronology().millisOfDay().set(getMillis(), millis));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the millis of day field updated.\n     * <p>\n     * DateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * millis of day changed.\n     *\n     * @param millis  the millis of day to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "public DateTimeField getField() {\n            return iField;\n        }", "comment": "/**\n         * Gets the field being used.\n         * \n         * @return the field\n         */"}}
{"code": {"body": "public DateTime getDateTime() {\n            return iInstant;\n        }", "comment": "/**\n         * Gets the datetime being used.\n         * \n         * @return the datetime\n         */"}}
{"code": {"body": "public DateTime addToCopy(int value) {\n            return iInstant.withMillis(iField.add(iInstant.getMillis(), value));\n        }", "comment": "/**\n         * Adds to this field in a copy of this DateTime.\n         * <p>\n         * The DateTime attached to this property is unchanged by this call.\n         * This operation is faster than converting a DateTime to a MutableDateTime\n         * and back again when setting one field. When setting multiple fields,\n         * it is generally quicker to make the conversion to MutableDateTime.\n         * \n         * @param value  the value to add to the field in the copy\n         * @return a copy of the DateTime with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "public DateTime addToCopy(long value) {\n            return iInstant.withMillis(iField.add(iInstant.getMillis(), value));\n        }", "comment": "/**\n         * Adds to this field in a copy of this DateTime.\n         * <p>\n         * The DateTime attached to this property is unchanged by this call.\n         * This operation is faster than converting a DateTime to a MutableDateTime\n         * and back again when setting one field. When setting multiple fields,\n         * it is generally quicker to make the conversion to MutableDateTime.\n         * \n         * @param value  the value to add to the field in the copy\n         * @return a copy of the DateTime with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "public DateTime addWrapFieldToCopy(int value) {\n            return iInstant.withMillis(iField.addWrapField(iInstant.getMillis(), value));\n        }", "comment": "/**\n         * Adds to this field, possibly wrapped, in a copy of this DateTime.\n         * A wrapped operation only changes this field.\n         * Thus 31st January addWrapField one day goes to the 1st January.\n         * <p>\n         * The DateTime attached to this property is unchanged by this call.\n         * This operation is faster than converting a DateTime to a MutableDateTime\n         * and back again when setting one field. When setting multiple fields,\n         * it is generally quicker to make the conversion to MutableDateTime.\n         * \n         * @param value  the value to add to the field in the copy\n         * @return a copy of the DateTime with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "public DateTime setCopy(int value) {\n            return iInstant.withMillis(iField.set(iInstant.getMillis(), value));\n        }", "comment": "/**\n         * Sets this field in a copy of the DateTime.\n         * <p>\n         * The DateTime attached to this property is unchanged by this call.\n         * This operation is faster than converting a DateTime to a MutableDateTime\n         * and back again when setting one field. When setting multiple fields,\n         * it is generally quicker to make the conversion to MutableDateTime.\n         * \n         * @param value  the value to set the field in the copy to\n         * @return a copy of the DateTime with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "public DateTime setCopy(String text, Locale locale) {\n            return iInstant.withMillis(iField.set(iInstant.getMillis(), text, locale));\n        }", "comment": "/**\n         * Sets this field in a copy of the DateTime to a parsed text value.\n         * <p>\n         * The DateTime attached to this property is unchanged by this call.\n         * This operation is faster than converting a DateTime to a MutableDateTime\n         * and back again when setting one field. When setting multiple fields,\n         * it is generally quicker to make the conversion to MutableDateTime.\n         * \n         * @param text  the text value to set\n         * @param locale  optional locale to use for selecting a text symbol\n         * @return a copy of the DateTime with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */"}}
{"code": {"body": "public DateTime setCopy(String text) {\n            return setCopy(text, null);\n        }", "comment": "/**\n         * Sets this field in a copy of the DateTime to a parsed text value.\n         * <p>\n         * The DateTime attached to this property is unchanged by this call.\n         * This operation is faster than converting a DateTime to a MutableDateTime\n         * and back again when setting one field. When setting multiple fields,\n         * it is generally quicker to make the conversion to MutableDateTime.\n         * \n         * @param text  the text value to set\n         * @return a copy of the DateTime with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */"}}
{"code": {"body": "public DateTime withMaximumValue() {\n            try {\n                return setCopy(getMaximumValue());\n            } catch (RuntimeException ex) {\n                if (IllegalInstantException.isIllegalInstant(ex)) {\n                    \n                    long beforeGap = getChronology().getZone().previousTransition(getMillis() + DateTimeConstants.MILLIS_PER_DAY);\n                    return new DateTime(beforeGap, getChronology());\n                }\n                throw ex;\n            }\n        }", "comment": "/**\n         * Returns a new DateTime with this field set to the maximum value\n         * for this field.\n         * <p>\n         * This operation is useful for obtaining a DateTime on the last day\n         * of the month, as month lengths vary.\n         * <pre>\n         * DateTime lastDayOfMonth = dt.dayOfMonth().withMaximumValue();\n         * </pre>\n         * <p>\n         * Where possible, the offset from UTC will be retained, thus applications\n         * may need to call {@link DateTime#withLaterOffsetAtOverlap()} on the result\n         * to force the later time during a DST overlap if desired.\n         * <p>\n         * From v2.2, this method handles a daylight svaings time gap, setting the\n         * time to the last instant before the gap.\n         * <p>\n         * The DateTime attached to this property is unchanged by this call.\n         *\n         * @return a copy of the DateTime with this field set to its maximum\n         * @since 1.2\n         */"}}
{"code": {"body": "public DateTime withMinimumValue() {\n            try {\n                return setCopy(getMinimumValue());\n            } catch (RuntimeException ex) {\n                if (IllegalInstantException.isIllegalInstant(ex)) {\n                    \n                    long afterGap = getChronology().getZone().nextTransition(getMillis() - DateTimeConstants.MILLIS_PER_DAY);\n                    return new DateTime(afterGap, getChronology());\n                }\n                throw ex;\n            }\n        }", "comment": "/**\n         * Returns a new DateTime with this field set to the minimum value\n         * for this field.\n         * <p>\n         * Where possible, the offset from UTC will be retained, thus applications\n         * may need to call {@link DateTime#withEarlierOffsetAtOverlap()} on the result\n         * to force the earlier time during a DST overlap if desired.\n         * <p>\n         * From v2.2, this method handles a daylight svaings time gap, setting the\n         * time to the first instant after the gap.\n         * <p>\n         * The DateTime attached to this property is unchanged by this call.\n         *\n         * @return a copy of the DateTime with this field set to its minimum\n         * @since 1.2\n         */"}}
{"code": {"body": "public DateTime roundFloorCopy() {\n            return iInstant.withMillis(iField.roundFloor(iInstant.getMillis()));\n        }", "comment": "/**\n         * Rounds to the lowest whole unit of this field on a copy of this DateTime.\n         *\n         * @return a copy of the DateTime with the field value changed\n         */"}}
{"code": {"body": "public DateTime roundCeilingCopy() {\n            return iInstant.withMillis(iField.roundCeiling(iInstant.getMillis()));\n        }", "comment": "/**\n         * Rounds to the highest whole unit of this field on a copy of this DateTime.\n         *\n         * @return a copy of the DateTime with the field value changed\n         */"}}
{"code": {"body": "public DateTime roundHalfFloorCopy() {\n            return iInstant.withMillis(iField.roundHalfFloor(iInstant.getMillis()));\n        }", "comment": "/**\n         * Rounds to the nearest whole unit of this field on a copy of this DateTime,\n         * favoring the floor if halfway.\n         *\n         * @return a copy of the DateTime with the field value changed\n         */"}}
{"code": {"body": "public DateTime roundHalfCeilingCopy() {\n            return iInstant.withMillis(iField.roundHalfCeiling(iInstant.getMillis()));\n        }", "comment": "/**\n         * Rounds to the nearest whole unit of this field on a copy of this DateTime,\n         * favoring the ceiling if halfway.\n         *\n         * @return a copy of the DateTime with the field value changed\n         */"}}
{"code": {"body": "public DateTime roundHalfEvenCopy() {\n            return iInstant.withMillis(iField.roundHalfEven(iInstant.getMillis()));\n        }", "comment": "/**\n         * Rounds to the nearest whole unit of this field on a copy of this\n         * DateTime.  If halfway, the ceiling is favored over the floor only if\n         * it makes this field's value even.\n         *\n         * @return a copy of the DateTime with the field value changed\n         */"}}
{"code": {"body": "    public static DateTime now(Chronology chronology) {\n        if (chronology == null) {\n            throw new NullPointerException(\"\");\n        }\n        return new DateTime(chronology);\n    }", "comment": "/**\n     * Obtains a {@code DateTime} set to the current system millisecond time\n     * using the specified chronology.\n     *\n     * @param chronology  the chronology, not null\n     * @return the current date-time, not null\n     * @since 2.0\n     */"}}
{"code": {"body": "    public static DateTime parse(String str, DateTimeFormatter formatter) {\n        return formatter.parseDateTime(str);\n    }", "comment": "/**\n     * Parses a {@code DateTime} from the specified string using a formatter.\n     * \n     * @param str  the string to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @since 2.0\n     */"}}
{"code": {"body": "    public DateTime toDateTime(Chronology chronology) {\n        chronology = DateTimeUtils.getChronology(chronology);\n        if (getChronology() == chronology) {\n            return this;\n        }\n        return super.toDateTime(chronology);\n    }", "comment": "/**\n     * Get this object as a DateTime, returning <code>this</code> if possible.\n     * \n     * @param chronology chronology to apply, or ISOChronology if null\n     * @return a DateTime using the same millis\n     */"}}
{"code": {"body": "    public DateTime toDateTimeISO() {\n        if (getChronology() == ISOChronology.getInstance()) {\n            return this;\n        }\n        return super.toDateTimeISO();\n    }", "comment": "/**\n     * Get this object as a DateTime using ISOChronology in the default zone,\n     * returning <code>this</code> if possible.\n     * \n     * @return a DateTime using the same millis\n     */"}}
{"code": {"body": "    public DateTime withMillis(long newMillis) {\n        return (newMillis == getMillis() ? this : new DateTime(newMillis, getChronology()));\n    }", "comment": "/**\n     * Returns a copy of this datetime with different millis.\n     * <p>\n     * The returned object will be either be a new instance or <code>this</code>.\n     * Only the millis will change, the chronology and time zone are kept.\n     *\n     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z\n     * @return a copy of this datetime with different millis\n     */"}}
{"code": {"body": "    public DateTime withChronology(Chronology newChronology) {\n        newChronology = DateTimeUtils.getChronology(newChronology);\n        return (newChronology == getChronology() ? this : new DateTime(getMillis(), newChronology));\n    }", "comment": "/**\n     * Returns a copy of this datetime with a different chronology.\n     * <p>\n     * The returned object will be either be a new instance or <code>this</code>.\n     * Only the chronology will change, the millis are kept.\n     *\n     * @param newChronology  the new chronology, null means ISO default\n     * @return a copy of this datetime with a different chronology\n     */"}}
{"code": {"body": "    public DateTime withZone(DateTimeZone newZone) {\n        return withChronology(getChronology().withZone(newZone));\n    }", "comment": "/**\n     * Returns a copy of this datetime with a different time zone, preserving the\n     * millisecond instant.\n     * <p>\n     * This method is useful for finding the local time in another timezone.\n     * For example, if this instant holds 12:30 in Europe/London, the result\n     * from this method with Europe/Paris would be 13:30.\n     * <p>\n     * The returned object will be a new instance of the same implementation type.\n     * This method changes the time zone, and does not change the\n     * millisecond instant, with the effect that the field values usually change.\n     * The returned object will be either be a new instance or <code>this</code>.\n     *\n     * @param newZone  the new time zone\n     * @return a copy of this datetime with a different time zone\n     * @see #withZoneRetainFields\n     */"}}
{"code": {"body": "    public DateTime withZoneRetainFields(DateTimeZone newZone) {\n        newZone = DateTimeUtils.getZone(newZone);\n        DateTimeZone originalZone = DateTimeUtils.getZone(getZone());\n        if (newZone == originalZone) {\n            return this;\n        }\n        \n        long millis = originalZone.getMillisKeepLocal(newZone, getMillis());\n        return new DateTime(millis, getChronology().withZone(newZone));\n    }", "comment": "/**\n     * Returns a copy of this datetime with a different time zone, preserving the\n     * field values.\n     * <p>\n     * This method is useful for finding the millisecond time in another timezone.\n     * For example, if this instant holds 12:30 in Europe/London (ie. 12:30Z),\n     * the result from this method with Europe/Paris would be 12:30 (ie. 11:30Z).\n     * <p>\n     * The returned object will be a new instance of the same implementation type.\n     * This method changes the time zone and the millisecond instant to keep\n     * the field values the same.\n     * The returned object will be either be a new instance or <code>this</code>.\n     *\n     * @param newZone  the new time zone, null means default\n     * @return a copy of this datetime with a different time zone\n     * @see #withZone\n     */"}}
{"code": {"body": "    public DateTime withEarlierOffsetAtOverlap() {\n        long newMillis = getZone().adjustOffset(getMillis(), false);\n        return withMillis(newMillis);\n    }", "comment": "/**\n     * Returns a copy of this ZonedDateTime changing the zone offset to the earlier\n     * of the two valid offsets at a local time-line overlap.\n     * <p>\n     * This method only has any effect when the local time-line overlaps, such as at\n     * an autumn daylight savings cutover. In this scenario, there are two valid offsets\n     * for the local date-time. Calling this method will return a date-time with the\n     * earlier of the two selected.\n     * <p>\n     * If this method is called when it is not an overlap, this is returned.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return a copy of this datetime with the earliest valid offset for the local datetime\n     */"}}
{"code": {"body": "    public DateTime withLaterOffsetAtOverlap() {\n        long newMillis = getZone().adjustOffset(getMillis(), true);\n        return withMillis(newMillis);\n    }", "comment": "/**\n     * Returns a copy of this ZonedDateTime changing the zone offset to the later\n     * of the two valid offsets at a local time-line overlap.\n     * <p>\n     * This method only has any effect when the local time-line overlaps, such as at\n     * an autumn daylight savings cutover. In this scenario, there are two valid offsets\n     * for the local date-time. Calling this method will return a date-time with the\n     * later of the two selected.\n     * <p>\n     * If this method is called when it is not an overlap, this is returned.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return a copy of this datetime with the latest valid offset for the local datetime\n     */"}}
{"code": {"body": "    public DateTime withDate(int year, int monthOfYear, int dayOfMonth) {\n        Chronology chrono = getChronology();\n        long instant = getMillis();\n        instant = chrono.year().set(instant, year);\n        instant = chrono.monthOfYear().set(instant, monthOfYear);\n        instant = chrono.dayOfMonth().set(instant, dayOfMonth);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the specified date, retaining the time fields.\n     * <p>\n     * If the date is already the date passed in, then <code>this</code> is returned.\n     * <p>\n     * To set a single field use the properties, for example:\n     * <pre>\n     * DateTime set = monthOfYear().setCopy(6);\n     * </pre>\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param year  the new year value\n     * @param monthOfYear  the new monthOfYear value\n     * @param dayOfMonth  the new dayOfMonth value\n     * @return a copy of this datetime with a different date\n     * @throws IllegalArgumentException if any value if invalid\n     */"}}
{"code": {"body": "    public DateTime withTime(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) {\n        Chronology chrono = getChronology();\n        long instant = getMillis();\n        instant = chrono.hourOfDay().set(instant, hourOfDay);\n        instant = chrono.minuteOfHour().set(instant, minuteOfHour);\n        instant = chrono.secondOfMinute().set(instant, secondOfMinute);\n        instant = chrono.millisOfSecond().set(instant, millisOfSecond);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the specified time, retaining the date fields.\n     * <p>\n     * If the time is already the time passed in, then <code>this</code> is returned.\n     * <p>\n     * To set a single field use the properties, for example:\n     * <pre>\n     * DateTime set = dt.hourOfDay().setCopy(6);\n     * </pre>\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hourOfDay  the hour of the day\n     * @param minuteOfHour  the minute of the hour\n     * @param secondOfMinute  the second of the minute\n     * @param millisOfSecond  the millisecond of the second\n     * @return a copy of this datetime with a different time\n     * @throws IllegalArgumentException if any value if invalid\n     */"}}
{"code": {"body": "    public DateTime withTimeAtStartOfDay() {\n        return toLocalDate().toDateTimeAtStartOfDay(getZone());\n    }", "comment": "/**\n     * Returns a copy of this datetime with the time set to the start of the day.\n     * <p>\n     * The time will normally be midnight, as that is the earliest time on\n     * any given day. However, in some time zones when Daylight Savings Time\n     * starts, there is no midnight because time jumps from 11:59 to 01:00.\n     * This method handles that situation by returning 01:00 on that date.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return a copy of this datetime with the time set to the start of the day, not null\n     */"}}
{"code": {"body": "    public DateTime withFields(ReadablePartial partial) {\n        if (partial == null) {\n            return this;\n        }\n        return withMillis(getChronology().set(partial, getMillis()));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the partial set of fields replacing those\n     * from this instance.\n     * <p>\n     * For example, if the partial is a <code>TimeOfDay</code> then the time fields\n     * would be changed in the returned instance.\n     * If the partial is null, then <code>this</code> is returned.\n     *\n     * @param partial  the partial set of fields to apply to this datetime, null ignored\n     * @return a copy of this datetime with a different set of fields\n     * @throws IllegalArgumentException if any value is invalid\n     */"}}
{"code": {"body": "    public DateTime withField(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        long instant = fieldType.getField(getChronology()).set(getMillis(), value);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the specified field set to a new value.\n     * <p>\n     * For example, if the field type is <code>hourOfDay</code> then the hour of day\n     * field would be changed in the returned instance.\n     * If the field type is null, then <code>this</code> is returned.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * DateTime updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);\n     * DateTime updated = dt.dayOfMonth().setCopy(6);\n     * DateTime updated = dt.property(DateTimeFieldType.dayOfMonth()).setCopy(6);\n     * </pre>\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this datetime with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     */"}}
{"code": {"body": "    public DateTime withFieldAdded(DurationFieldType fieldType, int amount) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (amount == 0) {\n            return this;\n        }\n        long instant = fieldType.getField(getChronology()).add(getMillis(), amount);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the value of the specified field increased.\n     * <p>\n     * If the addition is zero or the field is null, then <code>this</code> is returned.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * DateTime added = dt.withFieldAdded(DurationFieldType.years(), 6);\n     * DateTime added = dt.plusYears(6);\n     * DateTime added = dt.plus(Period.years(6));\n     * </pre>\n     * \n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this datetime with the field updated\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "    public DateTime withDurationAdded(ReadableDuration durationToAdd, int scalar) {\n        if (durationToAdd == null || scalar == 0) {\n            return this;\n        }\n        return withDurationAdded(durationToAdd.getMillis(), scalar);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the specified duration added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * \n     * @param durationToAdd  the duration to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this datetime with the duration added\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "    public DateTime withPeriodAdded(ReadablePeriod period, int scalar) {\n        if (period == null || scalar == 0) {\n            return this;\n        }\n        long instant = getChronology().add(period, getMillis(), scalar);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the specified period added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to add multiple copies of complex\n     * period instances. Adding one field is best achieved using methods\n     * like {@link #withFieldAdded(DurationFieldType, int)}\n     * or {@link #plusYears(int)}.\n     * \n     * @param period  the period to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this datetime with the period added\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "    public DateTime plus(ReadablePeriod period) {\n        return withPeriodAdded(period, 1);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the specified period added.\n     * <p>\n     * This method will add each element of the period one by one, from largest\n     * to smallest, adjusting the datetime to be accurate between each.\n     * <p>\n     * Thus, adding a period of one month and one day to 2007-03-31 will\n     * work as follows:\n     * First add one month and adjust, resulting in 2007-04-30\n     * Then add one day and adjust, resulting in 2007-05-01.\n     * <p>\n     * This method is typically used to add complex period instances.\n     * Adding one field is best achieved using methods\n     * like {@link #plusYears(int)}.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * This datetime instance is immutable and unaffected by this method call.\n     * \n     * @param period  the duration to add to this one, null means zero\n     * @return a copy of this datetime with the period added\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "    public DateTime plusYears(int years) {\n        if (years == 0) {\n            return this;\n        }\n        long instant = getChronology().years().add(getMillis(), years);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime plus the specified number of years.\n     * <p>\n     * The calculation will do its best to only change the year field\n     * retaining the same month of year.\n     * However, in certain circumstances, it may be necessary to alter\n     * smaller fields. For example, 2008-02-29 plus one year cannot result\n     * in 2009-02-29, so the day of month is adjusted to 2009-02-28.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateTime added = dt.plusYears(6);\n     * DateTime added = dt.plus(Period.years(6));\n     * DateTime added = dt.withFieldAdded(DurationFieldType.years(), 6);\n     * </pre>\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     *\n     * @param years  the amount of years to add, may be negative\n     * @return the new datetime plus the increased years\n     * @since 1.1\n     */"}}
{"code": {"body": "    public DateTime plusMonths(int months) {\n        if (months == 0) {\n            return this;\n        }\n        long instant = getChronology().months().add(getMillis(), months);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime plus the specified number of months.\n     * <p>\n     * The calculation will do its best to only change the month field\n     * retaining the same day of month.\n     * However, in certain circumstances, it may be necessary to alter\n     * smaller fields. For example, 2007-03-31 plus one month cannot result\n     * in 2007-04-31, so the day of month is adjusted to 2007-04-30.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateTime added = dt.plusMonths(6);\n     * DateTime added = dt.plus(Period.months(6));\n     * DateTime added = dt.withFieldAdded(DurationFieldType.months(), 6);\n     * </pre>\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     *\n     * @param months  the amount of months to add, may be negative\n     * @return the new datetime plus the increased months\n     * @since 1.1\n     */"}}
{"code": {"body": "    public DateTime plusWeeks(int weeks) {\n        if (weeks == 0) {\n            return this;\n        }\n        long instant = getChronology().weeks().add(getMillis(), weeks);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime plus the specified number of weeks.\n     * <p>\n     * The calculation operates as if it were adding the equivalent in days.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateTime added = dt.plusWeeks(6);\n     * DateTime added = dt.plus(Period.weeks(6));\n     * DateTime added = dt.withFieldAdded(DurationFieldType.weeks(), 6);\n     * </pre>\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the amount of weeks to add, may be negative\n     * @return the new datetime plus the increased weeks\n     * @since 1.1\n     */"}}
{"code": {"body": "    public DateTime plusDays(int days) {\n        if (days == 0) {\n            return this;\n        }\n        long instant = getChronology().days().add(getMillis(), days);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime plus the specified number of days.\n     * <p>\n     * The calculation will do its best to only change the day field\n     * retaining the same time of day.\n     * However, in certain circumstances, typically daylight savings cutover,\n     * it may be necessary to alter the time fields.\n     * <p>\n     * In spring an hour is typically removed. If adding one day results in\n     * the time being within the cutover then the time is adjusted to be\n     * within summer time. For example, if the cutover is from 01:59 to 03:00\n     * and the result of this method would have been 02:30, then the result\n     * will be adjusted to 03:30.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateTime added = dt.plusDays(6);\n     * DateTime added = dt.plus(Period.days(6));\n     * DateTime added = dt.withFieldAdded(DurationFieldType.days(), 6);\n     * </pre>\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     *\n     * @param days  the amount of days to add, may be negative\n     * @return the new datetime plus the increased days\n     * @since 1.1\n     */"}}
{"code": {"body": "    public DateTime plusHours(int hours) {\n        if (hours == 0) {\n            return this;\n        }\n        long instant = getChronology().hours().add(getMillis(), hours);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime plus the specified number of hours.\n     * <p>\n     * The calculation will add a duration equivalent to the number of hours\n     * expressed in milliseconds.\n     * <p>\n     * For example, if a spring daylight savings cutover is from 01:59 to 03:00\n     * then adding one hour to 01:30 will result in 03:30. This is a duration\n     * of one hour later, even though the hour field value changed from 1 to 3.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateTime added = dt.plusHours(6);\n     * DateTime added = dt.plus(Period.hours(6));\n     * DateTime added = dt.withFieldAdded(DurationFieldType.hours(), 6);\n     * </pre>\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the amount of hours to add, may be negative\n     * @return the new datetime plus the increased hours\n     * @since 1.1\n     */"}}
{"code": {"body": "    public DateTime plusMinutes(int minutes) {\n        if (minutes == 0) {\n            return this;\n        }\n        long instant = getChronology().minutes().add(getMillis(), minutes);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime plus the specified number of minutes.\n     * <p>\n     * The calculation will add a duration equivalent to the number of minutes\n     * expressed in milliseconds.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateTime added = dt.plusMinutes(6);\n     * DateTime added = dt.plus(Period.minutes(6));\n     * DateTime added = dt.withFieldAdded(DurationFieldType.minutes(), 6);\n     * </pre>\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the amount of minutes to add, may be negative\n     * @return the new datetime plus the increased minutes\n     * @since 1.1\n     */"}}
{"code": {"body": "    public DateTime plusSeconds(int seconds) {\n        if (seconds == 0) {\n            return this;\n        }\n        long instant = getChronology().seconds().add(getMillis(), seconds);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime plus the specified number of seconds.\n     * <p>\n     * The calculation will add a duration equivalent to the number of seconds\n     * expressed in milliseconds.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateTime added = dt.plusSeconds(6);\n     * DateTime added = dt.plus(Period.seconds(6));\n     * DateTime added = dt.withFieldAdded(DurationFieldType.seconds(), 6);\n     * </pre>\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the amount of seconds to add, may be negative\n     * @return the new datetime plus the increased seconds\n     * @since 1.1\n     */"}}
{"code": {"body": "    public DateTime plusMillis(int millis) {\n        if (millis == 0) {\n            return this;\n        }\n        long instant = getChronology().millis().add(getMillis(), millis);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime plus the specified number of millis.\n     * <p>\n     * The calculation will add a duration equivalent to the number of milliseconds.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateTime added = dt.plusMillis(6);\n     * DateTime added = dt.plus(Period.millis(6));\n     * DateTime added = dt.withFieldAdded(DurationFieldType.millis(), 6);\n     * </pre>\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     *\n     * @param millis  the amount of millis to add, may be negative\n     * @return the new datetime plus the increased millis\n     * @since 1.1\n     */"}}
{"code": {"body": "    public DateTime minus(ReadablePeriod period) {\n        return withPeriodAdded(period, -1);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the specified period taken away.\n     * <p>\n     * This method will subtract each element of the period one by one, from\n     * largest to smallest, adjusting the datetime to be accurate between each.\n     * <p>\n     * Thus, subtracting a period of one month and one day from 2007-05-31 will\n     * work as follows:\n     * First subtract one month and adjust, resulting in 2007-04-30\n     * Then subtract one day and adjust, resulting in 2007-04-29.\n     * Note that the day has been adjusted by two.\n     * <p>\n     * This method is typically used to subtract complex period instances.\n     * Subtracting one field is best achieved using methods\n     * like {@link #minusYears(int)}.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * This datetime instance is immutable and unaffected by this method call.\n     * \n     * @param period  the period to reduce this instant by\n     * @return a copy of this datetime with the period taken away\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "    public DateTime minusYears(int years) {\n        if (years == 0) {\n            return this;\n        }\n        long instant = getChronology().years().subtract(getMillis(), years);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime minus the specified number of years.\n     * <p>\n     * The calculation will do its best to only change the year field\n     * retaining the same month of year.\n     * However, in certain circumstances, it may be necessary to alter\n     * smaller fields. For example, 2008-02-29 minus one year cannot result\n     * in 2007-02-29, so the day of month is adjusted to 2007-02-28.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateTime subtracted = dt.minusYears(6);\n     * DateTime subtracted = dt.minus(Period.years(6));\n     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);\n     * </pre>\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     *\n     * @param years  the amount of years to subtract, may be negative\n     * @return the new datetime minus the increased years\n     * @since 1.1\n     */"}}
{"code": {"body": "    public DateTime minusMonths(int months) {\n        if (months == 0) {\n            return this;\n        }\n        long instant = getChronology().months().subtract(getMillis(), months);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime minus the specified number of months.\n     * <p>\n     * The calculation will do its best to only change the month field\n     * retaining the same day of month.\n     * However, in certain circumstances, it may be necessary to alter\n     * smaller fields. For example, 2007-05-31 minus one month cannot result\n     * in 2007-04-31, so the day of month is adjusted to 2007-04-30.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateTime subtracted = dt.minusMonths(6);\n     * DateTime subtracted = dt.minus(Period.months(6));\n     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);\n     * </pre>\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     *\n     * @param months  the amount of months to subtract, may be negative\n     * @return the new datetime minus the increased months\n     * @since 1.1\n     */"}}
{"code": {"body": "    public DateTime minusWeeks(int weeks) {\n        if (weeks == 0) {\n            return this;\n        }\n        long instant = getChronology().weeks().subtract(getMillis(), weeks);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime minus the specified number of weeks.\n     * <p>\n     * The calculation operates as if it were subtracting the equivalent in days.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateTime subtracted = dt.minusWeeks(6);\n     * DateTime subtracted = dt.minus(Period.weeks(6));\n     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6);\n     * </pre>\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the amount of weeks to subtract, may be negative\n     * @return the new datetime minus the increased weeks\n     * @since 1.1\n     */"}}
{"code": {"body": "    public DateTime minusDays(int days) {\n        if (days == 0) {\n            return this;\n        }\n        long instant = getChronology().days().subtract(getMillis(), days);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime minus the specified number of days.\n     * <p>\n     * The calculation will do its best to only change the day field\n     * retaining the same time of day.\n     * However, in certain circumstances, typically daylight savings cutover,\n     * it may be necessary to alter the time fields.\n     * <p>\n     * In spring an hour is typically removed. If subtracting one day results\n     * in the time being within the cutover then the time is adjusted to be\n     * within summer time. For example, if the cutover is from 01:59 to 03:00\n     * and the result of this method would have been 02:30, then the result\n     * will be adjusted to 03:30.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateTime subtracted = dt.minusDays(6);\n     * DateTime subtracted = dt.minus(Period.days(6));\n     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);\n     * </pre>\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     *\n     * @param days  the amount of days to subtract, may be negative\n     * @return the new datetime minus the increased days\n     * @since 1.1\n     */"}}
{"code": {"body": "    public DateTime minusHours(int hours) {\n        if (hours == 0) {\n            return this;\n        }\n        long instant = getChronology().hours().subtract(getMillis(), hours);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime minus the specified number of hours.\n     * <p>\n     * The calculation will subtract a duration equivalent to the number of\n     * hours expressed in milliseconds.\n     * <p>\n     * For example, if a spring daylight savings cutover is from 01:59 to 03:00\n     * then subtracting one hour from 03:30 will result in 01:30. This is a\n     * duration of one hour earlier, even though the hour field value changed\n     * from 3 to 1.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateTime subtracted = dt.minusHours(6);\n     * DateTime subtracted = dt.minus(Period.hours(6));\n     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.hours(), -6);\n     * </pre>\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the amount of hours to subtract, may be negative\n     * @return the new datetime minus the increased hours\n     * @since 1.1\n     */"}}
{"code": {"body": "    public DateTime minusMinutes(int minutes) {\n        if (minutes == 0) {\n            return this;\n        }\n        long instant = getChronology().minutes().subtract(getMillis(), minutes);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime minus the specified number of minutes.\n     * <p>\n     * The calculation will subtract a duration equivalent to the number of\n     * minutes expressed in milliseconds.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateTime subtracted = dt.minusMinutes(6);\n     * DateTime subtracted = dt.minus(Period.minutes(6));\n     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.minutes(), -6);\n     * </pre>\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the amount of minutes to subtract, may be negative\n     * @return the new datetime minus the increased minutes\n     * @since 1.1\n     */"}}
{"code": {"body": "    public DateTime minusSeconds(int seconds) {\n        if (seconds == 0) {\n            return this;\n        }\n        long instant = getChronology().seconds().subtract(getMillis(), seconds);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime minus the specified number of seconds.\n     * <p>\n     * The calculation will subtract a duration equivalent to the number of\n     * seconds expressed in milliseconds.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateTime subtracted = dt.minusSeconds(6);\n     * DateTime subtracted = dt.minus(Period.seconds(6));\n     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.seconds(), -6);\n     * </pre>\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the amount of seconds to subtract, may be negative\n     * @return the new datetime minus the increased seconds\n     * @since 1.1\n     */"}}
{"code": {"body": "    public DateTime minusMillis(int millis) {\n        if (millis == 0) {\n            return this;\n        }\n        long instant = getChronology().millis().subtract(getMillis(), millis);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime minus the specified number of millis.\n     * <p>\n     * The calculation will subtract a duration equivalent to the number of\n     * milliseconds.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * DateTime subtracted = dt.minusMillis(6);\n     * DateTime subtracted = dt.minus(Period.millis(6));\n     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.millis(), -6);\n     * </pre>\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     *\n     * @param millis  the amount of millis to subtract, may be negative\n     * @return the new datetime minus the increased millis\n     * @since 1.1\n     */"}}
{"code": {"body": "    public Property property(DateTimeFieldType type) {\n        if (type == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        DateTimeField field = type.getField(getChronology());\n        if (field.isSupported() == false) {\n            throw new IllegalArgumentException(\"\" + type + \"\");\n        }\n        return new Property(this, field);\n    }", "comment": "/**\n     * Gets the property object for the specified type, which contains many useful methods.\n     *\n     * @param type  the field type to get the chronology for\n     * @return the property object\n     * @throws IllegalArgumentException if the field is null or unsupported\n     */"}}
{"code": {"body": "    public LocalDateTime toLocalDateTime() {\n        return new LocalDateTime(getMillis(), getChronology());\n    }", "comment": "/**\n     * Converts this object to a <code>LocalDateTime</code> with\n     * the same datetime and chronology.\n     *\n     * @return a LocalDateTime with the same datetime and chronology\n     * @since 1.3\n     */"}}
{"code": {"body": "    public LocalDate toLocalDate() {\n        return new LocalDate(getMillis(), getChronology());\n    }", "comment": "/**\n     * Converts this object to a <code>LocalDate</code> with the\n     * same date and chronology.\n     *\n     * @return a LocalDate with the same date and chronology\n     * @since 1.3\n     */"}}
{"code": {"body": "    public LocalTime toLocalTime() {\n        return new LocalTime(getMillis(), getChronology());\n    }", "comment": "/**\n     * Converts this object to a <code>LocalTime</code> with the\n     * same time and chronology.\n     *\n     * @return a LocalTime with the same time and chronology\n     * @since 1.3\n     */"}}
{"code": {"body": "    public DateTime withEra(int era) {\n        return withMillis(getChronology().era().set(getMillis(), era));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the era field updated.\n     * <p>\n     * DateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * era changed.\n     *\n     * @param era  the era to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "    public DateTime withCenturyOfEra(int centuryOfEra) {\n        return withMillis(getChronology().centuryOfEra().set(getMillis(), centuryOfEra));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the century of era field updated.\n     * <p>\n     * DateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * century of era changed.\n     *\n     * @param centuryOfEra  the centurey of era to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "    public DateTime withYearOfEra(int yearOfEra) {\n        return withMillis(getChronology().yearOfEra().set(getMillis(), yearOfEra));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the year of era field updated.\n     * <p>\n     * DateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year of era changed.\n     *\n     * @param yearOfEra  the year of era to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "    public DateTime withYearOfCentury(int yearOfCentury) {\n        return withMillis(getChronology().yearOfCentury().set(getMillis(), yearOfCentury));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the year of century field updated.\n     * <p>\n     * DateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year of century changed.\n     *\n     * @param yearOfCentury  the year of century to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "    public DateTime withYear(int year) {\n        return withMillis(getChronology().year().set(getMillis(), year));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the year field updated.\n     * <p>\n     * DateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year changed.\n     *\n     * @param year  the year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "    public DateTime withWeekyear(int weekyear) {\n        return withMillis(getChronology().weekyear().set(getMillis(), weekyear));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the weekyear field updated.\n     * <p>\n     * The weekyear is the year that matches with the weekOfWeekyear field.\n     * In the standard ISO8601 week algorithm, the first week of the year\n     * is that in which at least 4 days are in the year. As a result of this\n     * definition, day 1 of the first week may be in the previous year.\n     * The weekyear allows you to query the effective year for that day.\n     * <p>\n     * DateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * weekyear changed.\n     *\n     * @param weekyear  the weekyear to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "    public DateTime withMonthOfYear(int monthOfYear) {\n        return withMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the month of year field updated.\n     * <p>\n     * DateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * month of year changed.\n     *\n     * @param monthOfYear  the month of year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "    public DateTime withWeekOfWeekyear(int weekOfWeekyear) {\n        return withMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the week of weekyear field updated.\n     * <p>\n     * This field is associated with the \"weekyear\" via {@link #withWeekyear(int)}.\n     * In the standard ISO8601 week algorithm, the first week of the year\n     * is that in which at least 4 days are in the year. As a result of this\n     * definition, day 1 of the first week may be in the previous year.\n     * <p>\n     * DateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * week of weekyear changed.\n     *\n     * @param weekOfWeekyear  the week of weekyear to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "    public DateTime withDayOfYear(int dayOfYear) {\n        return withMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the day of year field updated.\n     * <p>\n     * DateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of year changed.\n     *\n     * @param dayOfYear  the day of year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "    public DateTime withDayOfMonth(int dayOfMonth) {\n        return withMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the day of month field updated.\n     * <p>\n     * DateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of month changed.\n     *\n     * @param dayOfMonth  the day of month to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "    public DateTime withDayOfWeek(int dayOfWeek) {\n        return withMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the day of week field updated.\n     * <p>\n     * DateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of week changed.\n     *\n     * @param dayOfWeek  the day of week to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "    public DateTime withHourOfDay(int hour) {\n        return withMillis(getChronology().hourOfDay().set(getMillis(), hour));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the hour of day field updated.\n     * <p>\n     * DateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * hour of day changed.\n     *\n     * @param hour  the hour of day to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "    public DateTime withMinuteOfHour(int minute) {\n        return withMillis(getChronology().minuteOfHour().set(getMillis(), minute));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the minute of hour updated.\n     * <p>\n     * DateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * minute of hour changed.\n     *\n     * @param minute  the minute of hour to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "    public DateTime withSecondOfMinute(int second) {\n        return withMillis(getChronology().secondOfMinute().set(getMillis(), second));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the second of minute field updated.\n     * <p>\n     * DateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * second of minute changed.\n     *\n     * @param second  the second of minute to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "    public DateTime withMillisOfSecond(int millis) {\n        return withMillis(getChronology().millisOfSecond().set(getMillis(), millis));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the millis of second field updated.\n     * <p>\n     * DateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * millis of second changed.\n     *\n     * @param millis  the millis of second to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "    public DateTime withMillisOfDay(int millis) {\n        return withMillis(getChronology().millisOfDay().set(getMillis(), millis));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the millis of day field updated.\n     * <p>\n     * DateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * millis of day changed.\n     *\n     * @param millis  the millis of day to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "    public Property era() {\n        return new Property(this, getChronology().era());\n    }", "comment": "/**\n     * Get the era property which provides access to advanced functionality.\n     * \n     * @return the era property\n     */"}}
{"code": {"body": "    public Property centuryOfEra() {\n        return new Property(this, getChronology().centuryOfEra());\n    }", "comment": "/**\n     * Get the century of era property which provides access to advanced functionality.\n     * \n     * @return the year of era property\n     */"}}
{"code": {"body": "    public Property yearOfCentury() {\n        return new Property(this, getChronology().yearOfCentury());\n    }", "comment": "/**\n     * Get the year of century property which provides access to advanced functionality.\n     * \n     * @return the year of era property\n     */"}}
{"code": {"body": "    public Property yearOfEra() {\n        return new Property(this, getChronology().yearOfEra());\n    }", "comment": "/**\n     * Get the year of era property which provides access to advanced functionality.\n     * \n     * @return the year of era property\n     */"}}
{"code": {"body": "    public Property year() {\n        return new Property(this, getChronology().year());\n    }", "comment": "/**\n     * Get the year property which provides access to advanced functionality.\n     * \n     * @return the year property\n     */"}}
{"code": {"body": "    public Property weekyear() {\n        return new Property(this, getChronology().weekyear());\n    }", "comment": "/**\n     * Get the year of a week based year property which provides access to advanced functionality.\n     * \n     * @return the year of a week based year property\n     */"}}
{"code": {"body": "    public Property monthOfYear() {\n        return new Property(this, getChronology().monthOfYear());\n    }", "comment": "/**\n     * Get the month of year property which provides access to advanced functionality.\n     * \n     * @return the month of year property\n     */"}}
{"code": {"body": "    public Property weekOfWeekyear() {\n        return new Property(this, getChronology().weekOfWeekyear());\n    }", "comment": "/**\n     * Get the week of a week based year property which provides access to advanced functionality.\n     * \n     * @return the week of a week based year property\n     */"}}
{"code": {"body": "    public Property dayOfYear() {\n        return new Property(this, getChronology().dayOfYear());\n    }", "comment": "/**\n     * Get the day of year property which provides access to advanced functionality.\n     * \n     * @return the day of year property\n     */"}}
{"code": {"body": "    public Property dayOfMonth() {\n        return new Property(this, getChronology().dayOfMonth());\n    }", "comment": "/**\n     * Get the day of month property which provides access to advanced functionality.\n     * \n     * @return the day of month property\n     */"}}
{"code": {"body": "    public Property dayOfWeek() {\n        return new Property(this, getChronology().dayOfWeek());\n    }", "comment": "/**\n     * Get the day of week property which provides access to advanced functionality.\n     * \n     * @return the day of week property\n     */"}}
{"code": {"body": "    public Property hourOfDay() {\n        return new Property(this, getChronology().hourOfDay());\n    }", "comment": "/**\n     * Get the hour of day field property which provides access to advanced functionality.\n     * \n     * @return the hour of day property\n     */"}}
{"code": {"body": "    public Property minuteOfDay() {\n        return new Property(this, getChronology().minuteOfDay());\n    }", "comment": "/**\n     * Get the minute of day property which provides access to advanced functionality.\n     * \n     * @return the minute of day property\n     */"}}
{"code": {"body": "    public Property minuteOfHour() {\n        return new Property(this, getChronology().minuteOfHour());\n    }", "comment": "/**\n     * Get the minute of hour field property which provides access to advanced functionality.\n     * \n     * @return the minute of hour property\n     */"}}
{"code": {"body": "    public Property secondOfDay() {\n        return new Property(this, getChronology().secondOfDay());\n    }", "comment": "/**\n     * Get the second of day property which provides access to advanced functionality.\n     * \n     * @return the second of day property\n     */"}}
{"code": {"body": "    public Property secondOfMinute() {\n        return new Property(this, getChronology().secondOfMinute());\n    }", "comment": "/**\n     * Get the second of minute field property which provides access to advanced functionality.\n     * \n     * @return the second of minute property\n     */"}}
{"code": {"body": "    public Property millisOfDay() {\n        return new Property(this, getChronology().millisOfDay());\n    }", "comment": "/**\n     * Get the millis of day property which provides access to advanced functionality.\n     * \n     * @return the millis of day property\n     */"}}
{"code": {"body": "    public Property millisOfSecond() {\n        return new Property(this, getChronology().millisOfSecond());\n    }", "comment": "/**\n     * Get the millis of second property which provides access to advanced functionality.\n     * \n     * @return the millis of second property\n     */"}}
{"code": {"body": "        private void writeObject(ObjectOutputStream oos) throws IOException {\n            oos.writeObject(iInstant);\n            oos.writeObject(iField.getType());\n        }", "comment": "/**\n         * Writes the property in a safe serialization format.\n         */"}}
{"code": {"body": "        private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {\n            iInstant = (DateTime) oos.readObject();\n            DateTimeFieldType type = (DateTimeFieldType) oos.readObject();\n            iField = type.getField(iInstant.getChronology());\n        }", "comment": "/**\n         * Reads the property from a safe serialization format.\n         */"}}
{"code": {"body": "        public DateTimeField getField() {\n            return iField;\n        }", "comment": "/**\n         * Gets the field being used.\n         * \n         * @return the field\n         */"}}
{"code": {"body": "        protected long getMillis() {\n            return iInstant.getMillis();\n        }", "comment": "/**\n         * Gets the milliseconds of the datetime that this property is linked to.\n         * \n         * @return the milliseconds\n         */"}}
{"code": {"body": "        protected Chronology getChronology() {\n            return iInstant.getChronology();\n        }", "comment": "/**\n         * Gets the chronology of the datetime that this property is linked to.\n         * \n         * @return the chronology\n         * @since 1.4\n         */"}}
{"code": {"body": "        public DateTime getDateTime() {\n            return iInstant;\n        }", "comment": "/**\n         * Gets the datetime being used.\n         * \n         * @return the datetime\n         */"}}
{"code": {"body": "        public DateTime addToCopy(long value) {\n            return iInstant.withMillis(iField.add(iInstant.getMillis(), value));\n        }", "comment": "/**\n         * Adds to this field in a copy of this DateTime.\n         * <p>\n         * The DateTime attached to this property is unchanged by this call.\n         * This operation is faster than converting a DateTime to a MutableDateTime\n         * and back again when setting one field. When setting multiple fields,\n         * it is generally quicker to make the conversion to MutableDateTime.\n         * \n         * @param value  the value to add to the field in the copy\n         * @return a copy of the DateTime with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "        public DateTime addWrapFieldToCopy(int value) {\n            return iInstant.withMillis(iField.addWrapField(iInstant.getMillis(), value));\n        }", "comment": "/**\n         * Adds to this field, possibly wrapped, in a copy of this DateTime.\n         * A wrapped operation only changes this field.\n         * Thus 31st January addWrapField one day goes to the 1st January.\n         * <p>\n         * The DateTime attached to this property is unchanged by this call.\n         * This operation is faster than converting a DateTime to a MutableDateTime\n         * and back again when setting one field. When setting multiple fields,\n         * it is generally quicker to make the conversion to MutableDateTime.\n         * \n         * @param value  the value to add to the field in the copy\n         * @return a copy of the DateTime with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "        public DateTime setCopy(String text) {\n            return setCopy(text, null);\n        }", "comment": "/**\n         * Sets this field in a copy of the DateTime to a parsed text value.\n         * <p>\n         * The DateTime attached to this property is unchanged by this call.\n         * This operation is faster than converting a DateTime to a MutableDateTime\n         * and back again when setting one field. When setting multiple fields,\n         * it is generally quicker to make the conversion to MutableDateTime.\n         * \n         * @param text  the text value to set\n         * @return a copy of the DateTime with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */"}}
{"code": {"body": "        public DateTime withMaximumValue() {\n            try {\n                return setCopy(getMaximumValue());\n            } catch (RuntimeException ex) {\n                if (IllegalInstantException.isIllegalInstant(ex)) {\n                    \n                    long beforeGap = getChronology().getZone().previousTransition(getMillis() + DateTimeConstants.MILLIS_PER_DAY);\n                    return new DateTime(beforeGap, getChronology());\n                }\n                throw ex;\n            }\n        }", "comment": "/**\n         * Returns a new DateTime with this field set to the maximum value\n         * for this field.\n         * <p>\n         * This operation is useful for obtaining a DateTime on the last day\n         * of the month, as month lengths vary.\n         * <pre>\n         * DateTime lastDayOfMonth = dt.dayOfMonth().withMaximumValue();\n         * </pre>\n         * <p>\n         * Where possible, the offset from UTC will be retained, thus applications\n         * may need to call {@link DateTime#withLaterOffsetAtOverlap()} on the result\n         * to force the later time during a DST overlap if desired.\n         * <p>\n         * From v2.2, this method handles a daylight svaings time gap, setting the\n         * time to the last instant before the gap.\n         * <p>\n         * The DateTime attached to this property is unchanged by this call.\n         *\n         * @return a copy of the DateTime with this field set to its maximum\n         * @since 1.2\n         */"}}
{"code": {"body": "        public DateTime withMinimumValue() {\n            try {\n                return setCopy(getMinimumValue());\n            } catch (RuntimeException ex) {\n                if (IllegalInstantException.isIllegalInstant(ex)) {\n                    \n                    long afterGap = getChronology().getZone().nextTransition(getMillis() - DateTimeConstants.MILLIS_PER_DAY);\n                    return new DateTime(afterGap, getChronology());\n                }\n                throw ex;\n            }\n        }", "comment": "/**\n         * Returns a new DateTime with this field set to the minimum value\n         * for this field.\n         * <p>\n         * Where possible, the offset from UTC will be retained, thus applications\n         * may need to call {@link DateTime#withEarlierOffsetAtOverlap()} on the result\n         * to force the earlier time during a DST overlap if desired.\n         * <p>\n         * From v2.2, this method handles a daylight svaings time gap, setting the\n         * time to the first instant after the gap.\n         * <p>\n         * The DateTime attached to this property is unchanged by this call.\n         *\n         * @return a copy of the DateTime with this field set to its minimum\n         * @since 1.2\n         */"}}
{"code": {"body": "        public DateTime roundFloorCopy() {\n            return iInstant.withMillis(iField.roundFloor(iInstant.getMillis()));\n        }", "comment": "/**\n         * Rounds to the lowest whole unit of this field on a copy of this DateTime.\n         *\n         * @return a copy of the DateTime with the field value changed\n         */"}}
{"code": {"body": "        public DateTime roundCeilingCopy() {\n            return iInstant.withMillis(iField.roundCeiling(iInstant.getMillis()));\n        }", "comment": "/**\n         * Rounds to the highest whole unit of this field on a copy of this DateTime.\n         *\n         * @return a copy of the DateTime with the field value changed\n         */"}}
{"code": {"body": "        public DateTime roundHalfFloorCopy() {\n            return iInstant.withMillis(iField.roundHalfFloor(iInstant.getMillis()));\n        }", "comment": "/**\n         * Rounds to the nearest whole unit of this field on a copy of this DateTime,\n         * favoring the floor if halfway.\n         *\n         * @return a copy of the DateTime with the field value changed\n         */"}}
{"code": {"body": "        public DateTime roundHalfCeilingCopy() {\n            return iInstant.withMillis(iField.roundHalfCeiling(iInstant.getMillis()));\n        }", "comment": "/**\n         * Rounds to the nearest whole unit of this field on a copy of this DateTime,\n         * favoring the ceiling if halfway.\n         *\n         * @return a copy of the DateTime with the field value changed\n         */"}}
{"code": {"body": "        public DateTime roundHalfEvenCopy() {\n            return iInstant.withMillis(iField.roundHalfEven(iInstant.getMillis()));\n        }", "comment": "/**\n         * Rounds to the nearest whole unit of this field on a copy of this\n         * DateTime.  If halfway, the ceiling is favored over the floor only if\n         * it makes this field's value even.\n         *\n         * @return a copy of the DateTime with the field value changed\n         */"}}
{"code": {"body": "    public static DateTimeComparator getInstance(DateTimeFieldType lowerLimit, DateTimeFieldType upperLimit) {\n        if (lowerLimit == null && upperLimit == null) {\n            return ALL_INSTANCE;\n        }\n        if (lowerLimit == DateTimeFieldType.dayOfYear() && upperLimit == null) {\n            return DATE_INSTANCE;\n        }\n        if (lowerLimit == null && upperLimit == DateTimeFieldType.dayOfYear()) {\n            return TIME_INSTANCE;\n        }\n        return new DateTimeComparator(lowerLimit, upperLimit);\n    }", "comment": "/**\n     * Returns a DateTimeComparator with a lower and upper limit. Fields of a\n     * magnitude less than the lower limit are excluded from comparisons.\n     * Fields of a magnitude greater than or equal to the upper limit are also\n     * excluded from comparisons. Either limit may be specified as null, which\n     * indicates an unbounded limit.\n     *\n     * @param lowerLimit  inclusive lower limit for fields to be compared, null means no limit\n     * @param upperLimit  exclusive upper limit for fields to be compared, null means no limit\n     * @return a comparator over all fields between the limits\n     */"}}
{"code": {"body": "    public static DateTimeComparator getDateOnlyInstance() {\n        return DATE_INSTANCE;\n    }", "comment": "/**\n     * Returns a comparator that only considers date fields.\n     * Time of day is ignored.\n     * \n     * @return a comparator over all date fields\n     */"}}
{"code": {"body": "    public static DateTimeComparator getTimeOnlyInstance() {\n        return TIME_INSTANCE;\n    }", "comment": "/**\n     * Returns a comparator that only considers time fields.\n     * Date is ignored.\n     * \n     * @return a comparator over all time fields\n     */"}}
{"code": {"body": "    public DateTimeFieldType getLowerLimit() {\n        return iLowerLimit;\n    }", "comment": "/**\n     * Gets the field type that represents the lower limit of comparison.\n     * \n     * @return the field type, null if no upper limit\n     */"}}
{"code": {"body": "    public DateTimeFieldType getUpperLimit() {\n        return iUpperLimit;\n    }", "comment": "/**\n     * Gets the field type that represents the upper limit of comparison.\n     * \n     * @return the field type, null if no upper limit\n     */"}}
{"code": {"body": "    public int compare(Object lhsObj, Object rhsObj) {\n        InstantConverter conv = ConverterManager.getInstance().getInstantConverter(lhsObj);\n        Chronology lhsChrono = conv.getChronology(lhsObj, (Chronology) null);\n        long lhsMillis = conv.getInstantMillis(lhsObj, lhsChrono);\n        \n        conv = ConverterManager.getInstance().getInstantConverter(rhsObj);\n        Chronology rhsChrono = conv.getChronology(rhsObj, (Chronology) null);\n        long rhsMillis = conv.getInstantMillis(rhsObj, rhsChrono);\n\n        if (iLowerLimit != null) {\n            lhsMillis = iLowerLimit.getField(lhsChrono).roundFloor(lhsMillis);\n            rhsMillis = iLowerLimit.getField(rhsChrono).roundFloor(rhsMillis);\n        }\n\n        if (iUpperLimit != null) {\n            lhsMillis = iUpperLimit.getField(lhsChrono).remainder(lhsMillis);\n            rhsMillis = iUpperLimit.getField(rhsChrono).remainder(rhsMillis);\n        }\n\n        if (lhsMillis < rhsMillis) {\n            return -1;\n        } else if (lhsMillis > rhsMillis) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }", "comment": "/**\n     * Compare two objects against only the range of date time fields as\n     * specified in the constructor.\n     * \n     * @param lhsObj  the first object,\n     *      logically on the left of a &lt; comparison, null means now\n     * @param rhsObj  the second object,\n     *      logically on the right of a &lt; comparison, null means now\n     * @return zero if order does not matter,\n     *      negative value if lhsObj &lt; rhsObj, positive value otherwise.\n     * @throws IllegalArgumentException if either argument is not supported\n     */"}}
{"code": {"body": "    private Object readResolve() {\n        return getInstance(iLowerLimit, iUpperLimit);\n    }", "comment": "/**\n     * Support serialization singletons.\n     * \n     * @return the resolved singleton instance\n     */"}}
{"code": {"body": "    public boolean equals(Object object) {\n        if (object instanceof DateTimeComparator) {\n            DateTimeComparator other = (DateTimeComparator) object;\n            return (iLowerLimit == other.getLowerLimit() ||\n                    (iLowerLimit != null && iLowerLimit.equals(other.getLowerLimit()))) &&\n                   (iUpperLimit == other.getUpperLimit() ||\n                    (iUpperLimit != null && iUpperLimit.equals(other.getUpperLimit())));\n        }\n        return false;\n    }", "comment": "/**\n     * Compares this comparator to another.\n     * \n     * @param object  the object to compare to\n     * @return true if equal\n     */"}}
{"code": {"body": "    public int hashCode() {\n        return (iLowerLimit == null ? 0 : iLowerLimit.hashCode()) +\n               (123 * (iUpperLimit == null ? 0 : iUpperLimit.hashCode()));\n    }", "comment": "/**\n     * Gets a suitable hashcode.\n     * \n     * @return the hashcode\n     */"}}
{"code": {"body": "    public String toString() {\n        if (iLowerLimit == iUpperLimit) {\n            return \"\"\n                + (iLowerLimit == null ? \"\" : iLowerLimit.getName())\n                + \"\";\n        } else {\n            return \"\"\n                + (iLowerLimit == null ? \"\" : iLowerLimit.getName())\n                + \"\"\n                + (iUpperLimit == null ? \"\" : iUpperLimit.getName())\n                + \"\";\n        }\n    }", "comment": "/**\n     * Gets a debugging string.\n     * \n     * @return a debugging string\n     */"}}
{"code": {"body": "    public static DateTimeFieldType millisOfSecond() {\n        return MILLIS_OF_SECOND_TYPE;\n    }", "comment": "/**\n     * Get the millis of second field type.\n     * \n     * @return the DateTimeFieldType constant\n     */"}}
{"code": {"body": "    public static DateTimeFieldType millisOfDay() {\n        return MILLIS_OF_DAY_TYPE;\n    }", "comment": "/**\n     * Get the millis of day field type.\n     * \n     * @return the DateTimeFieldType constant\n     */"}}
{"code": {"body": "    public static DateTimeFieldType secondOfMinute() {\n        return SECOND_OF_MINUTE_TYPE;\n    }", "comment": "/**\n     * Get the second of minute field type.\n     * \n     * @return the DateTimeFieldType constant\n     */"}}
{"code": {"body": "    public static DateTimeFieldType secondOfDay() {\n        return SECOND_OF_DAY_TYPE;\n    }", "comment": "/**\n     * Get the second of day field type.\n     * \n     * @return the DateTimeFieldType constant\n     */"}}
{"code": {"body": "    public static DateTimeFieldType minuteOfHour() {\n        return MINUTE_OF_HOUR_TYPE;\n    }", "comment": "/**\n     * Get the minute of hour field type.\n     * \n     * @return the DateTimeFieldType constant\n     */"}}
{"code": {"body": "    public static DateTimeFieldType minuteOfDay() {\n        return MINUTE_OF_DAY_TYPE;\n    }", "comment": "/**\n     * Get the minute of day field type.\n     * \n     * @return the DateTimeFieldType constant\n     */"}}
{"code": {"body": "    public static DateTimeFieldType hourOfDay() {\n        return HOUR_OF_DAY_TYPE;\n    }", "comment": "/**\n     * Get the hour of day (0-23) field type.\n     * \n     * @return the DateTimeFieldType constant\n     */"}}
{"code": {"body": "    public static DateTimeFieldType clockhourOfDay() {\n        return CLOCKHOUR_OF_DAY_TYPE;\n    }", "comment": "/**\n     * Get the hour of day (offset to 1-24) field type.\n     * \n     * @return the DateTimeFieldType constant\n     */"}}
{"code": {"body": "    public static DateTimeFieldType hourOfHalfday() {\n        return HOUR_OF_HALFDAY_TYPE;\n    }", "comment": "/**\n     * Get the hour of am/pm (0-11) field type.\n     * \n     * @return the DateTimeFieldType constant\n     */"}}
{"code": {"body": "    public static DateTimeFieldType clockhourOfHalfday() {\n        return CLOCKHOUR_OF_HALFDAY_TYPE;\n    }", "comment": "/**\n     * Get the hour of am/pm (offset to 1-12) field type.\n     * \n     * @return the DateTimeFieldType constant\n     */"}}
{"code": {"body": "    public static DateTimeFieldType halfdayOfDay() {\n        return HALFDAY_OF_DAY_TYPE;\n    }", "comment": "/**\n     * Get the AM(0) PM(1) field type.\n     * \n     * @return the DateTimeFieldType constant\n     */"}}
{"code": {"body": "    public static DateTimeFieldType dayOfWeek() {\n        return DAY_OF_WEEK_TYPE;\n    }", "comment": "/**\n     * Get the day of week field type.\n     * \n     * @return the DateTimeFieldType constant\n     */"}}
{"code": {"body": "    public static DateTimeFieldType dayOfMonth() {\n        return DAY_OF_MONTH_TYPE;\n    }", "comment": "/**\n     * Get the day of month field type.\n     * \n     * @return the DateTimeFieldType constant\n     */"}}
{"code": {"body": "    public static DateTimeFieldType dayOfYear() {\n        return DAY_OF_YEAR_TYPE;\n    }", "comment": "/**\n     * Get the day of year field type.\n     * \n     * @return the DateTimeFieldType constant\n     */"}}
{"code": {"body": "    public static DateTimeFieldType weekOfWeekyear() {\n        return WEEK_OF_WEEKYEAR_TYPE;\n    }", "comment": "/**\n     * Get the week of a week based year field type.\n     * \n     * @return the DateTimeFieldType constant\n     */"}}
{"code": {"body": "    public static DateTimeFieldType weekyear() {\n        return WEEKYEAR_TYPE;\n    }", "comment": "/**\n     * Get the year of a week based year field type.\n     * \n     * @return the DateTimeFieldType constant\n     */"}}
{"code": {"body": "    public static DateTimeFieldType weekyearOfCentury() {\n        return WEEKYEAR_OF_CENTURY_TYPE;\n    }", "comment": "/**\n     * Get the year of a week based year within a century field type.\n     * \n     * @return the DateTimeFieldType constant\n     */"}}
{"code": {"body": "    public static DateTimeFieldType monthOfYear() {\n        return MONTH_OF_YEAR_TYPE;\n    }", "comment": "/**\n     * Get the month of year field type.\n     * \n     * @return the DateTimeFieldType constant\n     */"}}
{"code": {"body": "    public static DateTimeFieldType year() {\n        return YEAR_TYPE;\n    }", "comment": "/**\n     * Get the year field type.\n     * \n     * @return the DateTimeFieldType constant\n     */"}}
{"code": {"body": "    public static DateTimeFieldType yearOfEra() {\n        return YEAR_OF_ERA_TYPE;\n    }", "comment": "/**\n     * Get the year of era field type.\n     * \n     * @return the DateTimeFieldType constant\n     */"}}
{"code": {"body": "    public static DateTimeFieldType yearOfCentury() {\n        return YEAR_OF_CENTURY_TYPE;\n    }", "comment": "/**\n     * Get the year of century field type.\n     * \n     * @return the DateTimeFieldType constant\n     */"}}
{"code": {"body": "    public static DateTimeFieldType centuryOfEra() {\n        return CENTURY_OF_ERA_TYPE;\n    }", "comment": "/**\n     * Get the century of era field type.\n     * \n     * @return the DateTimeFieldType constant\n     */"}}
{"code": {"body": "    public static DateTimeFieldType era() {\n        return ERA_TYPE;\n    }", "comment": "/**\n     * Get the era field type.\n     * \n     * @return the DateTimeFieldType constant\n     */"}}
{"code": {"body": "    public String getName() {\n        return iName;\n    }", "comment": "/**\n     * Get the name of the field.\n     * <p>\n     * By convention, names follow a pattern of \"dddOfRrr\", where \"ddd\" represents\n     * the (singular) duration unit field name and \"Rrr\" represents the (singular)\n     * duration range field name. If the range field is not applicable, then\n     * the name of the field is simply the (singular) duration field name.\n     * \n     * @return field name\n     */"}}
{"code": {"body": "        public DurationFieldType getDurationType() {\n            return iUnitType;\n        }", "comment": "/** @inheritdoc */"}}
{"code": {"body": "        public DurationFieldType getRangeDurationType() {\n            return iRangeType;\n        }", "comment": "/** @inheritdoc */"}}
{"code": {"body": "        public DateTimeField getField(Chronology chronology) {\n            chronology = DateTimeUtils.getChronology(chronology);\n\n            switch (iOrdinal) {\n                case ERA:\n                    return chronology.era();\n                case YEAR_OF_ERA:\n                    return chronology.yearOfEra();\n                case CENTURY_OF_ERA:\n                    return chronology.centuryOfEra();\n                case YEAR_OF_CENTURY:\n                    return chronology.yearOfCentury();\n                case YEAR:\n                    return chronology.year();\n                case DAY_OF_YEAR:\n                    return chronology.dayOfYear();\n                case MONTH_OF_YEAR:\n                    return chronology.monthOfYear();\n                case DAY_OF_MONTH:\n                    return chronology.dayOfMonth();\n                case WEEKYEAR_OF_CENTURY:\n                    return chronology.weekyearOfCentury();\n                case WEEKYEAR:\n                    return chronology.weekyear();\n                case WEEK_OF_WEEKYEAR:\n                    return chronology.weekOfWeekyear();\n                case DAY_OF_WEEK:\n                    return chronology.dayOfWeek();\n                case HALFDAY_OF_DAY:\n                    return chronology.halfdayOfDay();\n                case HOUR_OF_HALFDAY:\n                    return chronology.hourOfHalfday();\n                case CLOCKHOUR_OF_HALFDAY:\n                    return chronology.clockhourOfHalfday();\n                case CLOCKHOUR_OF_DAY:\n                    return chronology.clockhourOfDay();\n                case HOUR_OF_DAY:\n                    return chronology.hourOfDay();\n                case MINUTE_OF_DAY:\n                    return chronology.minuteOfDay();\n                case MINUTE_OF_HOUR:\n                    return chronology.minuteOfHour();\n                case SECOND_OF_DAY:\n                    return chronology.secondOfDay();\n                case SECOND_OF_MINUTE:\n                    return chronology.secondOfMinute();\n                case MILLIS_OF_DAY:\n                    return chronology.millisOfDay();\n                case MILLIS_OF_SECOND:\n                    return chronology.millisOfSecond();\n                default:\n                    \n                    throw new InternalError();\n            }\n        }", "comment": "/** @inheritdoc */"}}
{"code": {"body": "    public boolean isSupported(Chronology chronology) {\n        return getField(chronology).isSupported();\n    }", "comment": "/**\n     * Checks whether this field supported in the given Chronology.\n     *\n     * @param chronology  the chronology to use, null means ISOChronology in default zone\n     * @return true if supported\n     */"}}
{"code": {"body": "    public String toString() {\n        return getName();\n    }", "comment": "/**\n     * Get a suitable debug string.\n     * \n     * @return debug string\n     */"}}
{"code": {"body": "        private Object readResolve() {\n            switch (iOrdinal) {\n                case ERA:\n                    return ERA_TYPE;\n                case YEAR_OF_ERA:\n                    return YEAR_OF_ERA_TYPE;\n                case CENTURY_OF_ERA:\n                    return CENTURY_OF_ERA_TYPE;\n                case YEAR_OF_CENTURY:\n                    return YEAR_OF_CENTURY_TYPE;\n                case YEAR:\n                    return YEAR_TYPE;\n                case DAY_OF_YEAR:\n                    return DAY_OF_YEAR_TYPE;\n                case MONTH_OF_YEAR:\n                    return MONTH_OF_YEAR_TYPE;\n                case DAY_OF_MONTH:\n                    return DAY_OF_MONTH_TYPE;\n                case WEEKYEAR_OF_CENTURY:\n                    return WEEKYEAR_OF_CENTURY_TYPE;\n                case WEEKYEAR:\n                    return WEEKYEAR_TYPE;\n                case WEEK_OF_WEEKYEAR:\n                    return WEEK_OF_WEEKYEAR_TYPE;\n                case DAY_OF_WEEK:\n                    return DAY_OF_WEEK_TYPE;\n                case HALFDAY_OF_DAY:\n                    return HALFDAY_OF_DAY_TYPE;\n                case HOUR_OF_HALFDAY:\n                    return HOUR_OF_HALFDAY_TYPE;\n                case CLOCKHOUR_OF_HALFDAY:\n                    return CLOCKHOUR_OF_HALFDAY_TYPE;\n                case CLOCKHOUR_OF_DAY:\n                    return CLOCKHOUR_OF_DAY_TYPE;\n                case HOUR_OF_DAY:\n                    return HOUR_OF_DAY_TYPE;\n                case MINUTE_OF_DAY:\n                    return MINUTE_OF_DAY_TYPE;\n                case MINUTE_OF_HOUR:\n                    return MINUTE_OF_HOUR_TYPE;\n                case SECOND_OF_DAY:\n                    return SECOND_OF_DAY_TYPE;\n                case SECOND_OF_MINUTE:\n                    return SECOND_OF_MINUTE_TYPE;\n                case MILLIS_OF_DAY:\n                    return MILLIS_OF_DAY_TYPE;\n                case MILLIS_OF_SECOND:\n                    return MILLIS_OF_SECOND_TYPE;\n                default:\n                    \n                    return this;\n            }\n        }", "comment": "/**\n         * Ensure a singleton is returned.\n         * \n         * @return the singleton type\n         */"}}
{"code": {"body": "    public static final long currentTimeMillis() {\n        return cMillisProvider.getMillis();\n    }", "comment": "/**\n     * Gets the current time in milliseconds.\n     * <p>\n     * By default this returns <code>System.currentTimeMillis()</code>.\n     * This may be changed using other methods in this class.\n     * \n     * @return the current time in milliseconds from 1970-01-01T00:00:00Z\n     */"}}
{"code": {"body": "    public static final void setCurrentMillisSystem() throws SecurityException {\n        checkPermission();\n        cMillisProvider = SYSTEM_MILLIS_PROVIDER;\n    }", "comment": "/**\n     * Resets the current time to return the system time.\n     * <p>\n     * This method changes the behaviour of {@link #currentTimeMillis()}.\n     * Whenever the current time is queried, {@link System#currentTimeMillis()} is used.\n     * \n     * @throws SecurityException if the application does not have sufficient security rights\n     */"}}
{"code": {"body": "    public static final void setCurrentMillisFixed(long fixedMillis) throws SecurityException {\n        checkPermission();\n        cMillisProvider = new FixedMillisProvider(fixedMillis);\n    }", "comment": "/**\n     * Sets the current time to return a fixed millisecond time.\n     * <p>\n     * This method changes the behaviour of {@link #currentTimeMillis()}.\n     * Whenever the current time is queried, the same millisecond time will be returned.\n     * \n     * @param fixedMillis  the fixed millisecond time to use\n     * @throws SecurityException if the application does not have sufficient security rights\n     */"}}
{"code": {"body": "    public static final void setCurrentMillisOffset(long offsetMillis) throws SecurityException {\n        checkPermission();\n        if (offsetMillis == 0) {\n            cMillisProvider = SYSTEM_MILLIS_PROVIDER;\n        } else {\n            cMillisProvider = new OffsetMillisProvider(offsetMillis);\n        }\n    }", "comment": "/**\n     * Sets the current time to return the system time plus an offset.\n     * <p>\n     * This method changes the behaviour of {@link #currentTimeMillis()}.\n     * Whenever the current time is queried, {@link System#currentTimeMillis()} is used\n     * and then offset by adding the millisecond value specified here.\n     * \n     * @param offsetMillis  the fixed millisecond time to use\n     * @throws SecurityException if the application does not have sufficient security rights\n     */"}}
{"code": {"body": "    public static final void setCurrentMillisProvider(MillisProvider millisProvider) throws SecurityException {\n        if (millisProvider == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        checkPermission();\n        cMillisProvider = millisProvider;\n    }", "comment": "/**\n     * Sets the provider of the current time to class specified.\n     * <p>\n     * This method changes the behaviour of {@link #currentTimeMillis()}.\n     * Whenever the current time is queried, the specified class will be called.\n     * \n     * @param millisProvider  the provider of the current time to use, not null\n     * @throws SecurityException if the application does not have sufficient security rights\n     * @since 2.0\n     */"}}
{"code": {"body": "    private static void checkPermission() throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"\"));\n        }\n    }", "comment": "/**\n     * Checks whether the provider may be changed using permission 'CurrentTime.setProvider'.\n     * \n     * @throws SecurityException if the provider may not be changed\n     */"}}
{"code": {"body": "    public static final long getInstantMillis(ReadableInstant instant) {\n        if (instant == null) {\n            return DateTimeUtils.currentTimeMillis();\n        }\n        return instant.getMillis();\n    }", "comment": "/**\n     * Gets the millisecond instant from the specified instant object handling null.\n     * <p>\n     * If the instant object is <code>null</code>, the {@link #currentTimeMillis()}\n     * will be returned. Otherwise, the millis from the object are returned.\n     * \n     * @param instant  the instant to examine, null means now\n     * @return the time in milliseconds from 1970-01-01T00:00:00Z\n     */"}}
{"code": {"body": "    public static final Chronology getInstantChronology(ReadableInstant instant) {\n        if (instant == null) {\n            return ISOChronology.getInstance();\n        }\n        Chronology chrono = instant.getChronology();\n        if (chrono == null) {\n            return ISOChronology.getInstance();\n        }\n        return chrono;\n    }", "comment": "/**\n     * Gets the chronology from the specified instant object handling null.\n     * <p>\n     * If the instant object is <code>null</code>, or the instant's chronology is\n     * <code>null</code>, {@link ISOChronology#getInstance()} will be returned.\n     * Otherwise, the chronology from the object is returned.\n     * \n     * @param instant  the instant to examine, null means ISO in the default zone\n     * @return the chronology, never null\n     */"}}
{"code": {"body": "    public static final Chronology getIntervalChronology(ReadableInterval interval) {\n        if (interval == null) {\n            return ISOChronology.getInstance();\n        }\n        Chronology chrono = interval.getChronology();\n        if (chrono == null) {\n            return ISOChronology.getInstance();\n        }\n        return chrono;\n    }", "comment": "/**\n     * Gets the chronology from the specified interval object handling null.\n     * <p>\n     * If the interval object is <code>null</code>, or the interval's chronology is\n     * <code>null</code>, {@link ISOChronology#getInstance()} will be returned.\n     * Otherwise, the chronology from the object is returned.\n     * \n     * @param interval  the interval to examine, null means ISO in the default zone\n     * @return the chronology, never null\n     */"}}
{"code": {"body": "    public static final ReadableInterval getReadableInterval(ReadableInterval interval) {\n        if (interval == null) {\n            long now = DateTimeUtils.currentTimeMillis();\n            interval = new Interval(now, now);\n        }\n        return interval;\n    }", "comment": "/**\n     * Gets the interval handling null.\n     * <p>\n     * If the interval is <code>null</code>, an interval representing now\n     * to now in the {@link ISOChronology#getInstance() ISOChronology}\n     * will be returned. Otherwise, the interval specified is returned.\n     * \n     * @param interval  the interval to use, null means now to now\n     * @return the interval, never null\n     * @since 1.1\n     */"}}
{"code": {"body": "    public static final Chronology getChronology(Chronology chrono) {\n        if (chrono == null) {\n            return ISOChronology.getInstance();\n        }\n        return chrono;\n    }", "comment": "/**\n     * Gets the chronology handling null.\n     * <p>\n     * If the chronology is <code>null</code>, {@link ISOChronology#getInstance()}\n     * will be returned. Otherwise, the chronology is returned.\n     * \n     * @param chrono  the chronology to use, null means ISO in the default zone\n     * @return the chronology, never null\n     */"}}
{"code": {"body": "    public static final DateTimeZone getZone(DateTimeZone zone) {\n        if (zone == null) {\n            return DateTimeZone.getDefault();\n        }\n        return zone;\n    }", "comment": "/**\n     * Gets the zone handling null.\n     * <p>\n     * If the zone is <code>null</code>, {@link DateTimeZone#getDefault()}\n     * will be returned. Otherwise, the zone specified is returned.\n     * \n     * @param zone  the time zone to use, null means the default zone\n     * @return the time zone, never null\n     */"}}
{"code": {"body": "    public static final PeriodType getPeriodType(PeriodType type) {\n        if (type == null) {\n            return PeriodType.standard();\n        }\n        return type;\n    }", "comment": "/**\n     * Gets the period type handling null.\n     * <p>\n     * If the zone is <code>null</code>, {@link PeriodType#standard()}\n     * will be returned. Otherwise, the type specified is returned.\n     * \n     * @param type  the time zone to use, null means the standard type\n     * @return the type to use, never null\n     */"}}
{"code": {"body": "    public static final long getDurationMillis(ReadableDuration duration) {\n        if (duration == null) {\n            return 0L;\n        }\n        return duration.getMillis();\n    }", "comment": "/**\n     * Gets the millisecond duration from the specified duration object handling null.\n     * <p>\n     * If the duration object is <code>null</code>, zero will be returned.\n     * Otherwise, the millis from the object are returned.\n     * \n     * @param duration  the duration to examine, null means zero\n     * @return the duration in milliseconds\n     */"}}
{"code": {"body": "    public static final boolean isContiguous(ReadablePartial partial) {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        DurationFieldType lastType = null;\n        for (int i = 0; i < partial.size(); i++) {\n            DateTimeField loopField = partial.getField(i);\n            if (i > 0) {\n                if (loopField.getRangeDurationField().getType() != lastType) {\n                    return false;\n                }\n            }\n            lastType = loopField.getDurationField().getType();\n        }\n        return true;\n    }", "comment": "/**\n     * Checks whether the partial is contiguous.\n     * <p>\n     * A partial is contiguous if one field starts where another ends.\n     * <p>\n     * For example <code>LocalDate</code> is contiguous because DayOfMonth has\n     * the same range (Month) as the unit of the next field (MonthOfYear), and\n     * MonthOfYear has the same range (Year) as the unit of the next field (Year).\n     * <p>\n     * Similarly, <code>LocalTime</code> is contiguous, as it consists of\n     * MillisOfSecond, SecondOfMinute, MinuteOfHour and HourOfDay (note how\n     * the names of each field 'join up').\n     * <p>\n     * However, a Year/HourOfDay partial is not contiguous because the range\n     * field Day is not equal to the next field Year.\n     * Similarly, a DayOfWeek/DayOfMonth partial is not contiguous because\n     * the range Month is not equal to the next field Day.\n     * \n     * @param partial  the partial to check\n     * @return true if the partial is contiguous\n     * @throws IllegalArgumentException if the partial is null\n     * @since 1.1\n     */"}}
{"code": {"body": "    public static final DateFormatSymbols getDateFormatSymbols(Locale locale) {\n        try {\n            Method method = DateFormatSymbols.class.getMethod(\"\", new Class[] {Locale.class});\n            return (DateFormatSymbols) method.invoke(null, new Object[] {locale});\n        } catch (Exception ex) {\n            return new DateFormatSymbols(locale);\n        }\n    }", "comment": "/**\n     * Gets the {@link DateFormatSymbols} based on the given locale.\n     * <p>\n     * If JDK 6 or newer is being used, DateFormatSymbols.getInstance(locale) will\n     * be used in order to allow the use of locales defined as extensions.\n     * Otherwise, new DateFormatSymbols(locale) will be used.\n     * See JDK 6 {@link DateFormatSymbols} for further information.\n     * \n     * @param locale  the {@link Locale} used to get the correct {@link DateFormatSymbols}\n     * @return the symbols\n     * @since 2.0\n     */"}}
{"code": {"body": "    public static final Map<String, DateTimeZone> getDefaultTimeZoneNames() {\n        return cZoneNames;\n    }", "comment": "/**\n     * Gets the default map of time zone names.\n     * <p>\n     * This can be changed by {@link #setDefaultTimeZoneNames}.\n     * <p>\n     * The default set of short time zone names is as follows:\n     * <ul>\n     * <li>UT - UTC\n     * <li>UTC - UTC\n     * <li>GMT - UTC\n     * <li>EST - America/New_York\n     * <li>EDT - America/New_York\n     * <li>CST - America/Chicago\n     * <li>CDT - America/Chicago\n     * <li>MST - America/Denver\n     * <li>MDT - America/Denver\n     * <li>PST - America/Los_Angeles\n     * <li>PDT - America/Los_Angeles\n     * </ul>\n     * \n     * @return the unmodifiable map of abbreviations to zones, not null\n     * @since 2.2\n     */"}}
{"code": {"body": "    public static final void setDefaultTimeZoneNames(Map<String, DateTimeZone> names) {\n        cZoneNames = Collections.unmodifiableMap(new HashMap<String, DateTimeZone>(names));\n    }", "comment": "/**\n     * Sets the default map of time zone names.\n     * <p>\n     * The map is copied before storage.\n     * \n     * @param names  the map of abbreviations to zones, not null\n     * @since 2.2\n     */"}}
{"code": {"body": "    public static final double toJulianDay(long epochMillis) {\n        \n        \n        \n        \n        \n        double epochDay = epochMillis / 86400000d;\n        return epochDay + 2440587.5d;\n    }", "comment": "/**\n     * Calculates the astronomical Julian Day for an instant.\n     * <p>\n     * The <a href=\"http://en.wikipedia.org/wiki/Julian_day\">Julian day</a> is a well-known\n     * system of time measurement for scientific use by the astronomy community.\n     * It expresses the interval of time in days and fractions of a day since\n     * January 1, 4713 BC (Julian) Greenwich noon.\n     * <p>\n     * Each day starts at midday (not midnight) and time is expressed as a fraction.\n     * Thus the fraction 0.25 is 18:00. equal to one quarter of the day from midday to midday.\n     * <p>\n     * Note that this method has nothing to do with the day-of-year.\n     * \n     * @param epochMillis  the epoch millis from 1970-01-01Z\n     * @return the astronomical Julian Day represented by the specified instant\n     * @since 2.2\n     */"}}
{"code": {"body": "    public static final long toJulianDayNumber(long epochMillis) {\n        return (long) Math.floor(toJulianDay(epochMillis) + 0.5d);\n    }", "comment": "/**\n     * Calculates the astronomical Julian Day Number for an instant.\n     * <p>\n     * The {@link #toJulianDay(long)} method calculates the astronomical Julian Day\n     * with a fraction based on days starting at midday.\n     * This method calculates the variant where days start at midnight.\n     * JDN 0 is used for the date equivalent to Monday January 1, 4713 BC (Julian).\n     * Thus these days start 12 hours before those of the fractional Julian Day.\n     * <p>\n     * Note that this method has nothing to do with the day-of-year.\n     * \n     * @param epochMillis  the epoch millis from 1970-01-01Z\n     * @return the astronomical Julian Day represented by the specified instant\n     * @since 2.2\n     */"}}
{"code": {"body": "    public static final long fromJulianDay(double julianDay) {\n        double epochDay = julianDay - 2440587.5d;\n        return (long) (epochDay * 86400000d);\n    }", "comment": "/**\n     * Creates a date-time from a Julian Day.\n     * <p>\n     * Returns the {@code DateTime} object equal to the specified Julian Day.\n     * \n     * @param julianDay  the Julian Day\n     * @return the epoch millis from 1970-01-01Z\n     * @since 2.2\n     */"}}
{"code": {"body": "        public long getMillis() {\n            return System.currentTimeMillis();\n        }", "comment": "/**\n         * Gets the current time.\n         * @return the current time in millis\n         */"}}
{"code": {"body": "    public static DateTimeZone getDefault() {\n        DateTimeZone zone = cDefault;\n        if (zone == null) {\n            synchronized(DateTimeZone.class) {\n                zone = cDefault;\n                if (zone == null) {\n                    DateTimeZone temp = null;\n                    try {\n                        try {\n                            String id = System.getProperty(\"\");\n                            if (id != null) {  \n                                temp = forID(id);\n                            }\n                        } catch (RuntimeException ex) {\n                            \n                        }\n                        if (temp == null) {\n                            temp = forTimeZone(TimeZone.getDefault());\n                        }\n                    } catch (IllegalArgumentException ex) {\n                        \n                    }\n                    if (temp == null) {\n                        temp = UTC;\n                    }\n                    cDefault = zone = temp;\n                }\n            }\n        }\n        return zone;\n    }", "comment": "/**\n     * Gets the default time zone.\n     * <p>\n     * The default time zone is derived from the system property {@code user.timezone}.\n     * If that is {@code null} or is not a valid identifier, then the value of the\n     * JDK {@code TimeZone} default is converted. If that fails, {@code UTC} is used.\n     * <p>\n     * NOTE: If the {@code java.util.TimeZone} default is updated <i>after</i> calling this\n     * method, then the change will not be picked up here.\n     * \n     * @return the default datetime zone object\n     */"}}
{"code": {"body": "    public static void setDefault(DateTimeZone zone) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"\"));\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        synchronized(DateTimeZone.class) {\n            cDefault = zone;\n        }\n    }", "comment": "/**\n     * Sets the default time zone.\n     * <p>\n     * NOTE: Calling this method does <i>not</i> set the {@code java.util.TimeZone} default.\n     * \n     * @param zone  the default datetime zone object, must not be null\n     * @throws IllegalArgumentException if the zone is null\n     * @throws SecurityException if the application has insufficient security rights\n     */"}}
{"code": {"body": "    public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException {\n        return forOffsetHoursMinutes(hoursOffset, 0);\n    }", "comment": "/**\n     * Gets a time zone instance for the specified offset to UTC in hours.\n     * This method assumes standard length hours.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * \n     * @param hoursOffset  the offset in hours from UTC, from -23 to +23\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if the offset is too large or too small\n     */"}}
{"code": {"body": "    public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\n        if (hoursOffset == 0 && minutesOffset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (hoursOffset < -23 || hoursOffset > 23) {\n            throw new IllegalArgumentException(\"\" + hoursOffset);\n        }\n        if (minutesOffset < -59 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"\" + minutesOffset);\n        }\n        if (hoursOffset > 0 && minutesOffset < 0) {\n            throw new IllegalArgumentException(\"\" + minutesOffset);\n        }\n        int offset = 0;\n        try {\n            int hoursInMinutes = hoursOffset * 60;\n            if (hoursInMinutes < 0) {\n                minutesOffset = hoursInMinutes - Math.abs(minutesOffset);\n            } else {\n                minutesOffset = hoursInMinutes + minutesOffset;\n            }\n            offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(\"\");\n        }\n        return forOffsetMillis(offset);\n    }", "comment": "/**\n     * Gets a time zone instance for the specified offset to UTC in hours and minutes.\n     * This method assumes 60 minutes in an hour, and standard length minutes.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * The hours value must be in the range -23 to +23.\n     * The minutes value must be in the range -59 to +59.\n     * The following combinations of sign for the hour and minute are possible:\n     * <pre>\n     *  Hour    Minute    Example    Result\n     * \n     *  +ve     +ve       (2, 15)    +02:15\n     *  +ve     zero      (2, 0)     +02:00\n     *  +ve     -ve       (2, -15)   IllegalArgumentException\n     * \n     *  zero    +ve       (0, 15)    +00:15\n     *  zero    zero      (0, 0)     +00:00\n     *  zero    -ve       (0, -15)   -00:15\n     * \n     *  -ve     +ve       (-2, 15)   -02:15\n     *  -ve     zero      (-2, 0)    -02:00\n     *  -ve     -ve       (-2, -15)  -02:15\n     * </pre>\n     * Note that in versions before 2.3, the minutes had to be zero or positive.\n     * \n     * @param hoursOffset  the offset in hours from UTC, from -23 to +23\n     * @param minutesOffset  the offset in minutes from UTC, from -59 to +59\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if any value is out of range, the minutes are negative\n     *  when the hours are positive, or the resulting offset exceeds +/- 23:59:59.000\n     */"}}
{"code": {"body": "    public static DateTimeZone forOffsetMillis(int millisOffset) {\n        if (millisOffset < -MAX_MILLIS || millisOffset > MAX_MILLIS) {\n            throw new IllegalArgumentException(\"\" + millisOffset);\n        }\n        String id = printOffset(millisOffset);\n        return fixedOffsetZone(id, millisOffset);\n    }", "comment": "/**\n     * Gets a time zone instance for the specified offset to UTC in milliseconds.\n     *\n     * @param millisOffset  the offset in millis from UTC, from -23:59:59.999 to +23:59:59.999\n     * @return the DateTimeZone object for the offset\n     */"}}
{"code": {"body": "    public static DateTimeZone forTimeZone(TimeZone zone) {\n        if (zone == null) {\n            return getDefault();\n        }\n        final String id = zone.getID();\n        if (id.equals(\"\")) {\n            return DateTimeZone.UTC;\n        }\n\n        \n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        \n        if (convId == null) {\n            convId = zone.getID();\n            if (convId.startsWith(\"\") || convId.startsWith(\"\")) {\n                convId = convId.substring(3);\n                int offset = parseOffset(convId);\n                if (offset == 0L) {\n                    return DateTimeZone.UTC;\n                } else {\n                    convId = printOffset(offset);\n                    return fixedOffsetZone(convId, offset);\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"\" + id + \"\");\n    }", "comment": "/**\n     * Gets a time zone instance for a JDK TimeZone.\n     * <p>\n     * DateTimeZone only accepts a subset of the IDs from TimeZone. The\n     * excluded IDs are the short three letter form (except UTC). This \n     * method will attempt to convert between time zones created using the\n     * short IDs and the full version.\n     * <p>\n     * This method is not designed to parse time zones with rules created by\n     * applications using <code>SimpleTimeZone</code> directly.\n     * \n     * @param zone  the zone to convert, null means default\n     * @return the DateTimeZone object for the zone\n     * @throws IllegalArgumentException if the zone is not recognised\n     */"}}
{"code": {"body": "    private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\n        if (offset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (iFixedOffsetCache == null) {\n            iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>();\n        }\n        DateTimeZone zone;\n        Reference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n        if (ref != null) {\n            zone = ref.get();\n            if (zone != null) {\n                return zone;\n            }\n        }\n        zone = new FixedDateTimeZone(id, null, offset, offset);\n        iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n        return zone;\n    }", "comment": "/**\n     * Gets the zone using a fixed offset amount.\n     * \n     * @param id  the zone id\n     * @param offset  the offset in millis\n     * @return the zone\n     */"}}
{"code": {"body": "    public static Set<String> getAvailableIDs() {\n        return cAvailableIDs;\n    }", "comment": "/**\n     * Gets all the available IDs supported.\n     * \n     * @return an unmodifiable Set of String IDs\n     */"}}
{"code": {"body": "    public static Provider getProvider() {\n        return cProvider;\n    }", "comment": "/**\n     * Gets the zone provider factory.\n     * <p>\n     * The zone provider is a pluggable instance factory that supplies the\n     * actual instances of DateTimeZone.\n     * \n     * @return the provider\n     */"}}
{"code": {"body": "    public static void setProvider(Provider provider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"\"));\n        }\n        setProvider0(provider);\n    }", "comment": "/**\n     * Sets the zone provider factory.\n     * <p>\n     * The zone provider is a pluggable instance factory that supplies the\n     * actual instances of DateTimeZone.\n     * \n     * @param provider  provider to use, or null for default\n     * @throws SecurityException if you do not have the permission DateTimeZone.setProvider\n     * @throws IllegalArgumentException if the provider is invalid\n     */"}}
{"code": {"body": "    private static void setProvider0(Provider provider) {\n        if (provider == null) {\n            provider = getDefaultProvider();\n        }\n        Set<String> ids = provider.getAvailableIDs();\n        if (ids == null || ids.size() == 0) {\n            throw new IllegalArgumentException\n                (\"\");\n        }\n        if (!ids.contains(\"\")) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (!UTC.equals(provider.getZone(\"\"))) {\n            throw new IllegalArgumentException(\"\");\n        }\n        cProvider = provider;\n        cAvailableIDs = ids;\n    }", "comment": "/**\n     * Sets the zone provider factory without performing the security check.\n     * \n     * @param provider  provider to use, or null for default\n     * @throws IllegalArgumentException if the provider is invalid\n     */"}}
{"code": {"body": "    private static Provider getDefaultProvider() {\n        Provider provider = null;\n\n        try {\n            String providerClass =\n                System.getProperty(\"\");\n            if (providerClass != null) {\n                try {\n                    provider = (Provider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            \n        }\n\n        if (provider == null) {\n            try {\n                provider = new ZoneInfoProvider(\"\");\n            } catch (Exception ex) {\n                Thread thread = Thread.currentThread();\n                thread.getThreadGroup().uncaughtException(thread, ex);\n            }\n        }\n\n        if (provider == null) {\n            provider = new UTCProvider();\n        }\n\n        return provider;\n    }", "comment": "/**\n     * Gets the default zone provider.\n     * <p>\n     * Tries the system property <code>org.joda.time.DateTimeZone.Provider</code>.\n     * Then tries a <code>ZoneInfoProvider</code> using the data in <code>org/joda/time/tz/data</code>.\n     * Then uses <code>UTCProvider</code>.\n     * \n     * @return the default name provider\n     */"}}
{"code": {"body": "    public static NameProvider getNameProvider() {\n        return cNameProvider;\n    }", "comment": "/**\n     * Gets the name provider factory.\n     * <p>\n     * The name provider is a pluggable instance factory that supplies the\n     * names of each DateTimeZone.\n     * \n     * @return the provider\n     */"}}
{"code": {"body": "    public static void setNameProvider(NameProvider nameProvider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"\"));\n        }\n        setNameProvider0(nameProvider);\n    }", "comment": "/**\n     * Sets the name provider factory.\n     * <p>\n     * The name provider is a pluggable instance factory that supplies the\n     * names of each DateTimeZone.\n     * \n     * @param nameProvider  provider to use, or null for default\n     * @throws SecurityException if you do not have the permission DateTimeZone.setNameProvider\n     * @throws IllegalArgumentException if the provider is invalid\n     */"}}
{"code": {"body": "    private static void setNameProvider0(NameProvider nameProvider) {\n        if (nameProvider == null) {\n            nameProvider = getDefaultNameProvider();\n        }\n        cNameProvider = nameProvider;\n    }", "comment": "/**\n     * Sets the name provider factory without performing the security check.\n     * \n     * @param nameProvider  provider to use, or null for default\n     * @throws IllegalArgumentException if the provider is invalid\n     */"}}
{"code": {"body": "    private static NameProvider getDefaultNameProvider() {\n        NameProvider nameProvider = null;\n        try {\n            String providerClass = System.getProperty(\"\");\n            if (providerClass != null) {\n                try {\n                    nameProvider = (NameProvider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            \n        }\n\n        if (nameProvider == null) {\n            nameProvider = new DefaultNameProvider();\n        }\n\n        return nameProvider;\n    }", "comment": "/**\n     * Gets the default name provider.\n     * <p>\n     * Tries the system property <code>org.joda.time.DateTimeZone.NameProvider</code>.\n     * Then uses <code>DefaultNameProvider</code>.\n     * \n     * @return the default name provider\n     */"}}
{"code": {"body": "    private static synchronized String getConvertedId(String id) {\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            \n            map = new HashMap<String, String>();\n            map.put(\"\", \"\");\n            map.put(\"\", \"\");\n            map.put(\"\", \"\");\n            map.put(\"\", \"\");\n            map.put(\"\", \"\");\n            map.put(\"\", \"\");\n            map.put(\"\", \"\");\n            map.put(\"\", \"\");  \n            map.put(\"\", \"\");\n            map.put(\"\", \"\");\n            map.put(\"\", \"\");  \n            map.put(\"\", \"\");\n            map.put(\"\", \"\");\n            map.put(\"\", \"\");  \n            map.put(\"\", \"\");\n            map.put(\"\", \"\");\n            map.put(\"\", \"\");\n            map.put(\"\", \"\");\n            map.put(\"\", \"\");\n            map.put(\"\", \"\");\n            map.put(\"\", \"\");\n            map.put(\"\", \"\");\n            map.put(\"\", \"\");\n            map.put(\"\", \"\");\n            map.put(\"\", \"\");\n            map.put(\"\", \"\");\n            map.put(\"\", \"\");\n            map.put(\"\", \"\");\n            map.put(\"\", \"\");\n            map.put(\"\", \"\");\n            map.put(\"\", \"\");\n            map.put(\"\", \"\");\n            map.put(\"\", \"\");\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }", "comment": "/**\n     * Converts an old style id to a new style id.\n     * \n     * @param id  the old style id\n     * @return the new style id, null if not found\n     */"}}
{"code": {"body": "    private static String printOffset(int offset) {\n        StringBuffer buf = new StringBuffer();\n        if (offset >= 0) {\n            buf.append('');\n        } else {\n            buf.append('');\n            offset = -offset;\n        }\n\n        int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n        FormatUtils.appendPaddedInteger(buf, hours, 2);\n        offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\n\n        int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\n        buf.append('');\n        FormatUtils.appendPaddedInteger(buf, minutes, 2);\n        offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\n        buf.append('');\n        FormatUtils.appendPaddedInteger(buf, seconds, 2);\n        offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        buf.append('');\n        FormatUtils.appendPaddedInteger(buf, offset, 3);\n        return buf.toString();\n    }", "comment": "/**\n     * Formats a timezone offset string.\n     * <p>\n     * This method is kept separate from the formatting classes to speed and\n     * simplify startup and classloading.\n     * \n     * @param offset  the offset in milliseconds\n     * @return the time zone string\n     */"}}
{"code": {"body": "    private static synchronized DateTimeFormatter offsetFormatter() {\n        if (cOffsetFormatter == null) {\n            cOffsetFormatter = new DateTimeFormatterBuilder()\n                .appendTimeZoneOffset(null, true, 2, 4)\n                .toFormatter();\n        }\n        return cOffsetFormatter;\n    }", "comment": "/**\n     * Gets a printer/parser for managing the offset id formatting.\n     * \n     * @return the formatter\n     */"}}
{"code": {"body": "    public String getShortName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getShortName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return printOffset(getOffset(instant));\n    }", "comment": "/**\n     * Gets the short name of this datetime zone suitable for display using\n     * the specified locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @param locale  the locale to get the name for\n     * @return the human-readable short name in the specified locale\n     */"}}
{"code": {"body": "    public String getName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return printOffset(getOffset(instant));\n    }", "comment": "/**\n     * Gets the long name of this datetime zone suitable for display using\n     * the specified locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @param locale  the locale to get the name for\n     * @return the human-readable long name in the specified locale\n     */"}}
{"code": {"body": "    public final int getOffset(ReadableInstant instant) {\n        if (instant == null) {\n            return getOffset(DateTimeUtils.currentTimeMillis());\n        }\n        return getOffset(instant.getMillis());\n    }", "comment": "/**\n     * Gets the millisecond offset to add to UTC to get local time.\n     * \n     * @param instant  instant to get the offset for, null means now\n     * @return the millisecond offset to add to UTC to get local time\n     */"}}
{"code": {"body": "    public boolean isStandardOffset(long instant) {\n        return getOffset(instant) == getStandardOffset(instant);\n    }", "comment": "/**\n     * Checks whether, at a particular instant, the offset is standard or not.\n     * <p>\n     * This method can be used to determine whether Summer Time (DST) applies.\n     * As a general rule, if the offset at the specified instant is standard,\n     * then either Winter time applies, or there is no Summer Time. If the\n     * instant is not standard, then Summer Time applies.\n     * <p>\n     * The implementation of the method is simply whether {@link #getOffset(long)}\n     * equals {@link #getStandardOffset(long)} at the specified instant.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n     * @return true if the offset at the given instant is the standard offset\n     * @since 1.5\n     */"}}
{"code": {"body": "    public int getOffsetFromLocal(long instantLocal) {\n        \n        final int offsetLocal = getOffset(instantLocal);\n        \n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        \n        if (offsetLocal != offsetAdjusted) {\n            \n            \n            if ((offsetLocal - offsetAdjusted) < 0) {\n                \n                \n                \n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        } else if (offsetLocal >= 0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }", "comment": "/**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */"}}
{"code": {"body": "    public long convertUTCToLocal(long instantUTC) {\n        int offset = getOffset(instantUTC);\n        long instantLocal = instantUTC + offset;\n        \n        if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) {\n            throw new ArithmeticException(\"\");\n        }\n        return instantLocal;\n    }", "comment": "/**\n     * Converts a standard UTC instant to a local instant with the same\n     * local time. This conversion is used before performing a calculation\n     * so that the calculation can be done using a simple local zone.\n     *\n     * @param instantUTC  the UTC instant to convert to local\n     * @return the local instant with the same local time\n     * @throws ArithmeticException if the result overflows a long\n     * @since 1.5\n     */"}}
{"code": {"body": "    public long convertLocalToUTC(long instantLocal, boolean strict) {\n        \n        int offsetLocal = getOffset(instantLocal);\n        \n        int offset = getOffset(instantLocal - offsetLocal);\n        \n        if (offsetLocal != offset) {\n            \n            \n            \n            if (strict || offsetLocal < 0) {\n                \n                long nextLocal = nextTransition(instantLocal - offsetLocal);\n                if (nextLocal == (instantLocal - offsetLocal)) {\n                    nextLocal = Long.MAX_VALUE;\n                }\n                long nextAdjusted = nextTransition(instantLocal - offset);\n                if (nextAdjusted == (instantLocal - offset)) {\n                    nextAdjusted = Long.MAX_VALUE;\n                }\n                if (nextLocal != nextAdjusted) {\n                    \n                    if (strict) {\n                        \n                        throw new IllegalInstantException(instantLocal, getID());\n                    } else {\n                        \n                        \n                        \n                        offset = offsetLocal;\n                    }\n                }\n            }\n        }\n        \n        long instantUTC = instantLocal - offset;\n        \n        if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) {\n            throw new ArithmeticException(\"\");\n        }\n        return instantUTC;\n    }", "comment": "/**\n     * Converts a local instant to a standard UTC instant with the same\n     * local time. This conversion is used after performing a calculation\n     * where the calculation was done using a simple local zone.\n     *\n     * @param instantLocal  the local instant to convert to UTC\n     * @param strict  whether the conversion should reject non-existent local times\n     * @return the UTC instant with the same local time, \n     * @throws ArithmeticException if the result overflows a long\n     * @throws IllegalInstantException if the zone has no equivalent local time\n     * @since 1.5\n     */"}}
{"code": {"body": "    public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) {\n        if (newZone == null) {\n            newZone = DateTimeZone.getDefault();\n        }\n        if (newZone == this) {\n            return oldInstant;\n        }\n        long instantLocal = convertUTCToLocal(oldInstant);\n        return newZone.convertLocalToUTC(instantLocal, false, oldInstant);\n    }", "comment": "/**\n     * Gets the millisecond instant in another zone keeping the same local time.\n     * <p>\n     * The conversion is performed by converting the specified UTC millis to local\n     * millis in this zone, then converting back to UTC millis in the new zone.\n     *\n     * @param newZone  the new zone, null means default\n     * @param oldInstant  the UTC millisecond instant to convert\n     * @return the UTC millisecond instant with the same local time in the new zone\n     */"}}
{"code": {"body": "    public boolean isLocalDateTimeGap(LocalDateTime localDateTime) {\n        if (isFixed()) {\n            return false;\n        }\n        try {\n            localDateTime.toDateTime(this);\n            return false;\n        } catch (IllegalInstantException ex) {\n            return true;\n        }\n    }", "comment": "/**\n     * Checks if the given {@link LocalDateTime} is within a gap.\n     * <p>\n     * When switching from standard time to Daylight Savings Time there is\n     * typically a gap where a clock hour is missing. This method identifies\n     * whether the local datetime refers to such a gap.\n     * \n     * @param localDateTime  the time to check, not null\n     * @return true if the given datetime refers to a gap\n     * @since 1.6\n     */"}}
{"code": {"body": "    public long adjustOffset(long instant, boolean earlierOrLater) {\n        \n        \n        \n        long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR;\n        long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR;\n        long offsetBefore = getOffset(instantBefore);\n        long offsetAfter = getOffset(instantAfter);\n        if (offsetBefore <= offsetAfter) {\n            return instant;  \n        }\n        \n        \n        long diff = offsetBefore - offsetAfter;\n        long transition = nextTransition(instantBefore);\n        long overlapStart = transition - diff;\n        long overlapEnd = transition + diff;\n        if (instant < overlapStart || instant >= overlapEnd) {\n          return instant;  \n        }\n        \n        \n        long afterStart = instant - overlapStart;\n        if (afterStart >= diff) {\n          \n          return earlierOrLater ? instant : instant - diff;\n        } else {\n          \n          return earlierOrLater ? instant + diff : instant;\n        }\n    }", "comment": "/**\n     * Adjusts the offset to be the earlier or later one during an overlap.\n     * \n     * @param instant  the instant to adjust\n     * @param earlierOrLater  false for earlier, true for later\n     * @return the adjusted instant millis\n     */"}}
{"code": {"body": "    public java.util.TimeZone toTimeZone() {\n        return java.util.TimeZone.getTimeZone(iID);\n    }", "comment": "/**\n     * Get the datetime zone as a {@link java.util.TimeZone}.\n     * \n     * @return the closest matching TimeZone object\n     */"}}
{"code": {"body": "    public int hashCode() {\n        return 57 + getID().hashCode();\n    }", "comment": "/**\n     * Gets a hash code compatable with equals.\n     * \n     * @return suitable hashcode\n     */"}}
{"code": {"body": "    protected Object writeReplace() throws ObjectStreamException {\n        return new Stub(iID);\n    }", "comment": "/**\n     * By default, when DateTimeZones are serialized, only a \"stub\" object\n     * referring to the id is written out. When the stub is read in, it\n     * replaces itself with a DateTimeZone object.\n     * @return a stub object to go in the stream\n     */"}}
{"code": {"body": "public Days plus(int days) {\n        if (days == 0) {\n            return this;\n        }\n        return Days.days(FieldUtils.safeAdd(getValue(), days));\n    }", "comment": "/**\n     * Returns a new instance with the specified number of days added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param days  the amount of days to add, may be negative\n     * @return the new period plus the specified number of days\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "public Days plus(Days days) {\n        if (days == null) {\n            return this;\n        }\n        return plus(days.getValue());\n    }", "comment": "/**\n     * Returns a new instance with the specified number of days added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param days  the amount of days to add, may be negative, null means zero\n     * @return the new period plus the specified number of days\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "public Days minus(int days) {\n        return plus(FieldUtils.safeNegate(days));\n    }", "comment": "/**\n     * Returns a new instance with the specified number of days taken away.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param days  the amount of days to take away, may be negative\n     * @return the new period minus the specified number of days\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "public Days minus(Days days) {\n        if (days == null) {\n            return this;\n        }\n        return minus(days.getValue());\n    }", "comment": "/**\n     * Returns a new instance with the specified number of days taken away.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param days  the amount of days to take away, may be negative, null means zero\n     * @return the new period minus the specified number of days\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "public Days multipliedBy(int scalar) {\n        return Days.days(FieldUtils.safeMultiply(getValue(), scalar));\n    }", "comment": "/**\n     * Returns a new instance with the days multiplied by the specified scalar.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param scalar  the amount to multiply by, may be negative\n     * @return the new period multiplied by the specified scalar\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "public Days dividedBy(int divisor) {\n        if (divisor == 1) {\n            return this;\n        }\n        return Days.days(getValue() / divisor);\n    }", "comment": "/**\n     * Returns a new instance with the days divided by the specified divisor.\n     * The calculation uses integer division, thus 3 divided by 2 is 1.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param divisor  the amount to divide by, may be negative\n     * @return the new period divided by the specified divisor\n     * @throws ArithmeticException if the divisor is zero\n     */"}}
{"code": {"body": "public Days negated() {\n        return Days.days(FieldUtils.safeNegate(getValue()));\n    }", "comment": "/**\n     * Returns a new instance with the days value negated.\n     *\n     * @return the new period with a negated value\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "    public static Days days(int days) {\n        switch (days) {\n            case 0:\n                return ZERO;\n            case 1:\n                return ONE;\n            case 2:\n                return TWO;\n            case 3:\n                return THREE;\n            case 4:\n                return FOUR;\n            case 5:\n                return FIVE;\n            case 6:\n                return SIX;\n            case 7:\n                return SEVEN;\n            case Integer.MAX_VALUE:\n                return MAX_VALUE;\n            case Integer.MIN_VALUE:\n                return MIN_VALUE;\n            default:\n                return new Days(days);\n        }\n    }", "comment": "/**\n     * Obtains an instance of <code>Days</code> that may be cached.\n     * <code>Days</code> is immutable, so instances can be cached and shared.\n     * This factory method provides access to shared instances.\n     *\n     * @param days  the number of days to obtain an instance for\n     * @return the instance of Days\n     */"}}
{"code": {"body": "    public static Days daysBetween(ReadablePartial start, ReadablePartial end) {\n        if (start instanceof LocalDate && end instanceof LocalDate)   {\n            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n            int days = chrono.days().getDifference(\n                    ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n            return Days.days(days);\n        }\n        int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\n        return Days.days(amount);\n    }", "comment": "/**\n     * Creates a <code>Days</code> representing the number of whole days\n     * between the two specified partial datetimes.\n     * <p>\n     * The two partials must contain the same fields, for example you can specify\n     * two <code>LocalDate</code> objects.\n     *\n     * @param start  the start partial date, must not be null\n     * @param end  the end partial date, must not be null\n     * @return the period in days\n     * @throws IllegalArgumentException if the partials are null or invalid\n     */"}}
{"code": {"body": "    public static Days daysIn(ReadableInterval interval) {\n        if (interval == null)   {\n            return Days.ZERO;\n        }\n        int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.days());\n        return Days.days(amount);\n    }", "comment": "/**\n     * Creates a <code>Days</code> representing the number of whole days\n     * in the specified interval. This method corectly handles any daylight\n     * savings time changes that may occur during the interval.\n     *\n     * @param interval  the interval to extract days from, null returns zero\n     * @return the period in days\n     * @throws IllegalArgumentException if the partials are null or invalid\n     */"}}
{"code": {"body": "    public static Days standardDaysIn(ReadablePeriod period) {\n        int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_DAY);\n        return Days.days(amount);\n    }", "comment": "/**\n     * Creates a new <code>Days</code> representing the number of complete\n     * standard length days in the specified period.\n     * <p>\n     * This factory method converts all fields from the period to hours using standardised\n     * durations for each field. Only those fields which have a precise duration in\n     * the ISO UTC chronology can be converted.\n     * <ul>\n     * <li>One week consists of 7 days.\n     * <li>One day consists of 24 hours.\n     * <li>One hour consists of 60 minutes.\n     * <li>One minute consists of 60 seconds.\n     * <li>One second consists of 1000 milliseconds.\n     * </ul>\n     * Months and Years are imprecise and periods containing these values cannot be converted.\n     *\n     * @param period  the period to get the number of hours from, null returns zero\n     * @return the period in days\n     * @throws IllegalArgumentException if the period contains imprecise duration values\n     */"}}
{"code": {"body": "    private Object readResolve() {\n        return Days.days(getValue());\n    }", "comment": "/**\n     * Resolves singletons.\n     * \n     * @return the singleton instance\n     */"}}
{"code": {"body": "    public DurationFieldType getFieldType() {\n        return DurationFieldType.days();\n    }", "comment": "/**\n     * Gets the duration field type, which is <code>days</code>.\n     *\n     * @return the period type\n     */"}}
{"code": {"body": "    public PeriodType getPeriodType() {\n        return PeriodType.days();\n    }", "comment": "/**\n     * Gets the period type, which is <code>days</code>.\n     *\n     * @return the period type\n     */"}}
{"code": {"body": "    public Weeks toStandardWeeks() {\n        return Weeks.weeks(getValue() / DateTimeConstants.DAYS_PER_WEEK);\n    }", "comment": "/**\n     * Converts this period in days to a period in weeks assuming a\n     * 7 day week.\n     * <p>\n     * This method allows you to convert between different types of period.\n     * However to achieve this it makes the assumption that all weeks are\n     * 7 days long.\n     * This may not be true for some unusual chronologies. However, it is included\n     * as it is a useful operation for many applications and business rules.\n     * \n     * @return a period representing the number of weeks for this number of days\n     */"}}
{"code": {"body": "    public Hours toStandardHours() {\n        return Hours.hours(FieldUtils.safeMultiply(getValue(), DateTimeConstants.HOURS_PER_DAY));\n    }", "comment": "/**\n     * Converts this period in days to a period in hours assuming a\n     * 24 hour day.\n     * <p>\n     * This method allows you to convert between different types of period.\n     * However to achieve this it makes the assumption that all days are 24 hours long.\n     * This is not true when daylight savings is considered and may also not\n     * be true for some unusual chronologies. However, it is included\n     * as it is a useful operation for many applications and business rules.\n     * \n     * @return a period representing the number of hours for this number of days\n     * @throws ArithmeticException if the number of hours is too large to be represented\n     */"}}
{"code": {"body": "    public Minutes toStandardMinutes() {\n        return Minutes.minutes(FieldUtils.safeMultiply(getValue(), DateTimeConstants.MINUTES_PER_DAY));\n    }", "comment": "/**\n     * Converts this period in days to a period in minutes assuming a\n     * 24 hour day and 60 minute hour.\n     * <p>\n     * This method allows you to convert between different types of period.\n     * However to achieve this it makes the assumption that all days are 24 hours\n     * long and all hours are 60 minutes long.\n     * This is not true when daylight savings is considered and may also not\n     * be true for some unusual chronologies. However, it is included\n     * as it is a useful operation for many applications and business rules.\n     * \n     * @return a period representing the number of minutes for this number of days\n     * @throws ArithmeticException if the number of minutes is too large to be represented\n     */"}}
{"code": {"body": "    public Seconds toStandardSeconds() {\n        return Seconds.seconds(FieldUtils.safeMultiply(getValue(), DateTimeConstants.SECONDS_PER_DAY));\n    }", "comment": "/**\n     * Converts this period in days to a period in seconds assuming a\n     * 24 hour day, 60 minute hour and 60 second minute.\n     * <p>\n     * This method allows you to convert between different types of period.\n     * However to achieve this it makes the assumption that all days are 24 hours\n     * long, all hours are 60 minutes long and all minutes are 60 seconds long.\n     * This is not true when daylight savings is considered and may also not\n     * be true for some unusual chronologies. However, it is included\n     * as it is a useful operation for many applications and business rules.\n     * \n     * @return a period representing the number of seconds for this number of days\n     * @throws ArithmeticException if the number of seconds is too large to be represented\n     */"}}
{"code": {"body": "    public Duration toStandardDuration() {\n        long days = getValue();  \n        return new Duration(days * DateTimeConstants.MILLIS_PER_DAY);\n    }", "comment": "/**\n     * Converts this period in days to a duration in milliseconds assuming a\n     * 24 hour day, 60 minute hour and 60 second minute.\n     * <p>\n     * This method allows you to convert from a period to a duration.\n     * However to achieve this it makes the assumption that all days are 24 hours\n     * long, all hours are 60 minutes and all minutes are 60 seconds.\n     * This is not true when daylight savings time is considered, and may also\n     * not be true for some unusual chronologies. However, it is included as it\n     * is a useful operation for many applications and business rules.\n     * \n     * @return a duration equivalent to this number of days\n     */"}}
{"code": {"body": "    public int getDays() {\n        return getValue();\n    }", "comment": "/**\n     * Gets the number of days that this period represents.\n     *\n     * @return the number of days in the period\n     */"}}
{"code": {"body": "    public Days plus(Days days) {\n        if (days == null) {\n            return this;\n        }\n        return plus(days.getValue());\n    }", "comment": "/**\n     * Returns a new instance with the specified number of days added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param days  the amount of days to add, may be negative, null means zero\n     * @return the new period plus the specified number of days\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "    public Days minus(Days days) {\n        if (days == null) {\n            return this;\n        }\n        return minus(days.getValue());\n    }", "comment": "/**\n     * Returns a new instance with the specified number of days taken away.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param days  the amount of days to take away, may be negative, null means zero\n     * @return the new period minus the specified number of days\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "    public Days multipliedBy(int scalar) {\n        return Days.days(FieldUtils.safeMultiply(getValue(), scalar));\n    }", "comment": "/**\n     * Returns a new instance with the days multiplied by the specified scalar.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param scalar  the amount to multiply by, may be negative\n     * @return the new period multiplied by the specified scalar\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "    public Days dividedBy(int divisor) {\n        if (divisor == 1) {\n            return this;\n        }\n        return Days.days(getValue() / divisor);\n    }", "comment": "/**\n     * Returns a new instance with the days divided by the specified divisor.\n     * The calculation uses integer division, thus 3 divided by 2 is 1.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param divisor  the amount to divide by, may be negative\n     * @return the new period divided by the specified divisor\n     * @throws ArithmeticException if the divisor is zero\n     */"}}
{"code": {"body": "    public Days negated() {\n        return Days.days(FieldUtils.safeNegate(getValue()));\n    }", "comment": "/**\n     * Returns a new instance with the days value negated.\n     *\n     * @return the new period with a negated value\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "    public boolean isGreaterThan(Days other) {\n        if (other == null) {\n            return getValue() > 0;\n        }\n        return getValue() > other.getValue();\n    }", "comment": "/**\n     * Is this days instance greater than the specified number of days.\n     *\n     * @param other  the other period, null means zero\n     * @return true if this days instance is greater than the specified one\n     */"}}
{"code": {"body": "    public boolean isLessThan(Days other) {\n        if (other == null) {\n            return getValue() < 0;\n        }\n        return getValue() < other.getValue();\n    }", "comment": "/**\n     * Is this days instance less than the specified number of days.\n     *\n     * @param other  the other period, null means zero\n     * @return true if this days instance is less than the specified one\n     */"}}
{"code": {"body": "public Duration(long duration) {\n        super(duration);\n    }", "comment": "/**\n     * Creates a duration from the given millisecond duration.\n     *\n     * @param duration  the duration, in milliseconds\n     */"}}
{"code": {"body": "public Duration(long startInstant, long endInstant) {\n        super(startInstant, endInstant);\n    }", "comment": "/**\n     * Creates a duration from the given interval endpoints.\n     *\n     * @param startInstant  interval start, in milliseconds\n     * @param endInstant  interval end, in milliseconds\n     * @throws ArithmeticException if the duration exceeds a 64 bit long\n     */"}}
{"code": {"body": "public Duration(ReadableInstant start, ReadableInstant end) {\n        super(start, end);\n    }", "comment": "/**\n     * Creates a duration from the given interval endpoints.\n     *\n     * @param start  interval start, null means now\n     * @param end  interval end, null means now\n     * @throws ArithmeticException if the duration exceeds a 64 bit long\n     */"}}
{"code": {"body": "public Duration(Object duration) {\n        super(duration);\n    }", "comment": "/**\n     * Creates a duration from the specified object using the\n     * {@link org.joda.time.convert.ConverterManager ConverterManager}.\n     *\n     * @param duration  duration to convert\n     * @throws IllegalArgumentException if duration is invalid\n     */"}}
{"code": {"body": "public Duration toDuration() {\n        return this;\n    }", "comment": "/**\n     * Get this duration as an immutable <code>Duration</code> object\n     * by returning <code>this</code>.\n     * \n     * @return <code>this</code>\n     */"}}
{"code": {"body": "public Duration withMillis(long duration) {\n        if (duration == getMillis()) {\n            return this;\n        }\n        return new Duration(duration);\n    }", "comment": "/**\n     * Creates a new Duration instance with a different milisecond length.\n     * \n     * @param duration  the new length of the duration\n     * @return the new duration instance\n     */"}}
{"code": {"body": "public Duration withDurationAdded(long durationToAdd, int scalar) {\n        if (durationToAdd == 0 || scalar == 0) {\n            return this;\n        }\n        long add = FieldUtils.safeMultiply(durationToAdd, scalar);\n        long duration = FieldUtils.safeAdd(getMillis(), add);\n        return new Duration(duration);\n    }", "comment": "/**\n     * Returns a new duration with this length plus that specified multiplied by the scalar.\n     * This instance is immutable and is not altered.\n     * <p>\n     * If the addition is zero, this instance is returned.\n     * \n     * @param durationToAdd  the duration to add to this one\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return the new duration instance\n     */"}}
{"code": {"body": "public Duration withDurationAdded(ReadableDuration durationToAdd, int scalar) {\n        if (durationToAdd == null || scalar == 0) {\n            return this;\n        }\n        return withDurationAdded(durationToAdd.getMillis(), scalar);\n    }", "comment": "/**\n     * Returns a new duration with this length plus that specified multiplied by the scalar.\n     * This instance is immutable and is not altered.\n     * <p>\n     * If the addition is zero, this instance is returned.\n     * \n     * @param durationToAdd  the duration to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return the new duration instance\n     */"}}
{"code": {"body": "public Duration plus(long amount) {\n        return withDurationAdded(amount, 1);\n    }", "comment": "/**\n     * Returns a new duration with this length plus that specified.\n     * This instance is immutable and is not altered.\n     * <p>\n     * If the addition is zero, this instance is returned.\n     * \n     * @param amount  the duration to add to this one\n     * @return the new duration instance\n     */"}}
{"code": {"body": "public Duration plus(ReadableDuration amount) {\n        if (amount == null) {\n            return this;\n        }\n        return withDurationAdded(amount.getMillis(), 1);\n    }", "comment": "/**\n     * Returns a new duration with this length plus that specified.\n     * This instance is immutable and is not altered.\n     * <p>\n     * If the amount is zero, this instance is returned.\n     * \n     * @param amount  the duration to add to this one, null means zero\n     * @return the new duration instance\n     */"}}
{"code": {"body": "public Duration minus(long amount) {\n        return withDurationAdded(amount, -1);\n    }", "comment": "/**\n     * Returns a new duration with this length minus that specified.\n     * This instance is immutable and is not altered.\n     * <p>\n     * If the addition is zero, this instance is returned.\n     * \n     * @param amount  the duration to take away from this one\n     * @return the new duration instance\n     */"}}
{"code": {"body": "public Duration minus(ReadableDuration amount) {\n        if (amount == null) {\n            return this;\n        }\n        return withDurationAdded(amount.getMillis(), -1);\n    }", "comment": "/**\n     * Returns a new duration with this length minus that specified.\n     * This instance is immutable and is not altered.\n     * <p>\n     * If the amount is zero, this instance is returned.\n     * \n     * @param amount  the duration to take away from this one, null means zero\n     * @return the new duration instance\n     */"}}
{"code": {"body": "    public static Duration standardDays(long days) {\n        if (days == 0) {\n            return ZERO;\n        }\n        return new Duration(FieldUtils.safeMultiply(days, DateTimeConstants.MILLIS_PER_DAY));\n    }", "comment": "/**\n     * Create a duration with the specified number of days assuming that\n     * there are the standard number of milliseconds in a day.\n     * <p>\n     * This method assumes that there are 24 hours in a day,\n     * 60 minutes in an hour, 60 seconds in a minute and 1000 milliseconds in\n     * a second. This will be true for most days, however days with Daylight\n     * Savings changes will not have 24 hours, so use this method with care.\n     * <p>\n     * A Duration is a representation of an amount of time. If you want to express\n     * the concepts of 'days' you should consider using the {@link Days} class.\n     *\n     * @param days  the number of standard days in this duration\n     * @return the duration, never null\n     * @throws ArithmeticException if the days value is too large\n     * @since 1.6\n     */"}}
{"code": {"body": "    public static Duration standardHours(long hours) {\n        if (hours == 0) {\n            return ZERO;\n        }\n        return new Duration(FieldUtils.safeMultiply(hours, DateTimeConstants.MILLIS_PER_HOUR));\n    }", "comment": "/**\n     * Create a duration with the specified number of hours assuming that\n     * there are the standard number of milliseconds in an hour.\n     * <p>\n     * This method assumes that there are 60 minutes in an hour,\n     * 60 seconds in a minute and 1000 milliseconds in a second.\n     * All currently supplied chronologies use this definition.\n     * <p>\n     * A Duration is a representation of an amount of time. If you want to express\n     * the concepts of 'hours' you should consider using the {@link Hours} class.\n     *\n     * @param hours  the number of standard hours in this duration\n     * @return the duration, never null\n     * @throws ArithmeticException if the hours value is too large\n     * @since 1.6\n     */"}}
{"code": {"body": "    public static Duration standardMinutes(long minutes) {\n        if (minutes == 0) {\n            return ZERO;\n        }\n        return new Duration(FieldUtils.safeMultiply(minutes, DateTimeConstants.MILLIS_PER_MINUTE));\n    }", "comment": "/**\n     * Create a duration with the specified number of minutes assuming that\n     * there are the standard number of milliseconds in a minute.\n     * <p>\n     * This method assumes that there are 60 seconds in a minute and\n     * 1000 milliseconds in a second.\n     * All currently supplied chronologies use this definition.\n     * <p>\n     * A Duration is a representation of an amount of time. If you want to express\n     * the concepts of 'minutes' you should consider using the {@link Minutes} class.\n     *\n     * @param minutes  the number of standard minutes in this duration\n     * @return the duration, never null\n     * @throws ArithmeticException if the minutes value is too large\n     * @since 1.6\n     */"}}
{"code": {"body": "    public static Duration standardSeconds(long seconds) {\n        if (seconds == 0) {\n            return ZERO;\n        }\n        return new Duration(FieldUtils.safeMultiply(seconds, DateTimeConstants.MILLIS_PER_SECOND));\n    }", "comment": "/**\n     * Create a duration with the specified number of seconds assuming that\n     * there are the standard number of milliseconds in a second.\n     * <p>\n     * This method assumes that there are 1000 milliseconds in a second.\n     * All currently supplied chronologies use this definition.\n     * <p>\n     * A Duration is a representation of an amount of time. If you want to express\n     * the concepts of 'seconds' you should consider using the {@link Seconds} class.\n     *\n     * @param seconds  the number of standard seconds in this duration\n     * @return the duration, never null\n     * @throws ArithmeticException if the seconds value is too large\n     * @since 1.6\n     */"}}
{"code": {"body": "    public static Duration millis(long millis) {\n        if (millis == 0) {\n            return ZERO;\n        }\n        return new Duration(millis);\n    }", "comment": "/**\n     * Create a duration with the specified number of milliseconds.\n     *\n     * @param millis  the number of standard milliseconds in this duration\n     * @return the duration, never null\n     * @since 2.0\n     */"}}
{"code": {"body": "    public long getStandardDays() {\n        return getMillis() / DateTimeConstants.MILLIS_PER_DAY;\n    }", "comment": "/**\n     * Gets the length of this duration in days assuming that there are the\n     * standard number of milliseconds in a day.\n     * <p>\n     * This method assumes that there are 24 hours in a day,\n     * 60 minutes in an hour, 60 seconds in a minute and 1000 milliseconds in\n     * a second. This will be true for most days, however days with Daylight\n     * Savings changes will not have 24 hours, so use this method with care.\n     * <p>\n     * This returns <code>getMillis() / MILLIS_PER_DAY</code>.\n     * The result is an integer division, thus excess milliseconds are truncated.\n     *\n     * @return the length of the duration in standard seconds\n     * @since 2.0\n     */"}}
{"code": {"body": "    public long getStandardHours() {\n        return getMillis() / DateTimeConstants.MILLIS_PER_HOUR;\n    }", "comment": "/**\n     * Gets the length of this duration in hours assuming that there are the\n     * standard number of milliseconds in an hour.\n     * <p>\n     * This method assumes that there are 60 minutes in an hour,\n     * 60 seconds in a minute and 1000 milliseconds in a second.\n     * All currently supplied chronologies use this definition.\n     * <p>\n     * This returns <code>getMillis() / MILLIS_PER_HOUR</code>.\n     * The result is an integer division, thus excess milliseconds are truncated.\n     *\n     * @return the length of the duration in standard seconds\n     * @since 2.0\n     */"}}
{"code": {"body": "    public long getStandardMinutes() {\n        return getMillis() / DateTimeConstants.MILLIS_PER_MINUTE;\n    }", "comment": "/**\n     * Gets the length of this duration in minutes assuming that there are the\n     * standard number of milliseconds in a minute.\n     * <p>\n     * This method assumes that there are 60 seconds in a minute and\n     * 1000 milliseconds in a second.\n     * All currently supplied chronologies use this definition.\n     * <p>\n     * This returns <code>getMillis() / 60000</code>.\n     * The result is an integer division, thus excess milliseconds are truncated.\n     *\n     * @return the length of the duration in standard seconds\n     * @since 2.0\n     */"}}
{"code": {"body": "    public long getStandardSeconds() {\n        return getMillis() / DateTimeConstants.MILLIS_PER_SECOND;\n    }", "comment": "/**\n     * Gets the length of this duration in seconds assuming that there are the\n     * standard number of milliseconds in a second.\n     * <p>\n     * This method assumes that there are 1000 milliseconds in a second.\n     * All currently supplied chronologies use this definition.\n     * <p>\n     * This returns <code>getMillis() / 1000</code>.\n     * The result is an integer division, so 2999 millis returns 2 seconds.\n     *\n     * @return the length of the duration in standard seconds\n     * @since 1.6\n     */"}}
{"code": {"body": "    public Duration toDuration() {\n        return this;\n    }", "comment": "/**\n     * Get this duration as an immutable <code>Duration</code> object\n     * by returning <code>this</code>.\n     * \n     * @return <code>this</code>\n     */"}}
{"code": {"body": "    public Days toStandardDays() {\n        long days = getStandardDays();\n        return Days.days(FieldUtils.safeToInt(days));\n    }", "comment": "/**\n     * Converts this duration to a period in days assuming that there are the\n     * standard number of milliseconds in a day.\n     * <p>\n     * This method assumes that there are 24 hours in a day,\n     * 60 minutes in an hour, 60 seconds in a minute and 1000 milliseconds in\n     * a second. This will be true for most days, however days with Daylight\n     * Savings changes will not have 24 hours, so use this method with care.\n     * \n     * @return a period representing the number of standard days in this period, never null\n     * @throws ArithmeticException if the number of days is too large to be represented\n     * @since 2.0\n     */"}}
{"code": {"body": "    public Hours toStandardHours() {\n        long hours = getStandardHours();\n        return Hours.hours(FieldUtils.safeToInt(hours));\n    }", "comment": "/**\n     * Converts this duration to a period in hours assuming that there are the\n     * standard number of milliseconds in an hour.\n     * <p>\n     * This method assumes that there are 60 minutes in an hour,\n     * 60 seconds in a minute and 1000 milliseconds in a second.\n     * All currently supplied chronologies use this definition.\n     * \n     * @return a period representing the number of standard hours in this period, never null\n     * @throws ArithmeticException if the number of hours is too large to be represented\n     * @since 2.0\n     */"}}
{"code": {"body": "    public Minutes toStandardMinutes() {\n        long minutes = getStandardMinutes();\n        return Minutes.minutes(FieldUtils.safeToInt(minutes));\n    }", "comment": "/**\n     * Converts this duration to a period in minutes assuming that there are the\n     * standard number of milliseconds in a minute.\n     * <p>\n     * This method assumes that there are 60 seconds in a minute and\n     * 1000 milliseconds in a second.\n     * All currently supplied chronologies use this definition.\n     * \n     * @return a period representing the number of standard minutes in this period, never null\n     * @throws ArithmeticException if the number of minutes is too large to be represented\n     * @since 2.0\n     */"}}
{"code": {"body": "    public Seconds toStandardSeconds() {\n        long seconds = getStandardSeconds();\n        return Seconds.seconds(FieldUtils.safeToInt(seconds));\n    }", "comment": "/**\n     * Converts this duration to a period in seconds assuming that there are the\n     * standard number of milliseconds in a second.\n     * <p>\n     * This method assumes that there are 1000 milliseconds in a second.\n     * All currently supplied chronologies use this definition.\n     * \n     * @return a period representing the number of standard seconds in this period, never null\n     * @throws ArithmeticException if the number of seconds is too large to be represented\n     * @since 1.6\n     */"}}
{"code": {"body": "    public Duration withMillis(long duration) {\n        if (duration == getMillis()) {\n            return this;\n        }\n        return new Duration(duration);\n    }", "comment": "/**\n     * Creates a new Duration instance with a different milisecond length.\n     * \n     * @param duration  the new length of the duration\n     * @return the new duration instance\n     */"}}
{"code": {"body": "    public Duration withDurationAdded(ReadableDuration durationToAdd, int scalar) {\n        if (durationToAdd == null || scalar == 0) {\n            return this;\n        }\n        return withDurationAdded(durationToAdd.getMillis(), scalar);\n    }", "comment": "/**\n     * Returns a new duration with this length plus that specified multiplied by the scalar.\n     * This instance is immutable and is not altered.\n     * <p>\n     * If the addition is zero, this instance is returned.\n     * \n     * @param durationToAdd  the duration to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return the new duration instance\n     */"}}
{"code": {"body": "    public Duration plus(ReadableDuration amount) {\n        if (amount == null) {\n            return this;\n        }\n        return withDurationAdded(amount.getMillis(), 1);\n    }", "comment": "/**\n     * Returns a new duration with this length plus that specified.\n     * This instance is immutable and is not altered.\n     * <p>\n     * If the amount is zero, this instance is returned.\n     * \n     * @param amount  the duration to add to this one, null means zero\n     * @return the new duration instance\n     */"}}
{"code": {"body": "    public Duration minus(ReadableDuration amount) {\n        if (amount == null) {\n            return this;\n        }\n        return withDurationAdded(amount.getMillis(), -1);\n    }", "comment": "/**\n     * Returns a new duration with this length minus that specified.\n     * This instance is immutable and is not altered.\n     * <p>\n     * If the amount is zero, this instance is returned.\n     * \n     * @param amount  the duration to take away from this one, null means zero\n     * @return the new duration instance\n     */"}}
{"code": {"body": "    public long subtract(long instant, long value) {\n        if (value == Long.MIN_VALUE) {\n            throw new ArithmeticException(\"\");\n        }\n        return add(instant, -value);\n    }", "comment": "/**\n     * Subtracts a duration value (which may be negative) from the instant.\n     * \n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to subtract from\n     * @param value  the value to subtract, in the units of the field\n     * @return the updated milliseconds\n     * @since 1.1\n     */"}}
{"code": {"body": "    public static DurationFieldType millis() {\n        return MILLIS_TYPE;\n    }", "comment": "/**\n     * Get the millis field type.\n     * \n     * @return the DateTimeFieldType constant\n     */"}}
{"code": {"body": "    public static DurationFieldType seconds() {\n        return SECONDS_TYPE;\n    }", "comment": "/**\n     * Get the seconds field type.\n     * \n     * @return the DateTimeFieldType constant\n     */"}}
{"code": {"body": "    public static DurationFieldType minutes() {\n        return MINUTES_TYPE;\n    }", "comment": "/**\n     * Get the minutes field type.\n     * \n     * @return the DateTimeFieldType constant\n     */"}}
{"code": {"body": "    public static DurationFieldType hours() {\n        return HOURS_TYPE;\n    }", "comment": "/**\n     * Get the hours field type.\n     * \n     * @return the DateTimeFieldType constant\n     */"}}
{"code": {"body": "    public static DurationFieldType halfdays() {\n        return HALFDAYS_TYPE;\n    }", "comment": "/**\n     * Get the halfdays field type.\n     * \n     * @return the DateTimeFieldType constant\n     */"}}
{"code": {"body": "    public static DurationFieldType days() {\n        return DAYS_TYPE;\n    }", "comment": "/**\n     * Get the days field type.\n     * \n     * @return the DateTimeFieldType constant\n     */"}}
{"code": {"body": "    public static DurationFieldType weeks() {\n        return WEEKS_TYPE;\n    }", "comment": "/**\n     * Get the weeks field type.\n     * \n     * @return the DateTimeFieldType constant\n     */"}}
{"code": {"body": "    public static DurationFieldType weekyears() {\n        return WEEKYEARS_TYPE;\n    }", "comment": "/**\n     * Get the weekyears field type.\n     * \n     * @return the DateTimeFieldType constant\n     */"}}
{"code": {"body": "    public static DurationFieldType months() {\n        return MONTHS_TYPE;\n    }", "comment": "/**\n     * Get the months field type.\n     * \n     * @return the DateTimeFieldType constant\n     */"}}
{"code": {"body": "    public static DurationFieldType years() {\n        return YEARS_TYPE;\n    }", "comment": "/**\n     * Get the years field type.\n     * \n     * @return the DateTimeFieldType constant\n     */"}}
{"code": {"body": "    public static DurationFieldType centuries() {\n        return CENTURIES_TYPE;\n    }", "comment": "/**\n     * Get the centuries field type.\n     * \n     * @return the DateTimeFieldType constant\n     */"}}
{"code": {"body": "    public static DurationFieldType eras() {\n        return ERAS_TYPE;\n    }", "comment": "/**\n     * Get the eras field type.\n     * \n     * @return the DateTimeFieldType constant\n     */"}}
{"code": {"body": "    public String getName() {\n        return iName;\n    }", "comment": "/**\n     * Get the name of the field.\n     * By convention, names are plural.\n     * \n     * @return field name\n     */"}}
{"code": {"body": "    public boolean isSupported(Chronology chronology) {\n        return getField(chronology).isSupported();\n    }", "comment": "/**\n     * Checks whether this field supported in the given Chronology.\n     *\n     * @param chronology  the chronology to use, null means ISOChronology in default zone\n     * @return true if supported\n     */"}}
{"code": {"body": "    public String toString() {\n        return getName();\n    }", "comment": "/**\n     * Get a suitable debug string.\n     * \n     * @return debug string\n     */"}}
{"code": {"body": "        private Object readResolve() {\n            switch (iOrdinal) {\n                case ERAS:\n                    return ERAS_TYPE;\n                case CENTURIES:\n                    return CENTURIES_TYPE;\n                case WEEKYEARS:\n                    return WEEKYEARS_TYPE;\n                case YEARS:\n                    return YEARS_TYPE;\n                case MONTHS:\n                    return MONTHS_TYPE;\n                case WEEKS:\n                    return WEEKS_TYPE;\n                case DAYS:\n                    return DAYS_TYPE;\n                case HALFDAYS:\n                    return HALFDAYS_TYPE;\n                case HOURS:\n                    return HOURS_TYPE;\n                case MINUTES:\n                    return MINUTES_TYPE;\n                case SECONDS:\n                    return SECONDS_TYPE;\n                case MILLIS:\n                    return MILLIS_TYPE;\n                default:\n                    \n                    return this;\n            }\n        }", "comment": "/**\n         * Ensure a singleton is returned.\n         * \n         * @return the singleton type\n         */"}}
{"code": {"body": "public Hours plus(int hours) {\n        if (hours == 0) {\n            return this;\n        }\n        return Hours.hours(FieldUtils.safeAdd(getValue(), hours));\n    }", "comment": "/**\n     * Returns a new instance with the specified number of hours added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the amount of hours to add, may be negative\n     * @return the new period plus the specified number of hours\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "public Hours plus(Hours hours) {\n        if (hours == null) {\n            return this;\n        }\n        return plus(hours.getValue());\n    }", "comment": "/**\n     * Returns a new instance with the specified number of hours added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the amount of hours to add, may be negative, null means zero\n     * @return the new period plus the specified number of hours\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "public Hours minus(int hours) {\n        return plus(FieldUtils.safeNegate(hours));\n    }", "comment": "/**\n     * Returns a new instance with the specified number of hours taken away.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the amount of hours to take away, may be negative\n     * @return the new period minus the specified number of hours\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "public Hours minus(Hours hours) {\n        if (hours == null) {\n            return this;\n        }\n        return minus(hours.getValue());\n    }", "comment": "/**\n     * Returns a new instance with the specified number of hours taken away.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the amount of hours to take away, may be negative, null means zero\n     * @return the new period minus the specified number of hours\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "public Hours multipliedBy(int scalar) {\n        return Hours.hours(FieldUtils.safeMultiply(getValue(), scalar));\n    }", "comment": "/**\n     * Returns a new instance with the hours multiplied by the specified scalar.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param scalar  the amount to multiply by, may be negative\n     * @return the new period multiplied by the specified scalar\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "public Hours dividedBy(int divisor) {\n        if (divisor == 1) {\n            return this;\n        }\n        return Hours.hours(getValue() / divisor);\n    }", "comment": "/**\n     * Returns a new instance with the hours divided by the specified divisor.\n     * The calculation uses integer division, thus 3 divided by 2 is 1.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param divisor  the amount to divide by, may be negative\n     * @return the new period divided by the specified divisor\n     * @throws ArithmeticException if the divisor is zero\n     */"}}
{"code": {"body": "public Hours negated() {\n        return Hours.hours(FieldUtils.safeNegate(getValue()));\n    }", "comment": "/**\n     * Returns a new instance with the hours value negated.\n     *\n     * @return the new period with a negated value\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "    public static Hours hours(int hours) {\n        switch (hours) {\n            case 0:\n                return ZERO;\n            case 1:\n                return ONE;\n            case 2:\n                return TWO;\n            case 3:\n                return THREE;\n            case 4:\n                return FOUR;\n            case 5:\n                return FIVE;\n            case 6:\n                return SIX;\n            case 7:\n                return SEVEN;\n            case 8:\n                return EIGHT;\n            case Integer.MAX_VALUE:\n                return MAX_VALUE;\n            case Integer.MIN_VALUE:\n                return MIN_VALUE;\n            default:\n                return new Hours(hours);\n        }\n    }", "comment": "/**\n     * Obtains an instance of <code>Hours</code> that may be cached.\n     * <code>Hours</code> is immutable, so instances can be cached and shared.\n     * This factory method provides access to shared instances.\n     *\n     * @param hours  the number of hours to obtain an instance for\n     * @return the instance of Hours\n     */"}}
{"code": {"body": "    public static Hours hoursBetween(ReadablePartial start, ReadablePartial end) {\n        if (start instanceof LocalTime && end instanceof LocalTime)   {\n            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n            int hours = chrono.hours().getDifference(\n                    ((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis());\n            return Hours.hours(hours);\n        }\n        int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\n        return Hours.hours(amount);\n    }", "comment": "/**\n     * Creates a <code>Hours</code> representing the number of whole hours\n     * between the two specified partial datetimes.\n     * <p>\n     * The two partials must contain the same fields, for example you can specify\n     * two <code>LocalTime</code> objects.\n     *\n     * @param start  the start partial date, must not be null\n     * @param end  the end partial date, must not be null\n     * @return the period in hours\n     * @throws IllegalArgumentException if the partials are null or invalid\n     */"}}
{"code": {"body": "    public static Hours hoursIn(ReadableInterval interval) {\n        if (interval == null)   {\n            return Hours.ZERO;\n        }\n        int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.hours());\n        return Hours.hours(amount);\n    }", "comment": "/**\n     * Creates a <code>Hours</code> representing the number of whole hours\n     * in the specified interval.\n     *\n     * @param interval  the interval to extract hours from, null returns zero\n     * @return the period in hours\n     * @throws IllegalArgumentException if the partials are null or invalid\n     */"}}
{"code": {"body": "    public static Hours standardHoursIn(ReadablePeriod period) {\n        int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_HOUR);\n        return Hours.hours(amount);\n    }", "comment": "/**\n     * Creates a new <code>Hours</code> representing the number of complete\n     * standard length hours in the specified period.\n     * <p>\n     * This factory method converts all fields from the period to hours using standardised\n     * durations for each field. Only those fields which have a precise duration in\n     * the ISO UTC chronology can be converted.\n     * <ul>\n     * <li>One week consists of 7 days.\n     * <li>One day consists of 24 hours.\n     * <li>One hour consists of 60 minutes.\n     * <li>One minute consists of 60 seconds.\n     * <li>One second consists of 1000 milliseconds.\n     * </ul>\n     * Months and Years are imprecise and periods containing these values cannot be converted.\n     *\n     * @param period  the period to get the number of hours from, null returns zero\n     * @return the period in hours\n     * @throws IllegalArgumentException if the period contains imprecise duration values\n     */"}}
{"code": {"body": "    private Object readResolve() {\n        return Hours.hours(getValue());\n    }", "comment": "/**\n     * Resolves singletons.\n     * \n     * @return the singleton instance\n     */"}}
{"code": {"body": "    public DurationFieldType getFieldType() {\n        return DurationFieldType.hours();\n    }", "comment": "/**\n     * Gets the duration field type, which is <code>hours</code>.\n     *\n     * @return the period type\n     */"}}
{"code": {"body": "    public PeriodType getPeriodType() {\n        return PeriodType.hours();\n    }", "comment": "/**\n     * Gets the period type, which is <code>hours</code>.\n     *\n     * @return the period type\n     */"}}
{"code": {"body": "    public Weeks toStandardWeeks() {\n        return Weeks.weeks(getValue() / DateTimeConstants.HOURS_PER_WEEK);\n    }", "comment": "/**\n     * Converts this period in hours to a period in weeks assuming a\n     * 7 day week and 24 hour day.\n     * <p>\n     * This method allows you to convert between different types of period.\n     * However to achieve this it makes the assumption that all weeks are 7 days\n     * long and all days are 24 hours long.\n     * This is not true when daylight savings time is considered, and may also\n     * not be true for some unusual chronologies. However, it is included as it\n     * is a useful operation for many applications and business rules.\n     * \n     * @return a period representing the number of whole weeks for this number of hours\n     */"}}
{"code": {"body": "    public Days toStandardDays() {\n        return Days.days(getValue() / DateTimeConstants.HOURS_PER_DAY);\n    }", "comment": "/**\n     * Converts this period in hours to a period in days assuming a\n     * 24 hour day.\n     * <p>\n     * This method allows you to convert between different types of period.\n     * However to achieve this it makes the assumption that all days are 24 hours long.\n     * This is not true when daylight savings time is considered, and may also\n     * not be true for some unusual chronologies. However, it is included as it\n     * is a useful operation for many applications and business rules.\n     * \n     * @return a period representing the number of whole days for this number of hours\n     */"}}
{"code": {"body": "    public Minutes toStandardMinutes() {\n        return Minutes.minutes(FieldUtils.safeMultiply(getValue(), DateTimeConstants.MINUTES_PER_HOUR));\n    }", "comment": "/**\n     * Converts this period in hours to a period in minutes assuming a\n     * 60 minute hour.\n     * <p>\n     * This method allows you to convert between different types of period.\n     * However to achieve this it makes the assumption that all hours are 60 minutes long.\n     * This may not be true for some unusual chronologies. However, it is included\n     * as it is a useful operation for many applications and business rules.\n     * \n     * @return a period representing the number of minutes for this number of hours\n     * @throws ArithmeticException if the number of minutes is too large to be represented\n     */"}}
{"code": {"body": "    public Seconds toStandardSeconds() {\n        return Seconds.seconds(FieldUtils.safeMultiply(getValue(), DateTimeConstants.SECONDS_PER_HOUR));\n    }", "comment": "/**\n     * Converts this period in hours to a period in seconds assuming a\n     * 60 minute hour and 60 second minute.\n     * <p>\n     * This method allows you to convert between different types of period.\n     * However to achieve this it makes the assumption that all hours are\n     * 60 minutes long and all minutes are 60 seconds long.\n     * This may not be true for some unusual chronologies. However, it is included\n     * as it is a useful operation for many applications and business rules.\n     * \n     * @return a period representing the number of seconds for this number of hours\n     * @throws ArithmeticException if the number of seconds is too large to be represented\n     */"}}
{"code": {"body": "    public Duration toStandardDuration() {\n        long hours = getValue();  \n        return new Duration(hours * DateTimeConstants.MILLIS_PER_HOUR);\n    }", "comment": "/**\n     * Converts this period in hours to a duration in milliseconds assuming a\n     * 60 minute hour and 60 second minute.\n     * <p>\n     * This method allows you to convert from a period to a duration.\n     * However to achieve this it makes the assumption that all hours are\n     * 60 minutes and all minutes are 60 seconds. This might not be true for an\n     * unusual chronology, for example one that takes leap seconds into account.\n     * However, the method is included as it is a useful operation for many\n     * applications and business rules.\n     *\n     * @return a duration equivalent to this number of hours\n     */"}}
{"code": {"body": "    public int getHours() {\n        return getValue();\n    }", "comment": "/**\n     * Gets the number of hours that this period represents.\n     *\n     * @return the number of hours in the period\n     */"}}
{"code": {"body": "    public Hours plus(Hours hours) {\n        if (hours == null) {\n            return this;\n        }\n        return plus(hours.getValue());\n    }", "comment": "/**\n     * Returns a new instance with the specified number of hours added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the amount of hours to add, may be negative, null means zero\n     * @return the new period plus the specified number of hours\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "    public Hours minus(Hours hours) {\n        if (hours == null) {\n            return this;\n        }\n        return minus(hours.getValue());\n    }", "comment": "/**\n     * Returns a new instance with the specified number of hours taken away.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the amount of hours to take away, may be negative, null means zero\n     * @return the new period minus the specified number of hours\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "    public Hours multipliedBy(int scalar) {\n        return Hours.hours(FieldUtils.safeMultiply(getValue(), scalar));\n    }", "comment": "/**\n     * Returns a new instance with the hours multiplied by the specified scalar.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param scalar  the amount to multiply by, may be negative\n     * @return the new period multiplied by the specified scalar\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "    public Hours dividedBy(int divisor) {\n        if (divisor == 1) {\n            return this;\n        }\n        return Hours.hours(getValue() / divisor);\n    }", "comment": "/**\n     * Returns a new instance with the hours divided by the specified divisor.\n     * The calculation uses integer division, thus 3 divided by 2 is 1.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param divisor  the amount to divide by, may be negative\n     * @return the new period divided by the specified divisor\n     * @throws ArithmeticException if the divisor is zero\n     */"}}
{"code": {"body": "    public Hours negated() {\n        return Hours.hours(FieldUtils.safeNegate(getValue()));\n    }", "comment": "/**\n     * Returns a new instance with the hours value negated.\n     *\n     * @return the new period with a negated value\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "    public boolean isGreaterThan(Hours other) {\n        if (other == null) {\n            return getValue() > 0;\n        }\n        return getValue() > other.getValue();\n    }", "comment": "/**\n     * Is this hours instance greater than the specified number of hours.\n     *\n     * @param other  the other period, null means zero\n     * @return true if this hours instance is greater than the specified one\n     */"}}
{"code": {"body": "    public boolean isLessThan(Hours other) {\n        if (other == null) {\n            return getValue() < 0;\n        }\n        return getValue() < other.getValue();\n    }", "comment": "/**\n     * Is this hours instance less than the specified number of hours.\n     *\n     * @param other  the other period, null means zero\n     * @return true if this hours instance is less than the specified one\n     */"}}
{"code": {"body": "public IllegalFieldValueException(DateTimeFieldType fieldType,", "comment": "/**\n     * Constructor.\n     * \n     * @param fieldType  type of field being set\n     * @param value  illegal value being set\n     * @param lowerBound  lower legal field value, or null if not applicable\n     * @param upperBound  upper legal field value, or null if not applicable\n     */"}}
{"code": {"body": "public IllegalFieldValueException(DateTimeFieldType fieldType,", "comment": "/**\n     * Constructor.\n     * \n     * @param fieldType  type of field being set\n     * @param value  illegal value being set\n     * @param lowerBound  lower legal field value, or null if not applicable\n     * @param upperBound  upper legal field value, or null if not applicable\n     */"}}
{"code": {"body": "public IllegalFieldValueException(DurationFieldType fieldType,", "comment": "/**\n     * Constructor.\n     * \n     * @param fieldType  type of field being set\n     * @param value  illegal value being set\n     * @param lowerBound  lower legal field value, or null if not applicable\n     * @param upperBound  upper legal field value, or null if not applicable\n     */"}}
{"code": {"body": "public IllegalFieldValueException(String fieldName,", "comment": "/**\n     * Constructor.\n     * \n     * @param fieldName  name of field being set\n     * @param value  illegal value being set\n     * @param lowerBound  lower legal field value, or null if not applicable\n     * @param upperBound  upper legal field value, or null if not applicable\n     */"}}
{"code": {"body": "public IllegalFieldValueException(DateTimeFieldType fieldType, String value) {\n        super(createMessage(fieldType.getName(), value));\n        iDateTimeFieldType = fieldType;\n        iDurationFieldType = null;\n        iFieldName = fieldType.getName();\n        iStringValue = value;\n        iNumberValue = null;\n        iLowerBound = null;\n        iUpperBound = null;\n        iMessage = super.getMessage();\n    }", "comment": "/**\n     * Constructor.\n     * \n     * @param fieldType  type of field being set\n     * @param value  illegal value being set\n     */"}}
{"code": {"body": "public IllegalFieldValueException(DurationFieldType fieldType, String value) {\n        super(createMessage(fieldType.getName(), value));\n        iDateTimeFieldType = null;\n        iDurationFieldType = fieldType;\n        iFieldName = fieldType.getName();\n        iStringValue = value;\n        iNumberValue = null;\n        iLowerBound = null;\n        iUpperBound = null;\n        iMessage = super.getMessage();\n    }", "comment": "/**\n     * Constructor.\n     * \n     * @param fieldType  type of field being set\n     * @param value  illegal value being set\n     */"}}
{"code": {"body": "public IllegalFieldValueException(String fieldName, String value) {\n        super(createMessage(fieldName, value));\n        iDateTimeFieldType = null;\n        iDurationFieldType = null;\n        iFieldName = fieldName;\n        iStringValue = value;\n        iNumberValue = null;\n        iLowerBound = null;\n        iUpperBound = null;\n        iMessage = super.getMessage();\n    }", "comment": "/**\n     * Constructor.\n     * \n     * @param fieldName  name of field being set\n     * @param value  illegal value being set\n     */"}}
{"code": {"body": "    private static String createMessage(String fieldName, String value) {\n        StringBuffer buf = new StringBuffer().append(\"\");\n\n        if (value == null) {\n            buf.append(\"\");\n        } else {\n            buf.append('');\n            buf.append(value);\n            buf.append('');\n        }\n\n        buf.append(\"\").append(fieldName).append('').append(\"\");\n        \n        return buf.toString();\n    }", "comment": "/**\n     * Creates a message for the exception.\n     *\n     * @param fieldName  the field name\n     * @param value  the value rejected\n     * @return the message\n     */"}}
{"code": {"body": "    public DateTimeFieldType getDateTimeFieldType() {\n        return iDateTimeFieldType;\n    }", "comment": "/**\n     * Returns the DateTimeFieldType whose value was invalid, or null if not applicable.\n     * \n     * @return the datetime field type\n     */"}}
{"code": {"body": "    public DurationFieldType getDurationFieldType() {\n        return iDurationFieldType;\n    }", "comment": "/**\n     * Returns the DurationFieldType whose value was invalid, or null if not applicable.\n     * \n     * @return the duration field type\n     */"}}
{"code": {"body": "    public String getFieldName() {\n        return iFieldName;\n    }", "comment": "/**\n     * Returns the name of the field whose value was invalid.\n     * \n     * @return the field name\n     */"}}
{"code": {"body": "    public Number getIllegalNumberValue() {\n        return iNumberValue;\n    }", "comment": "/**\n     * Returns the illegal integer value assigned to the field, or null if not applicable.\n     * \n     * @return the value\n     */"}}
{"code": {"body": "    public String getIllegalStringValue() {\n        return iStringValue;\n    }", "comment": "/**\n     * Returns the illegal string value assigned to the field, or null if not applicable.\n     * \n     * @return the value\n     */"}}
{"code": {"body": "    public String getIllegalValueAsString() {\n        String value = iStringValue;\n        if (value == null) {\n            value = String.valueOf(iNumberValue);\n        }\n        return value;\n    }", "comment": "/**\n     * Returns the illegal value assigned to the field as a non-null string.\n     * \n     * @return the value\n     */"}}
{"code": {"body": "    public Number getLowerBound() {\n        return iLowerBound;\n    }", "comment": "/**\n     * Returns the lower bound of the legal value range, or null if not applicable.\n     * \n     * @return the lower bound\n     */"}}
{"code": {"body": "    public Number getUpperBound() {\n        return iUpperBound;\n    }", "comment": "/**\n     * Returns the upper bound of the legal value range, or null if not applicable.\n     * \n     * @return the upper bound\n     */"}}
{"code": {"body": "    public void prependMessage(String message) {\n        if (iMessage == null) {\n            iMessage = message;\n        } else if (message != null) {\n            iMessage = message + \"\" + iMessage;\n        }\n    }", "comment": "/**\n     * Provide additional detail by prepending a message to the existing message.\n     * A colon is separator is automatically inserted between the messages.\n     * @since 1.3\n     */"}}
{"code": {"body": "public IllegalInstantException(String message) {\n        super(message);\n    }", "comment": "/**\n     * Constructor.\n     * \n     * @param message  the message\n     */"}}
{"code": {"body": "public IllegalInstantException(long instantLocal, String zoneId) {\n        super(createMessage(instantLocal, zoneId));\n    }", "comment": "/**\n     * Constructor.\n     * \n     * @param instantLocal  the local instant\n     * @param zoneId  the time-zone ID, may be null\n     */"}}
{"code": {"body": "    public static boolean isIllegalInstant(Throwable ex) {\n        if (ex instanceof IllegalInstantException) {\n            return true;\n        }\n        while (ex.getCause() != null && ex.getCause() != ex) {\n            return isIllegalInstant(ex.getCause());\n        }\n        return false;\n    }", "comment": "/**\n     * Checks if the exception is, or has a cause, of {@code IllegalInstantException}.\n     * \n     * @param ex  the exception to check\n     * @return true if an {@code IllegalInstantException}\n     */"}}
{"code": {"body": "public Instant() {\n        super();\n        iMillis = DateTimeUtils.currentTimeMillis();\n    }", "comment": "/**\n     * Constructs an instance set to the current system millisecond time.\n     * \n     * @see #now()\n     */"}}
{"code": {"body": "public Instant(long instant) {\n        super();\n        iMillis = instant;\n    }", "comment": "/**\n     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z.\n     * \n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     */"}}
{"code": {"body": "public Instant(Object instant) {\n        super();\n        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n        iMillis = converter.getInstantMillis(instant, ISOChronology.getInstanceUTC());\n    }", "comment": "/**\n     * Constructs an instance from an Object that represents a datetime.\n     * <p>\n     * The recognised object types are defined in {@link ConverterManager} and\n     * include String, Calendar and Date.\n     *\n     * @param instant  the datetime object, null means now\n     * @throws IllegalArgumentException if the instant is invalid\n     */"}}
{"code": {"body": "public Instant toInstant() {\n        return this;\n    }", "comment": "/**\n     * Get this object as an Instant by returning <code>this</code>.\n     * \n     * @return <code>this</code>\n     */"}}
{"code": {"body": "public Instant withMillis(long newMillis) {\n        return (newMillis == iMillis ? this : new Instant(newMillis));\n    }", "comment": "/**\n     * Gets a copy of this instant with different millis.\n     * <p>\n     * The returned object will be either be a new Instant or <code>this</code>.\n     *\n     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z\n     * @return a copy of this instant with different millis\n     */"}}
{"code": {"body": "public Instant withDurationAdded(long durationToAdd, int scalar) {\n        if (durationToAdd == 0 || scalar == 0) {\n            return this;\n        }\n        long instant = getChronology().add(getMillis(), durationToAdd, scalar);\n        return withMillis(instant);\n    }", "comment": "/**\n     * Gets a copy of this instant with the specified duration added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * \n     * @param durationToAdd  the duration to add to this one\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this instant with the duration added\n     * @throws ArithmeticException if the new instant exceeds the capacity of a long\n     */"}}
{"code": {"body": "public Instant withDurationAdded(ReadableDuration durationToAdd, int scalar) {\n        if (durationToAdd == null || scalar == 0) {\n            return this;\n        }\n        return withDurationAdded(durationToAdd.getMillis(), scalar);\n    }", "comment": "/**\n     * Gets a copy of this instant with the specified duration added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * \n     * @param durationToAdd  the duration to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this instant with the duration added\n     * @throws ArithmeticException if the new instant exceeds the capacity of a long\n     */"}}
{"code": {"body": "public Instant plus(long duration) {\n        return withDurationAdded(duration, 1);\n    }", "comment": "/**\n     * Gets a copy of this instant with the specified duration added.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * \n     * @param duration  the duration to add to this one\n     * @return a copy of this instant with the duration added\n     * @throws ArithmeticException if the new instant exceeds the capacity of a long\n     */"}}
{"code": {"body": "public Instant plus(ReadableDuration duration) {\n        return withDurationAdded(duration, 1);\n    }", "comment": "/**\n     * Gets a copy of this instant with the specified duration added.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * \n     * @param duration  the duration to add to this one, null means zero\n     * @return a copy of this instant with the duration added\n     * @throws ArithmeticException if the new instant exceeds the capacity of a long\n     */"}}
{"code": {"body": "public Instant minus(long duration) {\n        return withDurationAdded(duration, -1);\n    }", "comment": "/**\n     * Gets a copy of this instant with the specified duration taken away.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * \n     * @param duration  the duration to reduce this instant by\n     * @return a copy of this instant with the duration taken away\n     * @throws ArithmeticException if the new instant exceeds the capacity of a long\n     */"}}
{"code": {"body": "public Instant minus(ReadableDuration duration) {\n        return withDurationAdded(duration, -1);\n    }", "comment": "/**\n     * Gets a copy of this instant with the specified duration taken away.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * \n     * @param duration  the duration to reduce this instant by\n     * @return a copy of this instant with the duration taken away\n     * @throws ArithmeticException if the new instant exceeds the capacity of a long\n     */"}}
{"code": {"body": "    public static Instant now() {\n        return new Instant();\n    }", "comment": "/**\n     * Obtains an {@code Instant} set to the current system millisecond time.\n     * \n     * @return the current instant, not null\n     * @since 2.0\n     */"}}
{"code": {"body": "    public static Instant parse(String str, DateTimeFormatter formatter) {\n        return formatter.parseDateTime(str).toInstant();\n    }", "comment": "/**\n     * Parses a {@code Instant} from the specified string using a formatter.\n     * \n     * @param str  the string to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @since 2.0\n     */"}}
{"code": {"body": "    public Instant toInstant() {\n        return this;\n    }", "comment": "/**\n     * Get this object as an Instant by returning <code>this</code>.\n     * \n     * @return <code>this</code>\n     */"}}
{"code": {"body": "    public Instant withMillis(long newMillis) {\n        return (newMillis == iMillis ? this : new Instant(newMillis));\n    }", "comment": "/**\n     * Gets a copy of this instant with different millis.\n     * <p>\n     * The returned object will be either be a new Instant or <code>this</code>.\n     *\n     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z\n     * @return a copy of this instant with different millis\n     */"}}
{"code": {"body": "    public Instant withDurationAdded(ReadableDuration durationToAdd, int scalar) {\n        if (durationToAdd == null || scalar == 0) {\n            return this;\n        }\n        return withDurationAdded(durationToAdd.getMillis(), scalar);\n    }", "comment": "/**\n     * Gets a copy of this instant with the specified duration added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * \n     * @param durationToAdd  the duration to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this instant with the duration added\n     * @throws ArithmeticException if the new instant exceeds the capacity of a long\n     */"}}
{"code": {"body": "    public Instant plus(ReadableDuration duration) {\n        return withDurationAdded(duration, 1);\n    }", "comment": "/**\n     * Gets a copy of this instant with the specified duration added.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * \n     * @param duration  the duration to add to this one, null means zero\n     * @return a copy of this instant with the duration added\n     * @throws ArithmeticException if the new instant exceeds the capacity of a long\n     */"}}
{"code": {"body": "    public Instant minus(ReadableDuration duration) {\n        return withDurationAdded(duration, -1);\n    }", "comment": "/**\n     * Gets a copy of this instant with the specified duration taken away.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * \n     * @param duration  the duration to reduce this instant by\n     * @return a copy of this instant with the duration taken away\n     * @throws ArithmeticException if the new instant exceeds the capacity of a long\n     */"}}
{"code": {"body": "    public long getMillis() {\n        return iMillis;\n    }", "comment": "/**\n     * Gets the milliseconds of the instant.\n     * \n     * @return the number of milliseconds since 1970-01-01T00:00:00Z\n     */"}}
{"code": {"body": "    public Chronology getChronology() {\n        return ISOChronology.getInstanceUTC();\n    }", "comment": "/**\n     * Gets the chronology of the instant, which is ISO in the UTC zone.\n     * <p>\n     * This method returns {@link ISOChronology#getInstanceUTC()} which\n     * corresponds to the definition of the Java epoch 1970-01-01T00:00:00Z.\n     * \n     * @return ISO in the UTC zone\n     */"}}
{"code": {"body": "    public DateTime toDateTime() {\n        return new DateTime(getMillis(), ISOChronology.getInstance());\n    }", "comment": "/**\n     * Get this object as a DateTime using ISOChronology in the default zone.\n     * <p>\n     * This method returns a DateTime object in the default zone.\n     * This differs from the similarly named method on DateTime, DateMidnight\n     * or MutableDateTime which retains the time zone. The difference is\n     * because Instant really represents a time <i>without</i> a zone,\n     * thus calling this method we really have no zone to 'retain' and\n     * hence expect to switch to the default zone.\n     * <p>\n     * This method definition preserves compatibility with earlier versions\n     * of Joda-Time.\n     *\n     * @return a DateTime using the same millis\n     */"}}
{"code": {"body": "    public MutableDateTime toMutableDateTime() {\n        return new MutableDateTime(getMillis(), ISOChronology.getInstance());\n    }", "comment": "/**\n     * Get this object as a MutableDateTime using ISOChronology in the default zone.\n     * <p>\n     * This method returns a MutableDateTime object in the default zone.\n     * This differs from the similarly named method on DateTime, DateMidnight\n     * or MutableDateTime which retains the time zone. The difference is\n     * because Instant really represents a time <i>without</i> a zone,\n     * thus calling this method we really have no zone to 'retain' and\n     * hence expect to switch to the default zone.\n     * <p>\n     * This method definition preserves compatibility with earlier versions\n     * of Joda-Time.\n     *\n     * @return a MutableDateTime using the same millis\n     */"}}
{"code": {"body": "public Interval(long startInstant, long endInstant) {\n        super(startInstant, endInstant, null);\n    }", "comment": "/**\n     * Constructs an interval from a start and end instant with the ISO\n     * default chronology in the default time zone.\n     * \n     * @param startInstant  start of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n     * @param endInstant  end of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n     * @throws IllegalArgumentException if the end is before the start\n     */"}}
{"code": {"body": "public Interval(long startInstant, long endInstant, DateTimeZone zone) {\n        super(startInstant, endInstant, ISOChronology.getInstance(zone));\n    }", "comment": "/**\n     * Constructs an interval from a start and end instant with the ISO\n     * default chronology in the specified time zone.\n     * \n     * @param startInstant  start of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n     * @param endInstant  end of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n     * @param zone  the time zone to use, null means default zone\n     * @throws IllegalArgumentException if the end is before the start\n     * @since 1.5\n     */"}}
{"code": {"body": "public Interval(long startInstant, long endInstant, Chronology chronology) {\n        super(startInstant, endInstant, chronology);\n    }", "comment": "/**\n     * Constructs an interval from a start and end instant with the\n     * specified chronology.\n     * \n     * @param chronology  the chronology to use, null is ISO default\n     * @param startInstant  start of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n     * @param endInstant  end of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n     * @throws IllegalArgumentException if the end is before the start\n     */"}}
{"code": {"body": "public Interval(ReadableInstant start, ReadableInstant end) {\n        super(start, end);\n    }", "comment": "/**\n     * Constructs an interval from a start and end instant.\n     * <p>\n     * The chronology used is that of the start instant.\n     * \n     * @param start  start of this interval, null means now\n     * @param end  end of this interval, null means now\n     * @throws IllegalArgumentException if the end is before the start\n     */"}}
{"code": {"body": "public Interval(ReadableInstant start, ReadableDuration duration) {\n        super(start, duration);\n    }", "comment": "/**\n     * Constructs an interval from a start instant and a duration.\n     * \n     * @param start  start of this interval, null means now\n     * @param duration  the duration of this interval, null means zero length\n     * @throws IllegalArgumentException if the end is before the start\n     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n     */"}}
{"code": {"body": "public Interval(ReadableDuration duration, ReadableInstant end) {\n        super(duration, end);\n    }", "comment": "/**\n     * Constructs an interval from a millisecond duration and an end instant.\n     * \n     * @param duration  the duration of this interval, null means zero length\n     * @param end  end of this interval, null means now\n     * @throws IllegalArgumentException if the end is before the start\n     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n     */"}}
{"code": {"body": "public Interval(ReadableInstant start, ReadablePeriod period) {\n        super(start, period);\n    }", "comment": "/**\n     * Constructs an interval from a start instant and a time period.\n     * <p>\n     * When forming the interval, the chronology from the instant is used\n     * if present, otherwise the chronology of the period is used.\n     * \n     * @param start  start of this interval, null means now\n     * @param period  the period of this interval, null means zero length\n     * @throws IllegalArgumentException if the end is before the start\n     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n     */"}}
{"code": {"body": "public Interval(ReadablePeriod period, ReadableInstant end) {\n        super(period, end);\n    }", "comment": "/**\n     * Constructs an interval from a time period and an end instant.\n     * <p>\n     * When forming the interval, the chronology from the instant is used\n     * if present, otherwise the chronology of the period is used.\n     * \n     * @param period  the period of this interval, null means zero length\n     * @param end  end of this interval, null means now\n     * @throws IllegalArgumentException if the end is before the start\n     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n     */"}}
{"code": {"body": "public Interval(Object interval) {\n        super(interval, null);\n    }", "comment": "/**\n     * Constructs a time interval by converting or copying from another object.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadableInterval and String.\n     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}\n     * and {@link ISOPeriodFormat#standard()}, and may be 'datetime/datetime',\n     * 'datetime/period' or 'period/datetime'.\n     * \n     * @param interval  the time interval to copy\n     * @throws IllegalArgumentException if the interval is invalid\n     */"}}
{"code": {"body": "public Interval(Object interval, Chronology chronology) {\n        super(interval, chronology);\n    }", "comment": "/**\n     * Constructs a time interval by converting or copying from another object,\n     * overriding the chronology.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadableInterval and String.\n     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}\n     * and {@link ISOPeriodFormat#standard()}, and may be 'datetime/datetime',\n     * 'datetime/period' or 'period/datetime'.\n     * \n     * @param interval  the time interval to copy\n     * @param chronology  the chronology to use, null means ISO default\n     * @throws IllegalArgumentException if the interval is invalid\n     */"}}
{"code": {"body": "public Interval toInterval() {\n        return this;\n    }", "comment": "/**\n     * Get this interval as an immutable <code>Interval</code> object\n     * by returning <code>this</code>.\n     *\n     * @return <code>this</code>\n     */"}}
{"code": {"body": "public Interval overlap(ReadableInterval interval) {\n        interval = DateTimeUtils.getReadableInterval(interval);\n        if (overlaps(interval) == false) {\n            return null;\n        }\n        long start = Math.max(getStartMillis(), interval.getStartMillis());\n        long end = Math.min(getEndMillis(), interval.getEndMillis());\n        return new Interval(start, end, getChronology());\n    }", "comment": "/**\n     * Gets the overlap between this interval and another interval.\n     * <p>\n     * Intervals are inclusive of the start instant and exclusive of the end.\n     * An interval overlaps another if it shares some common part of the\n     * datetime continuum. This method returns the amount of the overlap,\n     * only if the intervals actually do overlap.\n     * If the intervals do not overlap, then null is returned.\n     * <p>\n     * When two intervals are compared the result is one of three states:\n     * (a) they abut, (b) there is a gap between them, (c) they overlap.\n     * The abuts state takes precedence over the other two, thus a zero duration\n     * interval at the start of a larger interval abuts and does not overlap.\n     * <p>\n     * The chronology of the returned interval is the same as that of\n     * this interval (the chronology of the interval parameter is not used).\n     * Note that the use of the chronology was only correctly implemented\n     * in version 1.3.\n     *\n     * @param interval  the interval to examine, null means now\n     * @return the overlap interval, null if no overlap\n     * @since 1.1\n     */"}}
{"code": {"body": "public Interval gap(ReadableInterval interval) {\n        interval = DateTimeUtils.getReadableInterval(interval);\n        long otherStart = interval.getStartMillis();\n        long otherEnd = interval.getEndMillis();\n        long thisStart = getStartMillis();\n        long thisEnd = getEndMillis();\n        if (thisStart > otherEnd) {\n            return new Interval(otherEnd, thisStart, getChronology());\n        } else if (otherStart > thisEnd) {\n            return new Interval(thisEnd, otherStart, getChronology());\n        } else {\n            return null;\n        }\n    }", "comment": "/**\n     * Gets the gap between this interval and another interval.\n     * The other interval can be either before or after this interval.\n     * <p>\n     * Intervals are inclusive of the start instant and exclusive of the end.\n     * An interval has a gap to another interval if there is a non-zero\n     * duration between them. This method returns the amount of the gap only\n     * if the intervals do actually have a gap between them.\n     * If the intervals overlap or abut, then null is returned.\n     * <p>\n     * When two intervals are compared the result is one of three states:\n     * (a) they abut, (b) there is a gap between them, (c) they overlap.\n     * The abuts state takes precedence over the other two, thus a zero duration\n     * interval at the start of a larger interval abuts and does not overlap.\n     * <p>\n     * The chronology of the returned interval is the same as that of\n     * this interval (the chronology of the interval parameter is not used).\n     * Note that the use of the chronology was only correctly implemented\n     * in version 1.3.\n     *\n     * @param interval  the interval to examine, null means now\n     * @return the gap interval, null if no gap\n     * @since 1.1\n     */"}}
{"code": {"body": "public Interval withChronology(Chronology chronology) {\n        if (getChronology() == chronology) {\n            return this;\n        }\n        return new Interval(getStartMillis(), getEndMillis(), chronology);\n    }", "comment": "/**\n     * Creates a new interval with the same start and end, but a different chronology.\n     *\n     * @param chronology  the chronology to use, null means ISO default\n     * @return an interval with a different chronology\n     */"}}
{"code": {"body": "public Interval withStartMillis(long startInstant) {\n        if (startInstant == getStartMillis()) {\n            return this;\n        }\n        return new Interval(startInstant, getEndMillis(), getChronology());\n    }", "comment": "/**\n     * Creates a new interval with the specified start millisecond instant.\n     *\n     * @param startInstant  the start instant for the new interval\n     * @return an interval with the end from this interval and the specified start\n     * @throws IllegalArgumentException if the resulting interval has end before start\n     */"}}
{"code": {"body": "public Interval withStart(ReadableInstant start) {\n        long startMillis = DateTimeUtils.getInstantMillis(start);\n        return withStartMillis(startMillis);\n    }", "comment": "/**\n     * Creates a new interval with the specified start instant.\n     *\n     * @param start  the start instant for the new interval, null means now\n     * @return an interval with the end from this interval and the specified start\n     * @throws IllegalArgumentException if the resulting interval has end before start\n     */"}}
{"code": {"body": "public Interval withEndMillis(long endInstant) {\n        if (endInstant == getEndMillis()) {\n            return this;\n        }\n        return new Interval(getStartMillis(), endInstant, getChronology());\n    }", "comment": "/**\n     * Creates a new interval with the specified start millisecond instant.\n     *\n     * @param endInstant  the end instant for the new interval\n     * @return an interval with the start from this interval and the specified end\n     * @throws IllegalArgumentException if the resulting interval has end before start\n     */"}}
{"code": {"body": "public Interval withEnd(ReadableInstant end) {\n        long endMillis = DateTimeUtils.getInstantMillis(end);\n        return withEndMillis(endMillis);\n    }", "comment": "/**\n     * Creates a new interval with the specified end instant.\n     *\n     * @param end  the end instant for the new interval, null means now\n     * @return an interval with the start from this interval and the specified end\n     * @throws IllegalArgumentException if the resulting interval has end before start\n     */"}}
{"code": {"body": "public Interval withDurationAfterStart(ReadableDuration duration) {\n        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n        if (durationMillis == toDurationMillis()) {\n            return this;\n        }\n        Chronology chrono = getChronology();\n        long startMillis = getStartMillis();\n        long endMillis = chrono.add(startMillis, durationMillis, 1);\n        return new Interval(startMillis, endMillis, chrono);\n    }", "comment": "/**\n     * Creates a new interval with the specified duration after the start instant.\n     *\n     * @param duration  the duration to add to the start to get the new end instant, null means zero\n     * @return an interval with the start from this interval and a calculated end\n     * @throws IllegalArgumentException if the duration is negative\n     */"}}
{"code": {"body": "public Interval withDurationBeforeEnd(ReadableDuration duration) {\n        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n        if (durationMillis == toDurationMillis()) {\n            return this;\n        }\n        Chronology chrono = getChronology();\n        long endMillis = getEndMillis();\n        long startMillis = chrono.add(endMillis, durationMillis, -1);\n        return new Interval(startMillis, endMillis, chrono);\n    }", "comment": "/**\n     * Creates a new interval with the specified duration before the end instant.\n     *\n     * @param duration  the duration to add to the start to get the new end instant, null means zero\n     * @return an interval with the start from this interval and a calculated end\n     * @throws IllegalArgumentException if the duration is negative\n     */"}}
{"code": {"body": "public Interval withPeriodAfterStart(ReadablePeriod period) {\n        if (period == null) {\n            return withDurationAfterStart(null);\n        }\n        Chronology chrono = getChronology();\n        long startMillis = getStartMillis();\n        long endMillis = chrono.add(period, startMillis, 1);\n        return new Interval(startMillis, endMillis, chrono);\n    }", "comment": "/**\n     * Creates a new interval with the specified period after the start instant.\n     *\n     * @param period  the period to add to the start to get the new end instant, null means zero\n     * @return an interval with the start from this interval and a calculated end\n     * @throws IllegalArgumentException if the period is negative\n     */"}}
{"code": {"body": "public Interval withPeriodBeforeEnd(ReadablePeriod period) {\n        if (period == null) {\n            return withDurationBeforeEnd(null);\n        }\n        Chronology chrono = getChronology();\n        long endMillis = getEndMillis();\n        long startMillis = chrono.add(period, endMillis, -1);\n        return new Interval(startMillis, endMillis, chrono);\n    }", "comment": "/**\n     * Creates a new interval with the specified period before the end instant.\n     *\n     * @param period  the period to add to the start to get the new end instant, null means zero\n     * @return an interval with the start from this interval and a calculated end\n     * @throws IllegalArgumentException if the period is negative\n     */"}}
{"code": {"body": "    public static Interval parse(String str) {\n        return new Interval(str);\n    }", "comment": "/**\n     * Parses a {@code Interval} from the specified string.\n     * <p>\n     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}\n     * and {@link ISOPeriodFormat#standard()}, and may be 'datetime/datetime',\n     * 'datetime/period' or 'period/datetime'.\n     * \n     * @param str  the string to parse, not null\n     * @since 2.0\n     */"}}
{"code": {"body": "    public Interval toInterval() {\n        return this;\n    }", "comment": "/**\n     * Get this interval as an immutable <code>Interval</code> object\n     * by returning <code>this</code>.\n     *\n     * @return <code>this</code>\n     */"}}
{"code": {"body": "    public Interval overlap(ReadableInterval interval) {\n        interval = DateTimeUtils.getReadableInterval(interval);\n        if (overlaps(interval) == false) {\n            return null;\n        }\n        long start = Math.max(getStartMillis(), interval.getStartMillis());\n        long end = Math.min(getEndMillis(), interval.getEndMillis());\n        return new Interval(start, end, getChronology());\n    }", "comment": "/**\n     * Gets the overlap between this interval and another interval.\n     * <p>\n     * Intervals are inclusive of the start instant and exclusive of the end.\n     * An interval overlaps another if it shares some common part of the\n     * datetime continuum. This method returns the amount of the overlap,\n     * only if the intervals actually do overlap.\n     * If the intervals do not overlap, then null is returned.\n     * <p>\n     * When two intervals are compared the result is one of three states:\n     * (a) they abut, (b) there is a gap between them, (c) they overlap.\n     * The abuts state takes precedence over the other two, thus a zero duration\n     * interval at the start of a larger interval abuts and does not overlap.\n     * <p>\n     * The chronology of the returned interval is the same as that of\n     * this interval (the chronology of the interval parameter is not used).\n     * Note that the use of the chronology was only correctly implemented\n     * in version 1.3.\n     *\n     * @param interval  the interval to examine, null means now\n     * @return the overlap interval, null if no overlap\n     * @since 1.1\n     */"}}
{"code": {"body": "    public Interval gap(ReadableInterval interval) {\n        interval = DateTimeUtils.getReadableInterval(interval);\n        long otherStart = interval.getStartMillis();\n        long otherEnd = interval.getEndMillis();\n        long thisStart = getStartMillis();\n        long thisEnd = getEndMillis();\n        if (thisStart > otherEnd) {\n            return new Interval(otherEnd, thisStart, getChronology());\n        } else if (otherStart > thisEnd) {\n            return new Interval(thisEnd, otherStart, getChronology());\n        } else {\n            return null;\n        }\n    }", "comment": "/**\n     * Gets the gap between this interval and another interval.\n     * The other interval can be either before or after this interval.\n     * <p>\n     * Intervals are inclusive of the start instant and exclusive of the end.\n     * An interval has a gap to another interval if there is a non-zero\n     * duration between them. This method returns the amount of the gap only\n     * if the intervals do actually have a gap between them.\n     * If the intervals overlap or abut, then null is returned.\n     * <p>\n     * When two intervals are compared the result is one of three states:\n     * (a) they abut, (b) there is a gap between them, (c) they overlap.\n     * The abuts state takes precedence over the other two, thus a zero duration\n     * interval at the start of a larger interval abuts and does not overlap.\n     * <p>\n     * The chronology of the returned interval is the same as that of\n     * this interval (the chronology of the interval parameter is not used).\n     * Note that the use of the chronology was only correctly implemented\n     * in version 1.3.\n     *\n     * @param interval  the interval to examine, null means now\n     * @return the gap interval, null if no gap\n     * @since 1.1\n     */"}}
{"code": {"body": "    public boolean abuts(ReadableInterval interval) {\n        if (interval == null) {\n            long now = DateTimeUtils.currentTimeMillis();\n            return (getStartMillis() == now || getEndMillis() == now);\n        } else {\n            return (interval.getEndMillis() == getStartMillis() ||\n                    getEndMillis() == interval.getStartMillis());\n        }\n    }", "comment": "/**\n     * Does this interval abut with the interval specified.\n     * <p>\n     * Intervals are inclusive of the start instant and exclusive of the end.\n     * An interval abuts if it starts immediately after, or ends immediately\n     * before this interval without overlap.\n     * A zero duration interval abuts with itself.\n     * <p>\n     * When two intervals are compared the result is one of three states:\n     * (a) they abut, (b) there is a gap between them, (c) they overlap.\n     * The abuts state takes precedence over the other two, thus a zero duration\n     * interval at the start of a larger interval abuts and does not overlap.\n     * <p>\n     * For example:\n     * <pre>\n     * [09:00 to 10:00) abuts [08:00 to 08:30)  = false (completely before)\n     * [09:00 to 10:00) abuts [08:00 to 09:00)  = true\n     * [09:00 to 10:00) abuts [08:00 to 09:01)  = false (overlaps)\n     * \n     * [09:00 to 10:00) abuts [09:00 to 09:00)  = true\n     * [09:00 to 10:00) abuts [09:00 to 09:01)  = false (overlaps)\n     * \n     * [09:00 to 10:00) abuts [10:00 to 10:00)  = true\n     * [09:00 to 10:00) abuts [10:00 to 10:30)  = true\n     * \n     * [09:00 to 10:00) abuts [10:30 to 11:00)  = false (completely after)\n     * \n     * [14:00 to 14:00) abuts [14:00 to 14:00)  = true\n     * [14:00 to 14:00) abuts [14:00 to 15:00)  = true\n     * [14:00 to 14:00) abuts [13:00 to 14:00)  = true\n     * </pre>\n     *\n     * @param interval  the interval to examine, null means now\n     * @return true if the interval abuts\n     * @since 1.1\n     */"}}
{"code": {"body": "    public Interval withChronology(Chronology chronology) {\n        if (getChronology() == chronology) {\n            return this;\n        }\n        return new Interval(getStartMillis(), getEndMillis(), chronology);\n    }", "comment": "/**\n     * Creates a new interval with the same start and end, but a different chronology.\n     *\n     * @param chronology  the chronology to use, null means ISO default\n     * @return an interval with a different chronology\n     */"}}
{"code": {"body": "    public Interval withStartMillis(long startInstant) {\n        if (startInstant == getStartMillis()) {\n            return this;\n        }\n        return new Interval(startInstant, getEndMillis(), getChronology());\n    }", "comment": "/**\n     * Creates a new interval with the specified start millisecond instant.\n     *\n     * @param startInstant  the start instant for the new interval\n     * @return an interval with the end from this interval and the specified start\n     * @throws IllegalArgumentException if the resulting interval has end before start\n     */"}}
{"code": {"body": "    public Interval withStart(ReadableInstant start) {\n        long startMillis = DateTimeUtils.getInstantMillis(start);\n        return withStartMillis(startMillis);\n    }", "comment": "/**\n     * Creates a new interval with the specified start instant.\n     *\n     * @param start  the start instant for the new interval, null means now\n     * @return an interval with the end from this interval and the specified start\n     * @throws IllegalArgumentException if the resulting interval has end before start\n     */"}}
{"code": {"body": "    public Interval withEndMillis(long endInstant) {\n        if (endInstant == getEndMillis()) {\n            return this;\n        }\n        return new Interval(getStartMillis(), endInstant, getChronology());\n    }", "comment": "/**\n     * Creates a new interval with the specified start millisecond instant.\n     *\n     * @param endInstant  the end instant for the new interval\n     * @return an interval with the start from this interval and the specified end\n     * @throws IllegalArgumentException if the resulting interval has end before start\n     */"}}
{"code": {"body": "    public Interval withEnd(ReadableInstant end) {\n        long endMillis = DateTimeUtils.getInstantMillis(end);\n        return withEndMillis(endMillis);\n    }", "comment": "/**\n     * Creates a new interval with the specified end instant.\n     *\n     * @param end  the end instant for the new interval, null means now\n     * @return an interval with the start from this interval and the specified end\n     * @throws IllegalArgumentException if the resulting interval has end before start\n     */"}}
{"code": {"body": "    public Interval withDurationAfterStart(ReadableDuration duration) {\n        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n        if (durationMillis == toDurationMillis()) {\n            return this;\n        }\n        Chronology chrono = getChronology();\n        long startMillis = getStartMillis();\n        long endMillis = chrono.add(startMillis, durationMillis, 1);\n        return new Interval(startMillis, endMillis, chrono);\n    }", "comment": "/**\n     * Creates a new interval with the specified duration after the start instant.\n     *\n     * @param duration  the duration to add to the start to get the new end instant, null means zero\n     * @return an interval with the start from this interval and a calculated end\n     * @throws IllegalArgumentException if the duration is negative\n     */"}}
{"code": {"body": "    public Interval withDurationBeforeEnd(ReadableDuration duration) {\n        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n        if (durationMillis == toDurationMillis()) {\n            return this;\n        }\n        Chronology chrono = getChronology();\n        long endMillis = getEndMillis();\n        long startMillis = chrono.add(endMillis, durationMillis, -1);\n        return new Interval(startMillis, endMillis, chrono);\n    }", "comment": "/**\n     * Creates a new interval with the specified duration before the end instant.\n     *\n     * @param duration  the duration to add to the start to get the new end instant, null means zero\n     * @return an interval with the start from this interval and a calculated end\n     * @throws IllegalArgumentException if the duration is negative\n     */"}}
{"code": {"body": "    public Interval withPeriodAfterStart(ReadablePeriod period) {\n        if (period == null) {\n            return withDurationAfterStart(null);\n        }\n        Chronology chrono = getChronology();\n        long startMillis = getStartMillis();\n        long endMillis = chrono.add(period, startMillis, 1);\n        return new Interval(startMillis, endMillis, chrono);\n    }", "comment": "/**\n     * Creates a new interval with the specified period after the start instant.\n     *\n     * @param period  the period to add to the start to get the new end instant, null means zero\n     * @return an interval with the start from this interval and a calculated end\n     * @throws IllegalArgumentException if the period is negative\n     */"}}
{"code": {"body": "    public Interval withPeriodBeforeEnd(ReadablePeriod period) {\n        if (period == null) {\n            return withDurationBeforeEnd(null);\n        }\n        Chronology chrono = getChronology();\n        long endMillis = getEndMillis();\n        long startMillis = chrono.add(period, endMillis, -1);\n        return new Interval(startMillis, endMillis, chrono);\n    }", "comment": "/**\n     * Creates a new interval with the specified period before the end instant.\n     *\n     * @param period  the period to add to the start to get the new end instant, null means zero\n     * @return an interval with the start from this interval and a calculated end\n     * @throws IllegalArgumentException if the period is negative\n     */"}}
{"code": {"body": "public JodaTimePermission(String name) {\n        super(name);\n    }", "comment": "/**\n     * Constructs a new permission object.\n     * \n     * @param name  the permission name\n     */"}}
{"code": {"body": "public LocalDate() {\n        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance());\n    }", "comment": "/**\n     * Constructs an instance set to the current local time evaluated using\n     * ISO chronology in the default zone.\n     * <p>\n     * Once the constructor is completed, the zone is no longer used.\n     * \n     * @see #now()\n     */"}}
{"code": {"body": "public LocalDate(DateTimeZone zone) {\n        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone));\n    }", "comment": "/**\n     * Constructs an instance set to the current local time evaluated using\n     * ISO chronology in the specified zone.\n     * <p>\n     * If the specified time zone is null, the default zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     *\n     * @param zone  the time zone, null means default zone\n     * @see #now(DateTimeZone)\n     */"}}
{"code": {"body": "public LocalDate(Chronology chronology) {\n        this(DateTimeUtils.currentTimeMillis(), chronology);\n    }", "comment": "/**\n     * Constructs an instance set to the current local time evaluated using\n     * specified chronology.\n     * <p>\n     * If the chronology is null, ISO chronology in the default time zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     *\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     * @see #now(Chronology)\n     */"}}
{"code": {"body": "public LocalDate(long instant) {\n        this(instant, ISOChronology.getInstance());\n    }", "comment": "/**\n     * Constructs an instance set to the local time defined by the specified\n     * instant evaluated using ISO chronology in the default zone.\n     * <p>\n     * Once the constructor is completed, the zone is no longer used.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     */"}}
{"code": {"body": "public LocalDate(long instant, DateTimeZone zone) {\n        this(instant, ISOChronology.getInstance(zone));\n    }", "comment": "/**\n     * Constructs an instance set to the local time defined by the specified\n     * instant evaluated using ISO chronology in the specified zone.\n     * <p>\n     * If the specified time zone is null, the default zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     * @param zone  the time zone, null means default zone\n     */"}}
{"code": {"body": "public LocalDate(long instant, Chronology chronology) {\n        chronology = DateTimeUtils.getChronology(chronology);\n        \n        long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);\n        chronology = chronology.withUTC();\n        iLocalMillis = chronology.dayOfMonth().roundFloor(localMillis);\n        iChronology = chronology;\n    }", "comment": "/**\n     * Constructs an instance set to the local time defined by the specified\n     * instant evaluated using the specified chronology.\n     * <p>\n     * If the chronology is null, ISO chronology in the default zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     */"}}
{"code": {"body": "public LocalDate(Object instant) {\n        this(instant, (Chronology) null);\n    }", "comment": "/**\n     * Constructs an instance from an Object that represents a datetime.\n     * The time zone will be retrieved from the object if possible,\n     * otherwise the default time zone will be used.\n     * <p>\n     * If the object contains no chronology, <code>ISOChronology</code> is used.\n     * Once the constructor is completed, the zone is no longer used.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n     * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.\n     * The default String converter ignores the zone and only parses the field values.\n     *\n     * @param instant  the datetime object\n     * @throws IllegalArgumentException if the instant is invalid\n     */"}}
{"code": {"body": "public LocalDate(Object instant, DateTimeZone zone) {\n        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);\n        Chronology chronology = converter.getChronology(instant, zone);\n        chronology = DateTimeUtils.getChronology(chronology);\n        iChronology = chronology.withUTC();\n        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateParser());\n        iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], 0);\n    }", "comment": "/**\n     * Constructs an instance from an Object that represents a datetime,\n     * forcing the time zone to that specified.\n     * <p>\n     * If the object contains no chronology, <code>ISOChronology</code> is used.\n     * If the specified time zone is null, the default zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n     * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.\n     * The default String converter ignores the zone and only parses the field values.\n     *\n     * @param instant  the datetime object\n     * @param zone  the time zone\n     * @throws IllegalArgumentException if the instant is invalid\n     */"}}
{"code": {"body": "public LocalDate(Object instant, Chronology chronology) {\n        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);\n        chronology = converter.getChronology(instant, chronology);\n        chronology = DateTimeUtils.getChronology(chronology);\n        iChronology = chronology.withUTC();\n        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateParser());\n        iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], 0);\n    }", "comment": "/**\n     * Constructs an instance from an Object that represents a datetime,\n     * using the specified chronology.\n     * <p>\n     * If the chronology is null, ISO in the default time zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     * If the instant contains a chronology, it will be ignored.\n     * For example, passing a {@code LocalDate} and a different chronology\n     * will return a date with the year/month/day from the date applied\n     * unaltered to the specified chronology.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n     * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.\n     * The default String converter ignores the zone and only parses the field values.\n     *\n     * @param instant  the datetime object\n     * @param chronology  the chronology\n     * @throws IllegalArgumentException if the instant is invalid\n     */"}}
{"code": {"body": "public LocalDateTime toLocalDateTime(LocalTime time) {\n        if (time == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (getChronology() != time.getChronology()) {\n            throw new IllegalArgumentException(\"\");\n        }\n        long localMillis = getLocalMillis() + time.getLocalMillis();\n        return new LocalDateTime(localMillis, getChronology());\n    }", "comment": "/**\n     * Converts this object to a LocalDateTime using a LocalTime to fill in\n     * the missing fields.\n     * <p>\n     * The resulting chronology is determined by the chronology of this\n     * LocalDate. The chronology of the time must also match.\n     * If the time is null an exception is thrown.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param time  the time of day to use, must not be null\n     * @return the LocalDateTime instance\n     * @throws IllegalArgumentException if the time is null\n     * @throws IllegalArgumentException if the chronology of the time does not match\n     * @since 1.5\n     */"}}
{"code": {"body": "public LocalDate withFields(ReadablePartial partial) {\n        if (partial == null) {\n            return this;\n        }\n        return withLocalMillis(getChronology().set(partial, getLocalMillis()));\n    }", "comment": "/**\n     * Returns a copy of this date with the partial set of fields replacing\n     * those from this instance.\n     * <p>\n     * For example, if the partial contains a year and a month then those two\n     * fields will be changed in the returned instance.\n     * Unsupported fields are ignored.\n     * If the partial is null, then <code>this</code> is returned.\n     *\n     * @param partial  the partial set of fields to apply to this date, null ignored\n     * @return a copy of this date with a different set of fields\n     * @throws IllegalArgumentException if any value is invalid\n     */"}}
{"code": {"body": "public LocalDate withField(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (isSupported(fieldType) == false) {\n            throw new IllegalArgumentException(\"\" + fieldType + \"\");\n        }\n        long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date with the specified field set to a new value.\n     * <p>\n     * For example, if the field type is <code>monthOfYear</code> then the\n     * month of year field will be changed in the returned instance.\n     * If the field type is null, then <code>this</code> is returned.\n     * <p>\n     * These two lines are equivalent:\n     * <pre>\n     * LocalDate updated = dt.withDayOfMonth(6);\n     * LocalDate updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);\n     * </pre>\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this date with the field set\n     * @throws IllegalArgumentException if the field is null or unsupported\n     */"}}
{"code": {"body": "public LocalDate withFieldAdded(DurationFieldType fieldType, int amount) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (isSupported(fieldType) == false) {\n            throw new IllegalArgumentException(\"\" + fieldType + \"\");\n        }\n        if (amount == 0) {\n            return this;\n        }\n        long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date with the value of the specified field increased.\n     * <p>\n     * If the addition is zero or the field is null, then <code>this</code> is returned.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * LocalDate added = dt.withFieldAdded(DurationFieldType.years(), 6);\n     * LocalDate added = dt.plusYears(6);\n     * LocalDate added = dt.plus(Period.years(6));\n     * </pre>\n     *\n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this date with the field updated\n     * @throws IllegalArgumentException if the field is null or unsupported\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */"}}
{"code": {"body": "public LocalDate withPeriodAdded(ReadablePeriod period, int scalar) {\n        if (period == null || scalar == 0) {\n            return this;\n        }\n        long instant = getLocalMillis();\n        Chronology chrono = getChronology();\n        for (int i = 0; i < period.size(); i++) {\n            long value = FieldUtils.safeMultiply(period.getValue(i), scalar);\n            DurationFieldType type = period.getFieldType(i);\n            if (isSupported(type)) {\n                instant = type.getField(chrono).add(instant, value);\n            }\n        }\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date with the specified period added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to add multiple copies of complex\n     * period instances. Adding one field is best achieved using methods\n     * like {@link #withFieldAdded(DurationFieldType, int)}\n     * or {@link #plusYears(int)}.\n     * <p>\n     * Unsupported time fields are ignored, thus adding a period of 24 hours\n     * will not have any effect.\n     *\n     * @param period  the period to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this date with the period added\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */"}}
{"code": {"body": "public LocalDate plus(ReadablePeriod period) {\n        return withPeriodAdded(period, 1);\n    }", "comment": "/**\n     * Returns a copy of this date with the specified period added.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to add complex period instances.\n     * Adding one field is best achieved using methods\n     * like {@link #plusYears(int)}.\n     * <p>\n     * Unsupported time fields are ignored, thus adding a period of 24 hours\n     * will not have any effect.\n     *\n     * @param period  the period to add to this one, null means zero\n     * @return a copy of this date with the period added\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */"}}
{"code": {"body": "public LocalDate plusYears(int years) {\n        if (years == 0) {\n            return this;\n        }\n        long instant = getChronology().years().add(getLocalMillis(), years);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date plus the specified number of years.\n     * <p>\n     * This adds the specified number of years to the date.\n     * If adding years makes the day-of-month invalid, it is adjusted to the last valid day in the month.\n     * This LocalDate instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDate added = dt.plusYears(6);\n     * LocalDate added = dt.plus(Period.years(6));\n     * LocalDate added = dt.withFieldAdded(DurationFieldType.years(), 6);\n     * </pre>\n     *\n     * @param years  the amount of years to add, may be negative\n     * @return the new LocalDate plus the increased years\n     */"}}
{"code": {"body": "public LocalDate plusMonths(int months) {\n        if (months == 0) {\n            return this;\n        }\n        long instant = getChronology().months().add(getLocalMillis(), months);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date plus the specified number of months.\n     * <p>\n     * This adds the specified number of months to the date.\n     * The addition may change the year, but the day-of-month is normally unchanged.\n     * If adding months makes the day-of-month invalid, it is adjusted to the last valid day in the month.\n     * This LocalDate instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDate added = dt.plusMonths(6);\n     * LocalDate added = dt.plus(Period.months(6));\n     * LocalDate added = dt.withFieldAdded(DurationFieldType.months(), 6);\n     * </pre>\n     *\n     * @param months  the amount of months to add, may be negative\n     * @return the new LocalDate plus the increased months\n     */"}}
{"code": {"body": "public LocalDate plusWeeks(int weeks) {\n        if (weeks == 0) {\n            return this;\n        }\n        long instant = getChronology().weeks().add(getLocalMillis(), weeks);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date plus the specified number of weeks.\n     * <p>\n     * This LocalDate instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDate added = dt.plusWeeks(6);\n     * LocalDate added = dt.plus(Period.weeks(6));\n     * LocalDate added = dt.withFieldAdded(DurationFieldType.weeks(), 6);\n     * </pre>\n     *\n     * @param weeks  the amount of weeks to add, may be negative\n     * @return the new LocalDate plus the increased weeks\n     */"}}
{"code": {"body": "public LocalDate plusDays(int days) {\n        if (days == 0) {\n            return this;\n        }\n        long instant = getChronology().days().add(getLocalMillis(), days);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date plus the specified number of days.\n     * <p>\n     * This LocalDate instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDate added = dt.plusDays(6);\n     * LocalDate added = dt.plus(Period.days(6));\n     * LocalDate added = dt.withFieldAdded(DurationFieldType.days(), 6);\n     * </pre>\n     *\n     * @param days  the amount of days to add, may be negative\n     * @return the new LocalDate plus the increased days\n     */"}}
{"code": {"body": "public LocalDate minus(ReadablePeriod period) {\n        return withPeriodAdded(period, -1);\n    }", "comment": "/**\n     * Returns a copy of this date with the specified period taken away.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to subtract complex period instances.\n     * Subtracting one field is best achieved using methods\n     * like {@link #minusYears(int)}.\n     * <p>\n     * Unsupported time fields are ignored, thus subtracting a period of 24 hours\n     * will not have any effect.\n     *\n     * @param period  the period to reduce this instant by\n     * @return a copy of this LocalDate with the period taken away\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */"}}
{"code": {"body": "public LocalDate minusYears(int years) {\n        if (years == 0) {\n            return this;\n        }\n        long instant = getChronology().years().subtract(getLocalMillis(), years);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date minus the specified number of years.\n     * <p>\n     * This subtracts the specified number of years from the date.\n     * If subtracting years makes the day-of-month invalid, it is adjusted to the last valid day in the month.\n     * This LocalDate instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDate subtracted = dt.minusYears(6);\n     * LocalDate subtracted = dt.minus(Period.years(6));\n     * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);\n     * </pre>\n     *\n     * @param years  the amount of years to subtract, may be negative\n     * @return the new LocalDate minus the increased years\n     */"}}
{"code": {"body": "public LocalDate minusMonths(int months) {\n        if (months == 0) {\n            return this;\n        }\n        long instant = getChronology().months().subtract(getLocalMillis(), months);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date minus the specified number of months.\n     * <p>\n     * This subtracts the specified number of months from the date.\n     * The subtraction may change the year, but the day-of-month is normally unchanged.\n     * If subtracting months makes the day-of-month invalid, it is adjusted to the last valid day in the month.\n     * This LocalDate instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDate subtracted = dt.minusMonths(6);\n     * LocalDate subtracted = dt.minus(Period.months(6));\n     * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);\n     * </pre>\n     *\n     * @param months  the amount of months to subtract, may be negative\n     * @return the new LocalDate minus the increased months\n     */"}}
{"code": {"body": "public LocalDate minusWeeks(int weeks) {\n        if (weeks == 0) {\n            return this;\n        }\n        long instant = getChronology().weeks().subtract(getLocalMillis(), weeks);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date minus the specified number of weeks.\n     * <p>\n     * This LocalDate instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDate subtracted = dt.minusWeeks(6);\n     * LocalDate subtracted = dt.minus(Period.weeks(6));\n     * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6);\n     * </pre>\n     *\n     * @param weeks  the amount of weeks to subtract, may be negative\n     * @return the new LocalDate minus the increased weeks\n     */"}}
{"code": {"body": "public LocalDate minusDays(int days) {\n        if (days == 0) {\n            return this;\n        }\n        long instant = getChronology().days().subtract(getLocalMillis(), days);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date minus the specified number of days.\n     * <p>\n     * This LocalDate instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDate subtracted = dt.minusDays(6);\n     * LocalDate subtracted = dt.minus(Period.days(6));\n     * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);\n     * </pre>\n     *\n     * @param days  the amount of days to subtract, may be negative\n     * @return the new LocalDate minus the increased days\n     */"}}
{"code": {"body": "public LocalDate withEra(int era) {\n        return withLocalMillis(getChronology().era().set(getLocalMillis(), era));\n    }", "comment": "/**\n     * Returns a copy of this date with the era field updated.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * era changed.\n     *\n     * @param era  the era to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "public LocalDate withCenturyOfEra(int centuryOfEra) {\n        return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(), centuryOfEra));\n    }", "comment": "/**\n     * Returns a copy of this date with the century of era field updated.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * century of era changed.\n     *\n     * @param centuryOfEra  the centurey of era to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "public LocalDate withYearOfEra(int yearOfEra) {\n        return withLocalMillis(getChronology().yearOfEra().set(getLocalMillis(), yearOfEra));\n    }", "comment": "/**\n     * Returns a copy of this date with the year of era field updated.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year of era changed.\n     *\n     * @param yearOfEra  the year of era to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "public LocalDate withYearOfCentury(int yearOfCentury) {\n        return withLocalMillis(getChronology().yearOfCentury().set(getLocalMillis(), yearOfCentury));\n    }", "comment": "/**\n     * Returns a copy of this date with the year of century field updated.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year of century changed.\n     *\n     * @param yearOfCentury  the year of century to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "public LocalDate withYear(int year) {\n        return withLocalMillis(getChronology().year().set(getLocalMillis(), year));\n    }", "comment": "/**\n     * Returns a copy of this date with the year field updated.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year changed.\n     *\n     * @param year  the year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "public LocalDate withWeekyear(int weekyear) {\n        return withLocalMillis(getChronology().weekyear().set(getLocalMillis(), weekyear));\n    }", "comment": "/**\n     * Returns a copy of this date with the weekyear field updated.\n     * <p>\n     * The weekyear is the year that matches with the weekOfWeekyear field.\n     * In the standard ISO8601 week algorithm, the first week of the year\n     * is that in which at least 4 days are in the year. As a result of this\n     * definition, day 1 of the first week may be in the previous year.\n     * The weekyear allows you to query the effective year for that day.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * weekyear changed.\n     *\n     * @param weekyear  the weekyear to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "public LocalDate withMonthOfYear(int monthOfYear) {\n        return withLocalMillis(getChronology().monthOfYear().set(getLocalMillis(), monthOfYear));\n    }", "comment": "/**\n     * Returns a copy of this date with the month of year field updated.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * month of year changed.\n     *\n     * @param monthOfYear  the month of year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "public LocalDate withWeekOfWeekyear(int weekOfWeekyear) {\n        return withLocalMillis(getChronology().weekOfWeekyear().set(getLocalMillis(), weekOfWeekyear));\n    }", "comment": "/**\n     * Returns a copy of this date with the week of weekyear field updated.\n     * <p>\n     * This field is associated with the \"weekyear\" via {@link #withWeekyear(int)}.\n     * In the standard ISO8601 week algorithm, the first week of the year\n     * is that in which at least 4 days are in the year. As a result of this\n     * definition, day 1 of the first week may be in the previous year.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * week of weekyear changed.\n     *\n     * @param weekOfWeekyear  the week of weekyear to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "public LocalDate withDayOfYear(int dayOfYear) {\n        return withLocalMillis(getChronology().dayOfYear().set(getLocalMillis(), dayOfYear));\n    }", "comment": "/**\n     * Returns a copy of this date with the day of year field updated.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of year changed.\n     *\n     * @param dayOfYear  the day of year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "public LocalDate withDayOfMonth(int dayOfMonth) {\n        return withLocalMillis(getChronology().dayOfMonth().set(getLocalMillis(), dayOfMonth));\n    }", "comment": "/**\n     * Returns a copy of this date with the day of month field updated.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of month changed.\n     *\n     * @param dayOfMonth  the day of month to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "public LocalDate withDayOfWeek(int dayOfWeek) {\n        return withLocalMillis(getChronology().dayOfWeek().set(getLocalMillis(), dayOfWeek));\n    }", "comment": "/**\n     * Returns a copy of this date with the day of week field updated.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of week changed.\n     *\n     * @param dayOfWeek  the day of week to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "public LocalDate getLocalDate() {\n            return iInstant;\n        }", "comment": "/**\n         * Gets the LocalDate object linked to this property.\n         * \n         * @return the linked LocalDate\n         */"}}
{"code": {"body": "public LocalDate addToCopy(int value) {\n            return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value));\n        }", "comment": "/**\n         * Adds to this field in a copy of this LocalDate.\n         * <p>\n         * The LocalDate attached to this property is unchanged by this call.\n         *\n         * @param value  the value to add to the field in the copy\n         * @return a copy of the LocalDate with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "public LocalDate addWrapFieldToCopy(int value) {\n            return iInstant.withLocalMillis(iField.addWrapField(iInstant.getLocalMillis(), value));\n        }", "comment": "/**\n         * Adds to this field, possibly wrapped, in a copy of this LocalDate.\n         * A field wrapped operation only changes this field.\n         * Thus 31st January addWrapField one day goes to the 1st January.\n         * <p>\n         * The LocalDate attached to this property is unchanged by this call.\n         *\n         * @param value  the value to add to the field in the copy\n         * @return a copy of the LocalDate with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "public LocalDate setCopy(int value) {\n            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), value));\n        }", "comment": "/**\n         * Sets this field in a copy of the LocalDate.\n         * <p>\n         * The LocalDate attached to this property is unchanged by this call.\n         *\n         * @param value  the value to set the field in the copy to\n         * @return a copy of the LocalDate with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "public LocalDate setCopy(String text, Locale locale) {\n            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), text, locale));\n        }", "comment": "/**\n         * Sets this field in a copy of the LocalDate to a parsed text value.\n         * <p>\n         * The LocalDate attached to this property is unchanged by this call.\n         *\n         * @param text  the text value to set\n         * @param locale  optional locale to use for selecting a text symbol\n         * @return a copy of the LocalDate with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */"}}
{"code": {"body": "public LocalDate setCopy(String text) {\n            return setCopy(text, null);\n        }", "comment": "/**\n         * Sets this field in a copy of the LocalDate to a parsed text value.\n         * <p>\n         * The LocalDate attached to this property is unchanged by this call.\n         *\n         * @param text  the text value to set\n         * @return a copy of the LocalDate with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */"}}
{"code": {"body": "public LocalDate withMaximumValue() {\n            return setCopy(getMaximumValue());\n        }", "comment": "/**\n         * Returns a new LocalDate with this field set to the maximum value\n         * for this field.\n         * <p>\n         * This operation is useful for obtaining a LocalDate on the last day\n         * of the month, as month lengths vary.\n         * <pre>\n         * LocalDate lastDayOfMonth = dt.dayOfMonth().withMaximumValue();\n         * </pre>\n         * <p>\n         * The LocalDate attached to this property is unchanged by this call.\n         *\n         * @return a copy of the LocalDate with this field set to its maximum\n         */"}}
{"code": {"body": "public LocalDate withMinimumValue() {\n            return setCopy(getMinimumValue());\n        }", "comment": "/**\n         * Returns a new LocalDate with this field set to the minimum value\n         * for this field.\n         * <p>\n         * The LocalDate attached to this property is unchanged by this call.\n         *\n         * @return a copy of the LocalDate with this field set to its minimum\n         */"}}
{"code": {"body": "public LocalDate roundFloorCopy() {\n            return iInstant.withLocalMillis(iField.roundFloor(iInstant.getLocalMillis()));\n        }", "comment": "/**\n         * Rounds to the lowest whole unit of this field on a copy of this\n         * LocalDate.\n         * <p>\n         * For example, rounding floor on the hourOfDay field of a LocalDate\n         * where the time is 10:30 would result in new LocalDate with the\n         * time of 10:00.\n         *\n         * @return a copy of the LocalDate with the field value changed\n         */"}}
{"code": {"body": "public LocalDate roundCeilingCopy() {\n            return iInstant.withLocalMillis(iField.roundCeiling(iInstant.getLocalMillis()));\n        }", "comment": "/**\n         * Rounds to the highest whole unit of this field on a copy of this\n         * LocalDate.\n         * <p>\n         * For example, rounding floor on the hourOfDay field of a LocalDate\n         * where the time is 10:30 would result in new LocalDate with the\n         * time of 11:00.\n         *\n         * @return a copy of the LocalDate with the field value changed\n         */"}}
{"code": {"body": "public LocalDate roundHalfFloorCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfFloor(iInstant.getLocalMillis()));\n        }", "comment": "/**\n         * Rounds to the nearest whole unit of this field on a copy of this\n         * LocalDate, favoring the floor if halfway.\n         *\n         * @return a copy of the LocalDate with the field value changed\n         */"}}
{"code": {"body": "public LocalDate roundHalfCeilingCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfCeiling(iInstant.getLocalMillis()));\n        }", "comment": "/**\n         * Rounds to the nearest whole unit of this field on a copy of this\n         * LocalDate, favoring the ceiling if halfway.\n         *\n         * @return a copy of the LocalDate with the field value changed\n         */"}}
{"code": {"body": "public LocalDate roundHalfEvenCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfEven(iInstant.getLocalMillis()));\n        }", "comment": "/**\n         * Rounds to the nearest whole unit of this field on a copy of this\n         * LocalDate.  If halfway, the ceiling is favored over the floor\n         * only if it makes this field's value even.\n         *\n         * @return a copy of the LocalDate with the field value changed\n         */"}}
{"code": {"body": "    public static LocalDate now(Chronology chronology) {\n        if (chronology == null) {\n            throw new NullPointerException(\"\");\n        }\n        return new LocalDate(chronology);\n    }", "comment": "/**\n     * Obtains a {@code LocalDate} set to the current system millisecond time\n     * using the specified chronology.\n     *\n     * @param chronology  the chronology, not null\n     * @return the current date-time, not null\n     * @since 2.0\n     */"}}
{"code": {"body": "    public static LocalDate parse(String str, DateTimeFormatter formatter) {\n        return formatter.parseLocalDate(str);\n    }", "comment": "/**\n     * Parses a {@code LocalDate} from the specified string using a formatter.\n     * \n     * @param str  the string to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @since 2.0\n     */"}}
{"code": {"body": "    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        int era = calendar.get(Calendar.ERA);\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDate(\n            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }", "comment": "/**\n     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDate.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDate with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */"}}
{"code": {"body": "    private Object readResolve() {\n        if (iChronology == null) {\n            return new LocalDate(iLocalMillis, ISOChronology.getInstanceUTC());\n        }\n        if (DateTimeZone.UTC.equals(iChronology.getZone()) == false) {\n            return new LocalDate(iLocalMillis, iChronology.withUTC());\n        }\n        return this;\n    }", "comment": "/**\n     * Handle broken serialization from other tools.\n     * @return the resolved object, not null\n     */"}}
{"code": {"body": "    public int size() {\n        return 3;\n    }", "comment": "/**\n     * Gets the number of fields in this partial, which is three.\n     * The supported fields are Year, MonthOfYear and DayOfMonth.\n     * Note that all fields from day and above may in fact be queried via\n     * other methods.\n     *\n     * @return the field count, three\n     */"}}
{"code": {"body": "        public DateTimeField getField() {\n            return iField;\n        }", "comment": "/**\n         * Gets the field being used.\n         * \n         * @return the field\n         */"}}
{"code": {"body": "    public int getValue(int index) {\n        switch (index) {\n            case YEAR:\n                return getChronology().year().get(getLocalMillis());\n            case MONTH_OF_YEAR:\n                return getChronology().monthOfYear().get(getLocalMillis());\n            case DAY_OF_MONTH:\n                return getChronology().dayOfMonth().get(getLocalMillis());\n            default:\n                throw new IndexOutOfBoundsException(\"\" + index);\n        }\n    }", "comment": "/**\n     * Gets the value of the field at the specifed index.\n     * <p>\n     * This method is required to support the <code>ReadablePartial</code>\n     * interface. The supported fields are Year, MonthOfYear and DayOfMonth.\n     * Note that all fields from day and above may in fact be queried via\n     * other methods.\n     *\n     * @param index  the index, zero to two\n     * @return the value\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */"}}
{"code": {"body": "    public int get(DateTimeFieldType fieldType) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (isSupported(fieldType) == false) {\n            throw new IllegalArgumentException(\"\" + fieldType + \"\");\n        }\n        return fieldType.getField(getChronology()).get(getLocalMillis());\n    }", "comment": "/**\n     * Get the value of one of the fields of a datetime.\n     * <p>\n     * This method gets the value of the specified field.\n     * For example:\n     * <pre>\n     * LocalDate dt = LocalDate.nowDefaultZone();\n     * int year = dt.get(DateTimeFieldType.year());\n     * </pre>\n     *\n     * @param fieldType  a field type, usually obtained from DateTimeFieldType, not null\n     * @return the value of that field\n     * @throws IllegalArgumentException if the field type is null or unsupported\n     */"}}
{"code": {"body": "    public boolean isSupported(DurationFieldType type) {\n        if (type == null) {\n            return false;\n        }\n        DurationField field = type.getField(getChronology());\n        if (DATE_DURATION_TYPES.contains(type) ||\n            field.getUnitMillis() >= getChronology().days().getUnitMillis()) {\n            return field.isSupported();\n        }\n        return false;\n    }", "comment": "/**\n     * Checks if the duration type specified is supported by this\n     * local date and chronology.\n     *\n     * @param type  a duration type, usually obtained from DurationFieldType\n     * @return true if the field type is supported\n     */"}}
{"code": {"body": "    protected long getLocalMillis() {\n        return iLocalMillis;\n    }", "comment": "/**\n     * Gets the local milliseconds from the Java epoch\n     * of 1970-01-01T00:00:00 (not fixed to any specific time zone).\n     * \n     * @return the number of milliseconds since 1970-01-01T00:00:00\n     * @since 1.5 (previously private)\n     */"}}
{"code": {"body": "        protected Chronology getChronology() {\n            return iInstant.getChronology();\n        }", "comment": "/**\n         * Gets the chronology of the datetime that this property is linked to.\n         * \n         * @return the chronology\n         * @since 1.4\n         */"}}
{"code": {"body": "    public boolean equals(Object partial) {\n        \n        if (this == partial) {\n            return true;\n        }\n        if (partial instanceof LocalDate) {\n            LocalDate other = (LocalDate) partial;\n            if (iChronology.equals(other.iChronology)) {\n                return iLocalMillis == other.iLocalMillis;\n            }\n        }\n        return super.equals(partial);\n    }", "comment": "/**\n     * Compares this ReadablePartial with another returning true if the chronology,\n     * field types and values are equal.\n     *\n     * @param partial  an object to check against\n     * @return true if fields and values are equal\n     */"}}
{"code": {"body": "    public int hashCode() {\n        \n        int hash = iHash;\n        if (hash == 0) {\n            hash = iHash = super.hashCode();\n        }\n        return hash;\n    }", "comment": "/**\n     * Gets a hash code for the instant as defined in <code>ReadablePartial</code>.\n     *\n     * @return a suitable hash code\n     */"}}
{"code": {"body": "    public int compareTo(ReadablePartial partial) {\n        \n        if (this == partial) {\n            return 0;\n        }\n        if (partial instanceof LocalDate) {\n            LocalDate other = (LocalDate) partial;\n            if (iChronology.equals(other.iChronology)) {\n                return (iLocalMillis < other.iLocalMillis ? -1 :\n                            (iLocalMillis == other.iLocalMillis ? 0 : 1));\n\n            }\n        }\n        return super.compareTo(partial);\n    }", "comment": "/**\n     * Compares this partial with another returning an integer\n     * indicating the order.\n     * <p>\n     * The fields are compared in order, from largest to smallest.\n     * The first field that is non-equal is used to determine the result.\n     * <p>\n     * The specified object must be a partial instance whose field types\n     * match those of this partial.\n     *\n     * @param partial  an object to check against\n     * @return negative if this is less, zero if equal, positive if greater\n     * @throws ClassCastException if the partial is the wrong class\n     *  or if it has field types that don't match\n     * @throws NullPointerException if the partial is null\n     */"}}
{"code": {"body": "    public DateTime toDateTimeAtStartOfDay(DateTimeZone zone) {\n        zone = DateTimeUtils.getZone(zone);\n        Chronology chrono = getChronology().withZone(zone);\n        long localMillis = getLocalMillis() + 6L * DateTimeConstants.MILLIS_PER_HOUR;\n        long instant = zone.convertLocalToUTC(localMillis, false);\n        instant = chrono.dayOfMonth().roundFloor(instant);\n        return new DateTime(instant, chrono);\n    }", "comment": "/**\n     * Converts this LocalDate to a full datetime at the earliest valid time\n     * for the date using the specified time zone.\n     * <p>\n     * The time will normally be midnight, as that is the earliest time on\n     * any given day. However, in some time zones when Daylight Savings Time\n     * starts, there is no midnight because time jumps from 11:59 to 01:00.\n     * This method handles that situation by returning 01:00 on that date.\n     * <p>\n     * This method uses the chronology from this instance plus the time zone\n     * specified.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param zone  the zone to use, null means default zone\n     * @return this date as a datetime at the start of the day\n     * @since 1.5\n     */"}}
{"code": {"body": "    public DateTime toDateTimeAtCurrentTime(DateTimeZone zone) {\n        zone = DateTimeUtils.getZone(zone);\n        Chronology chrono = getChronology().withZone(zone);\n        long instantMillis = DateTimeUtils.currentTimeMillis();\n        long resolved = chrono.set(this, instantMillis);\n        return new DateTime(resolved, chrono);\n    }", "comment": "/**\n     * Converts this LocalDate to a full datetime using the specified time zone\n     * setting the date fields from this instance and the time fields from\n     * the current time.\n     * <p>\n     * This method uses the chronology from this instance plus the time zone\n     * specified.\n     * <p>\n     * This method will throw an exception if the datetime that would be\n     * created does not exist when the time zone is taken into account.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param zone  the zone to use, null means default zone\n     * @return this date as a datetime with the time as the current time\n     */"}}
{"code": {"body": "    public LocalDateTime toLocalDateTime(LocalTime time) {\n        if (time == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (getChronology() != time.getChronology()) {\n            throw new IllegalArgumentException(\"\");\n        }\n        long localMillis = getLocalMillis() + time.getLocalMillis();\n        return new LocalDateTime(localMillis, getChronology());\n    }", "comment": "/**\n     * Converts this object to a LocalDateTime using a LocalTime to fill in\n     * the missing fields.\n     * <p>\n     * The resulting chronology is determined by the chronology of this\n     * LocalDate. The chronology of the time must also match.\n     * If the time is null an exception is thrown.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param time  the time of day to use, must not be null\n     * @return the LocalDateTime instance\n     * @throws IllegalArgumentException if the time is null\n     * @throws IllegalArgumentException if the chronology of the time does not match\n     * @since 1.5\n     */"}}
{"code": {"body": "    public DateTime toDateTime(LocalTime time, DateTimeZone zone) {\n        if (time != null && getChronology() != time.getChronology()) {\n            throw new IllegalArgumentException(\"\");\n        }\n        Chronology chrono = getChronology().withZone(zone);\n        long instant = DateTimeUtils.currentTimeMillis();\n        instant = chrono.set(this, instant);\n        if (time != null) {\n            instant = chrono.set(time, instant);\n        }\n        return new DateTime(instant, chrono);\n    }", "comment": "/**\n     * Converts this object to a DateTime using a LocalTime to fill in the\n     * missing fields.\n     * <p>\n     * The resulting chronology is determined by the chronology of this\n     * LocalDate plus the time zone. The chronology of the time must match.\n     * If the time is null, the current time in the date's chronology is used.\n     * <p>\n     * This method will throw an exception if the datetime that would be\n     * created does not exist when the time zone is taken into account.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param time  the time of day to use, null means current time\n     * @param zone  the zone to get the DateTime in, null means default\n     * @return the DateTime instance\n     * @throws IllegalArgumentException if the chronology of the time does not match\n     */"}}
{"code": {"body": "    public Interval toInterval(DateTimeZone zone) {\n        zone = DateTimeUtils.getZone(zone);\n        DateTime start = toDateTimeAtStartOfDay(zone);\n        DateTime end = plusDays(1).toDateTimeAtStartOfDay(zone);\n        return new Interval(start, end);\n    }", "comment": "/**\n     * Converts this object to an Interval representing the whole day.\n     * <p>\n     * The interval may have more or less than 24 hours if this is a daylight\n     * savings cutover date.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param zone  the zone to get the Interval in, null means default\n     * @return a interval over the day\n     */"}}
{"code": {"body": "    LocalDate withLocalMillis(long newMillis) {\n        newMillis = iChronology.dayOfMonth().roundFloor(newMillis);\n        return (newMillis == getLocalMillis() ? this : new LocalDate(newMillis, getChronology()));\n    }", "comment": "/**\n     * Returns a copy of this date with different local millis.\n     * <p>\n     * The returned object will be a new instance of the same type.\n     * Only the millis will change, the chronology is kept.\n     * The returned object will be either be a new instance or <code>this</code>.\n     *\n     * @param newMillis  the new millis, from 1970-01-01T00:00:00\n     * @return a copy of this date with different millis\n     */"}}
{"code": {"body": "    public LocalDate withFields(ReadablePartial partial) {\n        if (partial == null) {\n            return this;\n        }\n        return withLocalMillis(getChronology().set(partial, getLocalMillis()));\n    }", "comment": "/**\n     * Returns a copy of this date with the partial set of fields replacing\n     * those from this instance.\n     * <p>\n     * For example, if the partial contains a year and a month then those two\n     * fields will be changed in the returned instance.\n     * Unsupported fields are ignored.\n     * If the partial is null, then <code>this</code> is returned.\n     *\n     * @param partial  the partial set of fields to apply to this date, null ignored\n     * @return a copy of this date with a different set of fields\n     * @throws IllegalArgumentException if any value is invalid\n     */"}}
{"code": {"body": "    public LocalDate withField(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (isSupported(fieldType) == false) {\n            throw new IllegalArgumentException(\"\" + fieldType + \"\");\n        }\n        long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date with the specified field set to a new value.\n     * <p>\n     * For example, if the field type is <code>monthOfYear</code> then the\n     * month of year field will be changed in the returned instance.\n     * If the field type is null, then <code>this</code> is returned.\n     * <p>\n     * These two lines are equivalent:\n     * <pre>\n     * LocalDate updated = dt.withDayOfMonth(6);\n     * LocalDate updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);\n     * </pre>\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this date with the field set\n     * @throws IllegalArgumentException if the field is null or unsupported\n     */"}}
{"code": {"body": "    public LocalDate withFieldAdded(DurationFieldType fieldType, int amount) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (isSupported(fieldType) == false) {\n            throw new IllegalArgumentException(\"\" + fieldType + \"\");\n        }\n        if (amount == 0) {\n            return this;\n        }\n        long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date with the value of the specified field increased.\n     * <p>\n     * If the addition is zero or the field is null, then <code>this</code> is returned.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * LocalDate added = dt.withFieldAdded(DurationFieldType.years(), 6);\n     * LocalDate added = dt.plusYears(6);\n     * LocalDate added = dt.plus(Period.years(6));\n     * </pre>\n     *\n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this date with the field updated\n     * @throws IllegalArgumentException if the field is null or unsupported\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */"}}
{"code": {"body": "    public LocalDate withPeriodAdded(ReadablePeriod period, int scalar) {\n        if (period == null || scalar == 0) {\n            return this;\n        }\n        long instant = getLocalMillis();\n        Chronology chrono = getChronology();\n        for (int i = 0; i < period.size(); i++) {\n            long value = FieldUtils.safeMultiply(period.getValue(i), scalar);\n            DurationFieldType type = period.getFieldType(i);\n            if (isSupported(type)) {\n                instant = type.getField(chrono).add(instant, value);\n            }\n        }\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date with the specified period added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to add multiple copies of complex\n     * period instances. Adding one field is best achieved using methods\n     * like {@link #withFieldAdded(DurationFieldType, int)}\n     * or {@link #plusYears(int)}.\n     * <p>\n     * Unsupported time fields are ignored, thus adding a period of 24 hours\n     * will not have any effect.\n     *\n     * @param period  the period to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this date with the period added\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */"}}
{"code": {"body": "    public LocalDate plus(ReadablePeriod period) {\n        return withPeriodAdded(period, 1);\n    }", "comment": "/**\n     * Returns a copy of this date with the specified period added.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to add complex period instances.\n     * Adding one field is best achieved using methods\n     * like {@link #plusYears(int)}.\n     * <p>\n     * Unsupported time fields are ignored, thus adding a period of 24 hours\n     * will not have any effect.\n     *\n     * @param period  the period to add to this one, null means zero\n     * @return a copy of this date with the period added\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */"}}
{"code": {"body": "    public LocalDate plusYears(int years) {\n        if (years == 0) {\n            return this;\n        }\n        long instant = getChronology().years().add(getLocalMillis(), years);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date plus the specified number of years.\n     * <p>\n     * This adds the specified number of years to the date.\n     * If adding years makes the day-of-month invalid, it is adjusted to the last valid day in the month.\n     * This LocalDate instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDate added = dt.plusYears(6);\n     * LocalDate added = dt.plus(Period.years(6));\n     * LocalDate added = dt.withFieldAdded(DurationFieldType.years(), 6);\n     * </pre>\n     *\n     * @param years  the amount of years to add, may be negative\n     * @return the new LocalDate plus the increased years\n     */"}}
{"code": {"body": "    public LocalDate plusMonths(int months) {\n        if (months == 0) {\n            return this;\n        }\n        long instant = getChronology().months().add(getLocalMillis(), months);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date plus the specified number of months.\n     * <p>\n     * This adds the specified number of months to the date.\n     * The addition may change the year, but the day-of-month is normally unchanged.\n     * If adding months makes the day-of-month invalid, it is adjusted to the last valid day in the month.\n     * This LocalDate instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDate added = dt.plusMonths(6);\n     * LocalDate added = dt.plus(Period.months(6));\n     * LocalDate added = dt.withFieldAdded(DurationFieldType.months(), 6);\n     * </pre>\n     *\n     * @param months  the amount of months to add, may be negative\n     * @return the new LocalDate plus the increased months\n     */"}}
{"code": {"body": "    public LocalDate plusWeeks(int weeks) {\n        if (weeks == 0) {\n            return this;\n        }\n        long instant = getChronology().weeks().add(getLocalMillis(), weeks);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date plus the specified number of weeks.\n     * <p>\n     * This LocalDate instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDate added = dt.plusWeeks(6);\n     * LocalDate added = dt.plus(Period.weeks(6));\n     * LocalDate added = dt.withFieldAdded(DurationFieldType.weeks(), 6);\n     * </pre>\n     *\n     * @param weeks  the amount of weeks to add, may be negative\n     * @return the new LocalDate plus the increased weeks\n     */"}}
{"code": {"body": "    public LocalDate plusDays(int days) {\n        if (days == 0) {\n            return this;\n        }\n        long instant = getChronology().days().add(getLocalMillis(), days);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date plus the specified number of days.\n     * <p>\n     * This LocalDate instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDate added = dt.plusDays(6);\n     * LocalDate added = dt.plus(Period.days(6));\n     * LocalDate added = dt.withFieldAdded(DurationFieldType.days(), 6);\n     * </pre>\n     *\n     * @param days  the amount of days to add, may be negative\n     * @return the new LocalDate plus the increased days\n     */"}}
{"code": {"body": "    public LocalDate minus(ReadablePeriod period) {\n        return withPeriodAdded(period, -1);\n    }", "comment": "/**\n     * Returns a copy of this date with the specified period taken away.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to subtract complex period instances.\n     * Subtracting one field is best achieved using methods\n     * like {@link #minusYears(int)}.\n     * <p>\n     * Unsupported time fields are ignored, thus subtracting a period of 24 hours\n     * will not have any effect.\n     *\n     * @param period  the period to reduce this instant by\n     * @return a copy of this LocalDate with the period taken away\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */"}}
{"code": {"body": "    public LocalDate minusYears(int years) {\n        if (years == 0) {\n            return this;\n        }\n        long instant = getChronology().years().subtract(getLocalMillis(), years);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date minus the specified number of years.\n     * <p>\n     * This subtracts the specified number of years from the date.\n     * If subtracting years makes the day-of-month invalid, it is adjusted to the last valid day in the month.\n     * This LocalDate instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDate subtracted = dt.minusYears(6);\n     * LocalDate subtracted = dt.minus(Period.years(6));\n     * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);\n     * </pre>\n     *\n     * @param years  the amount of years to subtract, may be negative\n     * @return the new LocalDate minus the increased years\n     */"}}
{"code": {"body": "    public LocalDate minusMonths(int months) {\n        if (months == 0) {\n            return this;\n        }\n        long instant = getChronology().months().subtract(getLocalMillis(), months);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date minus the specified number of months.\n     * <p>\n     * This subtracts the specified number of months from the date.\n     * The subtraction may change the year, but the day-of-month is normally unchanged.\n     * If subtracting months makes the day-of-month invalid, it is adjusted to the last valid day in the month.\n     * This LocalDate instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDate subtracted = dt.minusMonths(6);\n     * LocalDate subtracted = dt.minus(Period.months(6));\n     * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);\n     * </pre>\n     *\n     * @param months  the amount of months to subtract, may be negative\n     * @return the new LocalDate minus the increased months\n     */"}}
{"code": {"body": "    public LocalDate minusWeeks(int weeks) {\n        if (weeks == 0) {\n            return this;\n        }\n        long instant = getChronology().weeks().subtract(getLocalMillis(), weeks);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date minus the specified number of weeks.\n     * <p>\n     * This LocalDate instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDate subtracted = dt.minusWeeks(6);\n     * LocalDate subtracted = dt.minus(Period.weeks(6));\n     * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6);\n     * </pre>\n     *\n     * @param weeks  the amount of weeks to subtract, may be negative\n     * @return the new LocalDate minus the increased weeks\n     */"}}
{"code": {"body": "    public LocalDate minusDays(int days) {\n        if (days == 0) {\n            return this;\n        }\n        long instant = getChronology().days().subtract(getLocalMillis(), days);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this date minus the specified number of days.\n     * <p>\n     * This LocalDate instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDate subtracted = dt.minusDays(6);\n     * LocalDate subtracted = dt.minus(Period.days(6));\n     * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);\n     * </pre>\n     *\n     * @param days  the amount of days to subtract, may be negative\n     * @return the new LocalDate minus the increased days\n     */"}}
{"code": {"body": "    public Property property(DateTimeFieldType fieldType) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (isSupported(fieldType) == false) {\n            throw new IllegalArgumentException(\"\" + fieldType + \"\");\n        }\n        return new Property(this, fieldType.getField(getChronology()));\n    }", "comment": "/**\n     * Gets the property object for the specified type, which contains many\n     * useful methods.\n     *\n     * @param fieldType  the field type to get the chronology for\n     * @return the property object\n     * @throws IllegalArgumentException if the field is null or unsupported\n     */"}}
{"code": {"body": "    public int getEra() {\n        return getChronology().era().get(getLocalMillis());\n    }", "comment": "/**\n     * Get the era field value.\n     *\n     * @return the era\n     */"}}
{"code": {"body": "    public int getCenturyOfEra() {\n        return getChronology().centuryOfEra().get(getLocalMillis());\n    }", "comment": "/**\n     * Get the year of era field value.\n     *\n     * @return the year of era\n     */"}}
{"code": {"body": "    public int getYearOfEra() {\n        return getChronology().yearOfEra().get(getLocalMillis());\n    }", "comment": "/**\n     * Get the year of era field value.\n     *\n     * @return the year of era\n     */"}}
{"code": {"body": "    public int getYearOfCentury() {\n        return getChronology().yearOfCentury().get(getLocalMillis());\n    }", "comment": "/**\n     * Get the year of century field value.\n     *\n     * @return the year of century\n     */"}}
{"code": {"body": "    public int getYear() {\n        return getChronology().year().get(getLocalMillis());\n    }", "comment": "/**\n     * Get the year field value.\n     *\n     * @return the year\n     */"}}
{"code": {"body": "    public int getWeekyear() {\n        return getChronology().weekyear().get(getLocalMillis());\n    }", "comment": "/**\n     * Get the weekyear field value.\n     * <p>\n     * The weekyear is the year that matches with the weekOfWeekyear field.\n     * In the standard ISO8601 week algorithm, the first week of the year\n     * is that in which at least 4 days are in the year. As a result of this\n     * definition, day 1 of the first week may be in the previous year.\n     * The weekyear allows you to query the effective year for that day.\n     *\n     * @return the weekyear\n     */"}}
{"code": {"body": "    public int getMonthOfYear() {\n        return getChronology().monthOfYear().get(getLocalMillis());\n    }", "comment": "/**\n     * Get the month of year field value.\n     *\n     * @return the month of year\n     */"}}
{"code": {"body": "    public int getWeekOfWeekyear() {\n        return getChronology().weekOfWeekyear().get(getLocalMillis());\n    }", "comment": "/**\n     * Get the week of weekyear field value.\n     * <p>\n     * This field is associated with the \"weekyear\" via {@link #getWeekyear()}.\n     * In the standard ISO8601 week algorithm, the first week of the year\n     * is that in which at least 4 days are in the year. As a result of this\n     * definition, day 1 of the first week may be in the previous year.\n     *\n     * @return the week of a week based year\n     */"}}
{"code": {"body": "    public int getDayOfYear() {\n        return getChronology().dayOfYear().get(getLocalMillis());\n    }", "comment": "/**\n     * Get the day of year field value.\n     *\n     * @return the day of year\n     */"}}
{"code": {"body": "    public int getDayOfMonth() {\n        return getChronology().dayOfMonth().get(getLocalMillis());\n    }", "comment": "/**\n     * Get the day of month field value.\n     * <p>\n     * The values for the day of month are defined in {@link org.joda.time.DateTimeConstants}.\n     *\n     * @return the day of month\n     */"}}
{"code": {"body": "    public int getDayOfWeek() {\n        return getChronology().dayOfWeek().get(getLocalMillis());\n    }", "comment": "/**\n     * Get the day of week field value.\n     * <p>\n     * The values for the day of week are defined in {@link org.joda.time.DateTimeConstants}.\n     *\n     * @return the day of week\n     */"}}
{"code": {"body": "    public LocalDate withEra(int era) {\n        return withLocalMillis(getChronology().era().set(getLocalMillis(), era));\n    }", "comment": "/**\n     * Returns a copy of this date with the era field updated.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * era changed.\n     *\n     * @param era  the era to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public LocalDate withCenturyOfEra(int centuryOfEra) {\n        return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(), centuryOfEra));\n    }", "comment": "/**\n     * Returns a copy of this date with the century of era field updated.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * century of era changed.\n     *\n     * @param centuryOfEra  the centurey of era to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public LocalDate withYearOfEra(int yearOfEra) {\n        return withLocalMillis(getChronology().yearOfEra().set(getLocalMillis(), yearOfEra));\n    }", "comment": "/**\n     * Returns a copy of this date with the year of era field updated.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year of era changed.\n     *\n     * @param yearOfEra  the year of era to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public LocalDate withYearOfCentury(int yearOfCentury) {\n        return withLocalMillis(getChronology().yearOfCentury().set(getLocalMillis(), yearOfCentury));\n    }", "comment": "/**\n     * Returns a copy of this date with the year of century field updated.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year of century changed.\n     *\n     * @param yearOfCentury  the year of century to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public LocalDate withYear(int year) {\n        return withLocalMillis(getChronology().year().set(getLocalMillis(), year));\n    }", "comment": "/**\n     * Returns a copy of this date with the year field updated.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year changed.\n     *\n     * @param year  the year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public LocalDate withWeekyear(int weekyear) {\n        return withLocalMillis(getChronology().weekyear().set(getLocalMillis(), weekyear));\n    }", "comment": "/**\n     * Returns a copy of this date with the weekyear field updated.\n     * <p>\n     * The weekyear is the year that matches with the weekOfWeekyear field.\n     * In the standard ISO8601 week algorithm, the first week of the year\n     * is that in which at least 4 days are in the year. As a result of this\n     * definition, day 1 of the first week may be in the previous year.\n     * The weekyear allows you to query the effective year for that day.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * weekyear changed.\n     *\n     * @param weekyear  the weekyear to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public LocalDate withMonthOfYear(int monthOfYear) {\n        return withLocalMillis(getChronology().monthOfYear().set(getLocalMillis(), monthOfYear));\n    }", "comment": "/**\n     * Returns a copy of this date with the month of year field updated.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * month of year changed.\n     *\n     * @param monthOfYear  the month of year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public LocalDate withWeekOfWeekyear(int weekOfWeekyear) {\n        return withLocalMillis(getChronology().weekOfWeekyear().set(getLocalMillis(), weekOfWeekyear));\n    }", "comment": "/**\n     * Returns a copy of this date with the week of weekyear field updated.\n     * <p>\n     * This field is associated with the \"weekyear\" via {@link #withWeekyear(int)}.\n     * In the standard ISO8601 week algorithm, the first week of the year\n     * is that in which at least 4 days are in the year. As a result of this\n     * definition, day 1 of the first week may be in the previous year.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * week of weekyear changed.\n     *\n     * @param weekOfWeekyear  the week of weekyear to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public LocalDate withDayOfYear(int dayOfYear) {\n        return withLocalMillis(getChronology().dayOfYear().set(getLocalMillis(), dayOfYear));\n    }", "comment": "/**\n     * Returns a copy of this date with the day of year field updated.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of year changed.\n     *\n     * @param dayOfYear  the day of year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public LocalDate withDayOfMonth(int dayOfMonth) {\n        return withLocalMillis(getChronology().dayOfMonth().set(getLocalMillis(), dayOfMonth));\n    }", "comment": "/**\n     * Returns a copy of this date with the day of month field updated.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of month changed.\n     *\n     * @param dayOfMonth  the day of month to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public LocalDate withDayOfWeek(int dayOfWeek) {\n        return withLocalMillis(getChronology().dayOfWeek().set(getLocalMillis(), dayOfWeek));\n    }", "comment": "/**\n     * Returns a copy of this date with the day of week field updated.\n     * <p>\n     * LocalDate is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of week changed.\n     *\n     * @param dayOfWeek  the day of week to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public Property era() {\n        return new Property(this, getChronology().era());\n    }", "comment": "/**\n     * Get the era property which provides access to advanced functionality.\n     *\n     * @return the era property\n     */"}}
{"code": {"body": "    public Property centuryOfEra() {\n        return new Property(this, getChronology().centuryOfEra());\n    }", "comment": "/**\n     * Get the century of era property which provides access to advanced functionality.\n     *\n     * @return the year of era property\n     */"}}
{"code": {"body": "    public Property yearOfCentury() {\n        return new Property(this, getChronology().yearOfCentury());\n    }", "comment": "/**\n     * Get the year of century property which provides access to advanced functionality.\n     *\n     * @return the year of era property\n     */"}}
{"code": {"body": "    public Property yearOfEra() {\n        return new Property(this, getChronology().yearOfEra());\n    }", "comment": "/**\n     * Get the year of era property which provides access to advanced functionality.\n     *\n     * @return the year of era property\n     */"}}
{"code": {"body": "    public Property year() {\n        return new Property(this, getChronology().year());\n    }", "comment": "/**\n     * Get the year property which provides access to advanced functionality.\n     *\n     * @return the year property\n     */"}}
{"code": {"body": "    public Property weekyear() {\n        return new Property(this, getChronology().weekyear());\n    }", "comment": "/**\n     * Get the weekyear property which provides access to advanced functionality.\n     *\n     * @return the weekyear property\n     */"}}
{"code": {"body": "    public Property monthOfYear() {\n        return new Property(this, getChronology().monthOfYear());\n    }", "comment": "/**\n     * Get the month of year property which provides access to advanced functionality.\n     *\n     * @return the month of year property\n     */"}}
{"code": {"body": "    public Property weekOfWeekyear() {\n        return new Property(this, getChronology().weekOfWeekyear());\n    }", "comment": "/**\n     * Get the week of a week based year property which provides access to advanced functionality.\n     *\n     * @return the week of a week based year property\n     */"}}
{"code": {"body": "    public Property dayOfYear() {\n        return new Property(this, getChronology().dayOfYear());\n    }", "comment": "/**\n     * Get the day of year property which provides access to advanced functionality.\n     *\n     * @return the day of year property\n     */"}}
{"code": {"body": "    public Property dayOfMonth() {\n        return new Property(this, getChronology().dayOfMonth());\n    }", "comment": "/**\n     * Get the day of month property which provides access to advanced functionality.\n     *\n     * @return the day of month property\n     */"}}
{"code": {"body": "    public Property dayOfWeek() {\n        return new Property(this, getChronology().dayOfWeek());\n    }", "comment": "/**\n     * Get the day of week property which provides access to advanced functionality.\n     *\n     * @return the day of week property\n     */"}}
{"code": {"body": "    public String toString(String pattern, Locale locale) throws IllegalArgumentException {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n    }", "comment": "/**\n     * Output the date using the specified format pattern.\n     *\n     * @param pattern  the pattern specification, null means use <code>toString</code>\n     * @param locale  Locale to use, null means default\n     * @see org.joda.time.format.DateTimeFormat\n     */"}}
{"code": {"body": "        private void writeObject(ObjectOutputStream oos) throws IOException {\n            oos.writeObject(iInstant);\n            oos.writeObject(iField.getType());\n        }", "comment": "/**\n         * Writes the property in a safe serialization format.\n         */"}}
{"code": {"body": "        private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {\n            iInstant = (LocalDate) oos.readObject();\n            DateTimeFieldType type = (DateTimeFieldType) oos.readObject();\n            iField = type.getField(iInstant.getChronology());\n        }", "comment": "/**\n         * Reads the property from a safe serialization format.\n         */"}}
{"code": {"body": "        protected long getMillis() {\n            return iInstant.getLocalMillis();\n        }", "comment": "/**\n         * Gets the milliseconds of the date that this property is linked to.\n         * \n         * @return the milliseconds\n         */"}}
{"code": {"body": "        public LocalDate getLocalDate() {\n            return iInstant;\n        }", "comment": "/**\n         * Gets the LocalDate object linked to this property.\n         * \n         * @return the linked LocalDate\n         */"}}
{"code": {"body": "        public LocalDate addToCopy(int value) {\n            return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value));\n        }", "comment": "/**\n         * Adds to this field in a copy of this LocalDate.\n         * <p>\n         * The LocalDate attached to this property is unchanged by this call.\n         *\n         * @param value  the value to add to the field in the copy\n         * @return a copy of the LocalDate with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "        public LocalDate addWrapFieldToCopy(int value) {\n            return iInstant.withLocalMillis(iField.addWrapField(iInstant.getLocalMillis(), value));\n        }", "comment": "/**\n         * Adds to this field, possibly wrapped, in a copy of this LocalDate.\n         * A field wrapped operation only changes this field.\n         * Thus 31st January addWrapField one day goes to the 1st January.\n         * <p>\n         * The LocalDate attached to this property is unchanged by this call.\n         *\n         * @param value  the value to add to the field in the copy\n         * @return a copy of the LocalDate with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "        public LocalDate setCopy(String text) {\n            return setCopy(text, null);\n        }", "comment": "/**\n         * Sets this field in a copy of the LocalDate to a parsed text value.\n         * <p>\n         * The LocalDate attached to this property is unchanged by this call.\n         *\n         * @param text  the text value to set\n         * @return a copy of the LocalDate with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */"}}
{"code": {"body": "        public LocalDate withMaximumValue() {\n            return setCopy(getMaximumValue());\n        }", "comment": "/**\n         * Returns a new LocalDate with this field set to the maximum value\n         * for this field.\n         * <p>\n         * This operation is useful for obtaining a LocalDate on the last day\n         * of the month, as month lengths vary.\n         * <pre>\n         * LocalDate lastDayOfMonth = dt.dayOfMonth().withMaximumValue();\n         * </pre>\n         * <p>\n         * The LocalDate attached to this property is unchanged by this call.\n         *\n         * @return a copy of the LocalDate with this field set to its maximum\n         */"}}
{"code": {"body": "        public LocalDate withMinimumValue() {\n            return setCopy(getMinimumValue());\n        }", "comment": "/**\n         * Returns a new LocalDate with this field set to the minimum value\n         * for this field.\n         * <p>\n         * The LocalDate attached to this property is unchanged by this call.\n         *\n         * @return a copy of the LocalDate with this field set to its minimum\n         */"}}
{"code": {"body": "        public LocalDate roundFloorCopy() {\n            return iInstant.withLocalMillis(iField.roundFloor(iInstant.getLocalMillis()));\n        }", "comment": "/**\n         * Rounds to the lowest whole unit of this field on a copy of this\n         * LocalDate.\n         * <p>\n         * For example, rounding floor on the hourOfDay field of a LocalDate\n         * where the time is 10:30 would result in new LocalDate with the\n         * time of 10:00.\n         *\n         * @return a copy of the LocalDate with the field value changed\n         */"}}
{"code": {"body": "        public LocalDate roundCeilingCopy() {\n            return iInstant.withLocalMillis(iField.roundCeiling(iInstant.getLocalMillis()));\n        }", "comment": "/**\n         * Rounds to the highest whole unit of this field on a copy of this\n         * LocalDate.\n         * <p>\n         * For example, rounding floor on the hourOfDay field of a LocalDate\n         * where the time is 10:30 would result in new LocalDate with the\n         * time of 11:00.\n         *\n         * @return a copy of the LocalDate with the field value changed\n         */"}}
{"code": {"body": "        public LocalDate roundHalfFloorCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfFloor(iInstant.getLocalMillis()));\n        }", "comment": "/**\n         * Rounds to the nearest whole unit of this field on a copy of this\n         * LocalDate, favoring the floor if halfway.\n         *\n         * @return a copy of the LocalDate with the field value changed\n         */"}}
{"code": {"body": "        public LocalDate roundHalfCeilingCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfCeiling(iInstant.getLocalMillis()));\n        }", "comment": "/**\n         * Rounds to the nearest whole unit of this field on a copy of this\n         * LocalDate, favoring the ceiling if halfway.\n         *\n         * @return a copy of the LocalDate with the field value changed\n         */"}}
{"code": {"body": "        public LocalDate roundHalfEvenCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfEven(iInstant.getLocalMillis()));\n        }", "comment": "/**\n         * Rounds to the nearest whole unit of this field on a copy of this\n         * LocalDate.  If halfway, the ceiling is favored over the floor\n         * only if it makes this field's value even.\n         *\n         * @return a copy of the LocalDate with the field value changed\n         */"}}
{"code": {"body": "public LocalDateTime() {\n        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance());\n    }", "comment": "/**\n     * Constructs an instance set to the current local time evaluated using\n     * ISO chronology in the default zone.\n     * <p>\n     * Once the constructor is completed, the zone is no longer used.\n     * \n     * @see #now()\n     */"}}
{"code": {"body": "public LocalDateTime(DateTimeZone zone) {\n        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone));\n    }", "comment": "/**\n     * Constructs an instance set to the current local time evaluated using\n     * ISO chronology in the specified zone.\n     * <p>\n     * If the specified time zone is null, the default zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     *\n     * @param zone  the time zone, null means default zone\n     * @see #now(DateTimeZone)\n     */"}}
{"code": {"body": "public LocalDateTime(Chronology chronology) {\n        this(DateTimeUtils.currentTimeMillis(), chronology);\n    }", "comment": "/**\n     * Constructs an instance set to the current local time evaluated using\n     * specified chronology.\n     * <p>\n     * If the chronology is null, ISO chronology in the default time zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     *\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     * @see #now(Chronology)\n     */"}}
{"code": {"body": "public LocalDateTime(long instant) {\n        this(instant, ISOChronology.getInstance());\n    }", "comment": "/**\n     * Constructs an instance set to the local time defined by the specified\n     * instant evaluated using ISO chronology in the default zone.\n     * <p>\n     * Once the constructor is completed, the zone is no longer used.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     */"}}
{"code": {"body": "public LocalDateTime(long instant, DateTimeZone zone) {\n        this(instant, ISOChronology.getInstance(zone));\n    }", "comment": "/**\n     * Constructs an instance set to the local time defined by the specified\n     * instant evaluated using ISO chronology in the specified zone.\n     * <p>\n     * If the specified time zone is null, the default zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     * @param zone  the time zone, null means default zone\n     */"}}
{"code": {"body": "public LocalDateTime(long instant, Chronology chronology) {\n        chronology = DateTimeUtils.getChronology(chronology);\n        \n        long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);\n        iLocalMillis = localMillis;\n        iChronology = chronology.withUTC();\n    }", "comment": "/**\n     * Constructs an instance set to the local time defined by the specified\n     * instant evaluated using the specified chronology.\n     * <p>\n     * If the chronology is null, ISO chronology in the default zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     */"}}
{"code": {"body": "public LocalDateTime(Object instant) {\n        this(instant, (Chronology) null);\n    }", "comment": "/**\n     * Constructs an instance from an Object that represents a datetime.\n     * <p>\n     * If the object contains no chronology, <code>ISOChronology</code> is used.\n     * If the object contains no time zone, the default zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n     * The String formats are described by {@link ISODateTimeFormat#localDateOptionalTimeParser()}.\n     * The default String converter ignores the zone and only parses the field values.\n     *\n     * @param instant  the datetime object\n     * @throws IllegalArgumentException if the instant is invalid\n     */"}}
{"code": {"body": "public LocalDateTime(Object instant, DateTimeZone zone) {\n        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);\n        Chronology chronology = converter.getChronology(instant, zone);\n        chronology = DateTimeUtils.getChronology(chronology);\n        iChronology = chronology.withUTC();\n        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateOptionalTimeParser());\n        iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], values[3]);\n    }", "comment": "/**\n     * Constructs an instance from an Object that represents a datetime,\n     * forcing the time zone to that specified.\n     * <p>\n     * If the object contains no chronology, <code>ISOChronology</code> is used.\n     * If the specified time zone is null, the default zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n     * The String formats are described by {@link ISODateTimeFormat#localDateOptionalTimeParser()}.\n     * The default String converter ignores the zone and only parses the field values.\n     *\n     * @param instant  the datetime object\n     * @param zone  the time zone\n     * @throws IllegalArgumentException if the instant is invalid\n     */"}}
{"code": {"body": "public LocalDateTime(Object instant, Chronology chronology) {\n        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);\n        chronology = converter.getChronology(instant, chronology);\n        chronology = DateTimeUtils.getChronology(chronology);\n        iChronology = chronology.withUTC();\n        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateOptionalTimeParser());\n        iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], values[3]);\n    }", "comment": "/**\n     * Constructs an instance from an Object that represents a datetime,\n     * using the specified chronology.\n     * <p>\n     * If the chronology is null, ISO in the default time zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     * If the instant contains a chronology, it will be ignored.\n     * For example, passing a {@code LocalDate} and a different chronology\n     * will return a date with the year/month/day from the date applied\n     * unaltered to the specified chronology.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n     * The String formats are described by {@link ISODateTimeFormat#localDateOptionalTimeParser()}.\n     * The default String converter ignores the zone and only parses the field values.\n     *\n     * @param instant  the datetime object\n     * @param chronology  the chronology\n     * @throws IllegalArgumentException if the instant is invalid\n     */"}}
{"code": {"body": "public LocalDateTime withDate(int year, int monthOfYear, int dayOfMonth) {\n        Chronology chrono = getChronology();\n        long instant = getLocalMillis();\n        instant = chrono.year().set(instant, year);\n        instant = chrono.monthOfYear().set(instant, monthOfYear);\n        instant = chrono.dayOfMonth().set(instant, dayOfMonth);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the specified date,\n     * retaining the time fields.\n     * <p>\n     * If the date is already the date passed in, then <code>this</code> is returned.\n     * <p>\n     * To set a single field use the properties, for example:\n     * <pre>\n     * DateTime set = dt.monthOfYear().setCopy(6);\n     * </pre>\n     *\n     * @param year  the new year value\n     * @param monthOfYear  the new monthOfYear value\n     * @param dayOfMonth  the new dayOfMonth value\n     * @return a copy of this datetime with a different date\n     * @throws IllegalArgumentException if any value if invalid\n     */"}}
{"code": {"body": "public LocalDateTime withTime(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) {\n        Chronology chrono = getChronology();\n        long instant = getLocalMillis();\n        instant = chrono.hourOfDay().set(instant, hourOfDay);\n        instant = chrono.minuteOfHour().set(instant, minuteOfHour);\n        instant = chrono.secondOfMinute().set(instant, secondOfMinute);\n        instant = chrono.millisOfSecond().set(instant, millisOfSecond);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the specified time,\n     * retaining the date fields.\n     * <p>\n     * If the time is already the time passed in, then <code>this</code> is returned.\n     * <p>\n     * To set a single field use the properties, for example:\n     * <pre>\n     * LocalDateTime set = dt.hourOfDay().setCopy(6);\n     * </pre>\n     *\n     * @param hourOfDay  the hour of the day\n     * @param minuteOfHour  the minute of the hour\n     * @param secondOfMinute  the second of the minute\n     * @param millisOfSecond  the millisecond of the second\n     * @return a copy of this datetime with a different time\n     * @throws IllegalArgumentException if any value if invalid\n     */"}}
{"code": {"body": "public LocalDateTime withFields(ReadablePartial partial) {\n        if (partial == null) {\n            return this;\n        }\n        return withLocalMillis(getChronology().set(partial, getLocalMillis()));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the partial set of fields\n     * replacing those from this instance.\n     * <p>\n     * For example, if the partial is a <code>TimeOfDay</code> then the time fields\n     * would be changed in the returned instance.\n     * If the partial is null, then <code>this</code> is returned.\n     *\n     * @param partial  the partial set of fields to apply to this datetime, null ignored\n     * @return a copy of this datetime with a different set of fields\n     * @throws IllegalArgumentException if any value is invalid\n     */"}}
{"code": {"body": "public LocalDateTime withField(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the specified field set to a new value.\n     * <p>\n     * For example, if the field type is <code>hourOfDay</code> then the hour of day\n     * field would be changed in the returned instance.\n     * If the field type is null, then <code>this</code> is returned.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * LocalDateTime updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);\n     * LocalDateTime updated = dt.dayOfMonth().setCopy(6);\n     * LocalDateTime updated = dt.property(DateTimeFieldType.dayOfMonth()).setCopy(6);\n     * </pre>\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this datetime with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     */"}}
{"code": {"body": "public LocalDateTime withFieldAdded(DurationFieldType fieldType, int amount) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (amount == 0) {\n            return this;\n        }\n        long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the value of the specified\n     * field increased.\n     * <p>\n     * If the addition is zero or the field is null, then <code>this</code> is returned.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.years(), 6);\n     * LocalDateTime added = dt.plusYears(6);\n     * LocalDateTime added = dt.plus(Period.years(6));\n     * </pre>\n     *\n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this datetime with the field updated\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */"}}
{"code": {"body": "public LocalDateTime withDurationAdded(ReadableDuration durationToAdd, int scalar) {\n        if (durationToAdd == null || scalar == 0) {\n            return this;\n        }\n        long instant = getChronology().add(getLocalMillis(), durationToAdd.getMillis(), scalar);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the specified duration added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     *\n     * @param durationToAdd  the duration to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this datetime with the duration added\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */"}}
{"code": {"body": "public LocalDateTime withPeriodAdded(ReadablePeriod period, int scalar) {\n        if (period == null || scalar == 0) {\n            return this;\n        }\n        long instant = getChronology().add(period, getLocalMillis(), scalar);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the specified period added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to add multiple copies of complex\n     * period instances. Adding one field is best achieved using methods\n     * like {@link #withFieldAdded(DurationFieldType, int)}\n     * or {@link #plusYears(int)}.\n     *\n     * @param period  the period to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this datetime with the period added\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */"}}
{"code": {"body": "public LocalDateTime plus(ReadableDuration duration) {\n        return withDurationAdded(duration, 1);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the specified duration added.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     *\n     * @param duration  the duration to add to this one, null means zero\n     * @return a copy of this datetime with the duration added\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */"}}
{"code": {"body": "public LocalDateTime plus(ReadablePeriod period) {\n        return withPeriodAdded(period, 1);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the specified period added.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to add complex period instances.\n     * Adding one field is best achieved using methods\n     * like {@link #plusYears(int)}.\n     *\n     * @param period  the period to add to this one, null means zero\n     * @return a copy of this datetime with the period added\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */"}}
{"code": {"body": "public LocalDateTime plusYears(int years) {\n        if (years == 0) {\n            return this;\n        }\n        long instant = getChronology().years().add(getLocalMillis(), years);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime plus the specified number of years.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime added = dt.plusYears(6);\n     * LocalDateTime added = dt.plus(Period.years(6));\n     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.years(), 6);\n     * </pre>\n     *\n     * @param years  the amount of years to add, may be negative\n     * @return the new LocalDateTime plus the increased years\n     */"}}
{"code": {"body": "public LocalDateTime plusMonths(int months) {\n        if (months == 0) {\n            return this;\n        }\n        long instant = getChronology().months().add(getLocalMillis(), months);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime plus the specified number of months.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime added = dt.plusMonths(6);\n     * LocalDateTime added = dt.plus(Period.months(6));\n     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.months(), 6);\n     * </pre>\n     *\n     * @param months  the amount of months to add, may be negative\n     * @return the new LocalDateTime plus the increased months\n     */"}}
{"code": {"body": "public LocalDateTime plusWeeks(int weeks) {\n        if (weeks == 0) {\n            return this;\n        }\n        long instant = getChronology().weeks().add(getLocalMillis(), weeks);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime plus the specified number of weeks.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime added = dt.plusWeeks(6);\n     * LocalDateTime added = dt.plus(Period.weeks(6));\n     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.weeks(), 6);\n     * </pre>\n     *\n     * @param weeks  the amount of weeks to add, may be negative\n     * @return the new LocalDateTime plus the increased weeks\n     */"}}
{"code": {"body": "public LocalDateTime plusDays(int days) {\n        if (days == 0) {\n            return this;\n        }\n        long instant = getChronology().days().add(getLocalMillis(), days);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime plus the specified number of days.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime added = dt.plusDays(6);\n     * LocalDateTime added = dt.plus(Period.days(6));\n     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.days(), 6);\n     * </pre>\n     *\n     * @param days  the amount of days to add, may be negative\n     * @return the new LocalDateTime plus the increased days\n     */"}}
{"code": {"body": "public LocalDateTime plusHours(int hours) {\n        if (hours == 0) {\n            return this;\n        }\n        long instant = getChronology().hours().add(getLocalMillis(), hours);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime plus the specified number of hours.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime added = dt.plusHours(6);\n     * LocalDateTime added = dt.plus(Period.hours(6));\n     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.hours(), 6);\n     * </pre>\n     *\n     * @param hours  the amount of hours to add, may be negative\n     * @return the new LocalDateTime plus the increased hours\n     */"}}
{"code": {"body": "public LocalDateTime plusMinutes(int minutes) {\n        if (minutes == 0) {\n            return this;\n        }\n        long instant = getChronology().minutes().add(getLocalMillis(), minutes);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime plus the specified number of minutes.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime added = dt.plusMinutes(6);\n     * LocalDateTime added = dt.plus(Period.minutes(6));\n     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.minutes(), 6);\n     * </pre>\n     *\n     * @param minutes  the amount of minutes to add, may be negative\n     * @return the new LocalDateTime plus the increased minutes\n     */"}}
{"code": {"body": "public LocalDateTime plusSeconds(int seconds) {\n        if (seconds == 0) {\n            return this;\n        }\n        long instant = getChronology().seconds().add(getLocalMillis(), seconds);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime plus the specified number of seconds.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime added = dt.plusSeconds(6);\n     * LocalDateTime added = dt.plus(Period.seconds(6));\n     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.seconds(), 6);\n     * </pre>\n     *\n     * @param seconds  the amount of seconds to add, may be negative\n     * @return the new LocalDateTime plus the increased seconds\n     */"}}
{"code": {"body": "public LocalDateTime plusMillis(int millis) {\n        if (millis == 0) {\n            return this;\n        }\n        long instant = getChronology().millis().add(getLocalMillis(), millis);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime plus the specified number of millis.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime added = dt.plusMillis(6);\n     * LocalDateTime added = dt.plus(Period.millis(6));\n     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.millis(), 6);\n     * </pre>\n     *\n     * @param millis  the amount of millis to add, may be negative\n     * @return the new LocalDateTime plus the increased millis\n     */"}}
{"code": {"body": "public LocalDateTime minus(ReadableDuration duration) {\n        return withDurationAdded(duration, -1);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the specified duration taken away.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     *\n     * @param duration  the duration to reduce this instant by\n     * @return a copy of this datetime with the duration taken away\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */"}}
{"code": {"body": "public LocalDateTime minus(ReadablePeriod period) {\n        return withPeriodAdded(period, -1);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the specified period taken away.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to subtract complex period instances.\n     * Subtracting one field is best achieved using methods\n     * like {@link #minusYears(int)}.\n     *\n     * @param period  the period to reduce this instant by\n     * @return a copy of this datetime with the period taken away\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */"}}
{"code": {"body": "public LocalDateTime minusYears(int years) {\n        if (years == 0) {\n            return this;\n        }\n        long instant = getChronology().years().subtract(getLocalMillis(), years);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime minus the specified number of years.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime subtracted = dt.minusYears(6);\n     * LocalDateTime subtracted = dt.minus(Period.years(6));\n     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);\n     * </pre>\n     *\n     * @param years  the amount of years to subtract, may be negative\n     * @return the new LocalDateTime minus the increased years\n     */"}}
{"code": {"body": "public LocalDateTime minusMonths(int months) {\n        if (months == 0) {\n            return this;\n        }\n        long instant = getChronology().months().subtract(getLocalMillis(), months);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime minus the specified number of months.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime subtracted = dt.minusMonths(6);\n     * LocalDateTime subtracted = dt.minus(Period.months(6));\n     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);\n     * </pre>\n     *\n     * @param months  the amount of months to subtract, may be negative\n     * @return the new LocalDateTime minus the increased months\n     */"}}
{"code": {"body": "public LocalDateTime minusWeeks(int weeks) {\n        if (weeks == 0) {\n            return this;\n        }\n        long instant = getChronology().weeks().subtract(getLocalMillis(), weeks);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime minus the specified number of weeks.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime subtracted = dt.minusWeeks(6);\n     * LocalDateTime subtracted = dt.minus(Period.weeks(6));\n     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6);\n     * </pre>\n     *\n     * @param weeks  the amount of weeks to subtract, may be negative\n     * @return the new LocalDateTime minus the increased weeks\n     */"}}
{"code": {"body": "public LocalDateTime minusDays(int days) {\n        if (days == 0) {\n            return this;\n        }\n        long instant = getChronology().days().subtract(getLocalMillis(), days);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime minus the specified number of days.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime subtracted = dt.minusDays(6);\n     * LocalDateTime subtracted = dt.minus(Period.days(6));\n     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);\n     * </pre>\n     *\n     * @param days  the amount of days to subtract, may be negative\n     * @return the new LocalDateTime minus the increased days\n     */"}}
{"code": {"body": "public LocalDateTime minusHours(int hours) {\n        if (hours == 0) {\n            return this;\n        }\n        long instant = getChronology().hours().subtract(getLocalMillis(), hours);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime minus the specified number of hours.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime subtracted = dt.minusHours(6);\n     * LocalDateTime subtracted = dt.minus(Period.hours(6));\n     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.hours(), -6);\n     * </pre>\n     *\n     * @param hours  the amount of hours to subtract, may be negative\n     * @return the new LocalDateTime minus the increased hours\n     */"}}
{"code": {"body": "public LocalDateTime minusMinutes(int minutes) {\n        if (minutes == 0) {\n            return this;\n        }\n        long instant = getChronology().minutes().subtract(getLocalMillis(), minutes);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime minus the specified number of minutes.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime subtracted = dt.minusMinutes(6);\n     * LocalDateTime subtracted = dt.minus(Period.minutes(6));\n     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.minutes(), -6);\n     * </pre>\n     *\n     * @param minutes  the amount of minutes to subtract, may be negative\n     * @return the new LocalDateTime minus the increased minutes\n     */"}}
{"code": {"body": "public LocalDateTime minusSeconds(int seconds) {\n        if (seconds == 0) {\n            return this;\n        }\n        long instant = getChronology().seconds().subtract(getLocalMillis(), seconds);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime minus the specified number of seconds.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime subtracted = dt.minusSeconds(6);\n     * LocalDateTime subtracted = dt.minus(Period.seconds(6));\n     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.seconds(), -6);\n     * </pre>\n     *\n     * @param seconds  the amount of seconds to subtract, may be negative\n     * @return the new LocalDateTime minus the increased seconds\n     */"}}
{"code": {"body": "public LocalDateTime minusMillis(int millis) {\n        if (millis == 0) {\n            return this;\n        }\n        long instant = getChronology().millis().subtract(getLocalMillis(), millis);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime minus the specified number of millis.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime subtracted = dt.minusMillis(6);\n     * LocalDateTime subtracted = dt.minus(Period.millis(6));\n     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.millis(), -6);\n     * </pre>\n     *\n     * @param millis  the amount of millis to subtract, may be negative\n     * @return the new LocalDateTime minus the increased millis\n     */"}}
{"code": {"body": "public LocalDateTime withEra(int era) {\n        return withLocalMillis(getChronology().era().set(getLocalMillis(), era));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the era field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * era changed.\n     *\n     * @param era  the era to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "public LocalDateTime withCenturyOfEra(int centuryOfEra) {\n        return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(), centuryOfEra));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the century of era field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * century of era changed.\n     *\n     * @param centuryOfEra  the centurey of era to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "public LocalDateTime withYearOfEra(int yearOfEra) {\n        return withLocalMillis(getChronology().yearOfEra().set(getLocalMillis(), yearOfEra));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the year of era field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year of era changed.\n     *\n     * @param yearOfEra  the year of era to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "public LocalDateTime withYearOfCentury(int yearOfCentury) {\n        return withLocalMillis(getChronology().yearOfCentury().set(getLocalMillis(), yearOfCentury));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the year of century field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year of century changed.\n     *\n     * @param yearOfCentury  the year of century to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "public LocalDateTime withYear(int year) {\n        return withLocalMillis(getChronology().year().set(getLocalMillis(), year));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the year field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year changed.\n     *\n     * @param year  the year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "public LocalDateTime withWeekyear(int weekyear) {\n        return withLocalMillis(getChronology().weekyear().set(getLocalMillis(), weekyear));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the weekyear field updated.\n     * <p>\n     * The weekyear is the year that matches with the weekOfWeekyear field.\n     * In the standard ISO8601 week algorithm, the first week of the year\n     * is that in which at least 4 days are in the year. As a result of this\n     * definition, day 1 of the first week may be in the previous year.\n     * The weekyear allows you to query the effective year for that day.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * weekyear changed.\n     *\n     * @param weekyear  the weekyear to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "public LocalDateTime withMonthOfYear(int monthOfYear) {\n        return withLocalMillis(getChronology().monthOfYear().set(getLocalMillis(), monthOfYear));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the month of year field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * month of year changed.\n     *\n     * @param monthOfYear  the month of year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "public LocalDateTime withWeekOfWeekyear(int weekOfWeekyear) {\n        return withLocalMillis(getChronology().weekOfWeekyear().set(getLocalMillis(), weekOfWeekyear));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the week of weekyear field updated.\n     * <p>\n     * This field is associated with the \"weekyear\" via {@link #withWeekyear(int)}.\n     * In the standard ISO8601 week algorithm, the first week of the year\n     * is that in which at least 4 days are in the year. As a result of this\n     * definition, day 1 of the first week may be in the previous year.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * week of weekyear changed.\n     *\n     * @param weekOfWeekyear  the week of weekyear to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "public LocalDateTime withDayOfYear(int dayOfYear) {\n        return withLocalMillis(getChronology().dayOfYear().set(getLocalMillis(), dayOfYear));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the day of year field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of year changed.\n     *\n     * @param dayOfYear  the day of year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "public LocalDateTime withDayOfMonth(int dayOfMonth) {\n        return withLocalMillis(getChronology().dayOfMonth().set(getLocalMillis(), dayOfMonth));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the day of month field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of month changed.\n     *\n     * @param dayOfMonth  the day of month to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "public LocalDateTime withDayOfWeek(int dayOfWeek) {\n        return withLocalMillis(getChronology().dayOfWeek().set(getLocalMillis(), dayOfWeek));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the day of week field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of week changed.\n     *\n     * @param dayOfWeek  the day of week to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "public LocalDateTime withHourOfDay(int hour) {\n        return withLocalMillis(getChronology().hourOfDay().set(getLocalMillis(), hour));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the hour of day field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * hour of day changed.\n     *\n     * @param hour  the hour of day to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "public LocalDateTime withMinuteOfHour(int minute) {\n        return withLocalMillis(getChronology().minuteOfHour().set(getLocalMillis(), minute));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the minute of hour field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * minute of hour changed.\n     *\n     * @param minute  the minute of hour to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "public LocalDateTime withSecondOfMinute(int second) {\n        return withLocalMillis(getChronology().secondOfMinute().set(getLocalMillis(), second));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the second of minute field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * second of minute changed.\n     *\n     * @param second  the second of minute to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "public LocalDateTime withMillisOfSecond(int millis) {\n        return withLocalMillis(getChronology().millisOfSecond().set(getLocalMillis(), millis));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the millis of second field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * millis of second changed.\n     *\n     * @param millis  the millis of second to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "public LocalDateTime withMillisOfDay(int millis) {\n        return withLocalMillis(getChronology().millisOfDay().set(getLocalMillis(), millis));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the millis of day field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * millis of day changed.\n     *\n     * @param millis  the millis of day to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "public LocalDateTime getLocalDateTime() {\n            return iInstant;\n        }", "comment": "/**\n         * Gets the LocalDateTime object linked to this property.\n         * \n         * @return the linked LocalDateTime\n         */"}}
{"code": {"body": "public LocalDateTime addToCopy(int value) {\n            return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value));\n        }", "comment": "/**\n         * Adds to this field in a copy of this LocalDateTime.\n         * <p>\n         * The LocalDateTime attached to this property is unchanged by this call.\n         *\n         * @param value  the value to add to the field in the copy\n         * @return a copy of the LocalDateTime with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "public LocalDateTime addToCopy(long value) {\n            return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value));\n        }", "comment": "/**\n         * Adds to this field in a copy of this LocalDateTime.\n         * <p>\n         * The LocalDateTime attached to this property is unchanged by this call.\n         *\n         * @param value  the value to add to the field in the copy\n         * @return a copy of the LocalDateTime with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "public LocalDateTime addWrapFieldToCopy(int value) {\n            return iInstant.withLocalMillis(iField.addWrapField(iInstant.getLocalMillis(), value));\n        }", "comment": "/**\n         * Adds to this field, possibly wrapped, in a copy of this LocalDateTime.\n         * A field wrapped operation only changes this field.\n         * Thus 31st January addWrapField one day goes to the 1st January.\n         * <p>\n         * The LocalDateTime attached to this property is unchanged by this call.\n         *\n         * @param value  the value to add to the field in the copy\n         * @return a copy of the LocalDateTime with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "public LocalDateTime setCopy(int value) {\n            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), value));\n        }", "comment": "/**\n         * Sets this field in a copy of the LocalDateTime.\n         * <p>\n         * The LocalDateTime attached to this property is unchanged by this call.\n         *\n         * @param value  the value to set the field in the copy to\n         * @return a copy of the LocalDateTime with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "public LocalDateTime setCopy(String text, Locale locale) {\n            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), text, locale));\n        }", "comment": "/**\n         * Sets this field in a copy of the LocalDateTime to a parsed text value.\n         * <p>\n         * The LocalDateTime attached to this property is unchanged by this call.\n         *\n         * @param text  the text value to set\n         * @param locale  optional locale to use for selecting a text symbol\n         * @return a copy of the LocalDateTime with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */"}}
{"code": {"body": "public LocalDateTime setCopy(String text) {\n            return setCopy(text, null);\n        }", "comment": "/**\n         * Sets this field in a copy of the LocalDateTime to a parsed text value.\n         * <p>\n         * The LocalDateTime attached to this property is unchanged by this call.\n         *\n         * @param text  the text value to set\n         * @return a copy of the LocalDateTime with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */"}}
{"code": {"body": "public LocalDateTime withMaximumValue() {\n            return setCopy(getMaximumValue());\n        }", "comment": "/**\n         * Returns a new LocalDateTime with this field set to the maximum value\n         * for this field.\n         * <p>\n         * This operation is useful for obtaining a LocalDateTime on the last day\n         * of the month, as month lengths vary.\n         * <pre>\n         * LocalDateTime lastDayOfMonth = dt.dayOfMonth().withMaximumValue();\n         * </pre>\n         * <p>\n         * The LocalDateTime attached to this property is unchanged by this call.\n         *\n         * @return a copy of the LocalDateTime with this field set to its maximum\n         */"}}
{"code": {"body": "public LocalDateTime withMinimumValue() {\n            return setCopy(getMinimumValue());\n        }", "comment": "/**\n         * Returns a new LocalDateTime with this field set to the minimum value\n         * for this field.\n         * <p>\n         * The LocalDateTime attached to this property is unchanged by this call.\n         *\n         * @return a copy of the LocalDateTime with this field set to its minimum\n         */"}}
{"code": {"body": "public LocalDateTime roundFloorCopy() {\n            return iInstant.withLocalMillis(iField.roundFloor(iInstant.getLocalMillis()));\n        }", "comment": "/**\n         * Rounds to the lowest whole unit of this field on a copy of this\n         * LocalDateTime.\n         * <p>\n         * For example, rounding floor on the hourOfDay field of a LocalDateTime\n         * where the time is 10:30 would result in new LocalDateTime with the\n         * time of 10:00.\n         *\n         * @return a copy of the LocalDateTime with the field value changed\n         */"}}
{"code": {"body": "public LocalDateTime roundCeilingCopy() {\n            return iInstant.withLocalMillis(iField.roundCeiling(iInstant.getLocalMillis()));\n        }", "comment": "/**\n         * Rounds to the highest whole unit of this field on a copy of this\n         * LocalDateTime.\n         * <p>\n         * For example, rounding floor on the hourOfDay field of a LocalDateTime\n         * where the time is 10:30 would result in new LocalDateTime with the\n         * time of 11:00.\n         *\n         * @return a copy of the LocalDateTime with the field value changed\n         */"}}
{"code": {"body": "public LocalDateTime roundHalfFloorCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfFloor(iInstant.getLocalMillis()));\n        }", "comment": "/**\n         * Rounds to the nearest whole unit of this field on a copy of this\n         * LocalDateTime, favoring the floor if halfway.\n         *\n         * @return a copy of the LocalDateTime with the field value changed\n         */"}}
{"code": {"body": "public LocalDateTime roundHalfCeilingCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfCeiling(iInstant.getLocalMillis()));\n        }", "comment": "/**\n         * Rounds to the nearest whole unit of this field on a copy of this\n         * LocalDateTime, favoring the ceiling if halfway.\n         *\n         * @return a copy of the LocalDateTime with the field value changed\n         */"}}
{"code": {"body": "public LocalDateTime roundHalfEvenCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfEven(iInstant.getLocalMillis()));\n        }", "comment": "/**\n         * Rounds to the nearest whole unit of this field on a copy of this\n         * LocalDateTime.  If halfway, the ceiling is favored over the floor\n         * only if it makes this field's value even.\n         *\n         * @return a copy of the LocalDateTime with the field value changed\n         */"}}
{"code": {"body": "    public static LocalDateTime now(Chronology chronology) {\n        if (chronology == null) {\n            throw new NullPointerException(\"\");\n        }\n        return new LocalDateTime(chronology);\n    }", "comment": "/**\n     * Obtains a {@code LocalDateTime} set to the current system millisecond time\n     * using the specified chronology.\n     * The resulting object does not use the zone.\n     *\n     * @param chronology  the chronology, not null\n     * @return the current date, not null\n     * @since 2.0\n     */"}}
{"code": {"body": "    public static LocalDateTime parse(String str, DateTimeFormatter formatter) {\n        return formatter.parseLocalDateTime(str);\n    }", "comment": "/**\n     * Parses a {@code LocalDateTime} from the specified string using a formatter.\n     * \n     * @param str  the string to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @since 2.0\n     */"}}
{"code": {"body": "    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        int era = calendar.get(Calendar.ERA);\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDateTime(\n            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH),\n            calendar.get(Calendar.HOUR_OF_DAY),\n            calendar.get(Calendar.MINUTE),\n            calendar.get(Calendar.SECOND),\n            calendar.get(Calendar.MILLISECOND)\n        );\n    }", "comment": "/**\n     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDateTime.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDateTime with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */"}}
{"code": {"body": "    private Object readResolve() {\n        if (iChronology == null) {\n            return new LocalDateTime(iLocalMillis, ISOChronology.getInstanceUTC());\n        }\n        if (DateTimeZone.UTC.equals(iChronology.getZone()) == false) {\n            return new LocalDateTime(iLocalMillis, iChronology.withUTC());\n        }\n        return this;\n    }", "comment": "/**\n     * Handle broken serialization from other tools.\n     * @return the resolved object, not null\n     */"}}
{"code": {"body": "    public int size() {\n        return 4;\n    }", "comment": "/**\n     * Gets the number of fields in this partial, which is four.\n     * The supported fields are Year, MonthOfDay, DayOfMonth and MillisOfDay.\n     *\n     * @return the field count, four\n     */"}}
{"code": {"body": "        public DateTimeField getField() {\n            return iField;\n        }", "comment": "/**\n         * Gets the field being used.\n         * \n         * @return the field\n         */"}}
{"code": {"body": "    public int getValue(int index) {\n        switch (index) {\n            case YEAR:\n                return getChronology().year().get(getLocalMillis());\n            case MONTH_OF_YEAR:\n                return getChronology().monthOfYear().get(getLocalMillis());\n            case DAY_OF_MONTH:\n                return getChronology().dayOfMonth().get(getLocalMillis());\n            case MILLIS_OF_DAY:\n                return getChronology().millisOfDay().get(getLocalMillis());\n            default:\n                throw new IndexOutOfBoundsException(\"\" + index);\n        }\n    }", "comment": "/**\n     * Gets the value of the field at the specifed index.\n     * <p>\n     * This method is required to support the <code>ReadablePartial</code>\n     * interface. The supported fields are Year, MonthOfDay, DayOfMonth and MillisOfDay.\n     *\n     * @param index  the index, zero to two\n     * @return the value\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */"}}
{"code": {"body": "    public int get(DateTimeFieldType type) {\n        if (type == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        return type.getField(getChronology()).get(getLocalMillis());\n    }", "comment": "/**\n     * Get the value of one of the fields of a datetime.\n     * <p>\n     * This method gets the value of the specified field.\n     * For example:\n     * <pre>\n     * DateTime dt = new DateTime();\n     * int year = dt.get(DateTimeFieldType.year());\n     * </pre>\n     *\n     * @param type  a field type, usually obtained from DateTimeFieldType, not null\n     * @return the value of that field\n     * @throws IllegalArgumentException if the field type is null\n     */"}}
{"code": {"body": "    public boolean isSupported(DurationFieldType type) {\n        if (type == null) {\n            return false;\n        }\n        return type.getField(getChronology()).isSupported();\n    }", "comment": "/**\n     * Checks if the duration type specified is supported by this\n     * local datetime and chronology.\n     *\n     * @param type  a duration type, usually obtained from DurationFieldType\n     * @return true if the field type is supported\n     */"}}
{"code": {"body": "    protected long getLocalMillis() {\n        return iLocalMillis;\n    }", "comment": "/**\n     * Gets the milliseconds of the datetime instant from the Java epoch\n     * of 1970-01-01T00:00:00 (not fixed to any specific time zone).\n     *\n     * @return the number of milliseconds since 1970-01-01T00:00:00\n     * @since 1.5 (previously private)\n     */"}}
{"code": {"body": "        protected Chronology getChronology() {\n            return iInstant.getChronology();\n        }", "comment": "/**\n         * Gets the chronology of the datetime that this property is linked to.\n         * \n         * @return the chronology\n         * @since 1.4\n         */"}}
{"code": {"body": "    public boolean equals(Object partial) {\n        \n        if (this == partial) {\n            return true;\n        }\n        if (partial instanceof LocalDateTime) {\n            LocalDateTime other = (LocalDateTime) partial;\n            if (iChronology.equals(other.iChronology)) {\n                return iLocalMillis == other.iLocalMillis;\n            }\n        }\n        return super.equals(partial);\n    }", "comment": "/**\n     * Compares this ReadablePartial with another returning true if the chronology,\n     * field types and values are equal.\n     *\n     * @param partial  an object to check against\n     * @return true if fields and values are equal\n     */"}}
{"code": {"body": "    public int compareTo(ReadablePartial partial) {\n        \n        if (this == partial) {\n            return 0;\n        }\n        if (partial instanceof LocalDateTime) {\n            LocalDateTime other = (LocalDateTime) partial;\n            if (iChronology.equals(other.iChronology)) {\n                return (iLocalMillis < other.iLocalMillis ? -1 :\n                            (iLocalMillis == other.iLocalMillis ? 0 : 1));\n\n            }\n        }\n        return super.compareTo(partial);\n    }", "comment": "/**\n     * Compares this partial with another returning an integer\n     * indicating the order.\n     * <p>\n     * The fields are compared in order, from largest to smallest.\n     * The first field that is non-equal is used to determine the result.\n     * <p>\n     * The specified object must be a partial instance whose field types\n     * match those of this partial.\n     *\n     * @param partial  an object to check against\n     * @return negative if this is less, zero if equal, positive if greater\n     * @throws ClassCastException if the partial is the wrong class\n     *  or if it has field types that don't match\n     * @throws NullPointerException if the partial is null\n     */"}}
{"code": {"body": "    public DateTime toDateTime(DateTimeZone zone) {\n        zone = DateTimeUtils.getZone(zone);\n        Chronology chrono = iChronology.withZone(zone);\n        return new DateTime(\n                getYear(), getMonthOfYear(), getDayOfMonth(),\n                getHourOfDay(), getMinuteOfHour(),\n                getSecondOfMinute(), getMillisOfSecond(), chrono);\n    }", "comment": "/**\n     * Converts this object to a DateTime using the specified zone.\n     * <p>\n     * This method will throw an exception if the datetime that would be\n     * created does not exist when the time zone is taken into account.\n     * \n     * @param zone time zone to apply, or default if null\n     * @return a DateTime using the same millis\n     */"}}
{"code": {"body": "    public LocalDate toLocalDate() {\n        return new LocalDate(getLocalMillis(), getChronology());\n    }", "comment": "/**\n     * Converts this object to a LocalDate with the same date and chronology.\n     *\n     * @return a LocalDate with the same date and chronology\n     */"}}
{"code": {"body": "    public LocalTime toLocalTime() {\n        return new LocalTime(getLocalMillis(), getChronology());\n    }", "comment": "/**\n     * Converts this object to a LocalTime with the same time and chronology.\n     *\n     * @return a LocalTime with the same time and chronology\n     */"}}
{"code": {"body": "    public Date toDate(final TimeZone timeZone) {\n        final Calendar calendar = Calendar.getInstance(timeZone);\n        calendar.clear();\n        calendar.set(getYear(), getMonthOfYear() - 1, getDayOfMonth(),\n                    getHourOfDay(), getMinuteOfHour(), getSecondOfMinute());\n        Date date = calendar.getTime();\n        date.setTime(date.getTime() + getMillisOfSecond());\n        return correctDstTransition(date, timeZone);\n    }", "comment": "/**\n     * Get the date time as a <code>java.util.Date</code> using the specified time zone.\n     * <p>\n     * The <code>Date</code> object created has exactly the same fields as this\n     * date-time, except when the time would be invalid due to a daylight savings\n     * gap. In that case, the time will be set to the earliest valid time after the gap.\n     * <p>\n     * In the case of a daylight savings overlap, the earlier instant is selected.\n     * <p>\n     * Converting to a JDK Date is full of complications as the JDK Date constructor\n     * doesn't behave as you might expect around DST transitions. This method works\n     * by taking a first guess and then adjusting. This also handles the situation\n     * where the JDK time zone data differs from the Joda-Time time zone data.\n     * <p>\n     * Unlike {@link #toDate()}, this implementation does not rely on Java's synchronized\n     * time zone initialization logic, and should demonstrate better concurrent performance\n     * characteristics.\n     *\n     * @return a Date initialised with this date-time, never null\n     * @since 2.3\n     */"}}
{"code": {"body": "    private Date correctDstTransition(Date date, final TimeZone timeZone) {\n        Calendar calendar = Calendar.getInstance(timeZone);\n        calendar.setTime(date);\n        LocalDateTime check = LocalDateTime.fromCalendarFields(calendar);\n        if (check.isBefore(this)) {\n            \n            \n            while (check.isBefore(this)) {\n                calendar.setTimeInMillis(calendar.getTimeInMillis() + 60000);\n                check = LocalDateTime.fromCalendarFields(calendar);\n            }\n            \n            while (check.isBefore(this) == false) {\n                calendar.setTimeInMillis(calendar.getTimeInMillis() - 1000);\n                check = LocalDateTime.fromCalendarFields(calendar);\n            }\n            calendar.setTimeInMillis(calendar.getTimeInMillis() + 1000);\n        } else if (check.equals(this)) {\n            \n            final Calendar earlier = Calendar.getInstance(timeZone);\n            earlier.setTimeInMillis(calendar.getTimeInMillis() - timeZone.getDSTSavings());\n            check = LocalDateTime.fromCalendarFields(earlier);\n            if (check.equals(this)) {\n                calendar = earlier;\n            }\n        }\n        return calendar.getTime();\n    }", "comment": "/**\n     * Correct <code>date</code> in case of DST overlap.\n     * <p>\n     * The <code>Date</code> object created has exactly the same fields as this\n     * date-time, except when the time would be invalid due to a daylight savings\n     * gap. In that case, the time will be set to the earliest valid time after the gap.\n     * <p>\n     * In the case of a daylight savings overlap, the earlier instant is selected.\n     * <p>\n     * Converting to a JDK Date is full of complications as the JDK Date constructor\n     * doesn't behave as you might expect around DST transitions. This method works\n     * by taking a first guess and then adjusting. This also handles the situation\n     * where the JDK time zone data differs from the Joda-Time time zone data.\n     * @see #toDate()\n     */"}}
{"code": {"body": "    LocalDateTime withLocalMillis(long newMillis) {\n        return (newMillis == getLocalMillis() ? this : new LocalDateTime(newMillis, getChronology()));\n    }", "comment": "/**\n     * Returns a copy of this datetime with different local millis.\n     * <p>\n     * The returned object will be a new instance of the same type.\n     * Only the millis will change, the chronology is kept.\n     * The returned object will be either be a new instance or <code>this</code>.\n     *\n     * @param newMillis  the new millis, from 1970-01-01T00:00:00\n     * @return a copy of this datetime with different millis\n     */"}}
{"code": {"body": "    public LocalDateTime withDate(int year, int monthOfYear, int dayOfMonth) {\n        Chronology chrono = getChronology();\n        long instant = getLocalMillis();\n        instant = chrono.year().set(instant, year);\n        instant = chrono.monthOfYear().set(instant, monthOfYear);\n        instant = chrono.dayOfMonth().set(instant, dayOfMonth);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the specified date,\n     * retaining the time fields.\n     * <p>\n     * If the date is already the date passed in, then <code>this</code> is returned.\n     * <p>\n     * To set a single field use the properties, for example:\n     * <pre>\n     * DateTime set = dt.monthOfYear().setCopy(6);\n     * </pre>\n     *\n     * @param year  the new year value\n     * @param monthOfYear  the new monthOfYear value\n     * @param dayOfMonth  the new dayOfMonth value\n     * @return a copy of this datetime with a different date\n     * @throws IllegalArgumentException if any value if invalid\n     */"}}
{"code": {"body": "    public LocalDateTime withTime(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) {\n        Chronology chrono = getChronology();\n        long instant = getLocalMillis();\n        instant = chrono.hourOfDay().set(instant, hourOfDay);\n        instant = chrono.minuteOfHour().set(instant, minuteOfHour);\n        instant = chrono.secondOfMinute().set(instant, secondOfMinute);\n        instant = chrono.millisOfSecond().set(instant, millisOfSecond);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the specified time,\n     * retaining the date fields.\n     * <p>\n     * If the time is already the time passed in, then <code>this</code> is returned.\n     * <p>\n     * To set a single field use the properties, for example:\n     * <pre>\n     * LocalDateTime set = dt.hourOfDay().setCopy(6);\n     * </pre>\n     *\n     * @param hourOfDay  the hour of the day\n     * @param minuteOfHour  the minute of the hour\n     * @param secondOfMinute  the second of the minute\n     * @param millisOfSecond  the millisecond of the second\n     * @return a copy of this datetime with a different time\n     * @throws IllegalArgumentException if any value if invalid\n     */"}}
{"code": {"body": "    public LocalDateTime withFields(ReadablePartial partial) {\n        if (partial == null) {\n            return this;\n        }\n        return withLocalMillis(getChronology().set(partial, getLocalMillis()));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the partial set of fields\n     * replacing those from this instance.\n     * <p>\n     * For example, if the partial is a <code>TimeOfDay</code> then the time fields\n     * would be changed in the returned instance.\n     * If the partial is null, then <code>this</code> is returned.\n     *\n     * @param partial  the partial set of fields to apply to this datetime, null ignored\n     * @return a copy of this datetime with a different set of fields\n     * @throws IllegalArgumentException if any value is invalid\n     */"}}
{"code": {"body": "    public LocalDateTime withField(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the specified field set to a new value.\n     * <p>\n     * For example, if the field type is <code>hourOfDay</code> then the hour of day\n     * field would be changed in the returned instance.\n     * If the field type is null, then <code>this</code> is returned.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * LocalDateTime updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);\n     * LocalDateTime updated = dt.dayOfMonth().setCopy(6);\n     * LocalDateTime updated = dt.property(DateTimeFieldType.dayOfMonth()).setCopy(6);\n     * </pre>\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this datetime with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     */"}}
{"code": {"body": "    public LocalDateTime withFieldAdded(DurationFieldType fieldType, int amount) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (amount == 0) {\n            return this;\n        }\n        long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the value of the specified\n     * field increased.\n     * <p>\n     * If the addition is zero or the field is null, then <code>this</code> is returned.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.years(), 6);\n     * LocalDateTime added = dt.plusYears(6);\n     * LocalDateTime added = dt.plus(Period.years(6));\n     * </pre>\n     *\n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this datetime with the field updated\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */"}}
{"code": {"body": "    public LocalDateTime withDurationAdded(ReadableDuration durationToAdd, int scalar) {\n        if (durationToAdd == null || scalar == 0) {\n            return this;\n        }\n        long instant = getChronology().add(getLocalMillis(), durationToAdd.getMillis(), scalar);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the specified duration added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     *\n     * @param durationToAdd  the duration to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this datetime with the duration added\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */"}}
{"code": {"body": "    public LocalDateTime withPeriodAdded(ReadablePeriod period, int scalar) {\n        if (period == null || scalar == 0) {\n            return this;\n        }\n        long instant = getChronology().add(period, getLocalMillis(), scalar);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the specified period added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to add multiple copies of complex\n     * period instances. Adding one field is best achieved using methods\n     * like {@link #withFieldAdded(DurationFieldType, int)}\n     * or {@link #plusYears(int)}.\n     *\n     * @param period  the period to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this datetime with the period added\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */"}}
{"code": {"body": "    public LocalDateTime plus(ReadablePeriod period) {\n        return withPeriodAdded(period, 1);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the specified period added.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to add complex period instances.\n     * Adding one field is best achieved using methods\n     * like {@link #plusYears(int)}.\n     *\n     * @param period  the period to add to this one, null means zero\n     * @return a copy of this datetime with the period added\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */"}}
{"code": {"body": "    public LocalDateTime plusYears(int years) {\n        if (years == 0) {\n            return this;\n        }\n        long instant = getChronology().years().add(getLocalMillis(), years);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime plus the specified number of years.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime added = dt.plusYears(6);\n     * LocalDateTime added = dt.plus(Period.years(6));\n     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.years(), 6);\n     * </pre>\n     *\n     * @param years  the amount of years to add, may be negative\n     * @return the new LocalDateTime plus the increased years\n     */"}}
{"code": {"body": "    public LocalDateTime plusMonths(int months) {\n        if (months == 0) {\n            return this;\n        }\n        long instant = getChronology().months().add(getLocalMillis(), months);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime plus the specified number of months.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime added = dt.plusMonths(6);\n     * LocalDateTime added = dt.plus(Period.months(6));\n     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.months(), 6);\n     * </pre>\n     *\n     * @param months  the amount of months to add, may be negative\n     * @return the new LocalDateTime plus the increased months\n     */"}}
{"code": {"body": "    public LocalDateTime plusWeeks(int weeks) {\n        if (weeks == 0) {\n            return this;\n        }\n        long instant = getChronology().weeks().add(getLocalMillis(), weeks);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime plus the specified number of weeks.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime added = dt.plusWeeks(6);\n     * LocalDateTime added = dt.plus(Period.weeks(6));\n     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.weeks(), 6);\n     * </pre>\n     *\n     * @param weeks  the amount of weeks to add, may be negative\n     * @return the new LocalDateTime plus the increased weeks\n     */"}}
{"code": {"body": "    public LocalDateTime plusDays(int days) {\n        if (days == 0) {\n            return this;\n        }\n        long instant = getChronology().days().add(getLocalMillis(), days);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime plus the specified number of days.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime added = dt.plusDays(6);\n     * LocalDateTime added = dt.plus(Period.days(6));\n     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.days(), 6);\n     * </pre>\n     *\n     * @param days  the amount of days to add, may be negative\n     * @return the new LocalDateTime plus the increased days\n     */"}}
{"code": {"body": "    public LocalDateTime plusHours(int hours) {\n        if (hours == 0) {\n            return this;\n        }\n        long instant = getChronology().hours().add(getLocalMillis(), hours);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime plus the specified number of hours.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime added = dt.plusHours(6);\n     * LocalDateTime added = dt.plus(Period.hours(6));\n     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.hours(), 6);\n     * </pre>\n     *\n     * @param hours  the amount of hours to add, may be negative\n     * @return the new LocalDateTime plus the increased hours\n     */"}}
{"code": {"body": "    public LocalDateTime plusMinutes(int minutes) {\n        if (minutes == 0) {\n            return this;\n        }\n        long instant = getChronology().minutes().add(getLocalMillis(), minutes);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime plus the specified number of minutes.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime added = dt.plusMinutes(6);\n     * LocalDateTime added = dt.plus(Period.minutes(6));\n     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.minutes(), 6);\n     * </pre>\n     *\n     * @param minutes  the amount of minutes to add, may be negative\n     * @return the new LocalDateTime plus the increased minutes\n     */"}}
{"code": {"body": "    public LocalDateTime plusSeconds(int seconds) {\n        if (seconds == 0) {\n            return this;\n        }\n        long instant = getChronology().seconds().add(getLocalMillis(), seconds);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime plus the specified number of seconds.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime added = dt.plusSeconds(6);\n     * LocalDateTime added = dt.plus(Period.seconds(6));\n     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.seconds(), 6);\n     * </pre>\n     *\n     * @param seconds  the amount of seconds to add, may be negative\n     * @return the new LocalDateTime plus the increased seconds\n     */"}}
{"code": {"body": "    public LocalDateTime plusMillis(int millis) {\n        if (millis == 0) {\n            return this;\n        }\n        long instant = getChronology().millis().add(getLocalMillis(), millis);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime plus the specified number of millis.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime added = dt.plusMillis(6);\n     * LocalDateTime added = dt.plus(Period.millis(6));\n     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.millis(), 6);\n     * </pre>\n     *\n     * @param millis  the amount of millis to add, may be negative\n     * @return the new LocalDateTime plus the increased millis\n     */"}}
{"code": {"body": "    public LocalDateTime minus(ReadablePeriod period) {\n        return withPeriodAdded(period, -1);\n    }", "comment": "/**\n     * Returns a copy of this datetime with the specified period taken away.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to subtract complex period instances.\n     * Subtracting one field is best achieved using methods\n     * like {@link #minusYears(int)}.\n     *\n     * @param period  the period to reduce this instant by\n     * @return a copy of this datetime with the period taken away\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */"}}
{"code": {"body": "    public LocalDateTime minusYears(int years) {\n        if (years == 0) {\n            return this;\n        }\n        long instant = getChronology().years().subtract(getLocalMillis(), years);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime minus the specified number of years.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime subtracted = dt.minusYears(6);\n     * LocalDateTime subtracted = dt.minus(Period.years(6));\n     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);\n     * </pre>\n     *\n     * @param years  the amount of years to subtract, may be negative\n     * @return the new LocalDateTime minus the increased years\n     */"}}
{"code": {"body": "    public LocalDateTime minusMonths(int months) {\n        if (months == 0) {\n            return this;\n        }\n        long instant = getChronology().months().subtract(getLocalMillis(), months);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime minus the specified number of months.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime subtracted = dt.minusMonths(6);\n     * LocalDateTime subtracted = dt.minus(Period.months(6));\n     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);\n     * </pre>\n     *\n     * @param months  the amount of months to subtract, may be negative\n     * @return the new LocalDateTime minus the increased months\n     */"}}
{"code": {"body": "    public LocalDateTime minusWeeks(int weeks) {\n        if (weeks == 0) {\n            return this;\n        }\n        long instant = getChronology().weeks().subtract(getLocalMillis(), weeks);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime minus the specified number of weeks.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime subtracted = dt.minusWeeks(6);\n     * LocalDateTime subtracted = dt.minus(Period.weeks(6));\n     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6);\n     * </pre>\n     *\n     * @param weeks  the amount of weeks to subtract, may be negative\n     * @return the new LocalDateTime minus the increased weeks\n     */"}}
{"code": {"body": "    public LocalDateTime minusDays(int days) {\n        if (days == 0) {\n            return this;\n        }\n        long instant = getChronology().days().subtract(getLocalMillis(), days);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime minus the specified number of days.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime subtracted = dt.minusDays(6);\n     * LocalDateTime subtracted = dt.minus(Period.days(6));\n     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);\n     * </pre>\n     *\n     * @param days  the amount of days to subtract, may be negative\n     * @return the new LocalDateTime minus the increased days\n     */"}}
{"code": {"body": "    public LocalDateTime minusHours(int hours) {\n        if (hours == 0) {\n            return this;\n        }\n        long instant = getChronology().hours().subtract(getLocalMillis(), hours);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime minus the specified number of hours.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime subtracted = dt.minusHours(6);\n     * LocalDateTime subtracted = dt.minus(Period.hours(6));\n     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.hours(), -6);\n     * </pre>\n     *\n     * @param hours  the amount of hours to subtract, may be negative\n     * @return the new LocalDateTime minus the increased hours\n     */"}}
{"code": {"body": "    public LocalDateTime minusMinutes(int minutes) {\n        if (minutes == 0) {\n            return this;\n        }\n        long instant = getChronology().minutes().subtract(getLocalMillis(), minutes);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime minus the specified number of minutes.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime subtracted = dt.minusMinutes(6);\n     * LocalDateTime subtracted = dt.minus(Period.minutes(6));\n     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.minutes(), -6);\n     * </pre>\n     *\n     * @param minutes  the amount of minutes to subtract, may be negative\n     * @return the new LocalDateTime minus the increased minutes\n     */"}}
{"code": {"body": "    public LocalDateTime minusSeconds(int seconds) {\n        if (seconds == 0) {\n            return this;\n        }\n        long instant = getChronology().seconds().subtract(getLocalMillis(), seconds);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime minus the specified number of seconds.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime subtracted = dt.minusSeconds(6);\n     * LocalDateTime subtracted = dt.minus(Period.seconds(6));\n     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.seconds(), -6);\n     * </pre>\n     *\n     * @param seconds  the amount of seconds to subtract, may be negative\n     * @return the new LocalDateTime minus the increased seconds\n     */"}}
{"code": {"body": "    public LocalDateTime minusMillis(int millis) {\n        if (millis == 0) {\n            return this;\n        }\n        long instant = getChronology().millis().subtract(getLocalMillis(), millis);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this datetime minus the specified number of millis.\n     * <p>\n     * This LocalDateTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalDateTime subtracted = dt.minusMillis(6);\n     * LocalDateTime subtracted = dt.minus(Period.millis(6));\n     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.millis(), -6);\n     * </pre>\n     *\n     * @param millis  the amount of millis to subtract, may be negative\n     * @return the new LocalDateTime minus the increased millis\n     */"}}
{"code": {"body": "    public Property property(DateTimeFieldType fieldType) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (isSupported(fieldType) == false) {\n            throw new IllegalArgumentException(\"\" + fieldType + \"\");\n        }\n        return new Property(this, fieldType.getField(getChronology()));\n    }", "comment": "/**\n     * Gets the property object for the specified type, which contains many\n     * useful methods.\n     *\n     * @param fieldType  the field type to get the chronology for\n     * @return the property object\n     * @throws IllegalArgumentException if the field is null or unsupported\n     */"}}
{"code": {"body": "    public int getEra() {\n        return getChronology().era().get(getLocalMillis());\n    }", "comment": "/**\n     * Get the era field value.\n     *\n     * @return the era\n     */"}}
{"code": {"body": "    public int getCenturyOfEra() {\n        return getChronology().centuryOfEra().get(getLocalMillis());\n    }", "comment": "/**\n     * Get the year of era field value.\n     *\n     * @return the year of era\n     */"}}
{"code": {"body": "    public int getYearOfEra() {\n        return getChronology().yearOfEra().get(getLocalMillis());\n    }", "comment": "/**\n     * Get the year of era field value.\n     *\n     * @return the year of era\n     */"}}
{"code": {"body": "    public int getYearOfCentury() {\n        return getChronology().yearOfCentury().get(getLocalMillis());\n    }", "comment": "/**\n     * Get the year of century field value.\n     *\n     * @return the year of century\n     */"}}
{"code": {"body": "    public int getYear() {\n        return getChronology().year().get(getLocalMillis());\n    }", "comment": "/**\n     * Get the year field value.\n     *\n     * @return the year\n     */"}}
{"code": {"body": "    public int getWeekyear() {\n        return getChronology().weekyear().get(getLocalMillis());\n    }", "comment": "/**\n     * Get the weekyear field value.\n     * <p>\n     * The weekyear is the year that matches with the weekOfWeekyear field.\n     * In the standard ISO8601 week algorithm, the first week of the year\n     * is that in which at least 4 days are in the year. As a result of this\n     * definition, day 1 of the first week may be in the previous year.\n     * The weekyear allows you to query the effective year for that day.\n     *\n     * @return the weekyear\n     */"}}
{"code": {"body": "    public int getMonthOfYear() {\n        return getChronology().monthOfYear().get(getLocalMillis());\n    }", "comment": "/**\n     * Get the month of year field value.\n     *\n     * @return the month of year\n     */"}}
{"code": {"body": "    public int getWeekOfWeekyear() {\n        return getChronology().weekOfWeekyear().get(getLocalMillis());\n    }", "comment": "/**\n     * Get the week of weekyear field value.\n     * <p>\n     * This field is associated with the \"weekyear\" via {@link #getWeekyear()}.\n     * In the standard ISO8601 week algorithm, the first week of the year\n     * is that in which at least 4 days are in the year. As a result of this\n     * definition, day 1 of the first week may be in the previous year.\n     *\n     * @return the week of a week based year\n     */"}}
{"code": {"body": "    public int getDayOfYear() {\n        return getChronology().dayOfYear().get(getLocalMillis());\n    }", "comment": "/**\n     * Get the day of year field value.\n     *\n     * @return the day of year\n     */"}}
{"code": {"body": "    public int getDayOfMonth() {\n        return getChronology().dayOfMonth().get(getLocalMillis());\n    }", "comment": "/**\n     * Get the day of month field value.\n     * <p>\n     * The values for the day of month are defined in {@link org.joda.time.DateTimeConstants}.\n     *\n     * @return the day of month\n     */"}}
{"code": {"body": "    public int getDayOfWeek() {\n        return getChronology().dayOfWeek().get(getLocalMillis());\n    }", "comment": "/**\n     * Get the day of week field value.\n     * <p>\n     * The values for the day of week are defined in {@link org.joda.time.DateTimeConstants}.\n     *\n     * @return the day of week\n     */"}}
{"code": {"body": "    public int getHourOfDay() {\n        return getChronology().hourOfDay().get(getLocalMillis());\n    }", "comment": "/**\n     * Get the hour of day field value.\n     *\n     * @return the hour of day\n     */"}}
{"code": {"body": "    public int getMinuteOfHour() {\n        return getChronology().minuteOfHour().get(getLocalMillis());\n    }", "comment": "/**\n     * Get the minute of hour field value.\n     *\n     * @return the minute of hour\n     */"}}
{"code": {"body": "    public int getSecondOfMinute() {\n        return getChronology().secondOfMinute().get(getLocalMillis());\n    }", "comment": "/**\n     * Get the second of minute field value.\n     *\n     * @return the second of minute\n     */"}}
{"code": {"body": "    public int getMillisOfSecond() {\n        return getChronology().millisOfSecond().get(getLocalMillis());\n    }", "comment": "/**\n     * Get the millis of second field value.\n     *\n     * @return the millis of second\n     */"}}
{"code": {"body": "    public int getMillisOfDay() {\n        return getChronology().millisOfDay().get(getLocalMillis());\n    }", "comment": "/**\n     * Get the millis of day field value.\n     *\n     * @return the millis of day\n     */"}}
{"code": {"body": "    public LocalDateTime withEra(int era) {\n        return withLocalMillis(getChronology().era().set(getLocalMillis(), era));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the era field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * era changed.\n     *\n     * @param era  the era to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public LocalDateTime withCenturyOfEra(int centuryOfEra) {\n        return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(), centuryOfEra));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the century of era field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * century of era changed.\n     *\n     * @param centuryOfEra  the centurey of era to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public LocalDateTime withYearOfEra(int yearOfEra) {\n        return withLocalMillis(getChronology().yearOfEra().set(getLocalMillis(), yearOfEra));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the year of era field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year of era changed.\n     *\n     * @param yearOfEra  the year of era to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public LocalDateTime withYearOfCentury(int yearOfCentury) {\n        return withLocalMillis(getChronology().yearOfCentury().set(getLocalMillis(), yearOfCentury));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the year of century field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year of century changed.\n     *\n     * @param yearOfCentury  the year of century to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public LocalDateTime withYear(int year) {\n        return withLocalMillis(getChronology().year().set(getLocalMillis(), year));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the year field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year changed.\n     *\n     * @param year  the year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public LocalDateTime withWeekyear(int weekyear) {\n        return withLocalMillis(getChronology().weekyear().set(getLocalMillis(), weekyear));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the weekyear field updated.\n     * <p>\n     * The weekyear is the year that matches with the weekOfWeekyear field.\n     * In the standard ISO8601 week algorithm, the first week of the year\n     * is that in which at least 4 days are in the year. As a result of this\n     * definition, day 1 of the first week may be in the previous year.\n     * The weekyear allows you to query the effective year for that day.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * weekyear changed.\n     *\n     * @param weekyear  the weekyear to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public LocalDateTime withMonthOfYear(int monthOfYear) {\n        return withLocalMillis(getChronology().monthOfYear().set(getLocalMillis(), monthOfYear));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the month of year field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * month of year changed.\n     *\n     * @param monthOfYear  the month of year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public LocalDateTime withWeekOfWeekyear(int weekOfWeekyear) {\n        return withLocalMillis(getChronology().weekOfWeekyear().set(getLocalMillis(), weekOfWeekyear));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the week of weekyear field updated.\n     * <p>\n     * This field is associated with the \"weekyear\" via {@link #withWeekyear(int)}.\n     * In the standard ISO8601 week algorithm, the first week of the year\n     * is that in which at least 4 days are in the year. As a result of this\n     * definition, day 1 of the first week may be in the previous year.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * week of weekyear changed.\n     *\n     * @param weekOfWeekyear  the week of weekyear to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public LocalDateTime withDayOfYear(int dayOfYear) {\n        return withLocalMillis(getChronology().dayOfYear().set(getLocalMillis(), dayOfYear));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the day of year field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of year changed.\n     *\n     * @param dayOfYear  the day of year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public LocalDateTime withDayOfMonth(int dayOfMonth) {\n        return withLocalMillis(getChronology().dayOfMonth().set(getLocalMillis(), dayOfMonth));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the day of month field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of month changed.\n     *\n     * @param dayOfMonth  the day of month to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public LocalDateTime withDayOfWeek(int dayOfWeek) {\n        return withLocalMillis(getChronology().dayOfWeek().set(getLocalMillis(), dayOfWeek));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the day of week field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of week changed.\n     *\n     * @param dayOfWeek  the day of week to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public LocalDateTime withHourOfDay(int hour) {\n        return withLocalMillis(getChronology().hourOfDay().set(getLocalMillis(), hour));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the hour of day field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * hour of day changed.\n     *\n     * @param hour  the hour of day to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public LocalDateTime withMinuteOfHour(int minute) {\n        return withLocalMillis(getChronology().minuteOfHour().set(getLocalMillis(), minute));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the minute of hour field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * minute of hour changed.\n     *\n     * @param minute  the minute of hour to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public LocalDateTime withSecondOfMinute(int second) {\n        return withLocalMillis(getChronology().secondOfMinute().set(getLocalMillis(), second));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the second of minute field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * second of minute changed.\n     *\n     * @param second  the second of minute to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public LocalDateTime withMillisOfSecond(int millis) {\n        return withLocalMillis(getChronology().millisOfSecond().set(getLocalMillis(), millis));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the millis of second field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * millis of second changed.\n     *\n     * @param millis  the millis of second to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public LocalDateTime withMillisOfDay(int millis) {\n        return withLocalMillis(getChronology().millisOfDay().set(getLocalMillis(), millis));\n    }", "comment": "/**\n     * Returns a copy of this datetime with the millis of day field updated.\n     * <p>\n     * LocalDateTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * millis of day changed.\n     *\n     * @param millis  the millis of day to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public Property era() {\n        return new Property(this, getChronology().era());\n    }", "comment": "/**\n     * Get the era property which provides access to advanced functionality.\n     *\n     * @return the era property\n     */"}}
{"code": {"body": "    public Property centuryOfEra() {\n        return new Property(this, getChronology().centuryOfEra());\n    }", "comment": "/**\n     * Get the century of era property which provides access to advanced functionality.\n     *\n     * @return the year of era property\n     */"}}
{"code": {"body": "    public Property yearOfCentury() {\n        return new Property(this, getChronology().yearOfCentury());\n    }", "comment": "/**\n     * Get the year of century property which provides access to advanced functionality.\n     *\n     * @return the year of era property\n     */"}}
{"code": {"body": "    public Property yearOfEra() {\n        return new Property(this, getChronology().yearOfEra());\n    }", "comment": "/**\n     * Get the year of era property which provides access to advanced functionality.\n     *\n     * @return the year of era property\n     */"}}
{"code": {"body": "    public Property year() {\n        return new Property(this, getChronology().year());\n    }", "comment": "/**\n     * Get the year property which provides access to advanced functionality.\n     *\n     * @return the year property\n     */"}}
{"code": {"body": "    public Property weekyear() {\n        return new Property(this, getChronology().weekyear());\n    }", "comment": "/**\n     * Get the weekyear property which provides access to advanced functionality.\n     *\n     * @return the weekyear property\n     */"}}
{"code": {"body": "    public Property monthOfYear() {\n        return new Property(this, getChronology().monthOfYear());\n    }", "comment": "/**\n     * Get the month of year property which provides access to advanced functionality.\n     *\n     * @return the month of year property\n     */"}}
{"code": {"body": "    public Property weekOfWeekyear() {\n        return new Property(this, getChronology().weekOfWeekyear());\n    }", "comment": "/**\n     * Get the week of a week based year property which provides access to advanced functionality.\n     *\n     * @return the week of a week based year property\n     */"}}
{"code": {"body": "    public Property dayOfYear() {\n        return new Property(this, getChronology().dayOfYear());\n    }", "comment": "/**\n     * Get the day of year property which provides access to advanced functionality.\n     *\n     * @return the day of year property\n     */"}}
{"code": {"body": "    public Property dayOfMonth() {\n        return new Property(this, getChronology().dayOfMonth());\n    }", "comment": "/**\n     * Get the day of month property which provides access to advanced functionality.\n     *\n     * @return the day of month property\n     */"}}
{"code": {"body": "    public Property dayOfWeek() {\n        return new Property(this, getChronology().dayOfWeek());\n    }", "comment": "/**\n     * Get the day of week property which provides access to advanced functionality.\n     *\n     * @return the day of week property\n     */"}}
{"code": {"body": "    public Property hourOfDay() {\n        return new Property(this, getChronology().hourOfDay());\n    }", "comment": "/**\n     * Get the hour of day field property which provides access to advanced functionality.\n     * \n     * @return the hour of day property\n     */"}}
{"code": {"body": "    public Property minuteOfHour() {\n        return new Property(this, getChronology().minuteOfHour());\n    }", "comment": "/**\n     * Get the minute of hour field property which provides access to advanced functionality.\n     * \n     * @return the minute of hour property\n     */"}}
{"code": {"body": "    public Property secondOfMinute() {\n        return new Property(this, getChronology().secondOfMinute());\n    }", "comment": "/**\n     * Get the second of minute field property which provides access to advanced functionality.\n     * \n     * @return the second of minute property\n     */"}}
{"code": {"body": "    public Property millisOfSecond() {\n        return new Property(this, getChronology().millisOfSecond());\n    }", "comment": "/**\n     * Get the millis of second property which provides access to advanced functionality.\n     * \n     * @return the millis of second property\n     */"}}
{"code": {"body": "    public Property millisOfDay() {\n        return new Property(this, getChronology().millisOfDay());\n    }", "comment": "/**\n     * Get the millis of day property which provides access to advanced functionality.\n     * \n     * @return the millis of day property\n     */"}}
{"code": {"body": "    public String toString(String pattern, Locale locale) throws IllegalArgumentException {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n    }", "comment": "/**\n     * Output the date using the specified format pattern.\n     *\n     * @param pattern  the pattern specification, null means use <code>toString</code>\n     * @param locale  Locale to use, null means default\n     * @see org.joda.time.format.DateTimeFormat\n     */"}}
{"code": {"body": "        private void writeObject(ObjectOutputStream oos) throws IOException {\n            oos.writeObject(iInstant);\n            oos.writeObject(iField.getType());\n        }", "comment": "/**\n         * Writes the property in a safe serialization format.\n         */"}}
{"code": {"body": "        private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {\n            iInstant = (LocalDateTime) oos.readObject();\n            DateTimeFieldType type = (DateTimeFieldType) oos.readObject();\n            iField = type.getField(iInstant.getChronology());\n        }", "comment": "/**\n         * Reads the property from a safe serialization format.\n         */"}}
{"code": {"body": "        protected long getMillis() {\n            return iInstant.getLocalMillis();\n        }", "comment": "/**\n         * Gets the milliseconds of the datetime that this property is linked to.\n         * \n         * @return the milliseconds\n         */"}}
{"code": {"body": "        public LocalDateTime getLocalDateTime() {\n            return iInstant;\n        }", "comment": "/**\n         * Gets the LocalDateTime object linked to this property.\n         * \n         * @return the linked LocalDateTime\n         */"}}
{"code": {"body": "        public LocalDateTime addToCopy(long value) {\n            return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value));\n        }", "comment": "/**\n         * Adds to this field in a copy of this LocalDateTime.\n         * <p>\n         * The LocalDateTime attached to this property is unchanged by this call.\n         *\n         * @param value  the value to add to the field in the copy\n         * @return a copy of the LocalDateTime with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "        public LocalDateTime addWrapFieldToCopy(int value) {\n            return iInstant.withLocalMillis(iField.addWrapField(iInstant.getLocalMillis(), value));\n        }", "comment": "/**\n         * Adds to this field, possibly wrapped, in a copy of this LocalDateTime.\n         * A field wrapped operation only changes this field.\n         * Thus 31st January addWrapField one day goes to the 1st January.\n         * <p>\n         * The LocalDateTime attached to this property is unchanged by this call.\n         *\n         * @param value  the value to add to the field in the copy\n         * @return a copy of the LocalDateTime with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "        public LocalDateTime setCopy(String text) {\n            return setCopy(text, null);\n        }", "comment": "/**\n         * Sets this field in a copy of the LocalDateTime to a parsed text value.\n         * <p>\n         * The LocalDateTime attached to this property is unchanged by this call.\n         *\n         * @param text  the text value to set\n         * @return a copy of the LocalDateTime with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */"}}
{"code": {"body": "        public LocalDateTime withMaximumValue() {\n            return setCopy(getMaximumValue());\n        }", "comment": "/**\n         * Returns a new LocalDateTime with this field set to the maximum value\n         * for this field.\n         * <p>\n         * This operation is useful for obtaining a LocalDateTime on the last day\n         * of the month, as month lengths vary.\n         * <pre>\n         * LocalDateTime lastDayOfMonth = dt.dayOfMonth().withMaximumValue();\n         * </pre>\n         * <p>\n         * The LocalDateTime attached to this property is unchanged by this call.\n         *\n         * @return a copy of the LocalDateTime with this field set to its maximum\n         */"}}
{"code": {"body": "        public LocalDateTime withMinimumValue() {\n            return setCopy(getMinimumValue());\n        }", "comment": "/**\n         * Returns a new LocalDateTime with this field set to the minimum value\n         * for this field.\n         * <p>\n         * The LocalDateTime attached to this property is unchanged by this call.\n         *\n         * @return a copy of the LocalDateTime with this field set to its minimum\n         */"}}
{"code": {"body": "        public LocalDateTime roundFloorCopy() {\n            return iInstant.withLocalMillis(iField.roundFloor(iInstant.getLocalMillis()));\n        }", "comment": "/**\n         * Rounds to the lowest whole unit of this field on a copy of this\n         * LocalDateTime.\n         * <p>\n         * For example, rounding floor on the hourOfDay field of a LocalDateTime\n         * where the time is 10:30 would result in new LocalDateTime with the\n         * time of 10:00.\n         *\n         * @return a copy of the LocalDateTime with the field value changed\n         */"}}
{"code": {"body": "        public LocalDateTime roundCeilingCopy() {\n            return iInstant.withLocalMillis(iField.roundCeiling(iInstant.getLocalMillis()));\n        }", "comment": "/**\n         * Rounds to the highest whole unit of this field on a copy of this\n         * LocalDateTime.\n         * <p>\n         * For example, rounding floor on the hourOfDay field of a LocalDateTime\n         * where the time is 10:30 would result in new LocalDateTime with the\n         * time of 11:00.\n         *\n         * @return a copy of the LocalDateTime with the field value changed\n         */"}}
{"code": {"body": "        public LocalDateTime roundHalfFloorCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfFloor(iInstant.getLocalMillis()));\n        }", "comment": "/**\n         * Rounds to the nearest whole unit of this field on a copy of this\n         * LocalDateTime, favoring the floor if halfway.\n         *\n         * @return a copy of the LocalDateTime with the field value changed\n         */"}}
{"code": {"body": "        public LocalDateTime roundHalfCeilingCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfCeiling(iInstant.getLocalMillis()));\n        }", "comment": "/**\n         * Rounds to the nearest whole unit of this field on a copy of this\n         * LocalDateTime, favoring the ceiling if halfway.\n         *\n         * @return a copy of the LocalDateTime with the field value changed\n         */"}}
{"code": {"body": "        public LocalDateTime roundHalfEvenCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfEven(iInstant.getLocalMillis()));\n        }", "comment": "/**\n         * Rounds to the nearest whole unit of this field on a copy of this\n         * LocalDateTime.  If halfway, the ceiling is favored over the floor\n         * only if it makes this field's value even.\n         *\n         * @return a copy of the LocalDateTime with the field value changed\n         */"}}
{"code": {"body": "public LocalTime() {\n        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance());\n    }", "comment": "/**\n     * Constructs an instance set to the current local time evaluated using\n     * ISO chronology in the default zone.\n     * <p>\n     * Once the constructor is completed, the zone is no longer used.\n     * \n     * @see #now()\n     */"}}
{"code": {"body": "public LocalTime(DateTimeZone zone) {\n        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone));\n    }", "comment": "/**\n     * Constructs an instance set to the current local time evaluated using\n     * ISO chronology in the specified zone.\n     * <p>\n     * If the specified time zone is null, the default zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     *\n     * @param zone  the time zone, null means default zone\n     * @see #now(DateTimeZone)\n     */"}}
{"code": {"body": "public LocalTime(Chronology chronology) {\n        this(DateTimeUtils.currentTimeMillis(), chronology);\n    }", "comment": "/**\n     * Constructs an instance set to the current local time evaluated using\n     * specified chronology and zone.\n     * <p>\n     * If the chronology is null, ISO chronology in the default time zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     *\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     * @see #now(Chronology)\n     */"}}
{"code": {"body": "public LocalTime(long instant) {\n        this(instant, ISOChronology.getInstance());\n    }", "comment": "/**\n     * Constructs an instance set to the local time defined by the specified\n     * instant evaluated using ISO chronology in the default zone.\n     * <p>\n     * Once the constructor is completed, the zone is no longer used.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     */"}}
{"code": {"body": "public LocalTime(long instant, DateTimeZone zone) {\n        this(instant, ISOChronology.getInstance(zone));\n    }", "comment": "/**\n     * Constructs an instance set to the local time defined by the specified\n     * instant evaluated using ISO chronology in the specified zone.\n     * <p>\n     * If the specified time zone is null, the default zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     * @param zone  the time zone, null means default zone\n     */"}}
{"code": {"body": "public LocalTime(long instant, Chronology chronology) {\n        chronology = DateTimeUtils.getChronology(chronology);\n        \n        long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);\n        chronology = chronology.withUTC();\n        iLocalMillis = chronology.millisOfDay().get(localMillis);\n        iChronology = chronology;\n    }", "comment": "/**\n     * Constructs an instance set to the local time defined by the specified\n     * instant evaluated using the specified chronology.\n     * <p>\n     * If the chronology is null, ISO chronology in the default zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     */"}}
{"code": {"body": "public LocalTime(Object instant) {\n        this(instant, (Chronology) null);\n    }", "comment": "/**\n     * Constructs an instance from an Object that represents a datetime.\n     * <p>\n     * If the object contains no chronology, <code>ISOChronology</code> is used.\n     * If the object contains no time zone, the default zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n     * The String formats are described by {@link ISODateTimeFormat#localTimeParser()}.\n     * The default String converter ignores the zone and only parses the field values.\n     *\n     * @param instant  the datetime object\n     * @throws IllegalArgumentException if the instant is invalid\n     */"}}
{"code": {"body": "public LocalTime(Object instant, DateTimeZone zone) {\n        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);\n        Chronology chronology = converter.getChronology(instant, zone);\n        chronology = DateTimeUtils.getChronology(chronology);\n        iChronology = chronology.withUTC();\n        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localTimeParser());\n        iLocalMillis = iChronology.getDateTimeMillis(0L, values[0], values[1], values[2], values[3]);\n    }", "comment": "/**\n     * Constructs an instance from an Object that represents a datetime,\n     * forcing the time zone to that specified.\n     * <p>\n     * If the object contains no chronology, <code>ISOChronology</code> is used.\n     * If the specified time zone is null, the default zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n     * The String formats are described by {@link ISODateTimeFormat#localTimeParser()}.\n     * The default String converter ignores the zone and only parses the field values.\n     *\n     * @param instant  the datetime object\n     * @param zone  the time zone\n     * @throws IllegalArgumentException if the instant is invalid\n     */"}}
{"code": {"body": "public LocalTime(Object instant, Chronology chronology) {\n        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);\n        chronology = converter.getChronology(instant, chronology);\n        chronology = DateTimeUtils.getChronology(chronology);\n        iChronology = chronology.withUTC();\n        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localTimeParser());\n        iLocalMillis = iChronology.getDateTimeMillis(0L, values[0], values[1], values[2], values[3]);\n    }", "comment": "/**\n     * Constructs an instance from an Object that represents a datetime,\n     * using the specified chronology.\n     * <p>\n     * If the chronology is null, ISO in the default time zone is used.\n     * Once the constructor is completed, the zone is no longer used.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n     * The String formats are described by {@link ISODateTimeFormat#localTimeParser()}.\n     * The default String converter ignores the zone and only parses the field values.\n     *\n     * @param instant  the datetime object\n     * @param chronology  the chronology\n     * @throws IllegalArgumentException if the instant is invalid\n     */"}}
{"code": {"body": "public LocalTime withFields(ReadablePartial partial) {\n        if (partial == null) {\n            return this;\n        }\n        return withLocalMillis(getChronology().set(partial, getLocalMillis()));\n    }", "comment": "/**\n     * Returns a copy of this time with the partial set of fields replacing\n     * those from this instance.\n     * <p>\n     * For example, if the partial contains an hour and minute then those two\n     * fields will be changed in the returned instance.\n     * Unsupported fields are ignored.\n     * If the partial is null, then <code>this</code> is returned.\n     *\n     * @param partial  the partial set of fields to apply to this time, null ignored\n     * @return a copy of this time with a different set of fields\n     * @throws IllegalArgumentException if any value is invalid\n     */"}}
{"code": {"body": "public LocalTime withField(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (isSupported(fieldType) == false) {\n            throw new IllegalArgumentException(\"\" + fieldType + \"\");\n        }\n        long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this time with the specified field set\n     * to a new value.\n     * <p>\n     * For example, if the field type is <code>hourOfDay</code> then the hour of day\n     * field would be changed in the returned instance.\n     * If the field type is null, then <code>this</code> is returned.\n     * <p>\n     * These lines are equivalent:\n     * <pre>\n     * LocalTime updated = dt.withHourOfDay(6);\n     * LocalTime updated = dt.withField(DateTimeFieldType.hourOfDay(), 6);\n     * </pre>\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this time with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     */"}}
{"code": {"body": "public LocalTime withFieldAdded(DurationFieldType fieldType, int amount) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (isSupported(fieldType) == false) {\n            throw new IllegalArgumentException(\"\" + fieldType + \"\");\n        }\n        if (amount == 0) {\n            return this;\n        }\n        long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this time with the value of the specified\n     * field increased.\n     * <p>\n     * If the addition is zero or the field is null, then <code>this</code>\n     * is returned.\n     * <p>\n     * If the addition causes the maximum value of the field to be exceeded,\n     * then the value will wrap. Thus 23:59 plus two minutes yields 00:01.\n     * <p>\n     * These lines are equivalent:\n     * <pre>\n     * LocalTime added = dt.plusHours(6);\n     * LocalTime added = dt.withFieldAdded(DurationFieldType.hours(), 6);\n     * </pre>\n     *\n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this time with the field updated\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */"}}
{"code": {"body": "public LocalTime withPeriodAdded(ReadablePeriod period, int scalar) {\n        if (period == null || scalar == 0) {\n            return this;\n        }\n        long instant = getChronology().add(period, getLocalMillis(), scalar);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this time with the specified period added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to add multiple copies of complex\n     * period instances. Adding one field is best achieved using methods\n     * like {@link #withFieldAdded(DurationFieldType, int)}\n     * or {@link #plusHours(int)}.\n     *\n     * @param period  the period to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this time with the period added\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */"}}
{"code": {"body": "public LocalTime plus(ReadablePeriod period) {\n        return withPeriodAdded(period, 1);\n    }", "comment": "/**\n     * Returns a copy of this time with the specified period added.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to add complex period instances.\n     * Adding one field is best achieved using methods\n     * like {@link #plusHours(int)}.\n     * \n     * @param period  the period to add to this one, null means zero\n     * @return a copy of this time with the period added\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */"}}
{"code": {"body": "public LocalTime plusHours(int hours) {\n        if (hours == 0) {\n            return this;\n        }\n        long instant = getChronology().hours().add(getLocalMillis(), hours);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this time plus the specified number of hours.\n     * <p>\n     * This LocalTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalTime added = dt.plusHours(6);\n     * LocalTime added = dt.plus(Period.hours(6));\n     * LocalTime added = dt.withFieldAdded(DurationFieldType.hours(), 6);\n     * </pre>\n     *\n     * @param hours  the amount of hours to add, may be negative\n     * @return the new LocalTime plus the increased hours\n     */"}}
{"code": {"body": "public LocalTime plusMinutes(int minutes) {\n        if (minutes == 0) {\n            return this;\n        }\n        long instant = getChronology().minutes().add(getLocalMillis(), minutes);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this time plus the specified number of minutes.\n     * <p>\n     * This LocalTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalTime added = dt.plusMinutes(6);\n     * LocalTime added = dt.plus(Period.minutes(6));\n     * LocalTime added = dt.withFieldAdded(DurationFieldType.minutes(), 6);\n     * </pre>\n     *\n     * @param minutes  the amount of minutes to add, may be negative\n     * @return the new LocalTime plus the increased minutes\n     */"}}
{"code": {"body": "public LocalTime plusSeconds(int seconds) {\n        if (seconds == 0) {\n            return this;\n        }\n        long instant = getChronology().seconds().add(getLocalMillis(), seconds);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this time plus the specified number of seconds.\n     * <p>\n     * This LocalTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalTime added = dt.plusSeconds(6);\n     * LocalTime added = dt.plus(Period.seconds(6));\n     * LocalTime added = dt.withFieldAdded(DurationFieldType.seconds(), 6);\n     * </pre>\n     *\n     * @param seconds  the amount of seconds to add, may be negative\n     * @return the new LocalTime plus the increased seconds\n     */"}}
{"code": {"body": "public LocalTime plusMillis(int millis) {\n        if (millis == 0) {\n            return this;\n        }\n        long instant = getChronology().millis().add(getLocalMillis(), millis);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this time plus the specified number of millis.\n     * <p>\n     * This LocalTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalTime added = dt.plusMillis(6);\n     * LocalTime added = dt.plus(Period.millis(6));\n     * LocalTime added = dt.withFieldAdded(DurationFieldType.millis(), 6);\n     * </pre>\n     *\n     * @param millis  the amount of millis to add, may be negative\n     * @return the new LocalTime plus the increased millis\n     */"}}
{"code": {"body": "public LocalTime minus(ReadablePeriod period) {\n        return withPeriodAdded(period, -1);\n    }", "comment": "/**\n     * Returns a copy of this time with the specified period taken away.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to subtract complex period instances.\n     * Subtracting one field is best achieved using methods\n     * like {@link #minusHours(int)}.\n     * \n     * @param period  the period to reduce this instant by\n     * @return a copy of this time with the period taken away\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */"}}
{"code": {"body": "public LocalTime minusHours(int hours) {\n        if (hours == 0) {\n            return this;\n        }\n        long instant = getChronology().hours().subtract(getLocalMillis(), hours);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this time minus the specified number of hours.\n     * <p>\n     * This LocalTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalTime subtracted = dt.minusHours(6);\n     * LocalTime subtracted = dt.minus(Period.hours(6));\n     * LocalTime subtracted = dt.withFieldAdded(DurationFieldType.hours(), -6);\n     * </pre>\n     *\n     * @param hours  the amount of hours to subtract, may be negative\n     * @return the new LocalTime minus the increased hours\n     */"}}
{"code": {"body": "public LocalTime minusMinutes(int minutes) {\n        if (minutes == 0) {\n            return this;\n        }\n        long instant = getChronology().minutes().subtract(getLocalMillis(), minutes);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this time minus the specified number of minutes.\n     * <p>\n     * This LocalTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalTime subtracted = dt.minusMinutes(6);\n     * LocalTime subtracted = dt.minus(Period.minutes(6));\n     * LocalTime subtracted = dt.withFieldAdded(DurationFieldType.minutes(), -6);\n     * </pre>\n     *\n     * @param minutes  the amount of minutes to subtract, may be negative\n     * @return the new LocalTime minus the increased minutes\n     */"}}
{"code": {"body": "public LocalTime minusSeconds(int seconds) {\n        if (seconds == 0) {\n            return this;\n        }\n        long instant = getChronology().seconds().subtract(getLocalMillis(), seconds);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this time minus the specified number of seconds.\n     * <p>\n     * This LocalTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalTime subtracted = dt.minusSeconds(6);\n     * LocalTime subtracted = dt.minus(Period.seconds(6));\n     * LocalTime subtracted = dt.withFieldAdded(DurationFieldType.seconds(), -6);\n     * </pre>\n     *\n     * @param seconds  the amount of seconds to subtract, may be negative\n     * @return the new LocalTime minus the increased seconds\n     */"}}
{"code": {"body": "public LocalTime minusMillis(int millis) {\n        if (millis == 0) {\n            return this;\n        }\n        long instant = getChronology().millis().subtract(getLocalMillis(), millis);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this time minus the specified number of millis.\n     * <p>\n     * This LocalTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalTime subtracted = dt.minusMillis(6);\n     * LocalTime subtracted = dt.minus(Period.millis(6));\n     * LocalTime subtracted = dt.withFieldAdded(DurationFieldType.millis(), -6);\n     * </pre>\n     *\n     * @param millis  the amount of millis to subtract, may be negative\n     * @return the new LocalTime minus the increased millis\n     */"}}
{"code": {"body": "public LocalTime withHourOfDay(int hour) {\n        return withLocalMillis(getChronology().hourOfDay().set(getLocalMillis(), hour));\n    }", "comment": "/**\n     * Returns a copy of this time with the hour of day field updated.\n     * <p>\n     * LocalTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * hour of day changed.\n     *\n     * @param hour  the hour of day to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "public LocalTime withMinuteOfHour(int minute) {\n        return withLocalMillis(getChronology().minuteOfHour().set(getLocalMillis(), minute));\n    }", "comment": "/**\n     * Returns a copy of this time with the minute of hour field updated.\n     * <p>\n     * LocalTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * minute of hour changed.\n     *\n     * @param minute  the minute of hour to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "public LocalTime withSecondOfMinute(int second) {\n        return withLocalMillis(getChronology().secondOfMinute().set(getLocalMillis(), second));\n    }", "comment": "/**\n     * Returns a copy of this time with the second of minute field updated.\n     * <p>\n     * LocalTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * second of minute changed.\n     *\n     * @param second  the second of minute to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "public LocalTime withMillisOfSecond(int millis) {\n        return withLocalMillis(getChronology().millisOfSecond().set(getLocalMillis(), millis));\n    }", "comment": "/**\n     * Returns a copy of this time with the millis of second field updated.\n     * <p>\n     * LocalTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * millis of second changed.\n     *\n     * @param millis  the millis of second to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "public LocalTime withMillisOfDay(int millis) {\n        return withLocalMillis(getChronology().millisOfDay().set(getLocalMillis(), millis));\n    }", "comment": "/**\n     * Returns a copy of this time with the millis of day field updated.\n     * <p>\n     * LocalTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * millis of day changed.\n     *\n     * @param millis  the millis of day to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "public LocalTime getLocalTime() {\n            return iInstant;\n        }", "comment": "/**\n         * Gets the LocalTime object linked to this property.\n         * \n         * @return the linked LocalTime\n         */"}}
{"code": {"body": "public LocalTime addCopy(int value) {\n            return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value));\n        }", "comment": "/**\n         * Adds to this field in a copy of this LocalTime.\n         * <p>\n         * The LocalTime attached to this property is unchanged by this call.\n         *\n         * @param value  the value to add to the field in the copy\n         * @return a copy of the LocalTime with the field value changed\n         */"}}
{"code": {"body": "public LocalTime addCopy(long value) {\n            return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value));\n        }", "comment": "/**\n         * Adds to this field in a copy of this LocalTime.\n         * If the addition exceeds the maximum value (eg. 23:59) it will\n         * wrap to the minimum value (eg. 00:00).\n         * <p>\n         * The LocalTime attached to this property is unchanged by this call.\n         *\n         * @param value  the value to add to the field in the copy\n         * @return a copy of the LocalTime with the field value changed\n         */"}}
{"code": {"body": "public LocalTime addNoWrapToCopy(int value) {\n            long millis = iField.add(iInstant.getLocalMillis(), value);\n            long rounded = iInstant.getChronology().millisOfDay().get(millis);\n            if (rounded != millis) {\n                throw new IllegalArgumentException(\"\");\n            }\n            return iInstant.withLocalMillis(millis);\n        }", "comment": "/**\n         * Adds to this field in a copy of this LocalTime.\n         * If the addition exceeds the maximum value (eg. 23:59) then\n         * an exception will be thrown.\n         * Contrast this behaviour to {@link #addCopy(int)}.\n         * <p>\n         * The LocalTime attached to this property is unchanged by this call.\n         *\n         * @param value  the value to add to the field in the copy\n         * @return a copy of the LocalTime with the field value changed\n         * @throws IllegalArgumentException if the result is invalid\n         */"}}
{"code": {"body": "public LocalTime addWrapFieldToCopy(int value) {\n            return iInstant.withLocalMillis(iField.addWrapField(iInstant.getLocalMillis(), value));\n        }", "comment": "/**\n         * Adds to this field, possibly wrapped, in a copy of this LocalTime.\n         * A field wrapped operation only changes this field.\n         * Thus 10:59 plusWrapField one minute goes to 10:00.\n         * <p>\n         * The LocalTime attached to this property is unchanged by this call.\n         *\n         * @param value  the value to add to the field in the copy\n         * @return a copy of the LocalTime with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "public LocalTime setCopy(int value) {\n            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), value));\n        }", "comment": "/**\n         * Sets this field in a copy of the LocalTime.\n         * <p>\n         * The LocalTime attached to this property is unchanged by this call.\n         *\n         * @param value  the value to set the field in the copy to\n         * @return a copy of the LocalTime with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "public LocalTime setCopy(String text, Locale locale) {\n            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), text, locale));\n        }", "comment": "/**\n         * Sets this field in a copy of the LocalTime to a parsed text value.\n         * <p>\n         * The LocalTime attached to this property is unchanged by this call.\n         *\n         * @param text  the text value to set\n         * @param locale  optional locale to use for selecting a text symbol\n         * @return a copy of the LocalTime with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */"}}
{"code": {"body": "public LocalTime setCopy(String text) {\n            return setCopy(text, null);\n        }", "comment": "/**\n         * Sets this field in a copy of the LocalTime to a parsed text value.\n         * <p>\n         * The LocalTime attached to this property is unchanged by this call.\n         *\n         * @param text  the text value to set\n         * @return a copy of the LocalTime with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */"}}
{"code": {"body": "public LocalTime withMaximumValue() {\n            return setCopy(getMaximumValue());\n        }", "comment": "/**\n         * Returns a new LocalTime with this field set to the maximum value\n         * for this field.\n         * <p>\n         * The LocalTime attached to this property is unchanged by this call.\n         *\n         * @return a copy of the LocalTime with this field set to its maximum\n         */"}}
{"code": {"body": "public LocalTime withMinimumValue() {\n            return setCopy(getMinimumValue());\n        }", "comment": "/**\n         * Returns a new LocalTime with this field set to the minimum value\n         * for this field.\n         * <p>\n         * The LocalTime attached to this property is unchanged by this call.\n         *\n         * @return a copy of the LocalTime with this field set to its minimum\n         */"}}
{"code": {"body": "public LocalTime roundFloorCopy() {\n            return iInstant.withLocalMillis(iField.roundFloor(iInstant.getLocalMillis()));\n        }", "comment": "/**\n         * Rounds to the lowest whole unit of this field on a copy of this\n         * LocalTime.\n         * <p>\n         * For example, rounding floor on the hourOfDay field of a LocalTime\n         * where the time is 10:30 would result in new LocalTime with the\n         * time of 10:00.\n         *\n         * @return a copy of the LocalTime with the field value changed\n         */"}}
{"code": {"body": "public LocalTime roundCeilingCopy() {\n            return iInstant.withLocalMillis(iField.roundCeiling(iInstant.getLocalMillis()));\n        }", "comment": "/**\n         * Rounds to the highest whole unit of this field on a copy of this\n         * LocalTime.\n         * <p>\n         * For example, rounding floor on the hourOfDay field of a LocalTime\n         * where the time is 10:30 would result in new LocalTime with the\n         * time of 11:00.\n         *\n         * @return a copy of the LocalTime with the field value changed\n         */"}}
{"code": {"body": "public LocalTime roundHalfFloorCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfFloor(iInstant.getLocalMillis()));\n        }", "comment": "/**\n         * Rounds to the nearest whole unit of this field on a copy of this\n         * LocalTime, favoring the floor if halfway.\n         *\n         * @return a copy of the LocalTime with the field value changed\n         */"}}
{"code": {"body": "public LocalTime roundHalfCeilingCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfCeiling(iInstant.getLocalMillis()));\n        }", "comment": "/**\n         * Rounds to the nearest whole unit of this field on a copy of this\n         * LocalTime, favoring the ceiling if halfway.\n         *\n         * @return a copy of the LocalTime with the field value changed\n         */"}}
{"code": {"body": "public LocalTime roundHalfEvenCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfEven(iInstant.getLocalMillis()));\n        }", "comment": "/**\n         * Rounds to the nearest whole unit of this field on a copy of this\n         * LocalTime.  If halfway, the ceiling is favored over the floor\n         * only if it makes this field's value even.\n         *\n         * @return a copy of the LocalTime with the field value changed\n         */"}}
{"code": {"body": "    public static LocalTime now(Chronology chronology) {\n        if (chronology == null) {\n            throw new NullPointerException(\"\");\n        }\n        return new LocalTime(chronology);\n    }", "comment": "/**\n     * Obtains a {@code LocalTime} set to the current system millisecond time\n     * using the specified chronology.\n     * The resulting object does not use the zone.\n     *\n     * @param chronology  the chronology, not null\n     * @return the current time, not null\n     * @since 2.0\n     */"}}
{"code": {"body": "    public static LocalTime parse(String str, DateTimeFormatter formatter) {\n        return formatter.parseLocalTime(str);\n    }", "comment": "/**\n     * Parses a {@code LocalTime} from the specified string using a formatter.\n     * \n     * @param str  the string to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @since 2.0\n     */"}}
{"code": {"body": "    public static LocalTime fromMillisOfDay(long millisOfDay, Chronology chrono) {\n        chrono = DateTimeUtils.getChronology(chrono).withUTC();\n        return new LocalTime(millisOfDay, chrono);\n    }", "comment": "/**\n     * Constructs a LocalTime from the specified millis of day using the\n     * specified chronology.\n     * <p>\n     * The millisOfDay value may exceed the number of millis in one day,\n     * but additional days will be ignored.\n     * This method uses the UTC time zone internally.\n     *\n     * @param millisOfDay  the number of milliseconds into a day to convert\n     * @param chrono  the chronology, null means ISO chronology\n     */"}}
{"code": {"body": "    public static LocalTime fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        return new LocalTime(\n            calendar.get(Calendar.HOUR_OF_DAY),\n            calendar.get(Calendar.MINUTE),\n            calendar.get(Calendar.SECOND),\n            calendar.get(Calendar.MILLISECOND)\n        );\n    }", "comment": "/**\n     * Constructs a LocalTime from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalTime.\n     * This is useful if you have been using the Calendar as a local time,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalTime with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from\n     * @return the created LocalTime\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */"}}
{"code": {"body": "    private Object readResolve() {\n        if (iChronology == null) {\n            return new LocalTime(iLocalMillis, ISOChronology.getInstanceUTC());\n        }\n        if (DateTimeZone.UTC.equals(iChronology.getZone()) == false) {\n            return new LocalTime(iLocalMillis, iChronology.withUTC());\n        }\n        return this;\n    }", "comment": "/**\n     * Handle broken serialization from other tools.\n     * @return the resolved object, not null\n     */"}}
{"code": {"body": "    public int size() {\n        return 4;\n    }", "comment": "/**\n     * Gets the number of fields in this partial, which is four.\n     * The supported fields are HourOfDay, MinuteOfHour, SecondOfMinute\n     * and MillisOfSecond.\n     *\n     * @return the field count, four\n     */"}}
{"code": {"body": "        public DateTimeField getField() {\n            return iField;\n        }", "comment": "/**\n         * Gets the field being used.\n         * \n         * @return the field\n         */"}}
{"code": {"body": "    public int getValue(int index) {\n        switch (index) {\n            case HOUR_OF_DAY:\n                return getChronology().hourOfDay().get(getLocalMillis());\n            case MINUTE_OF_HOUR:\n                return getChronology().minuteOfHour().get(getLocalMillis());\n            case SECOND_OF_MINUTE:\n                return getChronology().secondOfMinute().get(getLocalMillis());\n            case MILLIS_OF_SECOND:\n                return getChronology().millisOfSecond().get(getLocalMillis());\n            default:\n                throw new IndexOutOfBoundsException(\"\" + index);\n        }\n    }", "comment": "/**\n     * Gets the value of the field at the specifed index.\n     * <p>\n     * This method is required to support the <code>ReadablePartial</code>\n     * interface. The supported fields are HourOfDay, MinuteOfHour,\n     * SecondOfMinute and MillisOfSecond.\n     *\n     * @param index  the index, zero to three\n     * @return the value\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */"}}
{"code": {"body": "    public int get(DateTimeFieldType fieldType) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (isSupported(fieldType) == false) {\n            throw new IllegalArgumentException(\"\" + fieldType + \"\");\n        }\n        return fieldType.getField(getChronology()).get(getLocalMillis());\n    }", "comment": "/**\n     * Get the value of one of the fields of time.\n     * <p>\n     * This method gets the value of the specified field.\n     * For example:\n     * <pre>\n     * DateTime dt = new DateTime();\n     * int hourOfDay = dt.get(DateTimeFieldType.hourOfDay());\n     * </pre>\n     *\n     * @param fieldType  a field type, usually obtained from DateTimeFieldType, not null\n     * @return the value of that field\n     * @throws IllegalArgumentException if the field type is null\n     */"}}
{"code": {"body": "    public boolean isSupported(DurationFieldType type) {\n        if (type == null) {\n            return false;\n        }\n        DurationField field = type.getField(getChronology());\n        if (TIME_DURATION_TYPES.contains(type) ||\n            field.getUnitMillis() < getChronology().days().getUnitMillis()) {\n            return field.isSupported();\n        }\n        return false;\n    }", "comment": "/**\n     * Checks if the duration type specified is supported by this\n     * local time and chronology.\n     *\n     * @param type  a duration type, usually obtained from DurationFieldType\n     * @return true if the field type is supported\n     */"}}
{"code": {"body": "    protected long getLocalMillis() {\n        return iLocalMillis;\n    }", "comment": "/**\n     * Gets the local milliseconds from the Java epoch\n     * of 1970-01-01T00:00:00 (not fixed to any specific time zone).\n     * \n     * @return the number of milliseconds since 1970-01-01T00:00:00\n     * @since 1.5 (previously private)\n     */"}}
{"code": {"body": "        protected Chronology getChronology() {\n            return iInstant.getChronology();\n        }", "comment": "/**\n         * Gets the chronology of the datetime that this property is linked to.\n         * \n         * @return the chronology\n         * @since 1.4\n         */"}}
{"code": {"body": "    public boolean equals(Object partial) {\n        \n        if (this == partial) {\n            return true;\n        }\n        if (partial instanceof LocalTime) {\n            LocalTime other = (LocalTime) partial;\n            if (iChronology.equals(other.iChronology)) {\n                return iLocalMillis == other.iLocalMillis;\n            }\n        }\n        return super.equals(partial);\n    }", "comment": "/**\n     * Compares this ReadablePartial with another returning true if the chronology,\n     * field types and values are equal.\n     *\n     * @param partial  an object to check against\n     * @return true if fields and values are equal\n     */"}}
{"code": {"body": "    public int compareTo(ReadablePartial partial) {\n        \n        if (this == partial) {\n            return 0;\n        }\n        if (partial instanceof LocalTime) {\n            LocalTime other = (LocalTime) partial;\n            if (iChronology.equals(other.iChronology)) {\n                return (iLocalMillis < other.iLocalMillis ? -1 :\n                            (iLocalMillis == other.iLocalMillis ? 0 : 1));\n\n            }\n        }\n        return super.compareTo(partial);\n    }", "comment": "/**\n     * Compares this partial with another returning an integer\n     * indicating the order.\n     * <p>\n     * The fields are compared in order, from largest to smallest.\n     * The first field that is non-equal is used to determine the result.\n     * <p>\n     * The specified object must be a partial instance whose field types\n     * match those of this partial.\n     *\n     * @param partial  an object to check against\n     * @return negative if this is less, zero if equal, positive if greater\n     * @throws ClassCastException if the partial is the wrong class\n     *  or if it has field types that don't match\n     * @throws NullPointerException if the partial is null\n     */"}}
{"code": {"body": "    LocalTime withLocalMillis(long newMillis) {\n        return (newMillis == getLocalMillis() ? this : new LocalTime(newMillis, getChronology()));\n    }", "comment": "/**\n     * Returns a copy of this time with different local millis.\n     * <p>\n     * The returned object will be a new instance of the same type.\n     * Only the millis will change, the chronology is kept.\n     * The returned object will be either be a new instance or <code>this</code>.\n     *\n     * @param newMillis  the new millis, from 1970-01-01T00:00:00\n     * @return a copy of this time with different millis\n     */"}}
{"code": {"body": "    public LocalTime withFields(ReadablePartial partial) {\n        if (partial == null) {\n            return this;\n        }\n        return withLocalMillis(getChronology().set(partial, getLocalMillis()));\n    }", "comment": "/**\n     * Returns a copy of this time with the partial set of fields replacing\n     * those from this instance.\n     * <p>\n     * For example, if the partial contains an hour and minute then those two\n     * fields will be changed in the returned instance.\n     * Unsupported fields are ignored.\n     * If the partial is null, then <code>this</code> is returned.\n     *\n     * @param partial  the partial set of fields to apply to this time, null ignored\n     * @return a copy of this time with a different set of fields\n     * @throws IllegalArgumentException if any value is invalid\n     */"}}
{"code": {"body": "    public LocalTime withField(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (isSupported(fieldType) == false) {\n            throw new IllegalArgumentException(\"\" + fieldType + \"\");\n        }\n        long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this time with the specified field set\n     * to a new value.\n     * <p>\n     * For example, if the field type is <code>hourOfDay</code> then the hour of day\n     * field would be changed in the returned instance.\n     * If the field type is null, then <code>this</code> is returned.\n     * <p>\n     * These lines are equivalent:\n     * <pre>\n     * LocalTime updated = dt.withHourOfDay(6);\n     * LocalTime updated = dt.withField(DateTimeFieldType.hourOfDay(), 6);\n     * </pre>\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this time with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     */"}}
{"code": {"body": "    public LocalTime withFieldAdded(DurationFieldType fieldType, int amount) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (isSupported(fieldType) == false) {\n            throw new IllegalArgumentException(\"\" + fieldType + \"\");\n        }\n        if (amount == 0) {\n            return this;\n        }\n        long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this time with the value of the specified\n     * field increased.\n     * <p>\n     * If the addition is zero or the field is null, then <code>this</code>\n     * is returned.\n     * <p>\n     * If the addition causes the maximum value of the field to be exceeded,\n     * then the value will wrap. Thus 23:59 plus two minutes yields 00:01.\n     * <p>\n     * These lines are equivalent:\n     * <pre>\n     * LocalTime added = dt.plusHours(6);\n     * LocalTime added = dt.withFieldAdded(DurationFieldType.hours(), 6);\n     * </pre>\n     *\n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this time with the field updated\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */"}}
{"code": {"body": "    public LocalTime withPeriodAdded(ReadablePeriod period, int scalar) {\n        if (period == null || scalar == 0) {\n            return this;\n        }\n        long instant = getChronology().add(period, getLocalMillis(), scalar);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this time with the specified period added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to add multiple copies of complex\n     * period instances. Adding one field is best achieved using methods\n     * like {@link #withFieldAdded(DurationFieldType, int)}\n     * or {@link #plusHours(int)}.\n     *\n     * @param period  the period to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this time with the period added\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */"}}
{"code": {"body": "    public LocalTime plus(ReadablePeriod period) {\n        return withPeriodAdded(period, 1);\n    }", "comment": "/**\n     * Returns a copy of this time with the specified period added.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to add complex period instances.\n     * Adding one field is best achieved using methods\n     * like {@link #plusHours(int)}.\n     * \n     * @param period  the period to add to this one, null means zero\n     * @return a copy of this time with the period added\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */"}}
{"code": {"body": "    public LocalTime plusHours(int hours) {\n        if (hours == 0) {\n            return this;\n        }\n        long instant = getChronology().hours().add(getLocalMillis(), hours);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this time plus the specified number of hours.\n     * <p>\n     * This LocalTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalTime added = dt.plusHours(6);\n     * LocalTime added = dt.plus(Period.hours(6));\n     * LocalTime added = dt.withFieldAdded(DurationFieldType.hours(), 6);\n     * </pre>\n     *\n     * @param hours  the amount of hours to add, may be negative\n     * @return the new LocalTime plus the increased hours\n     */"}}
{"code": {"body": "    public LocalTime plusMinutes(int minutes) {\n        if (minutes == 0) {\n            return this;\n        }\n        long instant = getChronology().minutes().add(getLocalMillis(), minutes);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this time plus the specified number of minutes.\n     * <p>\n     * This LocalTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalTime added = dt.plusMinutes(6);\n     * LocalTime added = dt.plus(Period.minutes(6));\n     * LocalTime added = dt.withFieldAdded(DurationFieldType.minutes(), 6);\n     * </pre>\n     *\n     * @param minutes  the amount of minutes to add, may be negative\n     * @return the new LocalTime plus the increased minutes\n     */"}}
{"code": {"body": "    public LocalTime plusSeconds(int seconds) {\n        if (seconds == 0) {\n            return this;\n        }\n        long instant = getChronology().seconds().add(getLocalMillis(), seconds);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this time plus the specified number of seconds.\n     * <p>\n     * This LocalTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalTime added = dt.plusSeconds(6);\n     * LocalTime added = dt.plus(Period.seconds(6));\n     * LocalTime added = dt.withFieldAdded(DurationFieldType.seconds(), 6);\n     * </pre>\n     *\n     * @param seconds  the amount of seconds to add, may be negative\n     * @return the new LocalTime plus the increased seconds\n     */"}}
{"code": {"body": "    public LocalTime plusMillis(int millis) {\n        if (millis == 0) {\n            return this;\n        }\n        long instant = getChronology().millis().add(getLocalMillis(), millis);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this time plus the specified number of millis.\n     * <p>\n     * This LocalTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalTime added = dt.plusMillis(6);\n     * LocalTime added = dt.plus(Period.millis(6));\n     * LocalTime added = dt.withFieldAdded(DurationFieldType.millis(), 6);\n     * </pre>\n     *\n     * @param millis  the amount of millis to add, may be negative\n     * @return the new LocalTime plus the increased millis\n     */"}}
{"code": {"body": "    public LocalTime minus(ReadablePeriod period) {\n        return withPeriodAdded(period, -1);\n    }", "comment": "/**\n     * Returns a copy of this time with the specified period taken away.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to subtract complex period instances.\n     * Subtracting one field is best achieved using methods\n     * like {@link #minusHours(int)}.\n     * \n     * @param period  the period to reduce this instant by\n     * @return a copy of this time with the period taken away\n     * @throws ArithmeticException if the result exceeds the internal capacity\n     */"}}
{"code": {"body": "    public LocalTime minusHours(int hours) {\n        if (hours == 0) {\n            return this;\n        }\n        long instant = getChronology().hours().subtract(getLocalMillis(), hours);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this time minus the specified number of hours.\n     * <p>\n     * This LocalTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalTime subtracted = dt.minusHours(6);\n     * LocalTime subtracted = dt.minus(Period.hours(6));\n     * LocalTime subtracted = dt.withFieldAdded(DurationFieldType.hours(), -6);\n     * </pre>\n     *\n     * @param hours  the amount of hours to subtract, may be negative\n     * @return the new LocalTime minus the increased hours\n     */"}}
{"code": {"body": "    public LocalTime minusMinutes(int minutes) {\n        if (minutes == 0) {\n            return this;\n        }\n        long instant = getChronology().minutes().subtract(getLocalMillis(), minutes);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this time minus the specified number of minutes.\n     * <p>\n     * This LocalTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalTime subtracted = dt.minusMinutes(6);\n     * LocalTime subtracted = dt.minus(Period.minutes(6));\n     * LocalTime subtracted = dt.withFieldAdded(DurationFieldType.minutes(), -6);\n     * </pre>\n     *\n     * @param minutes  the amount of minutes to subtract, may be negative\n     * @return the new LocalTime minus the increased minutes\n     */"}}
{"code": {"body": "    public LocalTime minusSeconds(int seconds) {\n        if (seconds == 0) {\n            return this;\n        }\n        long instant = getChronology().seconds().subtract(getLocalMillis(), seconds);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this time minus the specified number of seconds.\n     * <p>\n     * This LocalTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalTime subtracted = dt.minusSeconds(6);\n     * LocalTime subtracted = dt.minus(Period.seconds(6));\n     * LocalTime subtracted = dt.withFieldAdded(DurationFieldType.seconds(), -6);\n     * </pre>\n     *\n     * @param seconds  the amount of seconds to subtract, may be negative\n     * @return the new LocalTime minus the increased seconds\n     */"}}
{"code": {"body": "    public LocalTime minusMillis(int millis) {\n        if (millis == 0) {\n            return this;\n        }\n        long instant = getChronology().millis().subtract(getLocalMillis(), millis);\n        return withLocalMillis(instant);\n    }", "comment": "/**\n     * Returns a copy of this time minus the specified number of millis.\n     * <p>\n     * This LocalTime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * LocalTime subtracted = dt.minusMillis(6);\n     * LocalTime subtracted = dt.minus(Period.millis(6));\n     * LocalTime subtracted = dt.withFieldAdded(DurationFieldType.millis(), -6);\n     * </pre>\n     *\n     * @param millis  the amount of millis to subtract, may be negative\n     * @return the new LocalTime minus the increased millis\n     */"}}
{"code": {"body": "    public Property property(DateTimeFieldType fieldType) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (isSupported(fieldType) == false) {\n            throw new IllegalArgumentException(\"\" + fieldType + \"\");\n        }\n        return new Property(this, fieldType.getField(getChronology()));\n    }", "comment": "/**\n     * Gets the property object for the specified type, which contains\n     * many useful methods.\n     *\n     * @param fieldType  the field type to get the chronology for\n     * @return the property object\n     * @throws IllegalArgumentException if the field is null or unsupported\n     */"}}
{"code": {"body": "    public int getHourOfDay() {\n        return getChronology().hourOfDay().get(getLocalMillis());\n    }", "comment": "/**\n     * Get the hour of day field value.\n     *\n     * @return the hour of day\n     */"}}
{"code": {"body": "    public int getMinuteOfHour() {\n        return getChronology().minuteOfHour().get(getLocalMillis());\n    }", "comment": "/**\n     * Get the minute of hour field value.\n     *\n     * @return the minute of hour\n     */"}}
{"code": {"body": "    public int getSecondOfMinute() {\n        return getChronology().secondOfMinute().get(getLocalMillis());\n    }", "comment": "/**\n     * Get the second of minute field value.\n     *\n     * @return the second of minute\n     */"}}
{"code": {"body": "    public int getMillisOfSecond() {\n        return getChronology().millisOfSecond().get(getLocalMillis());\n    }", "comment": "/**\n     * Get the millis of second field value.\n     *\n     * @return the millis of second\n     */"}}
{"code": {"body": "    public int getMillisOfDay() {\n        return getChronology().millisOfDay().get(getLocalMillis());\n    }", "comment": "/**\n     * Get the millis of day field value.\n     *\n     * @return the millis of day\n     */"}}
{"code": {"body": "    public LocalTime withHourOfDay(int hour) {\n        return withLocalMillis(getChronology().hourOfDay().set(getLocalMillis(), hour));\n    }", "comment": "/**\n     * Returns a copy of this time with the hour of day field updated.\n     * <p>\n     * LocalTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * hour of day changed.\n     *\n     * @param hour  the hour of day to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public LocalTime withMinuteOfHour(int minute) {\n        return withLocalMillis(getChronology().minuteOfHour().set(getLocalMillis(), minute));\n    }", "comment": "/**\n     * Returns a copy of this time with the minute of hour field updated.\n     * <p>\n     * LocalTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * minute of hour changed.\n     *\n     * @param minute  the minute of hour to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public LocalTime withSecondOfMinute(int second) {\n        return withLocalMillis(getChronology().secondOfMinute().set(getLocalMillis(), second));\n    }", "comment": "/**\n     * Returns a copy of this time with the second of minute field updated.\n     * <p>\n     * LocalTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * second of minute changed.\n     *\n     * @param second  the second of minute to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public LocalTime withMillisOfSecond(int millis) {\n        return withLocalMillis(getChronology().millisOfSecond().set(getLocalMillis(), millis));\n    }", "comment": "/**\n     * Returns a copy of this time with the millis of second field updated.\n     * <p>\n     * LocalTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * millis of second changed.\n     *\n     * @param millis  the millis of second to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public LocalTime withMillisOfDay(int millis) {\n        return withLocalMillis(getChronology().millisOfDay().set(getLocalMillis(), millis));\n    }", "comment": "/**\n     * Returns a copy of this time with the millis of day field updated.\n     * <p>\n     * LocalTime is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * millis of day changed.\n     *\n     * @param millis  the millis of day to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public Property hourOfDay() {\n        return new Property(this, getChronology().hourOfDay());\n    }", "comment": "/**\n     * Get the hour of day field property which provides access to advanced functionality.\n     * \n     * @return the hour of day property\n     */"}}
{"code": {"body": "    public Property minuteOfHour() {\n        return new Property(this, getChronology().minuteOfHour());\n    }", "comment": "/**\n     * Get the minute of hour field property which provides access to advanced functionality.\n     * \n     * @return the minute of hour property\n     */"}}
{"code": {"body": "    public Property secondOfMinute() {\n        return new Property(this, getChronology().secondOfMinute());\n    }", "comment": "/**\n     * Get the second of minute field property which provides access to advanced functionality.\n     * \n     * @return the second of minute property\n     */"}}
{"code": {"body": "    public Property millisOfSecond() {\n        return new Property(this, getChronology().millisOfSecond());\n    }", "comment": "/**\n     * Get the millis of second property which provides access to advanced functionality.\n     * \n     * @return the millis of second property\n     */"}}
{"code": {"body": "    public Property millisOfDay() {\n        return new Property(this, getChronology().millisOfDay());\n    }", "comment": "/**\n     * Get the millis of day property which provides access to advanced functionality.\n     * \n     * @return the millis of day property\n     */"}}
{"code": {"body": "    public DateTime toDateTimeToday(DateTimeZone zone) {\n        Chronology chrono = getChronology().withZone(zone);\n        long instantMillis = DateTimeUtils.currentTimeMillis();\n        long resolved = chrono.set(this, instantMillis);\n        return new DateTime(resolved, chrono);\n    }", "comment": "/**\n     * Converts this LocalTime to a full datetime using the specified time zone\n     * setting the time fields from this instance and the date fields from\n     * the current time.\n     * <p>\n     * This method uses the chronology from this instance plus the time zone\n     * specified.\n     *\n     * @param zone  the zone to use, null means default\n     * @return this time as a datetime using todays date\n     */"}}
{"code": {"body": "    public String toString(String pattern, Locale locale) throws IllegalArgumentException {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n    }", "comment": "/**\n     * Output the time using the specified format pattern.\n     *\n     * @param pattern  the pattern specification, null means use <code>toString</code>\n     * @param locale  Locale to use, null means default\n     * @see org.joda.time.format.DateTimeFormat\n     */"}}
{"code": {"body": "        private void writeObject(ObjectOutputStream oos) throws IOException {\n            oos.writeObject(iInstant);\n            oos.writeObject(iField.getType());\n        }", "comment": "/**\n         * Writes the property in a safe serialization format.\n         */"}}
{"code": {"body": "        private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {\n            iInstant = (LocalTime) oos.readObject();\n            DateTimeFieldType type = (DateTimeFieldType) oos.readObject();\n            iField = type.getField(iInstant.getChronology());\n        }", "comment": "/**\n         * Reads the property from a safe serialization format.\n         */"}}
{"code": {"body": "        protected long getMillis() {\n            return iInstant.getLocalMillis();\n        }", "comment": "/**\n         * Gets the milliseconds of the time that this property is linked to.\n         * \n         * @return the milliseconds\n         */"}}
{"code": {"body": "        public LocalTime getLocalTime() {\n            return iInstant;\n        }", "comment": "/**\n         * Gets the LocalTime object linked to this property.\n         * \n         * @return the linked LocalTime\n         */"}}
{"code": {"body": "        public LocalTime addCopy(long value) {\n            return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value));\n        }", "comment": "/**\n         * Adds to this field in a copy of this LocalTime.\n         * If the addition exceeds the maximum value (eg. 23:59) it will\n         * wrap to the minimum value (eg. 00:00).\n         * <p>\n         * The LocalTime attached to this property is unchanged by this call.\n         *\n         * @param value  the value to add to the field in the copy\n         * @return a copy of the LocalTime with the field value changed\n         */"}}
{"code": {"body": "        public LocalTime addNoWrapToCopy(int value) {\n            long millis = iField.add(iInstant.getLocalMillis(), value);\n            long rounded = iInstant.getChronology().millisOfDay().get(millis);\n            if (rounded != millis) {\n                throw new IllegalArgumentException(\"\");\n            }\n            return iInstant.withLocalMillis(millis);\n        }", "comment": "/**\n         * Adds to this field in a copy of this LocalTime.\n         * If the addition exceeds the maximum value (eg. 23:59) then\n         * an exception will be thrown.\n         * Contrast this behaviour to {@link #addCopy(int)}.\n         * <p>\n         * The LocalTime attached to this property is unchanged by this call.\n         *\n         * @param value  the value to add to the field in the copy\n         * @return a copy of the LocalTime with the field value changed\n         * @throws IllegalArgumentException if the result is invalid\n         */"}}
{"code": {"body": "        public LocalTime addWrapFieldToCopy(int value) {\n            return iInstant.withLocalMillis(iField.addWrapField(iInstant.getLocalMillis(), value));\n        }", "comment": "/**\n         * Adds to this field, possibly wrapped, in a copy of this LocalTime.\n         * A field wrapped operation only changes this field.\n         * Thus 10:59 plusWrapField one minute goes to 10:00.\n         * <p>\n         * The LocalTime attached to this property is unchanged by this call.\n         *\n         * @param value  the value to add to the field in the copy\n         * @return a copy of the LocalTime with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "        public LocalTime setCopy(String text) {\n            return setCopy(text, null);\n        }", "comment": "/**\n         * Sets this field in a copy of the LocalTime to a parsed text value.\n         * <p>\n         * The LocalTime attached to this property is unchanged by this call.\n         *\n         * @param text  the text value to set\n         * @return a copy of the LocalTime with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */"}}
{"code": {"body": "        public LocalTime withMaximumValue() {\n            return setCopy(getMaximumValue());\n        }", "comment": "/**\n         * Returns a new LocalTime with this field set to the maximum value\n         * for this field.\n         * <p>\n         * The LocalTime attached to this property is unchanged by this call.\n         *\n         * @return a copy of the LocalTime with this field set to its maximum\n         */"}}
{"code": {"body": "        public LocalTime withMinimumValue() {\n            return setCopy(getMinimumValue());\n        }", "comment": "/**\n         * Returns a new LocalTime with this field set to the minimum value\n         * for this field.\n         * <p>\n         * The LocalTime attached to this property is unchanged by this call.\n         *\n         * @return a copy of the LocalTime with this field set to its minimum\n         */"}}
{"code": {"body": "        public LocalTime roundFloorCopy() {\n            return iInstant.withLocalMillis(iField.roundFloor(iInstant.getLocalMillis()));\n        }", "comment": "/**\n         * Rounds to the lowest whole unit of this field on a copy of this\n         * LocalTime.\n         * <p>\n         * For example, rounding floor on the hourOfDay field of a LocalTime\n         * where the time is 10:30 would result in new LocalTime with the\n         * time of 10:00.\n         *\n         * @return a copy of the LocalTime with the field value changed\n         */"}}
{"code": {"body": "        public LocalTime roundCeilingCopy() {\n            return iInstant.withLocalMillis(iField.roundCeiling(iInstant.getLocalMillis()));\n        }", "comment": "/**\n         * Rounds to the highest whole unit of this field on a copy of this\n         * LocalTime.\n         * <p>\n         * For example, rounding floor on the hourOfDay field of a LocalTime\n         * where the time is 10:30 would result in new LocalTime with the\n         * time of 11:00.\n         *\n         * @return a copy of the LocalTime with the field value changed\n         */"}}
{"code": {"body": "        public LocalTime roundHalfFloorCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfFloor(iInstant.getLocalMillis()));\n        }", "comment": "/**\n         * Rounds to the nearest whole unit of this field on a copy of this\n         * LocalTime, favoring the floor if halfway.\n         *\n         * @return a copy of the LocalTime with the field value changed\n         */"}}
{"code": {"body": "        public LocalTime roundHalfCeilingCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfCeiling(iInstant.getLocalMillis()));\n        }", "comment": "/**\n         * Rounds to the nearest whole unit of this field on a copy of this\n         * LocalTime, favoring the ceiling if halfway.\n         *\n         * @return a copy of the LocalTime with the field value changed\n         */"}}
{"code": {"body": "        public LocalTime roundHalfEvenCopy() {\n            return iInstant.withLocalMillis(iField.roundHalfEven(iInstant.getLocalMillis()));\n        }", "comment": "/**\n         * Rounds to the nearest whole unit of this field on a copy of this\n         * LocalTime.  If halfway, the ceiling is favored over the floor\n         * only if it makes this field's value even.\n         *\n         * @return a copy of the LocalTime with the field value changed\n         */"}}
{"code": {"body": "public Minutes plus(int minutes) {\n        if (minutes == 0) {\n            return this;\n        }\n        return Minutes.minutes(FieldUtils.safeAdd(getValue(), minutes));\n    }", "comment": "/**\n     * Returns a new instance with the specified number of minutes added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the amount of minutes to add, may be negative\n     * @return the new period plus the specified number of minutes\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "public Minutes plus(Minutes minutes) {\n        if (minutes == null) {\n            return this;\n        }\n        return plus(minutes.getValue());\n    }", "comment": "/**\n     * Returns a new instance with the specified number of minutes added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the amount of minutes to add, may be negative, null means zero\n     * @return the new period plus the specified number of minutes\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "public Minutes minus(int minutes) {\n        return plus(FieldUtils.safeNegate(minutes));\n    }", "comment": "/**\n     * Returns a new instance with the specified number of minutes taken away.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the amount of minutes to take away, may be negative\n     * @return the new period minus the specified number of minutes\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "public Minutes minus(Minutes minutes) {\n        if (minutes == null) {\n            return this;\n        }\n        return minus(minutes.getValue());\n    }", "comment": "/**\n     * Returns a new instance with the specified number of minutes taken away.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the amount of minutes to take away, may be negative, null means zero\n     * @return the new period minus the specified number of minutes\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "public Minutes multipliedBy(int scalar) {\n        return Minutes.minutes(FieldUtils.safeMultiply(getValue(), scalar));\n    }", "comment": "/**\n     * Returns a new instance with the minutes multiplied by the specified scalar.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param scalar  the amount to multiply by, may be negative\n     * @return the new period multiplied by the specified scalar\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "public Minutes dividedBy(int divisor) {\n        if (divisor == 1) {\n            return this;\n        }\n        return Minutes.minutes(getValue() / divisor);\n    }", "comment": "/**\n     * Returns a new instance with the minutes divided by the specified divisor.\n     * The calculation uses integer division, thus 3 divided by 2 is 1.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param divisor  the amount to divide by, may be negative\n     * @return the new period divided by the specified divisor\n     * @throws ArithmeticException if the divisor is zero\n     */"}}
{"code": {"body": "public Minutes negated() {\n        return Minutes.minutes(FieldUtils.safeNegate(getValue()));\n    }", "comment": "/**\n     * Returns a new instance with the minutes value negated.\n     *\n     * @return the new period with a negated value\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "    public static Minutes minutes(int minutes) {\n        switch (minutes) {\n            case 0:\n                return ZERO;\n            case 1:\n                return ONE;\n            case 2:\n                return TWO;\n            case 3:\n                return THREE;\n            case Integer.MAX_VALUE:\n                return MAX_VALUE;\n            case Integer.MIN_VALUE:\n                return MIN_VALUE;\n            default:\n                return new Minutes(minutes);\n        }\n    }", "comment": "/**\n     * Obtains an instance of <code>Minutes</code> that may be cached.\n     * <code>Minutes</code> is immutable, so instances can be cached and shared.\n     * This factory method provides access to shared instances.\n     *\n     * @param minutes  the number of minutes to obtain an instance for\n     * @return the instance of Minutes\n     */"}}
{"code": {"body": "    public static Minutes minutesBetween(ReadablePartial start, ReadablePartial end) {\n        if (start instanceof LocalTime && end instanceof LocalTime)   {\n            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n            int minutes = chrono.minutes().getDifference(\n                    ((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis());\n            return Minutes.minutes(minutes);\n        }\n        int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\n        return Minutes.minutes(amount);\n    }", "comment": "/**\n     * Creates a <code>Minutes</code> representing the number of whole minutes\n     * between the two specified partial datetimes.\n     * <p>\n     * The two partials must contain the same fields, for example you can specify\n     * two <code>LocalTime</code> objects.\n     *\n     * @param start  the start partial date, must not be null\n     * @param end  the end partial date, must not be null\n     * @return the period in minutes\n     * @throws IllegalArgumentException if the partials are null or invalid\n     */"}}
{"code": {"body": "    public static Minutes minutesIn(ReadableInterval interval) {\n        if (interval == null)   {\n            return Minutes.ZERO;\n        }\n        int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.minutes());\n        return Minutes.minutes(amount);\n    }", "comment": "/**\n     * Creates a <code>Minutes</code> representing the number of whole minutes\n     * in the specified interval.\n     *\n     * @param interval  the interval to extract minutes from, null returns zero\n     * @return the period in minutes\n     * @throws IllegalArgumentException if the partials are null or invalid\n     */"}}
{"code": {"body": "    public static Minutes standardMinutesIn(ReadablePeriod period) {\n        int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_MINUTE);\n        return Minutes.minutes(amount);\n    }", "comment": "/**\n     * Creates a new <code>Minutes</code> representing the number of complete\n     * standard length minutes in the specified period.\n     * <p>\n     * This factory method converts all fields from the period to minutes using standardised\n     * durations for each field. Only those fields which have a precise duration in\n     * the ISO UTC chronology can be converted.\n     * <ul>\n     * <li>One week consists of 7 days.\n     * <li>One day consists of 24 hours.\n     * <li>One hour consists of 60 minutes.\n     * <li>One minute consists of 60 seconds.\n     * <li>One second consists of 1000 milliseconds.\n     * </ul>\n     * Months and Years are imprecise and periods containing these values cannot be converted.\n     *\n     * @param period  the period to get the number of minutes from, null returns zero\n     * @return the period in minutes\n     * @throws IllegalArgumentException if the period contains imprecise duration values\n     */"}}
{"code": {"body": "    private Object readResolve() {\n        return Minutes.minutes(getValue());\n    }", "comment": "/**\n     * Resolves singletons.\n     * \n     * @return the singleton instance\n     */"}}
{"code": {"body": "    public DurationFieldType getFieldType() {\n        return DurationFieldType.minutes();\n    }", "comment": "/**\n     * Gets the duration field type, which is <code>minutes</code>.\n     *\n     * @return the period type\n     */"}}
{"code": {"body": "    public PeriodType getPeriodType() {\n        return PeriodType.minutes();\n    }", "comment": "/**\n     * Gets the period type, which is <code>minutes</code>.\n     *\n     * @return the period type\n     */"}}
{"code": {"body": "    public Weeks toStandardWeeks() {\n        return Weeks.weeks(getValue() / DateTimeConstants.MINUTES_PER_WEEK);\n    }", "comment": "/**\n     * Converts this period in minutes to a period in weeks assuming a\n     * 7 days week, 24 hour day and 60 minute hour.\n     * <p>\n     * This method allows you to convert between different types of period.\n     * However to achieve this it makes the assumption that all weeks are\n     * 7 days long, all days are 24 hours long and all hours are 60 minutes long.\n     * This is not true when daylight savings is considered and may also not\n     * be true for some unusual chronologies. However, it is included\n     * as it is a useful operation for many applications and business rules.\n     * \n     * @return a period representing the number of whole weeks for this number of minutes\n     */"}}
{"code": {"body": "    public Days toStandardDays() {\n        return Days.days(getValue() / DateTimeConstants.MINUTES_PER_DAY);\n    }", "comment": "/**\n     * Converts this period in minutes to a period in days assuming a\n     * 24 hour day and 60 minute hour.\n     * <p>\n     * This method allows you to convert between different types of period.\n     * However to achieve this it makes the assumption that all days are\n     * 24 hours long and all hours are 60 minutes long.\n     * This is not true when daylight savings is considered and may also not\n     * be true for some unusual chronologies. However, it is included\n     * as it is a useful operation for many applications and business rules.\n     * \n     * @return a period representing the number of whole days for this number of minutes\n     */"}}
{"code": {"body": "    public Hours toStandardHours() {\n        return Hours.hours(getValue() / DateTimeConstants.MINUTES_PER_HOUR);\n    }", "comment": "/**\n     * Converts this period in minutes to a period in hours assuming a\n     * 60 minute hour.\n     * <p>\n     * This method allows you to convert between different types of period.\n     * However to achieve this it makes the assumption that all hours are\n     * 60 minutes long.\n     * This may not be true for some unusual chronologies. However, it is included\n     * as it is a useful operation for many applications and business rules.\n     * \n     * @return a period representing the number of hours for this number of minutes\n     */"}}
{"code": {"body": "    public Seconds toStandardSeconds() {\n        return Seconds.seconds(FieldUtils.safeMultiply(getValue(), DateTimeConstants.SECONDS_PER_MINUTE));\n    }", "comment": "/**\n     * Converts this period in minutes to a period in seconds assuming a\n     * 60 second minute.\n     * <p>\n     * This method allows you to convert between different types of period.\n     * However to achieve this it makes the assumption that all minutes are\n     * 60 seconds long.\n     * This may not be true for some unusual chronologies. However, it is included\n     * as it is a useful operation for many applications and business rules.\n     * \n     * @return a period representing the number of seconds for this number of minutes\n     * @throws ArithmeticException if the number of seconds is too large to be represented\n     */"}}
{"code": {"body": "    public Duration toStandardDuration() {\n        long minutes = getValue();  \n        return new Duration(minutes * DateTimeConstants.MILLIS_PER_MINUTE);\n    }", "comment": "/**\n     * Converts this period in minutes to a duration in milliseconds assuming a\n     * 60 second minute.\n     * <p>\n     * This method allows you to convert from a period to a duration.\n     * However to achieve this it makes the assumption that all minutes are\n     * 60 seconds long. This might not be true for an unusual chronology,\n     * for example one that takes leap seconds into account.\n     * However, the method is included as it is a useful operation for many\n     * applications and business rules.\n     *\n     * @return a duration equivalent to this number of minutes\n     */"}}
{"code": {"body": "    public int getMinutes() {\n        return getValue();\n    }", "comment": "/**\n     * Gets the number of minutes that this period represents.\n     *\n     * @return the number of minutes in the period\n     */"}}
{"code": {"body": "    public Minutes plus(Minutes minutes) {\n        if (minutes == null) {\n            return this;\n        }\n        return plus(minutes.getValue());\n    }", "comment": "/**\n     * Returns a new instance with the specified number of minutes added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the amount of minutes to add, may be negative, null means zero\n     * @return the new period plus the specified number of minutes\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "    public Minutes minus(Minutes minutes) {\n        if (minutes == null) {\n            return this;\n        }\n        return minus(minutes.getValue());\n    }", "comment": "/**\n     * Returns a new instance with the specified number of minutes taken away.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the amount of minutes to take away, may be negative, null means zero\n     * @return the new period minus the specified number of minutes\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "    public Minutes multipliedBy(int scalar) {\n        return Minutes.minutes(FieldUtils.safeMultiply(getValue(), scalar));\n    }", "comment": "/**\n     * Returns a new instance with the minutes multiplied by the specified scalar.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param scalar  the amount to multiply by, may be negative\n     * @return the new period multiplied by the specified scalar\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "    public Minutes dividedBy(int divisor) {\n        if (divisor == 1) {\n            return this;\n        }\n        return Minutes.minutes(getValue() / divisor);\n    }", "comment": "/**\n     * Returns a new instance with the minutes divided by the specified divisor.\n     * The calculation uses integer division, thus 3 divided by 2 is 1.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param divisor  the amount to divide by, may be negative\n     * @return the new period divided by the specified divisor\n     * @throws ArithmeticException if the divisor is zero\n     */"}}
{"code": {"body": "    public Minutes negated() {\n        return Minutes.minutes(FieldUtils.safeNegate(getValue()));\n    }", "comment": "/**\n     * Returns a new instance with the minutes value negated.\n     *\n     * @return the new period with a negated value\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "    public boolean isGreaterThan(Minutes other) {\n        if (other == null) {\n            return getValue() > 0;\n        }\n        return getValue() > other.getValue();\n    }", "comment": "/**\n     * Is this minutes instance greater than the specified number of minutes.\n     *\n     * @param other  the other period, null means zero\n     * @return true if this minutes instance is greater than the specified one\n     */"}}
{"code": {"body": "    public boolean isLessThan(Minutes other) {\n        if (other == null) {\n            return getValue() < 0;\n        }\n        return getValue() < other.getValue();\n    }", "comment": "/**\n     * Is this minutes instance less than the specified number of minutes.\n     *\n     * @param other  the other period, null means zero\n     * @return true if this minutes instance is less than the specified one\n     */"}}
{"code": {"body": "public MonthDay() {\n        super();\n    }", "comment": "/**\n     * Constructs a MonthDay with the current monthOfYear, using ISOChronology in\n     * the default zone to extract the fields.\n     * <p>\n     * The constructor uses the default time zone, resulting in the local time\n     * being initialised. Once the constructor is complete, all further calculations\n     * are performed without reference to a time-zone (by switching to UTC).\n     * \n     * @see #now()\n     */"}}
{"code": {"body": "public MonthDay(DateTimeZone zone) {\n        super(ISOChronology.getInstance(zone));\n    }", "comment": "/**\n     * Constructs a MonthDay with the current month-day, using ISOChronology in\n     * the specified zone to extract the fields.\n     * <p>\n     * The constructor uses the specified time zone to obtain the current month-day.\n     * Once the constructor is complete, all further calculations\n     * are performed without reference to a time-zone (by switching to UTC).\n     * \n     * @param zone  the zone to use, null means default zone\n     * @see #now(DateTimeZone)\n     */"}}
{"code": {"body": "public MonthDay(Chronology chronology) {\n        super(chronology);\n    }", "comment": "/**\n     * Constructs a MonthDay with the current month-day, using the specified chronology\n     * and zone to extract the fields.\n     * <p>\n     * The constructor uses the time zone of the chronology specified.\n     * Once the constructor is complete, all further calculations are performed\n     * without reference to a time-zone (by switching to UTC).\n     *\n     * @param chronology  the chronology, null means ISOChronology in the default zone\n     * @see #now(Chronology)\n     */"}}
{"code": {"body": "public MonthDay(long instant) {\n        super(instant);\n    }", "comment": "/**\n     * Constructs a MonthDay extracting the partial fields from the specified\n     * milliseconds using the ISOChronology in the default zone.\n     * <p>\n     * The constructor uses the default time zone, resulting in the local time\n     * being initialised. Once the constructor is complete, all further calculations\n     * are performed without reference to a time-zone (by switching to UTC).\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     */"}}
{"code": {"body": "public MonthDay(long instant, Chronology chronology) {\n        super(instant, chronology);\n    }", "comment": "/**\n     * Constructs a MonthDay extracting the partial fields from the specified\n     * milliseconds using the chronology provided.\n     * <p>\n     * The constructor uses the time zone of the chronology specified.\n     * Once the constructor is complete, all further calculations are performed\n     * without reference to a time-zone (by switching to UTC).\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     * @param chronology  the chronology, null means ISOChronology in the default zone\n     */"}}
{"code": {"body": "public MonthDay(Object instant) {\n        super(instant, null, ISODateTimeFormat.localDateParser());\n    }", "comment": "/**\n     * Constructs a MonthDay from an Object that represents some form of time.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadableInstant, String, Calendar and Date.\n     * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.\n     * <p>\n     * The chronology used will be derived from the object, defaulting to ISO.\n     *\n     * @param instant  the date-time object, null means now\n     * @throws IllegalArgumentException if the instant is invalid\n     */"}}
{"code": {"body": "public MonthDay(Object instant, Chronology chronology) {\n        super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.localDateParser());\n    }", "comment": "/**\n     * Constructs a MonthDay from an Object that represents some form of time,\n     * using the specified chronology.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadableInstant, String, Calendar and Date.\n     * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.\n     * <p>\n     * The constructor uses the time zone of the chronology specified.\n     * Once the constructor is complete, all further calculations are performed\n     * without reference to a time-zone (by switching to UTC).\n     * The specified chronology overrides that of the object.\n     *\n     * @param instant  the date-time object, null means now\n     * @param chronology  the chronology, null means ISO default\n     * @throws IllegalArgumentException if the instant is invalid\n     */"}}
{"code": {"body": "public MonthDay(int monthOfYear, int dayOfMonth) {\n        this(monthOfYear, dayOfMonth, null);\n    }", "comment": "/**\n     * Constructs a MonthDay with specified year and month\n     * using <code>ISOChronology</code>.\n     * <p>\n     * The constructor uses the no time zone initialising the fields as provided.\n     * Once the constructor is complete, all further calculations\n     * are performed without reference to a time-zone (by switching to UTC).\n     *\n     * @param monthOfYear  the month of the year\n     * @param dayOfMonth  the day of the month\n     */"}}
{"code": {"body": "public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology) {\n        super(new int[] {monthOfYear, dayOfMonth}, chronology);\n    }", "comment": "/**\n     * Constructs an instance set to the specified monthOfYear and dayOfMonth\n     * using the specified chronology, whose zone is ignored.\n     * <p>\n     * If the chronology is null, <code>ISOChronology</code> is used.\n     * <p>\n     * The constructor uses the time zone of the chronology specified.\n     * Once the constructor is complete, all further calculations are performed\n     * without reference to a time-zone (by switching to UTC).\n     *\n     * @param monthOfYear  the month of the year\n     * @param dayOfMonth  the day of the month\n     * @param chronology  the chronology, null means ISOChronology in the default zone\n     */"}}
{"code": {"body": "public MonthDay withChronologyRetainFields(Chronology newChronology) {\n        newChronology = DateTimeUtils.getChronology(newChronology);\n        newChronology = newChronology.withUTC();\n        if (newChronology == getChronology()) {\n            return this;\n        } else {\n            MonthDay newMonthDay = new MonthDay(this, newChronology);\n            newChronology.validate(newMonthDay, getValues());\n            return newMonthDay;\n        }\n    }", "comment": "/**\n     * Returns a copy of this month-day with the specified chronology.\n     * This instance is immutable and unaffected by this method call.\n     * <p>\n     * This method retains the values of the fields, thus the result will\n     * typically refer to a different instant.\n     * <p>\n     * The time zone of the specified chronology is ignored, as MonthDay\n     * operates without a time zone.\n     *\n     * @param newChronology  the new chronology, null means ISO\n     * @return a copy of this month-day with a different chronology, never null\n     * @throws IllegalArgumentException if the values are invalid for the new chronology\n     */"}}
{"code": {"body": "public MonthDay withField(DateTimeFieldType fieldType, int value) {\n        int index = indexOfSupported(fieldType);\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new MonthDay(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this month-day with the specified field set to a new value.\n     * <p>\n     * For example, if the field type is <code>dayOfMonth</code> then the day\n     * would be changed in the returned instance.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * MonthDay updated = md.withField(DateTimeFieldType.dayOfMonth(), 6);\n     * MonthDay updated = md.dayOfMonth().setCopy(6);\n     * MonthDay updated = md.property(DateTimeFieldType.dayOfMonth()).setCopy(6);\n     * </pre>\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this instance with the field set, never null\n     * @throws IllegalArgumentException if the value is null or invalid\n     */"}}
{"code": {"body": "public MonthDay withFieldAdded(DurationFieldType fieldType, int amount) {\n        int index = indexOfSupported(fieldType);\n        if (amount == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).add(this, index, newValues, amount);\n        return new MonthDay(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this month-day with the value of the specified field increased.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * MonthDay added = md.withFieldAdded(DurationFieldType.days(), 6);\n     * MonthDay added = md.plusDays(6);\n     * MonthDay added = md.dayOfMonth().addToCopy(6);\n     * </pre>\n     * \n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this instance with the field updated, never null\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the new date-time exceeds the capacity\n     */"}}
{"code": {"body": "public MonthDay withPeriodAdded(ReadablePeriod period, int scalar) {\n        if (period == null || scalar == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        for (int i = 0; i < period.size(); i++) {\n            DurationFieldType fieldType = period.getFieldType(i);\n            int index = indexOf(fieldType);\n            if (index >= 0) {\n                newValues = getField(index).add(this, index, newValues,\n                        FieldUtils.safeMultiply(period.getValue(i), scalar));\n            }\n        }\n        return new MonthDay(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this month-day with the specified period added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * Fields in the period that aren't present in the partial are ignored.\n     * <p>\n     * This method is typically used to add multiple copies of complex\n     * period instances. Adding one field is best achieved using methods\n     * like {@link #withFieldAdded(DurationFieldType, int)}\n     * or {@link #plusMonths(int)}.\n     * \n     * @param period  the period to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this instance with the period added, never null\n     * @throws ArithmeticException if the new date-time exceeds the capacity\n     */"}}
{"code": {"body": "public MonthDay plus(ReadablePeriod period) {\n        return withPeriodAdded(period, 1);\n    }", "comment": "/**\n     * Returns a copy of this month-day with the specified period added.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to add complex period instances.\n     * Adding one field is best achieved using methods\n     * like {@link #plusMonths(int)}.\n     * \n     * @param period  the duration to add to this one, null means zero\n     * @return a copy of this instance with the period added, never null\n     * @throws ArithmeticException if the new month-day exceeds the capacity\n     */"}}
{"code": {"body": "public MonthDay plusMonths(int months) {\n        return withFieldAdded(DurationFieldType.months(), months);\n    }", "comment": "/**\n     * Returns a copy of this month-day plus the specified number of months.\n     * <p>\n     * This month-day instance is immutable and unaffected by this method call.\n     * The month will wrap at the end of the year from December to January.\n     * The day will be adjusted to the last valid value if necessary.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * MonthDay added = md.plusMonths(6);\n     * MonthDay added = md.plus(Period.months(6));\n     * MonthDay added = md.withFieldAdded(DurationFieldType.months(), 6);\n     * </pre>\n     *\n     * @param months  the amount of months to add, may be negative\n     * @return the new month-day plus the increased months, never null\n     */"}}
{"code": {"body": "public MonthDay plusDays(int days) {\n        return withFieldAdded(DurationFieldType.days(), days);\n    }", "comment": "/**\n     * Returns a copy of this month-day plus the specified number of days.\n     * <p>\n     * This month-day instance is immutable and unaffected by this method call.\n     * The month will wrap at the end of the year from December to January.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * MonthDay added = md.plusDays(6);\n     * MonthDay added = md.plus(Period.days(6));\n     * MonthDay added = md.withFieldAdded(DurationFieldType.days(), 6);\n     * </pre>\n     *\n     * @param days  the amount of days to add, may be negative\n     * @return the new month-day plus the increased days, never null\n     */"}}
{"code": {"body": "public MonthDay minus(ReadablePeriod period) {\n        return withPeriodAdded(period, -1);\n    }", "comment": "/**\n     * Returns a copy of this month-day with the specified period taken away.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to subtract complex period instances.\n     * Subtracting one field is best achieved using methods\n     * like {@link #minusMonths(int)}.\n     * \n     * @param period  the period to reduce this instant by\n     * @return a copy of this instance with the period taken away, never null\n     * @throws ArithmeticException if the new month-day exceeds the capacity\n     */"}}
{"code": {"body": "public MonthDay minusMonths(int months) {\n        return withFieldAdded(DurationFieldType.months(), FieldUtils.safeNegate(months));\n    }", "comment": "/**\n     * Returns a copy of this month-day minus the specified number of months.\n     * <p>\n     * This MonthDay instance is immutable and unaffected by this method call.\n     * The month will wrap at the end of the year from January to December.\n     * The day will be adjusted to the last valid value if necessary.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * MonthDay subtracted = md.minusMonths(6);\n     * MonthDay subtracted = md.minus(Period.months(6));\n     * MonthDay subtracted = md.withFieldAdded(DurationFieldType.months(), -6);\n     * </pre>\n     *\n     * @param months  the amount of months to subtract, may be negative\n     * @return the new month-day minus the increased months, never null\n     */"}}
{"code": {"body": "public MonthDay minusDays(int days) {\n        return withFieldAdded(DurationFieldType.days(), FieldUtils.safeNegate(days));\n    }", "comment": "/**\n     * Returns a copy of this month-day minus the specified number of months.\n     * <p>\n     * This month-day instance is immutable and unaffected by this method call.\n     * The month will wrap at the end of the year from January to December.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * MonthDay subtracted = md.minusDays(6);\n     * MonthDay subtracted = md.minus(Period.days(6));\n     * MonthDay subtracted = md.withFieldAdded(DurationFieldType.days(), -6);\n     * </pre>\n     *\n     * @param days  the amount of days to subtract, may be negative\n     * @return the new month-day minus the increased days, never null\n     */"}}
{"code": {"body": "public MonthDay withMonthOfYear(int monthOfYear) {\n        int[] newValues = getValues();\n        newValues = getChronology().monthOfYear().set(this, MONTH_OF_YEAR, newValues, monthOfYear);\n        return new MonthDay(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this month-day with the month of year field updated.\n     * <p>\n     * MonthDay is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * month of year changed.\n     *\n     * @param monthOfYear  the month of year to set\n     * @return a copy of this object with the field set, never null\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "public MonthDay withDayOfMonth(int dayOfMonth) {\n        int[] newValues = getValues();\n        newValues = getChronology().dayOfMonth().set(this, DAY_OF_MONTH, newValues, dayOfMonth);\n        return new MonthDay(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this month-day with the day of month field updated.\n     * <p>\n     * MonthDay is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of month changed.\n     *\n     * @param dayOfMonth  the day of month to set\n     * @return a copy of this object with the field set, never null\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "public MonthDay getMonthDay() {\n            return iBase;\n        }", "comment": "/**\n         * Gets the partial that this property belongs to.\n         * \n         * @return the partial\n         */"}}
{"code": {"body": "public MonthDay addToCopy(int valueToAdd) {\n            int[] newValues = iBase.getValues();\n            newValues = getField().add(iBase, iFieldIndex, newValues, valueToAdd);\n            return new MonthDay(iBase, newValues);\n        }", "comment": "/**\n         * Adds to the value of this field in a copy of this MonthDay.\n         * <p>\n         * The value will be added to this field. If the value is too large to be\n         * added solely to this field then it will affect larger fields.\n         * Smaller fields are unaffected.\n         * <p>\n         * The MonthDay attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param valueToAdd  the value to add to the field in the copy\n         * @return a copy of the MonthDay with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "public MonthDay addWrapFieldToCopy(int valueToAdd) {\n            int[] newValues = iBase.getValues();\n            newValues = getField().addWrapField(iBase, iFieldIndex, newValues, valueToAdd);\n            return new MonthDay(iBase, newValues);\n        }", "comment": "/**\n         * Adds to the value of this field in a copy of this MonthDay wrapping\n         * within this field if the maximum value is reached.\n         * <p>\n         * The value will be added to this field. If the value is too large to be\n         * added solely to this field then it wraps within this field.\n         * Other fields are unaffected.\n         * <p>\n         * For example,\n         * <code>--12-30</code> addWrapField one month returns <code>--01-30</code>.\n         * <p>\n         * The MonthDay attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param valueToAdd  the value to add to the field in the copy\n         * @return a copy of the MonthDay with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "public MonthDay setCopy(int value) {\n            int[] newValues = iBase.getValues();\n            newValues = getField().set(iBase, iFieldIndex, newValues, value);\n            return new MonthDay(iBase, newValues);\n        }", "comment": "/**\n         * Sets this field in a copy of the MonthDay.\n         * <p>\n         * The MonthDay attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param value  the value to set the field in the copy to\n         * @return a copy of the MonthDay with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "public MonthDay setCopy(String text, Locale locale) {\n            int[] newValues = iBase.getValues();\n            newValues = getField().set(iBase, iFieldIndex, newValues, text, locale);\n            return new MonthDay(iBase, newValues);\n        }", "comment": "/**\n         * Sets this field in a copy of the MonthDay to a parsed text value.\n         * <p>\n         * The MonthDay attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param text  the text value to set\n         * @param locale  optional locale to use for selecting a text symbol\n         * @return a copy of the MonthDay with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */"}}
{"code": {"body": "public MonthDay setCopy(String text) {\n            return setCopy(text, null);\n        }", "comment": "/**\n         * Sets this field in a copy of the MonthDay to a parsed text value.\n         * <p>\n         * The MonthDay attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param text  the text value to set\n         * @return a copy of the MonthDay with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */"}}
{"code": {"body": "    public static MonthDay now(Chronology chronology) {\n        if (chronology == null) {\n            throw new NullPointerException(\"\");\n        }\n        return new MonthDay(chronology);\n    }", "comment": "/**\n     * Obtains a {@code MonthDay} set to the current system millisecond time\n     * using the specified chronology.\n     * The resulting object does not use the zone.\n     *\n     * @param chronology  the chronology, not null\n     * @return the current month-day, not null\n     * @since 2.0\n     */"}}
{"code": {"body": "    public static MonthDay parse(String str, DateTimeFormatter formatter) {\n        LocalDate date = formatter.parseLocalDate(str);\n        return new MonthDay(date.getMonthOfYear(), date.getDayOfMonth());\n    }", "comment": "/**\n     * Parses a {@code MonthDay} from the specified string using a formatter.\n     * \n     * @param str  the string to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @since 2.0\n     */"}}
{"code": {"body": "    public static MonthDay fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        return new MonthDay(calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH));\n    }", "comment": "/**\n     * Constructs a MonthDay from a <code>java.util.Calendar</code>\n     * using exactly the same field values avoiding any time zone effects.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the MonthDay.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a MonthDay with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from\n     * @return the created MonthDay, never null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the monthOfYear or dayOfMonth is invalid for the ISO chronology\n     */"}}
{"code": {"body": "    private Object readResolve() {\n        if (DateTimeZone.UTC.equals(getChronology().getZone()) == false) {\n            return new MonthDay(this, getChronology().withUTC());\n        }\n        return this;\n    }", "comment": "/**\n     * Handle broken serialization from other tools.\n     * @return the resolved object, not null\n     */"}}
{"code": {"body": "    public int size() {\n        return 2;\n    }", "comment": "/**\n     * Gets the number of fields in this partial, which is two.\n     * The supported fields are MonthOfYear and DayOfMonth.\n     * Note that only these fields may be queried.\n     *\n     * @return the field count, two\n     */"}}
{"code": {"body": "        public DateTimeField getField() {\n            return iBase.getField(iFieldIndex);\n        }", "comment": "/**\n         * Gets the field that this property uses.\n         * \n         * @return the field\n         */"}}
{"code": {"body": "    public DateTimeFieldType getFieldType(int index) {\n        return FIELD_TYPES[index];\n    }", "comment": "/**\n     * Gets the field type at the specified index.\n     *\n     * @param index  the index to retrieve\n     * @return the field at the specified index, never null\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */"}}
{"code": {"body": "    public DateTimeFieldType[] getFieldTypes() {\n        return (DateTimeFieldType[]) FIELD_TYPES.clone();\n    }", "comment": "/**\n     * Gets an array of the field type of each of the fields that this partial supports.\n     * <p>\n     * The fields are returned largest to smallest, Month, Day.\n     *\n     * @return the array of field types (cloned), largest to smallest, never null\n     */"}}
{"code": {"body": "    public MonthDay withChronologyRetainFields(Chronology newChronology) {\n        newChronology = DateTimeUtils.getChronology(newChronology);\n        newChronology = newChronology.withUTC();\n        if (newChronology == getChronology()) {\n            return this;\n        } else {\n            MonthDay newMonthDay = new MonthDay(this, newChronology);\n            newChronology.validate(newMonthDay, getValues());\n            return newMonthDay;\n        }\n    }", "comment": "/**\n     * Returns a copy of this month-day with the specified chronology.\n     * This instance is immutable and unaffected by this method call.\n     * <p>\n     * This method retains the values of the fields, thus the result will\n     * typically refer to a different instant.\n     * <p>\n     * The time zone of the specified chronology is ignored, as MonthDay\n     * operates without a time zone.\n     *\n     * @param newChronology  the new chronology, null means ISO\n     * @return a copy of this month-day with a different chronology, never null\n     * @throws IllegalArgumentException if the values are invalid for the new chronology\n     */"}}
{"code": {"body": "    public MonthDay withField(DateTimeFieldType fieldType, int value) {\n        int index = indexOfSupported(fieldType);\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new MonthDay(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this month-day with the specified field set to a new value.\n     * <p>\n     * For example, if the field type is <code>dayOfMonth</code> then the day\n     * would be changed in the returned instance.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * MonthDay updated = md.withField(DateTimeFieldType.dayOfMonth(), 6);\n     * MonthDay updated = md.dayOfMonth().setCopy(6);\n     * MonthDay updated = md.property(DateTimeFieldType.dayOfMonth()).setCopy(6);\n     * </pre>\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this instance with the field set, never null\n     * @throws IllegalArgumentException if the value is null or invalid\n     */"}}
{"code": {"body": "    public MonthDay withFieldAdded(DurationFieldType fieldType, int amount) {\n        int index = indexOfSupported(fieldType);\n        if (amount == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).add(this, index, newValues, amount);\n        return new MonthDay(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this month-day with the value of the specified field increased.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * MonthDay added = md.withFieldAdded(DurationFieldType.days(), 6);\n     * MonthDay added = md.plusDays(6);\n     * MonthDay added = md.dayOfMonth().addToCopy(6);\n     * </pre>\n     * \n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this instance with the field updated, never null\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the new date-time exceeds the capacity\n     */"}}
{"code": {"body": "    public MonthDay withPeriodAdded(ReadablePeriod period, int scalar) {\n        if (period == null || scalar == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        for (int i = 0; i < period.size(); i++) {\n            DurationFieldType fieldType = period.getFieldType(i);\n            int index = indexOf(fieldType);\n            if (index >= 0) {\n                newValues = getField(index).add(this, index, newValues,\n                        FieldUtils.safeMultiply(period.getValue(i), scalar));\n            }\n        }\n        return new MonthDay(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this month-day with the specified period added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * Fields in the period that aren't present in the partial are ignored.\n     * <p>\n     * This method is typically used to add multiple copies of complex\n     * period instances. Adding one field is best achieved using methods\n     * like {@link #withFieldAdded(DurationFieldType, int)}\n     * or {@link #plusMonths(int)}.\n     * \n     * @param period  the period to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this instance with the period added, never null\n     * @throws ArithmeticException if the new date-time exceeds the capacity\n     */"}}
{"code": {"body": "    public MonthDay plus(ReadablePeriod period) {\n        return withPeriodAdded(period, 1);\n    }", "comment": "/**\n     * Returns a copy of this month-day with the specified period added.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to add complex period instances.\n     * Adding one field is best achieved using methods\n     * like {@link #plusMonths(int)}.\n     * \n     * @param period  the duration to add to this one, null means zero\n     * @return a copy of this instance with the period added, never null\n     * @throws ArithmeticException if the new month-day exceeds the capacity\n     */"}}
{"code": {"body": "    public MonthDay plusMonths(int months) {\n        return withFieldAdded(DurationFieldType.months(), months);\n    }", "comment": "/**\n     * Returns a copy of this month-day plus the specified number of months.\n     * <p>\n     * This month-day instance is immutable and unaffected by this method call.\n     * The month will wrap at the end of the year from December to January.\n     * The day will be adjusted to the last valid value if necessary.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * MonthDay added = md.plusMonths(6);\n     * MonthDay added = md.plus(Period.months(6));\n     * MonthDay added = md.withFieldAdded(DurationFieldType.months(), 6);\n     * </pre>\n     *\n     * @param months  the amount of months to add, may be negative\n     * @return the new month-day plus the increased months, never null\n     */"}}
{"code": {"body": "    public MonthDay plusDays(int days) {\n        return withFieldAdded(DurationFieldType.days(), days);\n    }", "comment": "/**\n     * Returns a copy of this month-day plus the specified number of days.\n     * <p>\n     * This month-day instance is immutable and unaffected by this method call.\n     * The month will wrap at the end of the year from December to January.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * MonthDay added = md.plusDays(6);\n     * MonthDay added = md.plus(Period.days(6));\n     * MonthDay added = md.withFieldAdded(DurationFieldType.days(), 6);\n     * </pre>\n     *\n     * @param days  the amount of days to add, may be negative\n     * @return the new month-day plus the increased days, never null\n     */"}}
{"code": {"body": "    public MonthDay minus(ReadablePeriod period) {\n        return withPeriodAdded(period, -1);\n    }", "comment": "/**\n     * Returns a copy of this month-day with the specified period taken away.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to subtract complex period instances.\n     * Subtracting one field is best achieved using methods\n     * like {@link #minusMonths(int)}.\n     * \n     * @param period  the period to reduce this instant by\n     * @return a copy of this instance with the period taken away, never null\n     * @throws ArithmeticException if the new month-day exceeds the capacity\n     */"}}
{"code": {"body": "    public MonthDay minusMonths(int months) {\n        return withFieldAdded(DurationFieldType.months(), FieldUtils.safeNegate(months));\n    }", "comment": "/**\n     * Returns a copy of this month-day minus the specified number of months.\n     * <p>\n     * This MonthDay instance is immutable and unaffected by this method call.\n     * The month will wrap at the end of the year from January to December.\n     * The day will be adjusted to the last valid value if necessary.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * MonthDay subtracted = md.minusMonths(6);\n     * MonthDay subtracted = md.minus(Period.months(6));\n     * MonthDay subtracted = md.withFieldAdded(DurationFieldType.months(), -6);\n     * </pre>\n     *\n     * @param months  the amount of months to subtract, may be negative\n     * @return the new month-day minus the increased months, never null\n     */"}}
{"code": {"body": "    public MonthDay minusDays(int days) {\n        return withFieldAdded(DurationFieldType.days(), FieldUtils.safeNegate(days));\n    }", "comment": "/**\n     * Returns a copy of this month-day minus the specified number of months.\n     * <p>\n     * This month-day instance is immutable and unaffected by this method call.\n     * The month will wrap at the end of the year from January to December.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * MonthDay subtracted = md.minusDays(6);\n     * MonthDay subtracted = md.minus(Period.days(6));\n     * MonthDay subtracted = md.withFieldAdded(DurationFieldType.days(), -6);\n     * </pre>\n     *\n     * @param days  the amount of days to subtract, may be negative\n     * @return the new month-day minus the increased days, never null\n     */"}}
{"code": {"body": "    public LocalDate toLocalDate(int year) {\n        return new LocalDate(year, getMonthOfYear(), getDayOfMonth(), getChronology());\n    }", "comment": "/**\n     * Converts this object to a LocalDate with the same month-day and chronology.\n     *\n     * @param year  the year to use, valid for chronology\n     * @return a LocalDate with the same month-day and chronology, never null\n     */"}}
{"code": {"body": "    public int getMonthOfYear() {\n        return getValue(MONTH_OF_YEAR);\n    }", "comment": "/**\n     * Get the month of year field value.\n     *\n     * @return the month of year\n     */"}}
{"code": {"body": "    public int getDayOfMonth() {\n        return getValue(DAY_OF_MONTH);\n    }", "comment": "/**\n     * Get the day of month field value.\n     *\n     * @return the day of month\n     */"}}
{"code": {"body": "    public MonthDay withMonthOfYear(int monthOfYear) {\n        int[] newValues = getValues();\n        newValues = getChronology().monthOfYear().set(this, MONTH_OF_YEAR, newValues, monthOfYear);\n        return new MonthDay(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this month-day with the month of year field updated.\n     * <p>\n     * MonthDay is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * month of year changed.\n     *\n     * @param monthOfYear  the month of year to set\n     * @return a copy of this object with the field set, never null\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public MonthDay withDayOfMonth(int dayOfMonth) {\n        int[] newValues = getValues();\n        newValues = getChronology().dayOfMonth().set(this, DAY_OF_MONTH, newValues, dayOfMonth);\n        return new MonthDay(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this month-day with the day of month field updated.\n     * <p>\n     * MonthDay is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of month changed.\n     *\n     * @param dayOfMonth  the day of month to set\n     * @return a copy of this object with the field set, never null\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public Property property(DateTimeFieldType type) {\n        return new Property(this, indexOfSupported(type));\n    }", "comment": "/**\n     * Gets the property object for the specified type, which contains\n     * many useful methods.\n     *\n     * @param type  the field type to get the property for\n     * @return the property object\n     * @throws IllegalArgumentException if the field is null or unsupported\n     */"}}
{"code": {"body": "    public Property monthOfYear() {\n        return new Property(this, MONTH_OF_YEAR);\n    }", "comment": "/**\n     * Get the month of year field property which provides access to advanced functionality.\n     * \n     * @return the month of year property\n     */"}}
{"code": {"body": "    public Property dayOfMonth() {\n        return new Property(this, DAY_OF_MONTH);\n    }", "comment": "/**\n     * Get the day of month field property which provides access to advanced functionality.\n     * \n     * @return the day of month property\n     */"}}
{"code": {"body": "    public String toString(String pattern, Locale locale) throws IllegalArgumentException {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n    }", "comment": "/**\n     * Output the month-day using the specified format pattern.\n     *\n     * @param pattern  the pattern specification, null means use <code>toString</code>\n     * @param locale  Locale to use, null means default\n     * @see org.joda.time.format.DateTimeFormat\n     */"}}
{"code": {"body": "        protected ReadablePartial getReadablePartial() {\n            return iBase;\n        }", "comment": "/**\n         * Gets the partial that this property belongs to.\n         * \n         * @return the partial\n         */"}}
{"code": {"body": "        public MonthDay getMonthDay() {\n            return iBase;\n        }", "comment": "/**\n         * Gets the partial that this property belongs to.\n         * \n         * @return the partial\n         */"}}
{"code": {"body": "        public int get() {\n            return iBase.getValue(iFieldIndex);\n        }", "comment": "/**\n         * Gets the value of this field.\n         * \n         * @return the field value\n         */"}}
{"code": {"body": "        public MonthDay addToCopy(int valueToAdd) {\n            int[] newValues = iBase.getValues();\n            newValues = getField().add(iBase, iFieldIndex, newValues, valueToAdd);\n            return new MonthDay(iBase, newValues);\n        }", "comment": "/**\n         * Adds to the value of this field in a copy of this MonthDay.\n         * <p>\n         * The value will be added to this field. If the value is too large to be\n         * added solely to this field then it will affect larger fields.\n         * Smaller fields are unaffected.\n         * <p>\n         * The MonthDay attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param valueToAdd  the value to add to the field in the copy\n         * @return a copy of the MonthDay with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "        public MonthDay addWrapFieldToCopy(int valueToAdd) {\n            int[] newValues = iBase.getValues();\n            newValues = getField().addWrapField(iBase, iFieldIndex, newValues, valueToAdd);\n            return new MonthDay(iBase, newValues);\n        }", "comment": "/**\n         * Adds to the value of this field in a copy of this MonthDay wrapping\n         * within this field if the maximum value is reached.\n         * <p>\n         * The value will be added to this field. If the value is too large to be\n         * added solely to this field then it wraps within this field.\n         * Other fields are unaffected.\n         * <p>\n         * For example,\n         * <code>--12-30</code> addWrapField one month returns <code>--01-30</code>.\n         * <p>\n         * The MonthDay attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param valueToAdd  the value to add to the field in the copy\n         * @return a copy of the MonthDay with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "        public MonthDay setCopy(String text) {\n            return setCopy(text, null);\n        }", "comment": "/**\n         * Sets this field in a copy of the MonthDay to a parsed text value.\n         * <p>\n         * The MonthDay attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param text  the text value to set\n         * @return a copy of the MonthDay with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */"}}
{"code": {"body": "public Months plus(int months) {\n        if (months == 0) {\n            return this;\n        }\n        return Months.months(FieldUtils.safeAdd(getValue(), months));\n    }", "comment": "/**\n     * Returns a new instance with the specified number of months added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param months  the amount of months to add, may be negative\n     * @return the new period plus the specified number of months\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "public Months plus(Months months) {\n        if (months == null) {\n            return this;\n        }\n        return plus(months.getValue());\n    }", "comment": "/**\n     * Returns a new instance with the specified number of months added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param months  the amount of months to add, may be negative, null means zero\n     * @return the new period plus the specified number of months\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "public Months minus(int months) {\n        return plus(FieldUtils.safeNegate(months));\n    }", "comment": "/**\n     * Returns a new instance with the specified number of months taken away.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param months  the amount of months to take away, may be negative\n     * @return the new period minus the specified number of months\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "public Months minus(Months months) {\n        if (months == null) {\n            return this;\n        }\n        return minus(months.getValue());\n    }", "comment": "/**\n     * Returns a new instance with the specified number of months taken away.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param months  the amount of months to take away, may be negative, null means zero\n     * @return the new period minus the specified number of months\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "public Months multipliedBy(int scalar) {\n        return Months.months(FieldUtils.safeMultiply(getValue(), scalar));\n    }", "comment": "/**\n     * Returns a new instance with the months multiplied by the specified scalar.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param scalar  the amount to multiply by, may be negative\n     * @return the new period multiplied by the specified scalar\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "public Months dividedBy(int divisor) {\n        if (divisor == 1) {\n            return this;\n        }\n        return Months.months(getValue() / divisor);\n    }", "comment": "/**\n     * Returns a new instance with the months divided by the specified divisor.\n     * The calculation uses integer division, thus 3 divided by 2 is 1.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param divisor  the amount to divide by, may be negative\n     * @return the new period divided by the specified divisor\n     * @throws ArithmeticException if the divisor is zero\n     */"}}
{"code": {"body": "public Months negated() {\n        return Months.months(FieldUtils.safeNegate(getValue()));\n    }", "comment": "/**\n     * Returns a new instance with the months value negated.\n     *\n     * @return the new period with a negated value\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "    public static Months months(int months) {\n        switch (months) {\n            case 0:\n                return ZERO;\n            case 1:\n                return ONE;\n            case 2:\n                return TWO;\n            case 3:\n                return THREE;\n            case 4:\n                return FOUR;\n            case 5:\n                return FIVE;\n            case 6:\n                return SIX;\n            case 7:\n                return SEVEN;\n            case 8:\n                return EIGHT;\n            case 9:\n                return NINE;\n            case 10:\n                return TEN;\n            case 11:\n                return ELEVEN;\n            case 12:\n                return TWELVE;\n            case Integer.MAX_VALUE:\n                return MAX_VALUE;\n            case Integer.MIN_VALUE:\n                return MIN_VALUE;\n            default:\n                return new Months(months);\n        }\n    }", "comment": "/**\n     * Obtains an instance of <code>Months</code> that may be cached.\n     * <code>Months</code> is immutable, so instances can be cached and shared.\n     * This factory method provides access to shared instances.\n     *\n     * @param months  the number of months to obtain an instance for\n     * @return the instance of Months\n     */"}}
{"code": {"body": "    public static Months monthsBetween(ReadablePartial start, ReadablePartial end) {\n        if (start instanceof LocalDate && end instanceof LocalDate)   {\n            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n            int months = chrono.months().getDifference(\n                    ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n            return Months.months(months);\n        }\n        int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\n        return Months.months(amount);\n    }", "comment": "/**\n     * Creates a <code>Months</code> representing the number of whole months\n     * between the two specified partial datetimes.\n     * <p>\n     * The two partials must contain the same fields, for example you can specify\n     * two <code>LocalDate</code> objects.\n     *\n     * @param start  the start partial date, must not be null\n     * @param end  the end partial date, must not be null\n     * @return the period in months\n     * @throws IllegalArgumentException if the partials are null or invalid\n     */"}}
{"code": {"body": "    public static Months monthsIn(ReadableInterval interval) {\n        if (interval == null)   {\n            return Months.ZERO;\n        }\n        int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.months());\n        return Months.months(amount);\n    }", "comment": "/**\n     * Creates a <code>Months</code> representing the number of whole months\n     * in the specified interval. This method corectly handles any daylight\n     * savings time changes that may occur during the interval.\n     *\n     * @param interval  the interval to extract months from, null returns zero\n     * @return the period in months\n     * @throws IllegalArgumentException if the partials are null or invalid\n     */"}}
{"code": {"body": "    private Object readResolve() {\n        return Months.months(getValue());\n    }", "comment": "/**\n     * Resolves singletons.\n     * \n     * @return the singleton instance\n     */"}}
{"code": {"body": "    public DurationFieldType getFieldType() {\n        return DurationFieldType.months();\n    }", "comment": "/**\n     * Gets the duration field type, which is <code>months</code>.\n     *\n     * @return the period type\n     */"}}
{"code": {"body": "    public PeriodType getPeriodType() {\n        return PeriodType.months();\n    }", "comment": "/**\n     * Gets the period type, which is <code>months</code>.\n     *\n     * @return the period type\n     */"}}
{"code": {"body": "    public int getMonths() {\n        return getValue();\n    }", "comment": "/**\n     * Gets the number of months that this period represents.\n     *\n     * @return the number of months in the period\n     */"}}
{"code": {"body": "    public Months plus(Months months) {\n        if (months == null) {\n            return this;\n        }\n        return plus(months.getValue());\n    }", "comment": "/**\n     * Returns a new instance with the specified number of months added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param months  the amount of months to add, may be negative, null means zero\n     * @return the new period plus the specified number of months\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "    public Months minus(Months months) {\n        if (months == null) {\n            return this;\n        }\n        return minus(months.getValue());\n    }", "comment": "/**\n     * Returns a new instance with the specified number of months taken away.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param months  the amount of months to take away, may be negative, null means zero\n     * @return the new period minus the specified number of months\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "    public Months multipliedBy(int scalar) {\n        return Months.months(FieldUtils.safeMultiply(getValue(), scalar));\n    }", "comment": "/**\n     * Returns a new instance with the months multiplied by the specified scalar.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param scalar  the amount to multiply by, may be negative\n     * @return the new period multiplied by the specified scalar\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "    public Months dividedBy(int divisor) {\n        if (divisor == 1) {\n            return this;\n        }\n        return Months.months(getValue() / divisor);\n    }", "comment": "/**\n     * Returns a new instance with the months divided by the specified divisor.\n     * The calculation uses integer division, thus 3 divided by 2 is 1.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param divisor  the amount to divide by, may be negative\n     * @return the new period divided by the specified divisor\n     * @throws ArithmeticException if the divisor is zero\n     */"}}
{"code": {"body": "    public Months negated() {\n        return Months.months(FieldUtils.safeNegate(getValue()));\n    }", "comment": "/**\n     * Returns a new instance with the months value negated.\n     *\n     * @return the new period with a negated value\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "    public boolean isGreaterThan(Months other) {\n        if (other == null) {\n            return getValue() > 0;\n        }\n        return getValue() > other.getValue();\n    }", "comment": "/**\n     * Is this months instance greater than the specified number of months.\n     *\n     * @param other  the other period, null means zero\n     * @return true if this months instance is greater than the specified one\n     */"}}
{"code": {"body": "    public boolean isLessThan(Months other) {\n        if (other == null) {\n            return getValue() < 0;\n        }\n        return getValue() < other.getValue();\n    }", "comment": "/**\n     * Is this months instance less than the specified number of months.\n     *\n     * @param other  the other period, null means zero\n     * @return true if this months instance is less than the specified one\n     */"}}
{"code": {"body": "public MutableDateTime() {\n        super();\n    }", "comment": "/**\n     * Constructs an instance set to the current system millisecond time\n     * using <code>ISOChronology</code> in the default time zone.\n     * \n     * @see #now()\n     */"}}
{"code": {"body": "public MutableDateTime(DateTimeZone zone) {\n        super(zone);\n    }", "comment": "/**\n     * Constructs an instance set to the current system millisecond time\n     * using <code>ISOChronology</code> in the specified time zone.\n     * <p>\n     * If the specified time zone is null, the default zone is used.\n     *\n     * @param zone  the time zone, null means default zone\n     * @see #now(DateTimeZone)\n     */"}}
{"code": {"body": "public MutableDateTime(Chronology chronology) {\n        super(chronology);\n    }", "comment": "/**\n     * Constructs an instance set to the current system millisecond time\n     * using the specified chronology.\n     * <p>\n     * If the chronology is null, <code>ISOChronology</code>\n     * in the default time zone is used.\n     *\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     * @see #now(Chronology)\n     */"}}
{"code": {"body": "public MutableDateTime(long instant) {\n        super(instant);\n    }", "comment": "/**\n     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n     * using <code>ISOChronology</code> in the default time zone.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     */"}}
{"code": {"body": "public MutableDateTime(long instant, DateTimeZone zone) {\n        super(instant, zone);\n    }", "comment": "/**\n     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n     * using <code>ISOChronology</code> in the specified time zone.\n     * <p>\n     * If the specified time zone is null, the default zone is used.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     * @param zone  the time zone, null means default zone\n     */"}}
{"code": {"body": "public MutableDateTime(long instant, Chronology chronology) {\n        super(instant, chronology);\n    }", "comment": "/**\n     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n     * using the specified chronology.\n     * <p>\n     * If the chronology is null, <code>ISOChronology</code>\n     * in the default time zone is used.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     */"}}
{"code": {"body": "public MutableDateTime(Object instant) {\n        super(instant, (Chronology) null);\n    }", "comment": "/**\n     * Constructs an instance from an Object that represents a datetime.\n     * <p>\n     * If the object implies a chronology (such as GregorianCalendar does),\n     * then that chronology will be used. Otherwise, ISO default is used.\n     * Thus if a GregorianCalendar is passed in, the chronology used will\n     * be GJ, but if a Date is passed in the chronology will be ISO.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadableInstant, String, Calendar and Date.\n     *\n     * @param instant  the datetime object, null means now\n     * @throws IllegalArgumentException if the instant is invalid\n     */"}}
{"code": {"body": "public MutableDateTime(Object instant, DateTimeZone zone) {\n        super(instant, zone);\n    }", "comment": "/**\n     * Constructs an instance from an Object that represents a datetime,\n     * forcing the time zone to that specified.\n     * <p>\n     * If the object implies a chronology (such as GregorianCalendar does),\n     * then that chronology will be used, but with the time zone adjusted.\n     * Otherwise, ISO is used in the specified time zone.\n     * If the specified time zone is null, the default zone is used.\n     * Thus if a GregorianCalendar is passed in, the chronology used will\n     * be GJ, but if a Date is passed in the chronology will be ISO.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadableInstant, String, Calendar and Date.\n     *\n     * @param instant  the datetime object, null means now\n     * @param zone  the time zone, null means default time zone\n     * @throws IllegalArgumentException if the instant is invalid\n     */"}}
{"code": {"body": "public MutableDateTime(Object instant, Chronology chronology) {\n        super(instant, DateTimeUtils.getChronology(chronology));\n    }", "comment": "/**\n     * Constructs an instance from an Object that represents a datetime,\n     * using the specified chronology.\n     * <p>\n     * If the chronology is null, ISO in the default time zone is used.\n     * Any chronology implied by the object (such as GregorianCalendar does)\n     * is ignored.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadableInstant, String, Calendar and Date.\n     *\n     * @param instant  the datetime object, null means now\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     * @throws IllegalArgumentException if the instant is invalid\n     */"}}
{"code": {"body": "public MutableDateTime copy() {\n        return (MutableDateTime) clone();\n    }", "comment": "/**\n     * Clone this object without having to cast the returned object.\n     *\n     * @return a clone of the this object.\n     */"}}
{"code": {"body": "public MutableDateTime getMutableDateTime() {\n            return iInstant;\n        }", "comment": "/**\n         * Gets the mutable datetime being used.\n         * \n         * @return the mutable datetime\n         */"}}
{"code": {"body": "public MutableDateTime add(int value) {\n            iInstant.setMillis(getField().add(iInstant.getMillis(), value));\n            return iInstant;\n        }", "comment": "/**\n         * Adds a value to the millis value.\n         * \n         * @param value  the value to add\n         * @return the mutable datetime being used, so calls can be chained\n         * @see DateTimeField#add(long,int)\n         */"}}
{"code": {"body": "public MutableDateTime add(long value) {\n            iInstant.setMillis(getField().add(iInstant.getMillis(), value));\n            return iInstant;\n        }", "comment": "/**\n         * Adds a value to the millis value.\n         * \n         * @param value  the value to add\n         * @return the mutable datetime being used, so calls can be chained\n         * @see DateTimeField#add(long,long)\n         */"}}
{"code": {"body": "public MutableDateTime addWrapField(int value) {\n            iInstant.setMillis(getField().addWrapField(iInstant.getMillis(), value));\n            return iInstant;\n        }", "comment": "/**\n         * Adds a value, possibly wrapped, to the millis value.\n         * \n         * @param value  the value to add\n         * @return the mutable datetime being used, so calls can be chained\n         * @see DateTimeField#addWrapField\n         */"}}
{"code": {"body": "public MutableDateTime set(int value) {\n            iInstant.setMillis(getField().set(iInstant.getMillis(), value));\n            return iInstant;\n        }", "comment": "/**\n         * Sets a value.\n         * \n         * @param value  the value to set.\n         * @return the mutable datetime being used, so calls can be chained\n         * @see DateTimeField#set(long,int)\n         */"}}
{"code": {"body": "public MutableDateTime set(String text, Locale locale) {\n            iInstant.setMillis(getField().set(iInstant.getMillis(), text, locale));\n            return iInstant;\n        }", "comment": "/**\n         * Sets a text value.\n         * \n         * @param text  the text value to set\n         * @param locale  optional locale to use for selecting a text symbol\n         * @return the mutable datetime being used, so calls can be chained\n         * @throws IllegalArgumentException if the text value isn't valid\n         * @see DateTimeField#set(long,java.lang.String,java.util.Locale)\n         */"}}
{"code": {"body": "public MutableDateTime set(String text) {\n            set(text, null);\n            return iInstant;\n        }", "comment": "/**\n         * Sets a text value.\n         * \n         * @param text  the text value to set\n         * @return the mutable datetime being used, so calls can be chained\n         * @throws IllegalArgumentException if the text value isn't valid\n         * @see DateTimeField#set(long,java.lang.String)\n         */"}}
{"code": {"body": "public MutableDateTime roundFloor() {\n            iInstant.setMillis(getField().roundFloor(iInstant.getMillis()));\n            return iInstant;\n        }", "comment": "/**\n         * Round to the lowest whole unit of this field.\n         *\n         * @return the mutable datetime being used, so calls can be chained\n         * @see DateTimeField#roundFloor\n         */"}}
{"code": {"body": "public MutableDateTime roundCeiling() {\n            iInstant.setMillis(getField().roundCeiling(iInstant.getMillis()));\n            return iInstant;\n        }", "comment": "/**\n         * Round to the highest whole unit of this field.\n         *\n         * @return the mutable datetime being used, so calls can be chained\n         * @see DateTimeField#roundCeiling\n         */"}}
{"code": {"body": "public MutableDateTime roundHalfFloor() {\n            iInstant.setMillis(getField().roundHalfFloor(iInstant.getMillis()));\n            return iInstant;\n        }", "comment": "/**\n         * Round to the nearest whole unit of this field, favoring the floor if\n         * halfway.\n         *\n         * @return the mutable datetime being used, so calls can be chained\n         * @see DateTimeField#roundHalfFloor\n         */"}}
{"code": {"body": "public MutableDateTime roundHalfCeiling() {\n            iInstant.setMillis(getField().roundHalfCeiling(iInstant.getMillis()));\n            return iInstant;\n        }", "comment": "/**\n         * Round to the nearest whole unit of this field, favoring the ceiling if\n         * halfway.\n         *\n         * @return the mutable datetime being used, so calls can be chained\n         * @see DateTimeField#roundHalfCeiling\n         */"}}
{"code": {"body": "public MutableDateTime roundHalfEven() {\n            iInstant.setMillis(getField().roundHalfEven(iInstant.getMillis()));\n            return iInstant;\n        }", "comment": "/**\n         * Round to the nearest whole unit of this field. If halfway, the ceiling\n         * is favored over the floor only if it makes this field's value even.\n         *\n         * @return the mutable datetime being used, so calls can be chained\n         * @see DateTimeField#roundHalfEven\n         */"}}
{"code": {"body": "    public static MutableDateTime now(Chronology chronology) {\n        if (chronology == null) {\n            throw new NullPointerException(\"\");\n        }\n        return new MutableDateTime(chronology);\n    }", "comment": "/**\n     * Obtains a {@code MutableDateTime} set to the current system millisecond time\n     * using the specified chronology.\n     *\n     * @param chronology  the chronology, not null\n     * @return the current date-time, not null\n     * @since 2.0\n     */"}}
{"code": {"body": "    public static MutableDateTime parse(String str, DateTimeFormatter formatter) {\n        return formatter.parseDateTime(str).toMutableDateTime();\n    }", "comment": "/**\n     * Parses a {@code MutableDateTime} from the specified string using a formatter.\n     * \n     * @param str  the string to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @since 2.0\n     */"}}
{"code": {"body": "    public DateTimeField getRoundingField() {\n        return iRoundingField;\n    }", "comment": "/**\n     * Gets the field used for rounding this instant, returning null if rounding\n     * is not enabled.\n     * \n     * @return the rounding field\n     */"}}
{"code": {"body": "    public int getRoundingMode() {\n        return iRoundingMode;\n    }", "comment": "/**\n     * Gets the rounding mode for this instant, returning ROUND_NONE if rounding\n     * is not enabled.\n     * \n     * @return the rounding mode constant\n     */"}}
{"code": {"body": "    public void setRounding(DateTimeField field, int mode) {\n        if (field != null && (mode < ROUND_NONE || mode > ROUND_HALF_EVEN)) {\n            throw new IllegalArgumentException(\"\" + mode);\n        }\n        iRoundingField = (mode == ROUND_NONE ? null : field);\n        iRoundingMode = (field == null ? ROUND_NONE : mode);\n        setMillis(getMillis());\n    }", "comment": "/**\n     * Sets the status of rounding to use the specified field and mode.\n     * A null field or mode of ROUND_NONE will disable rounding.\n     * Once set, the instant is then rounded using the new field and mode.\n     * <p>\n     * Enabling rounding will cause all subsequent calls to {@link #setMillis(long)}\n     * to be rounded. This can be used to control the precision of the instant,\n     * for example by setting a rounding field of minuteOfDay, the seconds and\n     * milliseconds will always be zero.\n     *\n     * @param field  rounding field or null to disable\n     * @param mode  rounding mode or ROUND_NONE to disable\n     * @throws IllegalArgumentException if mode is unknown, no exception if field is null\n     */"}}
{"code": {"body": "    public void setMillis(ReadableInstant instant) {\n        long instantMillis = DateTimeUtils.getInstantMillis(instant);\n        setMillis(instantMillis);  \n    }", "comment": "/**\n     * Sets the millisecond instant of this instant from another.\n     * <p>\n     * This method does not change the chronology of this instant, just the\n     * millisecond instant.\n     * \n     * @param instant  the instant to use, null means now\n     */"}}
{"code": {"body": "        public MutableDateTime add(long value) {\n            iInstant.setMillis(getField().add(iInstant.getMillis(), value));\n            return iInstant;\n        }", "comment": "/**\n         * Adds a value to the millis value.\n         * \n         * @param value  the value to add\n         * @return the mutable datetime being used, so calls can be chained\n         * @see DateTimeField#add(long,long)\n         */"}}
{"code": {"body": "    public void setChronology(Chronology chronology) {\n        super.setChronology(chronology);\n    }", "comment": "/**\n     * Set the chronology of the datetime.\n     * <p>\n     * All changes to the chronology occur via this method.\n     * \n     * @param chronology  the chronology to use, null means ISOChronology in default zone\n     */"}}
{"code": {"body": "    public void setZone(DateTimeZone newZone) {\n        newZone = DateTimeUtils.getZone(newZone);\n        Chronology chrono = getChronology();\n        if (chrono.getZone() != newZone) {\n            setChronology(chrono.withZone(newZone));  \n        }\n    }", "comment": "/**\n     * Sets the time zone of the datetime, changing the chronology and field values.\n     * <p>\n     * Changing the zone using this method retains the millisecond instant.\n     * The millisecond instant is adjusted in the new zone to compensate.\n     * \n     * chronology. Setting the time zone does not affect the millisecond value\n     * of this instant.\n     * <p>\n     * If the chronology already has this time zone, no change occurs.\n     *\n     * @param newZone  the time zone to use, null means default zone\n     * @see #setZoneRetainFields\n     */"}}
{"code": {"body": "    public void setZoneRetainFields(DateTimeZone newZone) {\n        newZone = DateTimeUtils.getZone(newZone);\n        DateTimeZone originalZone = DateTimeUtils.getZone(getZone());\n        if (newZone == originalZone) {\n            return;\n        }\n        \n        long millis = originalZone.getMillisKeepLocal(newZone, getMillis());\n        setChronology(getChronology().withZone(newZone));  \n        setMillis(millis);\n    }", "comment": "/**\n     * Sets the time zone of the datetime, changing the chronology and millisecond.\n     * <p>\n     * Changing the zone using this method retains the field values.\n     * The millisecond instant is adjusted in the new zone to compensate.\n     * <p>\n     * If the chronology already has this time zone, no change occurs.\n     *\n     * @param newZone  the time zone to use, null means default zone\n     * @see #setZone\n     */"}}
{"code": {"body": "        public MutableDateTime set(String text) {\n            set(text, null);\n            return iInstant;\n        }", "comment": "/**\n         * Sets a text value.\n         * \n         * @param text  the text value to set\n         * @return the mutable datetime being used, so calls can be chained\n         * @throws IllegalArgumentException if the text value isn't valid\n         * @see DateTimeField#set(long,java.lang.String)\n         */"}}
{"code": {"body": "    public void setYear(final int year) {\n        setMillis(getChronology().year().set(getMillis(), year));\n    }", "comment": "/**\n     * Set the year to the specified value.\n     *\n     * @param year  the year\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public void addYears(final int years) {\n        setMillis(getChronology().years().add(getMillis(), years));\n    }", "comment": "/**\n     * Add a number of years to the date.\n     *\n     * @param years  the years to add\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public void setWeekyear(final int weekyear) {\n        setMillis(getChronology().weekyear().set(getMillis(), weekyear));\n    }", "comment": "/**\n     * Set the weekyear to the specified value.\n     *\n     * @param weekyear  the weekyear\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public void addWeekyears(final int weekyears) {\n        setMillis(getChronology().weekyears().add(getMillis(), weekyears));\n    }", "comment": "/**\n     * Add a number of weekyears to the date.\n     *\n     * @param weekyears  the weekyears to add\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public void setMonthOfYear(final int monthOfYear) {\n        setMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear));\n    }", "comment": "/**\n     * Set the month of the year to the specified value.\n     *\n     * @param monthOfYear  the month of the year\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public void addMonths(final int months) {\n        setMillis(getChronology().months().add(getMillis(), months));\n    }", "comment": "/**\n     * Add a number of months to the date.\n     *\n     * @param months  the months to add\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public void setWeekOfWeekyear(final int weekOfWeekyear) {\n        setMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear));\n    }", "comment": "/**\n     * Set the week of weekyear to the specified value.\n     *\n     * @param weekOfWeekyear the week of the weekyear\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public void addWeeks(final int weeks) {\n        setMillis(getChronology().weeks().add(getMillis(), weeks));\n    }", "comment": "/**\n     * Add a number of weeks to the date.\n     *\n     * @param weeks  the weeks to add\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public void setDayOfYear(final int dayOfYear) {\n        setMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear));\n    }", "comment": "/**\n     * Set the day of year to the specified value.\n     *\n     * @param dayOfYear the day of the year\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public void setDayOfMonth(final int dayOfMonth) {\n        setMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth));\n    }", "comment": "/**\n     * Set the day of the month to the specified value.\n     *\n     * @param dayOfMonth  the day of the month\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public void setDayOfWeek(final int dayOfWeek) {\n        setMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek));\n    }", "comment": "/**\n     * Set the day of week to the specified value.\n     *\n     * @param dayOfWeek  the day of the week\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public void addDays(final int days) {\n        setMillis(getChronology().days().add(getMillis(), days));\n    }", "comment": "/**\n     * Add a number of days to the date.\n     *\n     * @param days  the days to add\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public void setHourOfDay(final int hourOfDay) {\n        setMillis(getChronology().hourOfDay().set(getMillis(), hourOfDay));\n    }", "comment": "/**\n     * Set the hour of the day to the specified value.\n     *\n     * @param hourOfDay  the hour of day\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public void addHours(final int hours) {\n        setMillis(getChronology().hours().add(getMillis(), hours));\n    }", "comment": "/**\n     * Add a number of hours to the date.\n     *\n     * @param hours  the hours to add\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public void setMinuteOfDay(final int minuteOfDay) {\n        setMillis(getChronology().minuteOfDay().set(getMillis(), minuteOfDay));\n    }", "comment": "/**\n     * Set the minute of the day to the specified value.\n     *\n     * @param minuteOfDay  the minute of day\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public void setMinuteOfHour(final int minuteOfHour) {\n        setMillis(getChronology().minuteOfHour().set(getMillis(), minuteOfHour));\n    }", "comment": "/**\n     * Set the minute of the hour to the specified value.\n     *\n     * @param minuteOfHour  the minute of hour\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public void addMinutes(final int minutes) {\n        setMillis(getChronology().minutes().add(getMillis(), minutes));\n    }", "comment": "/**\n     * Add a number of minutes to the date.\n     *\n     * @param minutes  the minutes to add\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public void setSecondOfDay(final int secondOfDay) {\n        setMillis(getChronology().secondOfDay().set(getMillis(), secondOfDay));\n    }", "comment": "/**\n     * Set the second of the day to the specified value.\n     *\n     * @param secondOfDay  the second of day\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public void setSecondOfMinute(final int secondOfMinute) {\n        setMillis(getChronology().secondOfMinute().set(getMillis(), secondOfMinute));\n    }", "comment": "/**\n     * Set the second of the minute to the specified value.\n     *\n     * @param secondOfMinute  the second of minute\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public void addSeconds(final int seconds) {\n        setMillis(getChronology().seconds().add(getMillis(), seconds));\n    }", "comment": "/**\n     * Add a number of seconds to the date.\n     *\n     * @param seconds  the seconds to add\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public void setMillisOfDay(final int millisOfDay) {\n        setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay));\n    }", "comment": "/**\n     * Set the millis of the day to the specified value.\n     *\n     * @param millisOfDay  the millis of day\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public void setMillisOfSecond(final int millisOfSecond) {\n        setMillis(getChronology().millisOfSecond().set(getMillis(), millisOfSecond));\n    }", "comment": "/**\n     * Set the millis of the second to the specified value.\n     *\n     * @param millisOfSecond  the millis of second\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public void addMillis(final int millis) {\n        setMillis(getChronology().millis().add(getMillis(), millis));\n    }", "comment": "/**\n     * Add a number of milliseconds to the date. The implementation of this\n     * method differs from the {@link #add(long)} method in that a\n     * DateTimeField performs the addition.\n     *\n     * @param millis  the milliseconds to add\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public void setDate(\n            final int year,\n            final int monthOfYear,\n            final int dayOfMonth) {\n        Chronology c = getChronology();\n        long instantMidnight = c.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\n        setDate(instantMidnight);\n    }", "comment": "/**\n     * Set the date from fields.\n     * The time part of this object will be unaffected.\n     *\n     * @param year  the year\n     * @param monthOfYear  the month of the year\n     * @param dayOfMonth  the day of the month\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public void setTime(\n            final int hour,\n            final int minuteOfHour,\n            final int secondOfMinute,\n            final int millisOfSecond) {\n        long instant = getChronology().getDateTimeMillis(\n            getMillis(), hour, minuteOfHour, secondOfMinute, millisOfSecond);\n        setMillis(instant);\n    }", "comment": "/**\n     * Set the time from fields.\n     * The date part of this object will be unaffected.\n     *\n     * @param hour  the hour\n     * @param minuteOfHour  the minute of the hour\n     * @param secondOfMinute  the second of the minute\n     * @param millisOfSecond  the millisecond of the second\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public void setDateTime(\n            final int year,\n            final int monthOfYear,\n            final int dayOfMonth,\n            final int hourOfDay,\n            final int minuteOfHour,\n            final int secondOfMinute,\n            final int millisOfSecond) {\n        long instant = getChronology().getDateTimeMillis(\n            year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        setMillis(instant);\n    }", "comment": "/**\n     * Set the date and time from fields.\n     *\n     * @param year  the year\n     * @param monthOfYear  the month of the year\n     * @param dayOfMonth  the day of the month\n     * @param hourOfDay  the hour of the day\n     * @param minuteOfHour  the minute of the hour\n     * @param secondOfMinute  the second of the minute\n     * @param millisOfSecond  the millisecond of the second\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public Property property(DateTimeFieldType type) {\n        if (type == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        DateTimeField field = type.getField(getChronology());\n        if (field.isSupported() == false) {\n            throw new IllegalArgumentException(\"\" + type + \"\");\n        }\n        return new Property(this, field);\n    }", "comment": "/**\n     * Gets the property object for the specified type, which contains many useful methods.\n     *\n     * @param type  the field type to get the chronology for\n     * @return the property object\n     * @throws IllegalArgumentException if the field is null or unsupported\n     * @since 1.2\n     */"}}
{"code": {"body": "    public Property era() {\n        return new Property(this, getChronology().era());\n    }", "comment": "/**\n     * Get the era property.\n     * \n     * @return the era property\n     */"}}
{"code": {"body": "    public Property centuryOfEra() {\n        return new Property(this, getChronology().centuryOfEra());\n    }", "comment": "/**\n     * Get the century of era property.\n     * \n     * @return the year of era property\n     */"}}
{"code": {"body": "    public Property yearOfCentury() {\n        return new Property(this, getChronology().yearOfCentury());\n    }", "comment": "/**\n     * Get the year of century property.\n     * \n     * @return the year of era property\n     */"}}
{"code": {"body": "    public Property yearOfEra() {\n        return new Property(this, getChronology().yearOfEra());\n    }", "comment": "/**\n     * Get the year of era property.\n     * \n     * @return the year of era property\n     */"}}
{"code": {"body": "    public Property year() {\n        return new Property(this, getChronology().year());\n    }", "comment": "/**\n     * Get the year property.\n     * \n     * @return the year property\n     */"}}
{"code": {"body": "    public Property weekyear() {\n        return new Property(this, getChronology().weekyear());\n    }", "comment": "/**\n     * Get the year of a week based year property.\n     * \n     * @return the year of a week based year property\n     */"}}
{"code": {"body": "    public Property monthOfYear() {\n        return new Property(this, getChronology().monthOfYear());\n    }", "comment": "/**\n     * Get the month of year property.\n     * \n     * @return the month of year property\n     */"}}
{"code": {"body": "    public Property weekOfWeekyear() {\n        return new Property(this, getChronology().weekOfWeekyear());\n    }", "comment": "/**\n     * Get the week of a week based year property.\n     * \n     * @return the week of a week based year property\n     */"}}
{"code": {"body": "    public Property dayOfYear() {\n        return new Property(this, getChronology().dayOfYear());\n    }", "comment": "/**\n     * Get the day of year property.\n     * \n     * @return the day of year property\n     */"}}
{"code": {"body": "    public Property dayOfMonth() {\n        return new Property(this, getChronology().dayOfMonth());\n    }", "comment": "/**\n     * Get the day of month property.\n     * <p>\n     * The values for day of month are defined in {@link DateTimeConstants}.\n     * \n     * @return the day of month property\n     */"}}
{"code": {"body": "    public Property dayOfWeek() {\n        return new Property(this, getChronology().dayOfWeek());\n    }", "comment": "/**\n     * Get the day of week property.\n     * <p>\n     * The values for day of week are defined in {@link DateTimeConstants}.\n     * \n     * @return the day of week property\n     */"}}
{"code": {"body": "    public Property hourOfDay() {\n        return new Property(this, getChronology().hourOfDay());\n    }", "comment": "/**\n     * Get the hour of day field property\n     * \n     * @return the hour of day property\n     */"}}
{"code": {"body": "    public Property minuteOfDay() {\n        return new Property(this, getChronology().minuteOfDay());\n    }", "comment": "/**\n     * Get the minute of day property\n     * \n     * @return the minute of day property\n     */"}}
{"code": {"body": "    public Property minuteOfHour() {\n        return new Property(this, getChronology().minuteOfHour());\n    }", "comment": "/**\n     * Get the minute of hour field property\n     * \n     * @return the minute of hour property\n     */"}}
{"code": {"body": "    public Property secondOfDay() {\n        return new Property(this, getChronology().secondOfDay());\n    }", "comment": "/**\n     * Get the second of day property\n     * \n     * @return the second of day property\n     */"}}
{"code": {"body": "    public Property secondOfMinute() {\n        return new Property(this, getChronology().secondOfMinute());\n    }", "comment": "/**\n     * Get the second of minute field property\n     * \n     * @return the second of minute property\n     */"}}
{"code": {"body": "    public Property millisOfDay() {\n        return new Property(this, getChronology().millisOfDay());\n    }", "comment": "/**\n     * Get the millis of day property\n     * \n     * @return the millis of day property\n     */"}}
{"code": {"body": "    public Property millisOfSecond() {\n        return new Property(this, getChronology().millisOfSecond());\n    }", "comment": "/**\n     * Get the millis of second property\n     * \n     * @return the millis of second property\n     */"}}
{"code": {"body": "    public MutableDateTime copy() {\n        return (MutableDateTime) clone();\n    }", "comment": "/**\n     * Clone this object without having to cast the returned object.\n     *\n     * @return a clone of the this object.\n     */"}}
{"code": {"body": "    public Object clone() {\n        try {\n            return super.clone();\n        } catch (CloneNotSupportedException ex) {\n            throw new InternalError(\"\");\n        }\n    }", "comment": "/**\n     * Clone this object.\n     *\n     * @return a clone of this object.\n     */"}}
{"code": {"body": "        private void writeObject(ObjectOutputStream oos) throws IOException {\n            oos.writeObject(iInstant);\n            oos.writeObject(iField.getType());\n        }", "comment": "/**\n         * Writes the property in a safe serialization format.\n         */"}}
{"code": {"body": "        private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {\n            iInstant = (MutableDateTime) oos.readObject();\n            DateTimeFieldType type = (DateTimeFieldType) oos.readObject();\n            iField = type.getField(iInstant.getChronology());\n        }", "comment": "/**\n         * Reads the property from a safe serialization format.\n         */"}}
{"code": {"body": "        public DateTimeField getField() {\n            return iField;\n        }", "comment": "/**\n         * Gets the field being used.\n         * \n         * @return the field\n         */"}}
{"code": {"body": "        protected long getMillis() {\n            return iInstant.getMillis();\n        }", "comment": "/**\n         * Gets the milliseconds of the datetime that this property is linked to.\n         * \n         * @return the milliseconds\n         */"}}
{"code": {"body": "        protected Chronology getChronology() {\n            return iInstant.getChronology();\n        }", "comment": "/**\n         * Gets the chronology of the datetime that this property is linked to.\n         * \n         * @return the chronology\n         * @since 1.4\n         */"}}
{"code": {"body": "        public MutableDateTime getMutableDateTime() {\n            return iInstant;\n        }", "comment": "/**\n         * Gets the mutable datetime being used.\n         * \n         * @return the mutable datetime\n         */"}}
{"code": {"body": "        public MutableDateTime addWrapField(int value) {\n            iInstant.setMillis(getField().addWrapField(iInstant.getMillis(), value));\n            return iInstant;\n        }", "comment": "/**\n         * Adds a value, possibly wrapped, to the millis value.\n         * \n         * @param value  the value to add\n         * @return the mutable datetime being used, so calls can be chained\n         * @see DateTimeField#addWrapField\n         */"}}
{"code": {"body": "        public MutableDateTime roundFloor() {\n            iInstant.setMillis(getField().roundFloor(iInstant.getMillis()));\n            return iInstant;\n        }", "comment": "/**\n         * Round to the lowest whole unit of this field.\n         *\n         * @return the mutable datetime being used, so calls can be chained\n         * @see DateTimeField#roundFloor\n         */"}}
{"code": {"body": "        public MutableDateTime roundCeiling() {\n            iInstant.setMillis(getField().roundCeiling(iInstant.getMillis()));\n            return iInstant;\n        }", "comment": "/**\n         * Round to the highest whole unit of this field.\n         *\n         * @return the mutable datetime being used, so calls can be chained\n         * @see DateTimeField#roundCeiling\n         */"}}
{"code": {"body": "        public MutableDateTime roundHalfFloor() {\n            iInstant.setMillis(getField().roundHalfFloor(iInstant.getMillis()));\n            return iInstant;\n        }", "comment": "/**\n         * Round to the nearest whole unit of this field, favoring the floor if\n         * halfway.\n         *\n         * @return the mutable datetime being used, so calls can be chained\n         * @see DateTimeField#roundHalfFloor\n         */"}}
{"code": {"body": "        public MutableDateTime roundHalfCeiling() {\n            iInstant.setMillis(getField().roundHalfCeiling(iInstant.getMillis()));\n            return iInstant;\n        }", "comment": "/**\n         * Round to the nearest whole unit of this field, favoring the ceiling if\n         * halfway.\n         *\n         * @return the mutable datetime being used, so calls can be chained\n         * @see DateTimeField#roundHalfCeiling\n         */"}}
{"code": {"body": "        public MutableDateTime roundHalfEven() {\n            iInstant.setMillis(getField().roundHalfEven(iInstant.getMillis()));\n            return iInstant;\n        }", "comment": "/**\n         * Round to the nearest whole unit of this field. If halfway, the ceiling\n         * is favored over the floor only if it makes this field's value even.\n         *\n         * @return the mutable datetime being used, so calls can be chained\n         * @see DateTimeField#roundHalfEven\n         */"}}
{"code": {"body": "public MutableInterval() {\n        super(0L, 0L, null);\n    }", "comment": "/**\n     * Constructs a zero length time interval from 1970-01-01 to 1970-01-01.\n     */"}}
{"code": {"body": "public MutableInterval(long startInstant, long endInstant) {\n        super(startInstant, endInstant, null);\n    }", "comment": "/**\n     * Constructs an interval from a start and end instant with the ISO default chronology.\n     * \n     * @param startInstant  start of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n     * @param endInstant  end of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n     * @throws IllegalArgumentException if the end is before the start\n     */"}}
{"code": {"body": "public MutableInterval(long startInstant, long endInstant, Chronology chronology) {\n        super(startInstant, endInstant, chronology);\n    }", "comment": "/**\n     * Constructs an interval from a start and end instant with a chronology.\n     * \n     * @param chronology  the chronology to use, null is ISO default\n     * @param startInstant  start of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n     * @param endInstant  end of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n     * @throws IllegalArgumentException if the end is before the start\n     */"}}
{"code": {"body": "public MutableInterval(ReadableInstant start, ReadableInstant end) {\n        super(start, end);\n    }", "comment": "/**\n     * Constructs an interval from a start and end instant.\n     * <p>\n     * The chronology used is that of the start instant.\n     * \n     * @param start  start of this interval, null means now\n     * @param end  end of this interval, null means now\n     * @throws IllegalArgumentException if the end is before the start\n     */"}}
{"code": {"body": "public MutableInterval(ReadableInstant start, ReadableDuration duration) {\n        super(start, duration);\n    }", "comment": "/**\n     * Constructs an interval from a start instant and a duration.\n     * \n     * @param start  start of this interval, null means now\n     * @param duration  the duration of this interval, null means zero length\n     * @throws IllegalArgumentException if the end is before the start\n     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n     */"}}
{"code": {"body": "public MutableInterval(ReadableDuration duration, ReadableInstant end) {\n        super(duration, end);\n    }", "comment": "/**\n     * Constructs an interval from a millisecond duration and an end instant.\n     * \n     * @param duration  the duration of this interval, null means zero length\n     * @param end  end of this interval, null means now\n     * @throws IllegalArgumentException if the end is before the start\n     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n     */"}}
{"code": {"body": "public MutableInterval(ReadableInstant start, ReadablePeriod period) {\n        super(start, period);\n    }", "comment": "/**\n     * Constructs an interval from a start instant and a time period.\n     * <p>\n     * When forming the interval, the chronology from the instant is used\n     * if present, otherwise the chronology of the period is used.\n     * \n     * @param start  start of this interval, null means now\n     * @param period  the period of this interval, null means zero length\n     * @throws IllegalArgumentException if the end is before the start\n     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n     */"}}
{"code": {"body": "public MutableInterval(ReadablePeriod period, ReadableInstant end) {\n        super(period, end);\n    }", "comment": "/**\n     * Constructs an interval from a time period and an end instant.\n     * <p>\n     * When forming the interval, the chronology from the instant is used\n     * if present, otherwise the chronology of the period is used.\n     * \n     * @param period  the period of this interval, null means zero length\n     * @param end  end of this interval, null means now\n     * @throws IllegalArgumentException if the end is before the start\n     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n     */"}}
{"code": {"body": "public MutableInterval(Object interval) {\n        super(interval, null);\n    }", "comment": "/**\n     * Constructs a time interval by converting or copying from another object.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadableInterval and String.\n     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}\n     * and {@link ISOPeriodFormat#standard()}, and may be 'datetime/datetime',\n     * 'datetime/period' or 'period/datetime'.\n     * \n     * @param interval  the time interval to copy\n     * @throws IllegalArgumentException if the interval is invalid\n     */"}}
{"code": {"body": "public MutableInterval(Object interval, Chronology chronology) {\n        super(interval, chronology);\n    }", "comment": "/**\n     * Constructs a time interval by converting or copying from another object,\n     * overriding the chronology.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadableInterval and String.\n     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}\n     * and {@link ISOPeriodFormat#standard()}, and may be 'datetime/datetime',\n     * 'datetime/period' or 'period/datetime'.\n     * \n     * @param interval  the time interval to copy\n     * @param chronology  the chronology to use, null means ISO default\n     * @throws IllegalArgumentException if the interval is invalid\n     */"}}
{"code": {"body": "public MutableInterval copy() {\n        return (MutableInterval) clone();\n    }", "comment": "/**\n     * Clone this object without having to cast the returned object.\n     *\n     * @return a clone of the this object.\n     */"}}
{"code": {"body": "    public static MutableInterval parse(String str) {\n        return new MutableInterval(str);\n    }", "comment": "/**\n     * Parses a {@code MutableInterval} from the specified string.\n     * <p>\n     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}\n     * and {@link ISOPeriodFormat#standard()}, and may be 'datetime/datetime',\n     * 'datetime/period' or 'period/datetime'.\n     * \n     * @param str  the string to parse, not null\n     * @since 2.0\n     */"}}
{"code": {"body": "    public void setInterval(ReadableInstant start, ReadableInstant end) {\n        if (start == null && end == null) {\n            long now = DateTimeUtils.currentTimeMillis();\n            setInterval(now, now);\n        } else {\n            long startMillis = DateTimeUtils.getInstantMillis(start);\n            long endMillis = DateTimeUtils.getInstantMillis(end);\n            Chronology chrono = DateTimeUtils.getInstantChronology(start);\n            super.setInterval(startMillis, endMillis, chrono);\n        }\n    }", "comment": "/**\n     * Sets this interval from two instants, replacing the chronology with\n     * that from the start instant.\n     *\n     * @param start  the start of the time interval\n     * @param end  the start of the time interval\n     * @throws IllegalArgumentException if the end is before the start\n     */"}}
{"code": {"body": "    public void setChronology(Chronology chrono) {\n        super.setInterval(getStartMillis(), getEndMillis(), chrono);\n    }", "comment": "/**\n     * Sets the chronology of this time interval.\n     *\n     * @param chrono  the chronology to use, null means ISO default\n     */"}}
{"code": {"body": "    public void setStartMillis(long startInstant) {\n        super.setInterval(startInstant, getEndMillis(), getChronology());\n    }", "comment": "/**\n     * Sets the start of this time interval.\n     *\n     * @param startInstant  the start of the time interval,\n     *  millisecond instant from 1970-01-01T00:00:00Z\n     * @throws IllegalArgumentException if the end is before the start\n     */"}}
{"code": {"body": "    public void setStart(ReadableInstant start) {\n        long startMillis = DateTimeUtils.getInstantMillis(start);\n        super.setInterval(startMillis, getEndMillis(), getChronology());\n    }", "comment": "/**\n     * Sets the start of this time interval as an Instant.\n     *\n     * @param start  the start of the time interval, null means now\n     * @throws IllegalArgumentException if the end is before the start\n     */"}}
{"code": {"body": "    public void setEndMillis(long endInstant) {\n        super.setInterval(getStartMillis(), endInstant, getChronology());\n    }", "comment": "/** \n     * Sets the end of this time interval.\n     *\n     * @param endInstant  the end of the time interval,\n     *  millisecond instant from 1970-01-01T00:00:00Z\n     * @throws IllegalArgumentException if the end is before the start\n     */"}}
{"code": {"body": "    public void setEnd(ReadableInstant end) {\n        long endMillis = DateTimeUtils.getInstantMillis(end);\n        super.setInterval(getStartMillis(), endMillis, getChronology());\n    }", "comment": "/** \n     * Sets the end of this time interval as an Instant.\n     *\n     * @param end  the end of the time interval, null means now\n     * @throws IllegalArgumentException if the end is before the start\n     */"}}
{"code": {"body": "    public void setDurationAfterStart(ReadableDuration duration) {\n        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n        setEndMillis(FieldUtils.safeAdd(getStartMillis(), durationMillis));\n    }", "comment": "/**\n     * Sets the duration of this time interval, preserving the start instant.\n     *\n     * @param duration  new duration for interval, null means zero length\n     * @throws IllegalArgumentException if the end is before the start\n     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n     */"}}
{"code": {"body": "    public void setDurationBeforeEnd(ReadableDuration duration) {\n        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n        setStartMillis(FieldUtils.safeAdd(getEndMillis(), -durationMillis));\n    }", "comment": "/**\n     * Sets the duration of this time interval, preserving the end instant.\n     *\n     * @param duration  new duration for interval, null means zero length\n     * @throws IllegalArgumentException if the end is before the start\n     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n     */"}}
{"code": {"body": "    public void setPeriodAfterStart(ReadablePeriod period) {\n        if (period == null) {\n            setEndMillis(getStartMillis());\n        } else {\n            setEndMillis(getChronology().add(period, getStartMillis(), 1));\n        }\n    }", "comment": "/**\n     * Sets the period of this time interval, preserving the start instant\n     * and using the ISOChronology in the default zone for calculations.\n     *\n     * @param period  new period for interval, null means zero length\n     * @throws IllegalArgumentException if the end is before the start\n     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n     */"}}
{"code": {"body": "    public void setPeriodBeforeEnd(ReadablePeriod period) {\n        if (period == null) {\n            setStartMillis(getEndMillis());\n        } else {\n            setStartMillis(getChronology().add(period, getEndMillis(), -1));\n        }\n    }", "comment": "/**\n     * Sets the period of this time interval, preserving the end instant\n     * and using the ISOChronology in the default zone for calculations.\n     *\n     * @param period  new period for interval, null means zero length\n     * @throws IllegalArgumentException if the end is before the start\n     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n     */"}}
{"code": {"body": "    public MutableInterval copy() {\n        return (MutableInterval) clone();\n    }", "comment": "/**\n     * Clone this object without having to cast the returned object.\n     *\n     * @return a clone of the this object.\n     */"}}
{"code": {"body": "    public Object clone() {\n        try {\n            return super.clone();\n        } catch (CloneNotSupportedException ex) {\n            throw new InternalError(\"\");\n        }\n    }", "comment": "/**\n     * Clone this object.\n     *\n     * @return a clone of this object.\n     */"}}
{"code": {"body": "public MutablePeriod() {\n        super(0L, null, null);\n    }", "comment": "/**\n     * Creates a zero-length period using the standard period type.\n     */"}}
{"code": {"body": "public MutablePeriod(PeriodType type) {\n        super(0L, type, null);\n    }", "comment": "/**\n     * Creates a zero-length period using the specified period type.\n     *\n     * @param type  which set of fields this period supports\n     */"}}
{"code": {"body": "public MutablePeriod(int hours, int minutes, int seconds, int millis) {\n        super(0, 0, 0, 0, hours, minutes, seconds, millis, PeriodType.standard());\n    }", "comment": "/**\n     * Create a period from a set of field values using the standard set of fields.\n     *\n     * @param hours  amount of hours in this period\n     * @param minutes  amount of minutes in this period\n     * @param seconds  amount of seconds in this period\n     * @param millis  amount of milliseconds in this period\n     */"}}
{"code": {"body": "public MutablePeriod(int years, int months, int weeks, int days,", "comment": "/**\n     * Create a period from a set of field values using the standard set of fields.\n     *\n     * @param years  amount of years in this period\n     * @param months  amount of months in this period\n     * @param weeks  amount of weeks in this period\n     * @param days  amount of days in this period\n     * @param hours  amount of hours in this period\n     * @param minutes  amount of minutes in this period\n     * @param seconds  amount of seconds in this period\n     * @param millis  amount of milliseconds in this period\n     */"}}
{"code": {"body": "public MutablePeriod(int years, int months, int weeks, int days,", "comment": "/**\n     * Create a period from a set of field values using the standard set of fields.\n     *\n     * @param years  amount of years in this period\n     * @param months  amount of months in this period\n     * @param weeks  amount of weeks in this period\n     * @param days  amount of days in this period\n     * @param hours  amount of hours in this period\n     * @param minutes  amount of minutes in this period\n     * @param seconds  amount of seconds in this period\n     * @param millis  amount of milliseconds in this period\n     */"}}
{"code": {"body": "public MutablePeriod(long duration) {\n        super(duration);\n    }", "comment": "/**\n     * Creates a period from the given millisecond duration using the standard\n     * set of fields.\n     * <p>\n     * Only precise fields in the period type will be used.\n     * For the standard period type this is the time fields only.\n     * Thus the year, month, week and day fields will not be populated.\n     * <p>\n     * If the duration is small, less than one day, then this method will perform\n     * as you might expect and split the fields evenly.\n     * <p>\n     * If the duration is larger than one day then all the remaining duration will\n     * be stored in the largest available precise field, hours in this case.\n     * <p>\n     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n     * ((365 + 60 + 5) * 24) hours by this constructor.\n     * <p>\n     * For more control over the conversion process, you have two options:\n     * <ul>\n     * <li>convert the duration to an {@link Interval}, and from there obtain the period\n     * <li>specify a period type that contains precise definitions of the day and larger\n     * fields, such as the UTC or precise types.\n     * </ul>\n     *\n     * @param duration  the duration, in milliseconds\n     */"}}
{"code": {"body": "public MutablePeriod(long duration, PeriodType type) {\n        super(duration, type, null);\n    }", "comment": "/**\n     * Creates a period from the given millisecond duration.\n     * <p>\n     * Only precise fields in the period type will be used.\n     * Imprecise fields will not be populated.\n     * <p>\n     * If the duration is small then this method will perform\n     * as you might expect and split the fields evenly.\n     * <p>\n     * If the duration is large then all the remaining duration will\n     * be stored in the largest available precise field.\n     * For details as to which fields are precise, review the period type javadoc.\n     *\n     * @param duration  the duration, in milliseconds\n     * @param type  which set of fields this period supports, null means standard\n     */"}}
{"code": {"body": "public MutablePeriod(long duration, Chronology chronology) {\n        super(duration, null, chronology);\n    }", "comment": "/**\n     * Creates a period from the given millisecond duration using the standard\n     * set of fields.\n     * <p>\n     * Only precise fields in the period type will be used.\n     * Imprecise fields will not be populated.\n     * <p>\n     * If the duration is small then this method will perform\n     * as you might expect and split the fields evenly.\n     * <p>\n     * If the duration is large then all the remaining duration will\n     * be stored in the largest available precise field.\n     * For details as to which fields are precise, review the period type javadoc.\n     *\n     * @param duration  the duration, in milliseconds\n     * @param chronology  the chronology to use to split the duration, null means ISO default\n     */"}}
{"code": {"body": "public MutablePeriod(long duration, PeriodType type, Chronology chronology) {\n        super(duration, type, chronology);\n    }", "comment": "/**\n     * Creates a period from the given millisecond duration.\n     * <p>\n     * Only precise fields in the period type will be used.\n     * Imprecise fields will not be populated.\n     * <p>\n     * If the duration is small then this method will perform\n     * as you might expect and split the fields evenly.\n     * <p>\n     * If the duration is large then all the remaining duration will\n     * be stored in the largest available precise field.\n     * For details as to which fields are precise, review the period type javadoc.\n     *\n     * @param duration  the duration, in milliseconds\n     * @param type  which set of fields this period supports, null means standard\n     * @param chronology  the chronology to use to split the duration, null means ISO default\n     */"}}
{"code": {"body": "public MutablePeriod(long startInstant, long endInstant) {\n        super(startInstant, endInstant, null, null);\n    }", "comment": "/**\n     * Creates a period from the given interval endpoints using the standard\n     * set of fields.\n     *\n     * @param startInstant  interval start, in milliseconds\n     * @param endInstant  interval end, in milliseconds\n     */"}}
{"code": {"body": "public MutablePeriod(long startInstant, long endInstant, PeriodType type) {\n        super(startInstant, endInstant, type, null);\n    }", "comment": "/**\n     * Creates a period from the given interval endpoints.\n     *\n     * @param startInstant  interval start, in milliseconds\n     * @param endInstant  interval end, in milliseconds\n     * @param type  which set of fields this period supports, null means standard\n     */"}}
{"code": {"body": "public MutablePeriod(long startInstant, long endInstant, Chronology chrono) {\n        super(startInstant, endInstant, null, chrono);\n    }", "comment": "/**\n     * Creates a period from the given interval endpoints using the standard\n     * set of fields.\n     *\n     * @param startInstant  interval start, in milliseconds\n     * @param endInstant  interval end, in milliseconds\n     * @param chrono  the chronology to use, null means ISO in default zone\n     */"}}
{"code": {"body": "public MutablePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono) {\n        super(startInstant, endInstant, type, chrono);\n    }", "comment": "/**\n     * Creates a period from the given interval endpoints.\n     *\n     * @param startInstant  interval start, in milliseconds\n     * @param endInstant  interval end, in milliseconds\n     * @param type  which set of fields this period supports, null means standard\n     * @param chrono  the chronology to use, null means ISO in default zone\n     */"}}
{"code": {"body": "public MutablePeriod(ReadableInstant startInstant, ReadableInstant endInstant) {\n        super(startInstant, endInstant, null);\n    }", "comment": "/**\n     * Creates a period from the given interval endpoints using the standard\n     * set of fields.\n     * <p>\n     * The chronology of the start instant is used, unless that is null when the\n     * chronology of the end instant is used instead.\n     *\n     * @param startInstant  interval start, null means now\n     * @param endInstant  interval end, null means now\n     */"}}
{"code": {"body": "public MutablePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type) {\n        super(startInstant, endInstant, type);\n    }", "comment": "/**\n     * Creates a period from the given interval endpoints.\n     * <p>\n     * The chronology of the start instant is used, unless that is null when the\n     * chronology of the end instant is used instead.\n     *\n     * @param startInstant  interval start, null means now\n     * @param endInstant  interval end, null means now\n     * @param type  which set of fields this period supports, null means AllType\n     */"}}
{"code": {"body": "public MutablePeriod(ReadableInstant startInstant, ReadableDuration duration) {\n        super(startInstant, duration, null);\n    }", "comment": "/**\n     * Creates a period from the given start point and the duration.\n     *\n     * @param startInstant  the interval start, null means now\n     * @param duration  the duration of the interval, null means zero-length\n     */"}}
{"code": {"body": "public MutablePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type) {\n        super(startInstant, duration, type);\n    }", "comment": "/**\n     * Creates a period from the given start point and the duration.\n     *\n     * @param startInstant  the interval start, null means now\n     * @param duration  the duration of the interval, null means zero-length\n     * @param type  which set of fields this period supports, null means standard\n     */"}}
{"code": {"body": "public MutablePeriod(ReadableDuration duration, ReadableInstant endInstant) {\n        super(duration, endInstant, null);\n    }", "comment": "/**\n     * Creates a period from the given duration and end point.\n     *\n     * @param duration  the duration of the interval, null means zero-length\n     * @param endInstant  the interval end, null means now\n     */"}}
{"code": {"body": "public MutablePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type) {\n        super(duration, endInstant, type);\n    }", "comment": "/**\n     * Creates a period from the given duration and end point.\n     *\n     * @param duration  the duration of the interval, null means zero-length\n     * @param endInstant  the interval end, null means now\n     * @param type  which set of fields this period supports, null means standard\n     */"}}
{"code": {"body": "public MutablePeriod(Object period) {\n        super(period, null, null);\n    }", "comment": "/**\n     * Creates a period by converting or copying from another object.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadablePeriod, ReadableInterval and String.\n     * The String formats are described by {@link ISOPeriodFormat#standard()}.\n     *\n     * @param period  period to convert\n     * @throws IllegalArgumentException if period is invalid\n     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n     */"}}
{"code": {"body": "public MutablePeriod(Object period, PeriodType type) {\n        super(period, type, null);\n    }", "comment": "/**\n     * Creates a period by converting or copying from another object.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadablePeriod, ReadableInterval and String.\n     * The String formats are described by {@link ISOPeriodFormat#standard()}.\n     *\n     * @param period  period to convert\n     * @param type  which set of fields this period supports, null means use converter\n     * @throws IllegalArgumentException if period is invalid\n     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n     */"}}
{"code": {"body": "public MutablePeriod(Object period, Chronology chrono) {\n        super(period, null, chrono);\n    }", "comment": "/**\n     * Creates a period by converting or copying from another object.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadablePeriod, ReadableInterval and String.\n     * The String formats are described by {@link ISOPeriodFormat#standard()}.\n     *\n     * @param period  period to convert\n     * @param chrono  the chronology to use, null means ISO in default zone\n     * @throws IllegalArgumentException if period is invalid\n     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n     */"}}
{"code": {"body": "public MutablePeriod(Object period, PeriodType type, Chronology chrono) {\n        super(period, type, chrono);\n    }", "comment": "/**\n     * Creates a period by converting or copying from another object.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadablePeriod, ReadableInterval and String.\n     * The String formats are described by {@link ISOPeriodFormat#standard()}.\n     *\n     * @param period  period to convert\n     * @param type  which set of fields this period supports, null means use converter\n     * @param chrono  the chronology to use, null means ISO in default zone\n     * @throws IllegalArgumentException if period is invalid\n     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n     */"}}
{"code": {"body": "public MutablePeriod copy() {\n        return (MutablePeriod) clone();\n    }", "comment": "/**\n     * Clone this object without having to cast the returned object.\n     *\n     * @return a clone of the this object.\n     */"}}
{"code": {"body": "    public static MutablePeriod parse(String str, PeriodFormatter formatter) {\n        return formatter.parsePeriod(str).toMutablePeriod();\n    }", "comment": "/**\n     * Parses a {@code MutablePeriod} from the specified string using a formatter.\n     * \n     * @param str  the string to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @since 2.0\n     */"}}
{"code": {"body": "    public void clear() {\n        super.setValues(new int[size()]);\n    }", "comment": "/**\n     * Clears the period, setting all values back to zero.\n     */"}}
{"code": {"body": "    public void setValue(int index, int value) {\n        super.setValue(index, value);\n    }", "comment": "/**\n     * Sets the value of one of the fields by index.\n     *\n     * @param index  the field index\n     * @param value  the new value for the field\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */"}}
{"code": {"body": "    public void set(DurationFieldType field, int value) {\n        super.setField(field, value);\n    }", "comment": "/**\n     * Sets the value of one of the fields.\n     * <p>\n     * The field type specified must be one of those that is supported by the period.\n     *\n     * @param field  a DurationFieldType instance that is supported by this period, not null\n     * @param value  the new value for the field\n     * @throws IllegalArgumentException if the field is null or not supported\n     */"}}
{"code": {"body": "    public void setPeriod(long duration, Chronology chrono) {\n        chrono = DateTimeUtils.getChronology(chrono);\n        setValues(chrono.get(this, duration));\n    }", "comment": "/**\n     * Sets all the fields in one go from a millisecond duration.\n     * <p>\n     * When dividing the duration, only precise fields in the period type will be used.\n     * For large durations, all the remaining duration will be stored in the largest\n     * available precise field.\n     * \n     * @param duration  the duration, in milliseconds\n     * @param chrono  the chronology to use, null means ISO chronology\n     * @throws ArithmeticException if the set exceeds the capacity of the period\n     */"}}
{"code": {"body": "    public void add(long duration, Chronology chrono) {\n        add(new Period(duration, getPeriodType(), chrono));\n    }", "comment": "/**\n     * Adds a millisecond duration to this one by dividing the duration into\n     * fields and calling {@link #add(ReadablePeriod)}.\n     * <p>\n     * When dividing the duration, only precise fields in the period type will be used.\n     * For large durations, all the remaining duration will be stored in the largest\n     * available precise field.\n     * \n     * @param duration  the duration, in milliseconds\n     * @param chrono  the chronology to use, null means ISO default\n     * @throws ArithmeticException if the addition exceeds the capacity of the period\n     */"}}
{"code": {"body": "    public void mergePeriod(ReadablePeriod period) {\n        super.mergePeriod(period);\n    }", "comment": "/**\n     * Merges all the fields from the specified period into this one.\n     * <p>\n     * Fields that are not present in the specified period are left unaltered.\n     * \n     * @param period  the period to set, null ignored\n     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n     */"}}
{"code": {"body": "    public int getYears() {\n        return getPeriodType().getIndexedField(this, PeriodType.YEAR_INDEX);\n    }", "comment": "/**\n     * Gets the years field part of the period.\n     * \n     * @return the number of years in the period, zero if unsupported\n     */"}}
{"code": {"body": "    public int getMonths() {\n        return getPeriodType().getIndexedField(this, PeriodType.MONTH_INDEX);\n    }", "comment": "/**\n     * Gets the months field part of the period.\n     * \n     * @return the number of months in the period, zero if unsupported\n     */"}}
{"code": {"body": "    public int getWeeks() {\n        return getPeriodType().getIndexedField(this, PeriodType.WEEK_INDEX);\n    }", "comment": "/**\n     * Gets the weeks field part of the period.\n     * \n     * @return the number of weeks in the period, zero if unsupported\n     */"}}
{"code": {"body": "    public int getDays() {\n        return getPeriodType().getIndexedField(this, PeriodType.DAY_INDEX);\n    }", "comment": "/**\n     * Gets the days field part of the period.\n     * \n     * @return the number of days in the period, zero if unsupported\n     */"}}
{"code": {"body": "    public int getHours() {\n        return getPeriodType().getIndexedField(this, PeriodType.HOUR_INDEX);\n    }", "comment": "/**\n     * Gets the hours field part of the period.\n     * \n     * @return the number of hours in the period, zero if unsupported\n     */"}}
{"code": {"body": "    public int getMinutes() {\n        return getPeriodType().getIndexedField(this, PeriodType.MINUTE_INDEX);\n    }", "comment": "/**\n     * Gets the minutes field part of the period.\n     * \n     * @return the number of minutes in the period, zero if unsupported\n     */"}}
{"code": {"body": "    public int getSeconds() {\n        return getPeriodType().getIndexedField(this, PeriodType.SECOND_INDEX);\n    }", "comment": "/**\n     * Gets the seconds field part of the period.\n     * \n     * @return the number of seconds in the period, zero if unsupported\n     */"}}
{"code": {"body": "    public int getMillis() {\n        return getPeriodType().getIndexedField(this, PeriodType.MILLI_INDEX);\n    }", "comment": "/**\n     * Gets the millis field part of the period.\n     * \n     * @return the number of millis in the period, zero if unsupported\n     */"}}
{"code": {"body": "    public void setYears(int years) {\n        super.setField(DurationFieldType.years(), years);\n    }", "comment": "/**\n     * Sets the number of years of the period.\n     * \n     * @param years  the number of years\n     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n     */"}}
{"code": {"body": "    public void addYears(int years) {\n        super.addField(DurationFieldType.years(), years);\n    }", "comment": "/**\n     * Adds the specified years to the number of years in the period.\n     * \n     * @param years  the number of years\n     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n     * @throws ArithmeticException if the addition exceeds the capacity of the period\n     */"}}
{"code": {"body": "    public void setMonths(int months) {\n        super.setField(DurationFieldType.months(), months);\n    }", "comment": "/**\n     * Sets the number of months of the period.\n     * \n     * @param months  the number of months\n     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n     */"}}
{"code": {"body": "    public void addMonths(int months) {\n        super.addField(DurationFieldType.months(), months);\n    }", "comment": "/**\n     * Adds the specified months to the number of months in the period.\n     * \n     * @param months  the number of months\n     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n     * @throws ArithmeticException if the addition exceeds the capacity of the period\n     */"}}
{"code": {"body": "    public void setWeeks(int weeks) {\n        super.setField(DurationFieldType.weeks(), weeks);\n    }", "comment": "/**\n     * Sets the number of weeks of the period.\n     * \n     * @param weeks  the number of weeks\n     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n     */"}}
{"code": {"body": "    public void addWeeks(int weeks) {\n        super.addField(DurationFieldType.weeks(), weeks);\n    }", "comment": "/**\n     * Adds the specified weeks to the number of weeks in the period.\n     * \n     * @param weeks  the number of weeks\n     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n     * @throws ArithmeticException if the addition exceeds the capacity of the period\n     */"}}
{"code": {"body": "    public void setDays(int days) {\n        super.setField(DurationFieldType.days(), days);\n    }", "comment": "/**\n     * Sets the number of days of the period.\n     * \n     * @param days  the number of days\n     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n     */"}}
{"code": {"body": "    public void addDays(int days) {\n        super.addField(DurationFieldType.days(), days);\n    }", "comment": "/**\n     * Adds the specified days to the number of days in the period.\n     * \n     * @param days  the number of days\n     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n     * @throws ArithmeticException if the addition exceeds the capacity of the period\n     */"}}
{"code": {"body": "    public void setHours(int hours) {\n        super.setField(DurationFieldType.hours(), hours);\n    }", "comment": "/**\n     * Sets the number of hours of the period.\n     * \n     * @param hours  the number of hours\n     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n     */"}}
{"code": {"body": "    public void addHours(int hours) {\n        super.addField(DurationFieldType.hours(), hours);\n    }", "comment": "/**\n     * Adds the specified hours to the number of hours in the period.\n     * \n     * @param hours  the number of hours\n     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n     * @throws ArithmeticException if the addition exceeds the capacity of the period\n     */"}}
{"code": {"body": "    public void setMinutes(int minutes) {\n        super.setField(DurationFieldType.minutes(), minutes);\n    }", "comment": "/**\n     * Sets the number of minutes of the period.\n     * \n     * @param minutes  the number of minutes\n     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n     */"}}
{"code": {"body": "    public void addMinutes(int minutes) {\n        super.addField(DurationFieldType.minutes(), minutes);\n    }", "comment": "/**\n     * Adds the specified minutes to the number of minutes in the period.\n     * \n     * @param minutes  the number of minutes\n     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n     * @throws ArithmeticException if the addition exceeds the capacity of the period\n     */"}}
{"code": {"body": "    public void setSeconds(int seconds) {\n        super.setField(DurationFieldType.seconds(), seconds);\n    }", "comment": "/**\n     * Sets the number of seconds of the period.\n     * \n     * @param seconds  the number of seconds\n     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n     */"}}
{"code": {"body": "    public void addSeconds(int seconds) {\n        super.addField(DurationFieldType.seconds(), seconds);\n    }", "comment": "/**\n     * Adds the specified seconds to the number of seconds in the period.\n     * \n     * @param seconds  the number of seconds\n     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n     * @throws ArithmeticException if the addition exceeds the capacity of the period\n     */"}}
{"code": {"body": "    public void setMillis(int millis) {\n        super.setField(DurationFieldType.millis(), millis);\n    }", "comment": "/**\n     * Sets the number of millis of the period.\n     * \n     * @param millis  the number of millis\n     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n     */"}}
{"code": {"body": "    public void addMillis(int millis) {\n        super.addField(DurationFieldType.millis(), millis);\n    }", "comment": "/**\n     * Adds the specified millis to the number of millis in the period.\n     * \n     * @param millis  the number of millis\n     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n     * @throws ArithmeticException if the addition exceeds the capacity of the period\n     */"}}
{"code": {"body": "    public MutablePeriod copy() {\n        return (MutablePeriod) clone();\n    }", "comment": "/**\n     * Clone this object without having to cast the returned object.\n     *\n     * @return a clone of the this object.\n     */"}}
{"code": {"body": "    public Object clone() {\n        try {\n            return super.clone();\n        } catch (CloneNotSupportedException ex) {\n            throw new InternalError(\"\");\n        }\n    }", "comment": "/**\n     * Clone this object.\n     *\n     * @return a clone of this object.\n     */"}}
{"code": {"body": "public Partial() {\n        this((Chronology) null);\n    }", "comment": "/**\n     * Constructs a Partial with no fields or values, which can be considered\n     * to represent any date.\n     * <p>\n     * This is most useful when constructing partials, for example:\n     * <pre>\n     * Partial p = new Partial()\n     *     .with(DateTimeFieldType.dayOfWeek(), 5)\n     *     .with(DateTimeFieldType.hourOfDay(), 12)\n     *     .with(DateTimeFieldType.minuteOfHour(), 20);\n     * </pre>\n     * Note that, although this is a clean way to write code, it is fairly\n     * inefficient internally.\n     * <p>\n     * The constructor uses the default ISO chronology.\n     */"}}
{"code": {"body": "public Partial(Chronology chrono) {\n        super();\n        iChronology = DateTimeUtils.getChronology(chrono).withUTC();\n        iTypes = new DateTimeFieldType[0];\n        iValues = new int[0];\n    }", "comment": "/**\n     * Constructs a Partial with no fields or values, which can be considered\n     * to represent any date.\n     * <p>\n     * This is most useful when constructing partials, for example:\n     * <pre>\n     * Partial p = new Partial(chrono)\n     *     .with(DateTimeFieldType.dayOfWeek(), 5)\n     *     .with(DateTimeFieldType.hourOfDay(), 12)\n     *     .with(DateTimeFieldType.minuteOfHour(), 20);\n     * </pre>\n     * Note that, although this is a clean way to write code, it is fairly\n     * inefficient internally.\n     *\n     * @param chrono  the chronology, null means ISO\n     */"}}
{"code": {"body": "public Partial(DateTimeFieldType type, int value) {\n        this(type, value, null);\n    }", "comment": "/**\n     * Constructs a Partial with the specified field and value.\n     * <p>\n     * The constructor uses the default ISO chronology.\n     * \n     * @param type  the single type to create the partial from, not null\n     * @param value  the value to store\n     * @throws IllegalArgumentException if the type or value is invalid\n     */"}}
{"code": {"body": "public Partial(DateTimeFieldType type, int value, Chronology chronology) {\n        super();\n        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n        iChronology = chronology;\n        if (type == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        iTypes = new DateTimeFieldType[] {type};\n        iValues = new int[] {value};\n        chronology.validate(this, iValues);\n    }", "comment": "/**\n     * Constructs a Partial with the specified field and value.\n     * <p>\n     * The constructor uses the specified chronology.\n     * \n     * @param type  the single type to create the partial from, not null\n     * @param value  the value to store\n     * @param chronology  the chronology, null means ISO\n     * @throws IllegalArgumentException if the type or value is invalid\n     */"}}
{"code": {"body": "public Partial(DateTimeFieldType[] types, int[] values) {\n        this(types, values, null);\n    }", "comment": "/**\n     * Constructs a Partial with the specified fields and values.\n     * The fields must be specified in the order largest to smallest.\n     * <p>\n     * The constructor uses the specified chronology.\n     * \n     * @param types  the types to create the partial from, not null\n     * @param values  the values to store, not null\n     * @throws IllegalArgumentException if the types or values are invalid\n     */"}}
{"code": {"body": "public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n        super();\n        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n        iChronology = chronology;\n        if (types == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (values.length != types.length) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (types.length == 0) {\n            iTypes = types;\n            iValues = values;\n            return;\n        }\n        for (int i = 0; i < types.length; i++) {\n            if (types[i] == null) {\n                throw new IllegalArgumentException(\"\" + i);\n            }\n        }\n        DurationField lastUnitField = null;\n        for (int i = 0; i < types.length; i++) {\n            DateTimeFieldType loopType = types[i];\n            DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n            if (i > 0) {\n                int compare = lastUnitField.compareTo(loopUnitField);\n                if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"\" +\n                            types[i - 1].getName() + \"\" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"\" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"\" +\n                                    types[i - 1].getName() + \"\" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"\" +\n                                    types[i - 1].getName() + \"\" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"\" + loopType.getName());\n                        }\n                    }\n                }\n            }\n            lastUnitField = loopUnitField;\n        }\n        \n        iTypes = (DateTimeFieldType[]) types.clone();\n        chronology.validate(this, values);\n        iValues = (int[]) values.clone();\n    }", "comment": "/**\n     * Constructs a Partial with the specified fields and values.\n     * The fields must be specified in the order largest to smallest.\n     * <p>\n     * The constructor uses the specified chronology.\n     * \n     * @param types  the types to create the partial from, not null\n     * @param values  the values to store, not null\n     * @param chronology  the chronology, null means ISO\n     * @throws IllegalArgumentException if the types or values are invalid\n     */"}}
{"code": {"body": "public Partial(ReadablePartial partial) {\n        super();\n        if (partial == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        iChronology = DateTimeUtils.getChronology(partial.getChronology()).withUTC();\n        iTypes = new DateTimeFieldType[partial.size()];\n        iValues = new int[partial.size()];\n        for (int i = 0; i < partial.size(); i++) {\n            iTypes[i] = partial.getFieldType(i);\n            iValues[i] = partial.getValue(i);\n        }\n    }", "comment": "/**\n     * Constructs a Partial by copying all the fields and types from\n     * another partial.\n     * <p>\n     * This is most useful when copying from a YearMonthDay or TimeOfDay.\n     */"}}
{"code": {"body": "public Partial withChronologyRetainFields(Chronology newChronology) {\n        newChronology = DateTimeUtils.getChronology(newChronology);\n        newChronology = newChronology.withUTC();\n        if (newChronology == getChronology()) {\n            return this;\n        } else {\n            Partial newPartial = new Partial(newChronology, iTypes, iValues);\n            newChronology.validate(newPartial, iValues);\n            return newPartial;\n        }\n    }", "comment": "/**\n     * Creates a new Partial instance with the specified chronology.\n     * This instance is immutable and unaffected by this method call.\n     * <p>\n     * This method retains the values of the fields, thus the result will\n     * typically refer to a different instant.\n     * <p>\n     * The time zone of the specified chronology is ignored, as Partial\n     * operates without a time zone.\n     *\n     * @param newChronology  the new chronology, null means ISO\n     * @return a copy of this datetime with a different chronology\n     * @throws IllegalArgumentException if the values are invalid for the new chronology\n     */"}}
{"code": {"body": "public Partial with(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        int index = indexOf(fieldType);\n        if (index == -1) {\n            DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n            int[] newValues = new int[newTypes.length];\n            \n            \n            int i = 0;\n            DurationField unitField = fieldType.getDurationType().getField(iChronology);\n            if (unitField.isSupported()) {\n                for (; i < iTypes.length; i++) {\n                    DateTimeFieldType loopType = iTypes[i];\n                    DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                    if (loopUnitField.isSupported()) {\n                        int compare = unitField.compareTo(loopUnitField);\n                        if (compare > 0) {\n                            break;\n                        } else if (compare == 0) {\n                            DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                            DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                            if (rangeField.compareTo(loopRangeField) > 0) {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            System.arraycopy(iTypes, 0, newTypes, 0, i);\n            System.arraycopy(iValues, 0, newValues, 0, i);\n            newTypes[i] = fieldType;\n            newValues[i] = value;\n            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n            System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n            \n            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n            iChronology.validate(newPartial, newValues);\n            return newPartial;\n        }\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new Partial(this, newValues);\n    }", "comment": "/**\n     * Gets a copy of this date with the specified field set to a new value.\n     * <p>\n     * If this partial did not previously support the field, the new one will.\n     * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.\n     * <p>\n     * For example, if the field type is <code>dayOfMonth</code> then the day\n     * would be changed/added in the returned instance.\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this instance with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     */"}}
{"code": {"body": "public Partial without(DateTimeFieldType fieldType) {\n        int index = indexOf(fieldType);\n        if (index != -1) {\n            DateTimeFieldType[] newTypes = new DateTimeFieldType[size() - 1];\n            int[] newValues = new int[size() - 1];\n            System.arraycopy(iTypes, 0, newTypes, 0, index);\n            System.arraycopy(iTypes, index + 1, newTypes, index, newTypes.length - index);\n            System.arraycopy(iValues, 0, newValues, 0, index);\n            System.arraycopy(iValues, index + 1, newValues, index, newValues.length - index);\n            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n            iChronology.validate(newPartial, newValues);\n            return newPartial;\n        }\n        return this;\n    }", "comment": "/**\n     * Gets a copy of this date with the specified field removed.\n     * <p>\n     * If this partial did not previously support the field, no error occurs.\n     *\n     * @param fieldType  the field type to remove, may be null\n     * @return a copy of this instance with the field removed\n     */"}}
{"code": {"body": "public Partial withField(DateTimeFieldType fieldType, int value) {\n        int index = indexOfSupported(fieldType);\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new Partial(this, newValues);\n    }", "comment": "/**\n     * Gets a copy of this Partial with the specified field set to a new value.\n     * <p>\n     * If this partial does not support the field, an exception is thrown.\n     * Contrast this behaviour with {@link #with(DateTimeFieldType, int)}.\n     * <p>\n     * For example, if the field type is <code>dayOfMonth</code> then the day\n     * would be changed in the returned instance if supported.\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this instance with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     */"}}
{"code": {"body": "public Partial withFieldAdded(DurationFieldType fieldType, int amount) {\n        int index = indexOfSupported(fieldType);\n        if (amount == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).add(this, index, newValues, amount);\n        return new Partial(this, newValues);\n    }", "comment": "/**\n     * Gets a copy of this Partial with the value of the specified field increased.\n     * If this partial does not support the field, an exception is thrown.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * The addition will overflow into larger fields (eg. minute to hour).\n     * However, it will not wrap around if the top maximum is reached.\n     *\n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this instance with the field updated\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the new datetime exceeds the capacity\n     */"}}
{"code": {"body": "public Partial withFieldAddWrapped(DurationFieldType fieldType, int amount) {\n        int index = indexOfSupported(fieldType);\n        if (amount == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).addWrapPartial(this, index, newValues, amount);\n        return new Partial(this, newValues);\n    }", "comment": "/**\n     * Gets a copy of this Partial with the value of the specified field increased.\n     * If this partial does not support the field, an exception is thrown.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * The addition will overflow into larger fields (eg. minute to hour).\n     * If the maximum is reached, the addition will wra.\n     *\n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this instance with the field updated\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the new datetime exceeds the capacity\n     */"}}
{"code": {"body": "public Partial withPeriodAdded(ReadablePeriod period, int scalar) {\n        if (period == null || scalar == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        for (int i = 0; i < period.size(); i++) {\n            DurationFieldType fieldType = period.getFieldType(i);\n            int index = indexOf(fieldType);\n            if (index >= 0) {\n                newValues = getField(index).add(this, index, newValues,\n                        FieldUtils.safeMultiply(period.getValue(i), scalar));\n            }\n        }\n        return new Partial(this, newValues);\n    }", "comment": "/**\n     * Gets a copy of this Partial with the specified period added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * Fields in the period that aren't present in the partial are ignored.\n     * <p>\n     * This method is typically used to add multiple copies of complex\n     * period instances. Adding one field is best achieved using the method\n     * {@link #withFieldAdded(DurationFieldType, int)}.\n     * \n     * @param period  the period to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this instance with the period added\n     * @throws ArithmeticException if the new datetime exceeds the capacity\n     */"}}
{"code": {"body": "public Partial plus(ReadablePeriod period) {\n        return withPeriodAdded(period, 1);\n    }", "comment": "/**\n     * Gets a copy of this instance with the specified period added.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     *\n     * @param period  the duration to add to this one, null means zero\n     * @return a copy of this instance with the period added\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "public Partial minus(ReadablePeriod period) {\n        return withPeriodAdded(period, -1);\n    }", "comment": "/**\n     * Gets a copy of this instance with the specified period take away.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     *\n     * @param period  the period to reduce this instant by\n     * @return a copy of this instance with the period taken away\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "public Partial getPartial() {\n            return iPartial;\n        }", "comment": "/**\n         * Gets the partial that this property belongs to.\n         * \n         * @return the partial\n         */"}}
{"code": {"body": "public Partial addToCopy(int valueToAdd) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().add(iPartial, iFieldIndex, newValues, valueToAdd);\n            return new Partial(iPartial, newValues);\n        }", "comment": "/**\n         * Adds to the value of this field in a copy of this Partial.\n         * <p>\n         * The value will be added to this field. If the value is too large to be\n         * added solely to this field then it will affect larger fields.\n         * Smaller fields are unaffected.\n         * <p>\n         * If the result would be too large, beyond the maximum year, then an\n         * IllegalArgumentException is thrown.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param valueToAdd  the value to add to the field in the copy\n         * @return a copy of the Partial with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "public Partial addWrapFieldToCopy(int valueToAdd) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().addWrapField(iPartial, iFieldIndex, newValues, valueToAdd);\n            return new Partial(iPartial, newValues);\n        }", "comment": "/**\n         * Adds to the value of this field in a copy of this Partial wrapping\n         * within this field if the maximum value is reached.\n         * <p>\n         * The value will be added to this field. If the value is too large to be\n         * added solely to this field then it wraps within this field.\n         * Other fields are unaffected.\n         * <p>\n         * For example,\n         * <code>2004-12-20</code> addWrapField one month returns <code>2004-01-20</code>.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param valueToAdd  the value to add to the field in the copy\n         * @return a copy of the Partial with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "public Partial setCopy(int value) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().set(iPartial, iFieldIndex, newValues, value);\n            return new Partial(iPartial, newValues);\n        }", "comment": "/**\n         * Sets this field in a copy of the Partial.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param value  the value to set the field in the copy to\n         * @return a copy of the Partial with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "public Partial setCopy(String text, Locale locale) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().set(iPartial, iFieldIndex, newValues, text, locale);\n            return new Partial(iPartial, newValues);\n        }", "comment": "/**\n         * Sets this field in a copy of the Partial to a parsed text value.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param text  the text value to set\n         * @param locale  optional locale to use for selecting a text symbol\n         * @return a copy of the Partial with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */"}}
{"code": {"body": "public Partial setCopy(String text) {\n            return setCopy(text, null);\n        }", "comment": "/**\n         * Sets this field in a copy of the Partial to a parsed text value.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param text  the text value to set\n         * @return a copy of the Partial with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */"}}
{"code": {"body": "public Partial withMaximumValue() {\n            return setCopy(getMaximumValue());\n        }", "comment": "/**\n         * Returns a new Partial with this field set to the maximum value\n         * for this field.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         *\n         * @return a copy of the Partial with this field set to its maximum\n         * @since 1.2\n         */"}}
{"code": {"body": "public Partial withMinimumValue() {\n            return setCopy(getMinimumValue());\n        }", "comment": "/**\n         * Returns a new Partial with this field set to the minimum value\n         * for this field.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         *\n         * @return a copy of the Partial with this field set to its minimum\n         * @since 1.2\n         */"}}
{"code": {"body": "    public int size() {\n        return iTypes.length;\n    }", "comment": "/**\n     * Gets the number of fields in this partial.\n     * \n     * @return the field count\n     */"}}
{"code": {"body": "    public Chronology getChronology() {\n        return iChronology;\n    }", "comment": "/**\n     * Gets the chronology of the partial which is never null.\n     * <p>\n     * The {@link Chronology} is the calculation engine behind the partial and\n     * provides conversion and validation of the fields in a particular calendar system.\n     * \n     * @return the chronology, never null\n     */"}}
{"code": {"body": "        public DateTimeField getField() {\n            return iPartial.getField(iFieldIndex);\n        }", "comment": "/**\n         * Gets the field that this property uses.\n         * \n         * @return the field\n         */"}}
{"code": {"body": "    public DateTimeFieldType getFieldType(int index) {\n        return iTypes[index];\n    }", "comment": "/**\n     * Gets the field type at the specified index.\n     *\n     * @param index  the index to retrieve\n     * @return the field at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */"}}
{"code": {"body": "    public DateTimeFieldType[] getFieldTypes() {\n        return (DateTimeFieldType[]) iTypes.clone();\n    }", "comment": "/**\n     * Gets an array of the field type of each of the fields that\n     * this partial supports.\n     * <p>\n     * The fields are returned largest to smallest.\n     *\n     * @return the array of field types (cloned), largest to smallest\n     */"}}
{"code": {"body": "    public int getValue(int index) {\n        return iValues[index];\n    }", "comment": "/**\n     * Gets the value of the field at the specifed index.\n     * \n     * @param index  the index\n     * @return the value\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */"}}
{"code": {"body": "    public int[] getValues() {\n        return (int[]) iValues.clone();\n    }", "comment": "/**\n     * Gets an array of the value of each of the fields that\n     * this partial supports.\n     * <p>\n     * The fields are returned largest to smallest.\n     * Each value corresponds to the same array index as <code>getFieldTypes()</code>\n     *\n     * @return the current values of each field (cloned), largest to smallest\n     */"}}
{"code": {"body": "    public Partial withChronologyRetainFields(Chronology newChronology) {\n        newChronology = DateTimeUtils.getChronology(newChronology);\n        newChronology = newChronology.withUTC();\n        if (newChronology == getChronology()) {\n            return this;\n        } else {\n            Partial newPartial = new Partial(newChronology, iTypes, iValues);\n            newChronology.validate(newPartial, iValues);\n            return newPartial;\n        }\n    }", "comment": "/**\n     * Creates a new Partial instance with the specified chronology.\n     * This instance is immutable and unaffected by this method call.\n     * <p>\n     * This method retains the values of the fields, thus the result will\n     * typically refer to a different instant.\n     * <p>\n     * The time zone of the specified chronology is ignored, as Partial\n     * operates without a time zone.\n     *\n     * @param newChronology  the new chronology, null means ISO\n     * @return a copy of this datetime with a different chronology\n     * @throws IllegalArgumentException if the values are invalid for the new chronology\n     */"}}
{"code": {"body": "    public Partial with(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        int index = indexOf(fieldType);\n        if (index == -1) {\n            DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n            int[] newValues = new int[newTypes.length];\n            \n            \n            int i = 0;\n            DurationField unitField = fieldType.getDurationType().getField(iChronology);\n            if (unitField.isSupported()) {\n                for (; i < iTypes.length; i++) {\n                    DateTimeFieldType loopType = iTypes[i];\n                    DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                    if (loopUnitField.isSupported()) {\n                        int compare = unitField.compareTo(loopUnitField);\n                        if (compare > 0) {\n                            break;\n                        } else if (compare == 0) {\n                            DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                            DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                            if (rangeField.compareTo(loopRangeField) > 0) {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            System.arraycopy(iTypes, 0, newTypes, 0, i);\n            System.arraycopy(iValues, 0, newValues, 0, i);\n            newTypes[i] = fieldType;\n            newValues[i] = value;\n            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n            System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n            \n            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n            iChronology.validate(newPartial, newValues);\n            return newPartial;\n        }\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new Partial(this, newValues);\n    }", "comment": "/**\n     * Gets a copy of this date with the specified field set to a new value.\n     * <p>\n     * If this partial did not previously support the field, the new one will.\n     * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.\n     * <p>\n     * For example, if the field type is <code>dayOfMonth</code> then the day\n     * would be changed/added in the returned instance.\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this instance with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     */"}}
{"code": {"body": "    public Partial without(DateTimeFieldType fieldType) {\n        int index = indexOf(fieldType);\n        if (index != -1) {\n            DateTimeFieldType[] newTypes = new DateTimeFieldType[size() - 1];\n            int[] newValues = new int[size() - 1];\n            System.arraycopy(iTypes, 0, newTypes, 0, index);\n            System.arraycopy(iTypes, index + 1, newTypes, index, newTypes.length - index);\n            System.arraycopy(iValues, 0, newValues, 0, index);\n            System.arraycopy(iValues, index + 1, newValues, index, newValues.length - index);\n            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n            iChronology.validate(newPartial, newValues);\n            return newPartial;\n        }\n        return this;\n    }", "comment": "/**\n     * Gets a copy of this date with the specified field removed.\n     * <p>\n     * If this partial did not previously support the field, no error occurs.\n     *\n     * @param fieldType  the field type to remove, may be null\n     * @return a copy of this instance with the field removed\n     */"}}
{"code": {"body": "    public Partial withField(DateTimeFieldType fieldType, int value) {\n        int index = indexOfSupported(fieldType);\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new Partial(this, newValues);\n    }", "comment": "/**\n     * Gets a copy of this Partial with the specified field set to a new value.\n     * <p>\n     * If this partial does not support the field, an exception is thrown.\n     * Contrast this behaviour with {@link #with(DateTimeFieldType, int)}.\n     * <p>\n     * For example, if the field type is <code>dayOfMonth</code> then the day\n     * would be changed in the returned instance if supported.\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this instance with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     */"}}
{"code": {"body": "    public Partial withFieldAdded(DurationFieldType fieldType, int amount) {\n        int index = indexOfSupported(fieldType);\n        if (amount == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).add(this, index, newValues, amount);\n        return new Partial(this, newValues);\n    }", "comment": "/**\n     * Gets a copy of this Partial with the value of the specified field increased.\n     * If this partial does not support the field, an exception is thrown.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * The addition will overflow into larger fields (eg. minute to hour).\n     * However, it will not wrap around if the top maximum is reached.\n     *\n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this instance with the field updated\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the new datetime exceeds the capacity\n     */"}}
{"code": {"body": "    public Partial withFieldAddWrapped(DurationFieldType fieldType, int amount) {\n        int index = indexOfSupported(fieldType);\n        if (amount == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).addWrapPartial(this, index, newValues, amount);\n        return new Partial(this, newValues);\n    }", "comment": "/**\n     * Gets a copy of this Partial with the value of the specified field increased.\n     * If this partial does not support the field, an exception is thrown.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * The addition will overflow into larger fields (eg. minute to hour).\n     * If the maximum is reached, the addition will wra.\n     *\n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this instance with the field updated\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the new datetime exceeds the capacity\n     */"}}
{"code": {"body": "    public Partial withPeriodAdded(ReadablePeriod period, int scalar) {\n        if (period == null || scalar == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        for (int i = 0; i < period.size(); i++) {\n            DurationFieldType fieldType = period.getFieldType(i);\n            int index = indexOf(fieldType);\n            if (index >= 0) {\n                newValues = getField(index).add(this, index, newValues,\n                        FieldUtils.safeMultiply(period.getValue(i), scalar));\n            }\n        }\n        return new Partial(this, newValues);\n    }", "comment": "/**\n     * Gets a copy of this Partial with the specified period added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * Fields in the period that aren't present in the partial are ignored.\n     * <p>\n     * This method is typically used to add multiple copies of complex\n     * period instances. Adding one field is best achieved using the method\n     * {@link #withFieldAdded(DurationFieldType, int)}.\n     * \n     * @param period  the period to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this instance with the period added\n     * @throws ArithmeticException if the new datetime exceeds the capacity\n     */"}}
{"code": {"body": "    public Partial plus(ReadablePeriod period) {\n        return withPeriodAdded(period, 1);\n    }", "comment": "/**\n     * Gets a copy of this instance with the specified period added.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     *\n     * @param period  the duration to add to this one, null means zero\n     * @return a copy of this instance with the period added\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "    public Partial minus(ReadablePeriod period) {\n        return withPeriodAdded(period, -1);\n    }", "comment": "/**\n     * Gets a copy of this instance with the specified period take away.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     *\n     * @param period  the period to reduce this instant by\n     * @return a copy of this instance with the period taken away\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "    public Property property(DateTimeFieldType type) {\n        return new Property(this, indexOfSupported(type));\n    }", "comment": "/**\n     * Gets the property object for the specified type, which contains\n     * many useful methods for getting and manipulating the partial.\n     * <p>\n     * See also {@link ReadablePartial#get(DateTimeFieldType)}.\n     *\n     * @param type  the field type to get the property for, not null\n     * @return the property object\n     * @throws IllegalArgumentException if the field is null or unsupported\n     */"}}
{"code": {"body": "    public boolean isMatch(ReadablePartial partial) {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        for (int i = 0; i < iTypes.length; i++) {\n            int value = partial.get(iTypes[i]);\n            if (value != iValues[i]) {\n                return false;\n            }\n        }\n        return true;\n    }", "comment": "/**\n     * Does this partial match the specified partial.\n     * <p>\n     * A match occurs when all the fields of this partial are the same as the\n     * corresponding fields on the specified partial.\n     *\n     * @param partial  a partial to check against, must not be null\n     * @return true if this partial matches the specified partial\n     * @throws IllegalArgumentException if the partial is null\n     * @throws IllegalArgumentException if the fields of the two partials do not match\n     * @since 1.5\n     */"}}
{"code": {"body": "    public DateTimeFormatter getFormatter() {\n        DateTimeFormatter[] f = iFormatter;\n        if (f == null) {\n            if (size() == 0) {\n                return null;\n            }\n            f = new DateTimeFormatter[2];\n            try {\n                List<DateTimeFieldType> list = new ArrayList<DateTimeFieldType>(Arrays.asList(iTypes));\n                f[0] = ISODateTimeFormat.forFields(list, true, false);\n                if (list.size() == 0) {\n                    f[1] = f[0];\n                }\n            } catch (IllegalArgumentException ex) {\n                \n            }\n            iFormatter = f;\n        }\n        return f[0];\n    }", "comment": "/**\n     * Gets a formatter suitable for the fields in this partial.\n     * <p>\n     * If there is no appropriate ISO format, null is returned.\n     * This method may return a formatter that does not display all the\n     * fields of the partial. This might occur when you have overlapping\n     * fields, such as dayOfWeek and dayOfMonth.\n     *\n     * @return a formatter suitable for the fields in this partial, null\n     *  if none is suitable\n     */"}}
{"code": {"body": "    public String toString(String pattern, Locale locale) {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n    }", "comment": "/**\n     * Output the date using the specified format pattern.\n     * Unsupported fields will appear as special unicode characters.\n     *\n     * @param pattern  the pattern specification, null means use <code>toString</code>\n     * @param locale  Locale to use, null means default\n     * @see org.joda.time.format.DateTimeFormat\n     */"}}
{"code": {"body": "    public String toStringList() {\n        int size = size();\n        StringBuilder buf = new StringBuilder(20 * size);\n        buf.append('');\n        for (int i = 0; i < size; i++) {\n            if (i > 0) {\n                buf.append('').append('');\n            }\n            buf.append(iTypes[i].getName());\n            buf.append('');\n            buf.append(iValues[i]);\n        }\n        buf.append('');\n        return buf.toString();\n    }", "comment": "/**\n     * Gets a string version of the partial that lists all the fields.\n     * <p>\n     * This method exists to provide a better debugging toString than\n     * the standard toString. This method lists all the fields and their\n     * values in a style similar to the collections framework.\n     *\n     * @return a toString format that lists all the fields\n     */"}}
{"code": {"body": "        protected ReadablePartial getReadablePartial() {\n            return iPartial;\n        }", "comment": "/**\n         * Gets the partial that this property belongs to.\n         * \n         * @return the partial\n         */"}}
{"code": {"body": "        public Partial getPartial() {\n            return iPartial;\n        }", "comment": "/**\n         * Gets the partial that this property belongs to.\n         * \n         * @return the partial\n         */"}}
{"code": {"body": "        public int get() {\n            return iPartial.getValue(iFieldIndex);\n        }", "comment": "/**\n         * Gets the value of this field.\n         * \n         * @return the field value\n         */"}}
{"code": {"body": "        public Partial addToCopy(int valueToAdd) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().add(iPartial, iFieldIndex, newValues, valueToAdd);\n            return new Partial(iPartial, newValues);\n        }", "comment": "/**\n         * Adds to the value of this field in a copy of this Partial.\n         * <p>\n         * The value will be added to this field. If the value is too large to be\n         * added solely to this field then it will affect larger fields.\n         * Smaller fields are unaffected.\n         * <p>\n         * If the result would be too large, beyond the maximum year, then an\n         * IllegalArgumentException is thrown.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param valueToAdd  the value to add to the field in the copy\n         * @return a copy of the Partial with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "        public Partial addWrapFieldToCopy(int valueToAdd) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().addWrapField(iPartial, iFieldIndex, newValues, valueToAdd);\n            return new Partial(iPartial, newValues);\n        }", "comment": "/**\n         * Adds to the value of this field in a copy of this Partial wrapping\n         * within this field if the maximum value is reached.\n         * <p>\n         * The value will be added to this field. If the value is too large to be\n         * added solely to this field then it wraps within this field.\n         * Other fields are unaffected.\n         * <p>\n         * For example,\n         * <code>2004-12-20</code> addWrapField one month returns <code>2004-01-20</code>.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param valueToAdd  the value to add to the field in the copy\n         * @return a copy of the Partial with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "        public Partial setCopy(String text) {\n            return setCopy(text, null);\n        }", "comment": "/**\n         * Sets this field in a copy of the Partial to a parsed text value.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param text  the text value to set\n         * @return a copy of the Partial with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */"}}
{"code": {"body": "        public Partial withMaximumValue() {\n            return setCopy(getMaximumValue());\n        }", "comment": "/**\n         * Returns a new Partial with this field set to the maximum value\n         * for this field.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         *\n         * @return a copy of the Partial with this field set to its maximum\n         * @since 1.2\n         */"}}
{"code": {"body": "        public Partial withMinimumValue() {\n            return setCopy(getMinimumValue());\n        }", "comment": "/**\n         * Returns a new Partial with this field set to the minimum value\n         * for this field.\n         * <p>\n         * The Partial attached to this property is unchanged by this call.\n         *\n         * @return a copy of the Partial with this field set to its minimum\n         * @since 1.2\n         */"}}
{"code": {"body": "public Period() {\n        super(0L, null, null);\n    }", "comment": "/**\n     * Creates a new empty period with the standard set of fields.\n     * <p>\n     * One way to initialise a period is as follows:\n     * <pre>\n     * Period = new Period().withYears(6).withMonths(3).withSeconds(23);\n     * </pre>\n     * Bear in mind that this creates four period instances in total, three of\n     * which are immediately discarded.\n     * The alterative is more efficient, but less readable:\n     * <pre>\n     * Period = new Period(6, 3, 0, 0, 0, 0, 23, 0);\n     * </pre>\n     * The following is also slightly less wasteful:\n     * <pre>\n     * Period = Period.years(6).withMonths(3).withSeconds(23);\n     * </pre>\n     */"}}
{"code": {"body": "public Period(int hours, int minutes, int seconds, int millis) {\n        super(0, 0, 0, 0, hours, minutes, seconds, millis, PeriodType.standard());\n    }", "comment": "/**\n     * Create a period from a set of field values using the standard set of fields.\n     * Note that the parameters specify the time fields hours, minutes,\n     * seconds and millis, not the date fields.\n     *\n     * @param hours  amount of hours in this period\n     * @param minutes  amount of minutes in this period\n     * @param seconds  amount of seconds in this period\n     * @param millis  amount of milliseconds in this period\n     */"}}
{"code": {"body": "public Period(int years, int months, int weeks, int days,", "comment": "/**\n     * Create a period from a set of field values using the standard set of fields.\n     *\n     * @param years  amount of years in this period\n     * @param months  amount of months in this period\n     * @param weeks  amount of weeks in this period\n     * @param days  amount of days in this period\n     * @param hours  amount of hours in this period\n     * @param minutes  amount of minutes in this period\n     * @param seconds  amount of seconds in this period\n     * @param millis  amount of milliseconds in this period\n     */"}}
{"code": {"body": "public Period(int years, int months, int weeks, int days,", "comment": "/**\n     * Create a period from a set of field values using the standard set of fields.\n     *\n     * @param years  amount of years in this period\n     * @param months  amount of months in this period\n     * @param weeks  amount of weeks in this period\n     * @param days  amount of days in this period\n     * @param hours  amount of hours in this period\n     * @param minutes  amount of minutes in this period\n     * @param seconds  amount of seconds in this period\n     * @param millis  amount of milliseconds in this period\n     */"}}
{"code": {"body": "public Period(long duration) {\n        super(duration);\n    }", "comment": "/**\n     * Creates a period from the given millisecond duration using the standard\n     * set of fields.\n     * <p>\n     * Only precise fields in the period type will be used.\n     * For the standard period type this is the time fields only.\n     * Thus the year, month, week and day fields will not be populated.\n     * <p>\n     * If the duration is small, less than one day, then this method will perform\n     * as you might expect and split the fields evenly.\n     * <p>\n     * If the duration is larger than one day then all the remaining duration will\n     * be stored in the largest available precise field, hours in this case.\n     * <p>\n     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n     * ((365 + 60 + 5) * 24) hours by this constructor.\n     * <p>\n     * For more control over the conversion process, you have two options:\n     * <ul>\n     * <li>convert the duration to an {@link Interval}, and from there obtain the period\n     * <li>specify a period type that contains precise definitions of the day and larger\n     * fields, such as UTC\n     * </ul>\n     *\n     * @param duration  the duration, in milliseconds\n     */"}}
{"code": {"body": "public Period(long duration, PeriodType type) {\n        super(duration, type, null);\n    }", "comment": "/**\n     * Creates a period from the given millisecond duration.\n     * <p>\n     * Only precise fields in the period type will be used.\n     * Imprecise fields will not be populated.\n     * <p>\n     * If the duration is small then this method will perform\n     * as you might expect and split the fields evenly.\n     * <p>\n     * If the duration is large then all the remaining duration will\n     * be stored in the largest available precise field.\n     * For details as to which fields are precise, review the period type javadoc.\n     *\n     * @param duration  the duration, in milliseconds\n     * @param type  which set of fields this period supports, null means standard\n     */"}}
{"code": {"body": "public Period(long duration, Chronology chronology) {\n        super(duration, null, chronology);\n    }", "comment": "/**\n     * Creates a period from the given millisecond duration using the standard\n     * set of fields.\n     * <p>\n     * Only precise fields in the period type will be used.\n     * Imprecise fields will not be populated.\n     * <p>\n     * If the duration is small then this method will perform\n     * as you might expect and split the fields evenly.\n     * <p>\n     * If the duration is large then all the remaining duration will\n     * be stored in the largest available precise field.\n     * For details as to which fields are precise, review the period type javadoc.\n     *\n     * @param duration  the duration, in milliseconds\n     * @param chronology  the chronology to use to split the duration, null means ISO default\n     */"}}
{"code": {"body": "public Period(long duration, PeriodType type, Chronology chronology) {\n        super(duration, type, chronology);\n    }", "comment": "/**\n     * Creates a period from the given millisecond duration.\n     * <p>\n     * Only precise fields in the period type will be used.\n     * Imprecise fields will not be populated.\n     * <p>\n     * If the duration is small then this method will perform\n     * as you might expect and split the fields evenly.\n     * <p>\n     * If the duration is large then all the remaining duration will\n     * be stored in the largest available precise field.\n     * For details as to which fields are precise, review the period type javadoc.\n     *\n     * @param duration  the duration, in milliseconds\n     * @param type  which set of fields this period supports, null means standard\n     * @param chronology  the chronology to use to split the duration, null means ISO default\n     */"}}
{"code": {"body": "public Period(long startInstant, long endInstant) {\n        super(startInstant, endInstant, null, null);\n    }", "comment": "/**\n     * Creates a period from the given interval endpoints using the standard\n     * set of fields.\n     *\n     * @param startInstant  interval start, in milliseconds\n     * @param endInstant  interval end, in milliseconds\n     */"}}
{"code": {"body": "public Period(long startInstant, long endInstant, PeriodType type) {\n        super(startInstant, endInstant, type, null);\n    }", "comment": "/**\n     * Creates a period from the given interval endpoints.\n     *\n     * @param startInstant  interval start, in milliseconds\n     * @param endInstant  interval end, in milliseconds\n     * @param type  which set of fields this period supports, null means standard\n     */"}}
{"code": {"body": "public Period(long startInstant, long endInstant, Chronology chrono) {\n        super(startInstant, endInstant, null, chrono);\n    }", "comment": "/**\n     * Creates a period from the given interval endpoints using the standard\n     * set of fields.\n     *\n     * @param startInstant  interval start, in milliseconds\n     * @param endInstant  interval end, in milliseconds\n     * @param chrono  the chronology to use, null means ISO in default zone\n     */"}}
{"code": {"body": "public Period(long startInstant, long endInstant, PeriodType type, Chronology chrono) {\n        super(startInstant, endInstant, type, chrono);\n    }", "comment": "/**\n     * Creates a period from the given interval endpoints.\n     *\n     * @param startInstant  interval start, in milliseconds\n     * @param endInstant  interval end, in milliseconds\n     * @param type  which set of fields this period supports, null means standard\n     * @param chrono  the chronology to use, null means ISO in default zone\n     */"}}
{"code": {"body": "public Period(ReadableInstant startInstant, ReadableInstant endInstant) {\n        super(startInstant, endInstant, null);\n    }", "comment": "/**\n     * Creates a period between the given instants using the standard set of fields.\n     * <p>\n     * Most calculations performed by this method have obvious results.\n     * The special case is where the calculation is from a \"long\" month to a \"short\" month.\n     * Here, the result favours increasing the months field rather than the days.\n     * For example, 2013-01-31 to 2013-02-28 is treated as one whole month.\n     * By contrast, 2013-01-31 to 2013-03-30 is treated as one month and 30 days\n     * (exposed as 4 weeks and 2 days).\n     * The results are explained by considering that the start date plus the\n     * calculated period result in the end date.\n     *\n     * @param startInstant  interval start, null means now\n     * @param endInstant  interval end, null means now\n     */"}}
{"code": {"body": "public Period(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type) {\n        super(startInstant, endInstant, type);\n    }", "comment": "/**\n     * Creates a period between the given instants.\n     * <p>\n     * Most calculations performed by this method have obvious results.\n     * The special case is where the calculation is from a \"long\" month to a \"short\" month.\n     * Here, the result favours increasing the months field rather than the days.\n     * For example, 2013-01-31 to 2013-02-28 is treated as one whole month.\n     * By contrast, 2013-01-31 to 2013-03-30 is treated as one month and 30 days.\n     * The results are explained by considering that the start date plus the\n     * calculated period result in the end date.\n     *\n     * @param startInstant  interval start, null means now\n     * @param endInstant  interval end, null means now\n     * @param type  which set of fields this period supports, null means standard\n     */"}}
{"code": {"body": "public Period(ReadablePartial start, ReadablePartial end) {\n        super(start, end, null);\n    }", "comment": "/**\n     * Creates a period from two partially specified times.\n     * <p>\n     * The two partials must contain the same fields, thus you can specify\n     * two <code>LocalDate</code> objects, or two <code>LocalTime</code> objects,\n     * but not one of each.\n     * As these are Partial objects, time zones have no effect on the result.\n     * <p>\n     * The two partials must also both be contiguous - see\n     * {@link DateTimeUtils#isContiguous(ReadablePartial)} for a definition.\n     * Both <code>LocalDate</code> and <code>LocalTime</code> are contiguous.\n     * <p>\n     * Most calculations performed by this method have obvious results.\n     * The special case is where the calculation is from a \"long\" month to a \"short\" month.\n     * Here, the result favours increasing the months field rather than the days.\n     * For example, 2013-01-31 to 2013-02-28 is treated as one whole month.\n     * By contrast, 2013-01-31 to 2013-03-30 is treated as one month and 30 days\n     * (exposed as 4 weeks and 2 days).\n     * The results are explained by considering that the start date plus the\n     * calculated period result in the end date.\n     * <p>\n     * An alternative way of constructing a Period from two Partials\n     * is {@link #fieldDifference(ReadablePartial, ReadablePartial)}.\n     * That method handles all kinds of partials.\n     *\n     * @param start  the start of the period, must not be null\n     * @param end  the end of the period, must not be null\n     * @throws IllegalArgumentException if the partials are null or invalid\n     * @since 1.1\n     */"}}
{"code": {"body": "public Period(ReadablePartial start, ReadablePartial end, PeriodType type) {\n        super(start, end, type);\n    }", "comment": "/**\n     * Creates a period from two partially specified times.\n     * <p>\n     * The two partials must contain the same fields, thus you can specify\n     * two <code>LocalDate</code> objects, or two <code>LocalTime</code> objects,\n     * but not one of each.\n     * As these are Partial objects, time zones have no effect on the result.\n     * <p>\n     * The two partials must also both be contiguous - see\n     * {@link DateTimeUtils#isContiguous(ReadablePartial)} for a definition.\n     * Both <code>LocalDate</code> and <code>LocalTime</code> are contiguous.\n     * <p>\n     * Most calculations performed by this method have obvious results.\n     * The special case is where the calculation is from a \"long\" month to a \"short\" month.\n     * Here, the result favours increasing the months field rather than the days.\n     * For example, 2013-01-31 to 2013-02-28 is treated as one whole month.\n     * By contrast, 2013-01-31 to 2013-03-30 is treated as one month and 30 days.\n     * The results are explained by considering that the start date plus the\n     * calculated period result in the end date.\n     * <p>\n     * An alternative way of constructing a Period from two Partials\n     * is {@link #fieldDifference(ReadablePartial, ReadablePartial)}.\n     * That method handles all kinds of partials.\n     *\n     * @param start  the start of the period, must not be null\n     * @param end  the end of the period, must not be null\n     * @param type  which set of fields this period supports, null means standard\n     * @throws IllegalArgumentException if the partials are null or invalid\n     * @since 1.1\n     */"}}
{"code": {"body": "public Period(ReadableInstant startInstant, ReadableDuration duration) {\n        super(startInstant, duration, null);\n    }", "comment": "/**\n     * Creates a period from the given start point and the duration.\n     *\n     * @param startInstant  the interval start, null means now\n     * @param duration  the duration of the interval, null means zero-length\n     */"}}
{"code": {"body": "public Period(ReadableInstant startInstant, ReadableDuration duration, PeriodType type) {\n        super(startInstant, duration, type);\n    }", "comment": "/**\n     * Creates a period from the given start point and the duration.\n     *\n     * @param startInstant  the interval start, null means now\n     * @param duration  the duration of the interval, null means zero-length\n     * @param type  which set of fields this period supports, null means standard\n     */"}}
{"code": {"body": "public Period(ReadableDuration duration, ReadableInstant endInstant) {\n        super(duration, endInstant, null);\n    }", "comment": "/**\n     * Creates a period from the given duration and end point.\n     *\n     * @param duration  the duration of the interval, null means zero-length\n     * @param endInstant  the interval end, null means now\n     */"}}
{"code": {"body": "public Period(ReadableDuration duration, ReadableInstant endInstant, PeriodType type) {\n        super(duration, endInstant, type);\n    }", "comment": "/**\n     * Creates a period from the given duration and end point.\n     *\n     * @param duration  the duration of the interval, null means zero-length\n     * @param endInstant  the interval end, null means now\n     * @param type  which set of fields this period supports, null means standard\n     */"}}
{"code": {"body": "public Period(Object period) {\n        super(period, null, null);\n    }", "comment": "/**\n     * Creates a period by converting or copying from another object.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadablePeriod, ReadableInterval and String.\n     * The String formats are described by {@link ISOPeriodFormat#standard()}.\n     *\n     * @param period  period to convert\n     * @throws IllegalArgumentException if period is invalid\n     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n     */"}}
{"code": {"body": "public Period(Object period, PeriodType type) {\n        super(period, type, null);\n    }", "comment": "/**\n     * Creates a period by converting or copying from another object.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadablePeriod, ReadableInterval and String.\n     * The String formats are described by {@link ISOPeriodFormat#standard()}.\n     *\n     * @param period  period to convert\n     * @param type  which set of fields this period supports, null means use converter\n     * @throws IllegalArgumentException if period is invalid\n     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n     */"}}
{"code": {"body": "public Period(Object period, Chronology chrono) {\n        super(period, null, chrono);\n    }", "comment": "/**\n     * Creates a period by converting or copying from another object.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadablePeriod, ReadableInterval and String.\n     * The String formats are described by {@link ISOPeriodFormat#standard()}.\n     *\n     * @param period  period to convert\n     * @param chrono  the chronology to use, null means ISO in default zone\n     * @throws IllegalArgumentException if period is invalid\n     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n     */"}}
{"code": {"body": "public Period(Object period, PeriodType type, Chronology chrono) {\n        super(period, type, chrono);\n    }", "comment": "/**\n     * Creates a period by converting or copying from another object.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadablePeriod, ReadableInterval and String.\n     * The String formats are described by {@link ISOPeriodFormat#standard()}.\n     *\n     * @param period  period to convert\n     * @param type  which set of fields this period supports, null means use converter\n     * @param chrono  the chronology to use, null means ISO in default zone\n     * @throws IllegalArgumentException if period is invalid\n     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n     */"}}
{"code": {"body": "public Period toPeriod() {\n        return this;\n    }", "comment": "/**\n     * Get this period as an immutable <code>Period</code> object\n     * by returning <code>this</code>.\n     * \n     * @return <code>this</code>\n     */"}}
{"code": {"body": "public Period withPeriodType(PeriodType type) {\n        type = DateTimeUtils.getPeriodType(type);\n        if (type.equals(getPeriodType())) {\n            return this;\n        }\n        return new Period(this, type);\n    }", "comment": "/**\n     * Creates a new Period instance with the same field values but\n     * different PeriodType.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     * \n     * @param type  the period type to use, null means standard\n     * @return the new period instance\n     * @throws IllegalArgumentException if the new period won't accept all of the current fields\n     */"}}
{"code": {"body": "public Period withFields(ReadablePeriod period) {\n        if (period == null) {\n            return this;\n        }\n        int[] newValues = getValues();  \n        newValues = super.mergePeriodInto(newValues, period);\n        return new Period(newValues, getPeriodType());\n    }", "comment": "/**\n     * Creates a new Period instance with the fields from the specified period\n     * copied on top of those from this period.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     * \n     * @param period  the period to copy from, null ignored\n     * @return the new period instance\n     * @throws IllegalArgumentException if a field type is unsupported\n     */"}}
{"code": {"body": "public Period withField(DurationFieldType field, int value) {\n        if (field == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        int[] newValues = getValues();  \n        super.setFieldInto(newValues, field, value);\n        return new Period(newValues, getPeriodType());\n    }", "comment": "/**\n     * Creates a new Period instance with the specified field set to a new value.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     * \n     * @param field  the field to set, not null\n     * @param value  the value to set to\n     * @return the new period instance\n     * @throws IllegalArgumentException if the field type is null or unsupported\n     */"}}
{"code": {"body": "public Period withFieldAdded(DurationFieldType field, int value) {\n        if (field == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (value == 0) {\n            return this;\n        }\n        int[] newValues = getValues();  \n        super.addFieldInto(newValues, field, value);\n        return new Period(newValues, getPeriodType());\n    }", "comment": "/**\n     * Creates a new Period instance with the valueToAdd added to the specified field.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     * \n     * @param field  the field to set, not null\n     * @param value  the value to add\n     * @return the new period instance\n     * @throws IllegalArgumentException if the field type is null or unsupported\n     */"}}
{"code": {"body": "public Period withYears(int years) {\n        int[] values = getValues();  \n        getPeriodType().setIndexedField(this, PeriodType.YEAR_INDEX, values, years);\n        return new Period(values, getPeriodType());\n    }", "comment": "/**\n     * Returns a new period with the specified number of years.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param years  the amount of years to add, may be negative\n     * @return the new period with the increased years\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "public Period withMonths(int months) {\n        int[] values = getValues();  \n        getPeriodType().setIndexedField(this, PeriodType.MONTH_INDEX, values, months);\n        return new Period(values, getPeriodType());\n    }", "comment": "/**\n     * Returns a new period with the specified number of months.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param months  the amount of months to add, may be negative\n     * @return the new period with the increased months\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "public Period withWeeks(int weeks) {\n        int[] values = getValues();  \n        getPeriodType().setIndexedField(this, PeriodType.WEEK_INDEX, values, weeks);\n        return new Period(values, getPeriodType());\n    }", "comment": "/**\n     * Returns a new period with the specified number of weeks.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the amount of weeks to add, may be negative\n     * @return the new period with the increased weeks\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "public Period withDays(int days) {\n        int[] values = getValues();  \n        getPeriodType().setIndexedField(this, PeriodType.DAY_INDEX, values, days);\n        return new Period(values, getPeriodType());\n    }", "comment": "/**\n     * Returns a new period with the specified number of days.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param days  the amount of days to add, may be negative\n     * @return the new period with the increased days\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "public Period withHours(int hours) {\n        int[] values = getValues();  \n        getPeriodType().setIndexedField(this, PeriodType.HOUR_INDEX, values, hours);\n        return new Period(values, getPeriodType());\n    }", "comment": "/**\n     * Returns a new period with the specified number of hours.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the amount of hours to add, may be negative\n     * @return the new period with the increased hours\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "public Period withMinutes(int minutes) {\n        int[] values = getValues();  \n        getPeriodType().setIndexedField(this, PeriodType.MINUTE_INDEX, values, minutes);\n        return new Period(values, getPeriodType());\n    }", "comment": "/**\n     * Returns a new period with the specified number of minutes.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the amount of minutes to add, may be negative\n     * @return the new period with the increased minutes\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "public Period withSeconds(int seconds) {\n        int[] values = getValues();  \n        getPeriodType().setIndexedField(this, PeriodType.SECOND_INDEX, values, seconds);\n        return new Period(values, getPeriodType());\n    }", "comment": "/**\n     * Returns a new period with the specified number of seconds.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the amount of seconds to add, may be negative\n     * @return the new period with the increased seconds\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "public Period withMillis(int millis) {\n        int[] values = getValues();  \n        getPeriodType().setIndexedField(this, PeriodType.MILLI_INDEX, values, millis);\n        return new Period(values, getPeriodType());\n    }", "comment": "/**\n     * Returns a new period with the specified number of millis.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param millis  the amount of millis to add, may be negative\n     * @return the new period with the increased millis\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "public Period plus(ReadablePeriod period) {\n        if (period == null) {\n            return this;\n        }\n        int[] values = getValues();  \n        getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, period.get(DurationFieldType.YEARS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, period.get(DurationFieldType.MONTHS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, period.get(DurationFieldType.WEEKS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, period.get(DurationFieldType.DAYS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, period.get(DurationFieldType.HOURS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, period.get(DurationFieldType.MINUTES_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, period.get(DurationFieldType.SECONDS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, period.get(DurationFieldType.MILLIS_TYPE));\n        return new Period(values, getPeriodType());\n    }", "comment": "/**\n     * Returns a new period with the specified period added.\n     * <p>\n     * Each field of the period is added separately. Thus a period of\n     * 2 hours 30 minutes plus 3 hours 40 minutes will produce a result\n     * of 5 hours 70 minutes - see {@link #normalizedStandard()}.\n     * <p>\n     * If the period being added contains a non-zero amount for a field that\n     * is not supported in this period then an exception is thrown.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param period  the period to add, null adds zero and returns this\n     * @return the new updated period\n     * @throws UnsupportedOperationException if any field is not supported\n     * @since 1.5\n     */"}}
{"code": {"body": "public Period plusYears(int years) {\n        if (years == 0) {\n            return this;\n        }\n        int[] values = getValues();  \n        getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, years);\n        return new Period(values, getPeriodType());\n    }", "comment": "/**\n     * Returns a new period with the specified number of years added.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param years  the amount of years to add, may be negative\n     * @return the new period with the increased years\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "public Period plusMonths(int months) {\n        if (months == 0) {\n            return this;\n        }\n        int[] values = getValues();  \n        getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, months);\n        return new Period(values, getPeriodType());\n    }", "comment": "/**\n     * Returns a new period plus the specified number of months added.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param months  the amount of months to add, may be negative\n     * @return the new period plus the increased months\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "public Period plusWeeks(int weeks) {\n        if (weeks == 0) {\n            return this;\n        }\n        int[] values = getValues();  \n        getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, weeks);\n        return new Period(values, getPeriodType());\n    }", "comment": "/**\n     * Returns a new period plus the specified number of weeks added.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the amount of weeks to add, may be negative\n     * @return the new period plus the increased weeks\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "public Period plusDays(int days) {\n        if (days == 0) {\n            return this;\n        }\n        int[] values = getValues();  \n        getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, days);\n        return new Period(values, getPeriodType());\n    }", "comment": "/**\n     * Returns a new period plus the specified number of days added.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param days  the amount of days to add, may be negative\n     * @return the new period plus the increased days\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "public Period plusHours(int hours) {\n        if (hours == 0) {\n            return this;\n        }\n        int[] values = getValues();  \n        getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, hours);\n        return new Period(values, getPeriodType());\n    }", "comment": "/**\n     * Returns a new period plus the specified number of hours added.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the amount of hours to add, may be negative\n     * @return the new period plus the increased hours\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "public Period plusMinutes(int minutes) {\n        if (minutes == 0) {\n            return this;\n        }\n        int[] values = getValues();  \n        getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, minutes);\n        return new Period(values, getPeriodType());\n    }", "comment": "/**\n     * Returns a new period plus the specified number of minutes added.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the amount of minutes to add, may be negative\n     * @return the new period plus the increased minutes\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "public Period plusSeconds(int seconds) {\n        if (seconds == 0) {\n            return this;\n        }\n        int[] values = getValues();  \n        getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, seconds);\n        return new Period(values, getPeriodType());\n    }", "comment": "/**\n     * Returns a new period plus the specified number of seconds added.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the amount of seconds to add, may be negative\n     * @return the new period plus the increased seconds\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "public Period plusMillis(int millis) {\n        if (millis == 0) {\n            return this;\n        }\n        int[] values = getValues();  \n        getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, millis);\n        return new Period(values, getPeriodType());\n    }", "comment": "/**\n     * Returns a new period plus the specified number of millis added.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param millis  the amount of millis to add, may be negative\n     * @return the new period plus the increased millis\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "public Period minus(ReadablePeriod period) {\n        if (period == null) {\n            return this;\n        }\n        int[] values = getValues();  \n        getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, -period.get(DurationFieldType.YEARS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, -period.get(DurationFieldType.MONTHS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, -period.get(DurationFieldType.WEEKS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, -period.get(DurationFieldType.DAYS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, -period.get(DurationFieldType.HOURS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, -period.get(DurationFieldType.MINUTES_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, -period.get(DurationFieldType.SECONDS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, -period.get(DurationFieldType.MILLIS_TYPE));\n        return new Period(values, getPeriodType());\n    }", "comment": "/**\n     * Returns a new period with the specified period subtracted.\n     * <p>\n     * Each field of the period is subtracted separately. Thus a period of\n     * 3 hours 30 minutes minus 2 hours 40 minutes will produce a result\n     * of 1 hour and -10 minutes - see {@link #normalizedStandard()}.\n     * <p>\n     * If the period being added contains a non-zero amount for a field that\n     * is not supported in this period then an exception is thrown.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param period  the period to add, null adds zero and returns this\n     * @return the new updated period\n     * @throws UnsupportedOperationException if any field is not supported\n     * @since 1.5\n     */"}}
{"code": {"body": "public Period minusYears(int years) {\n        return plusYears(-years);\n    }", "comment": "/**\n     * Returns a new period with the specified number of years taken away.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param years  the amount of years to take away, may be negative\n     * @return the new period with the increased years\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "public Period minusMonths(int months) {\n        return plusMonths(-months);\n    }", "comment": "/**\n     * Returns a new period minus the specified number of months taken away.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param months  the amount of months to take away, may be negative\n     * @return the new period minus the increased months\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "public Period minusWeeks(int weeks) {\n        return plusWeeks(-weeks);\n    }", "comment": "/**\n     * Returns a new period minus the specified number of weeks taken away.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the amount of weeks to take away, may be negative\n     * @return the new period minus the increased weeks\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "public Period minusDays(int days) {\n        return plusDays(-days);\n    }", "comment": "/**\n     * Returns a new period minus the specified number of days taken away.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param days  the amount of days to take away, may be negative\n     * @return the new period minus the increased days\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "public Period minusHours(int hours) {\n        return plusHours(-hours);\n    }", "comment": "/**\n     * Returns a new period minus the specified number of hours taken away.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the amount of hours to take away, may be negative\n     * @return the new period minus the increased hours\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "public Period minusMinutes(int minutes) {\n        return plusMinutes(-minutes);\n    }", "comment": "/**\n     * Returns a new period minus the specified number of minutes taken away.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the amount of minutes to take away, may be negative\n     * @return the new period minus the increased minutes\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "public Period minusSeconds(int seconds) {\n        return plusSeconds(-seconds);\n    }", "comment": "/**\n     * Returns a new period minus the specified number of seconds taken away.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the amount of seconds to take away, may be negative\n     * @return the new period minus the increased seconds\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "public Period minusMillis(int millis) {\n        return plusMillis(-millis);\n    }", "comment": "/**\n     * Returns a new period minus the specified number of millis taken away.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param millis  the amount of millis to take away, may be negative\n     * @return the new period minus the increased millis\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "public Period multipliedBy(int scalar) {\n        if (this == ZERO || scalar == 1) {\n            return this;\n        }\n        int[] values = getValues();  \n        for (int i = 0; i < values.length; i++) {\n            values[i] = FieldUtils.safeMultiply(values[i], scalar);\n        }\n        return new Period(values, getPeriodType());\n    }", "comment": "/**\n     * Returns a new instance with each element in this period multiplied\n     * by the specified scalar.\n     *\n     * @param scalar  the scalar to multiply by, not null\n     * @return a {@code Period} based on this period with the amounts multiplied by the scalar, never null\n     * @throws ArithmeticException if the capacity of any field is exceeded\n     * @since 2.1\n     */"}}
{"code": {"body": "public Period negated() {\n        return multipliedBy(-1);\n    }", "comment": "/**\n     * Returns a new instance with each amount in this period negated.\n     *\n     * @return a {@code Period} based on this period with the amounts negated, never null\n     * @throws ArithmeticException if any field has the minimum value\n     * @since 2.1\n     */"}}
{"code": {"body": "public Period normalizedStandard() {\n        return normalizedStandard(PeriodType.standard());\n    }", "comment": "/**\n     * Normalizes this period using standard rules, assuming a 12 month year,\n     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n     * <p>\n     * This method allows you to normalize a period.\n     * However to achieve this it makes the assumption that all years are\n     * 12 months, all weeks are 7 days, all days are 24 hours,\n     * all hours are 60 minutes and all minutes are 60 seconds. This is not\n     * true when daylight savings time is considered, and may also not be true\n     * for some chronologies. However, it is included as it is a useful operation\n     * for many applications and business rules.\n     * <p>\n     * If the period contains years or months, then the months will be\n     * normalized to be between 0 and 11. The days field and below will be\n     * normalized as necessary, however this will not overflow into the months\n     * field. Thus a period of 1 year 15 months will normalize to 2 years 3 months.\n     * But a period of 1 month 40 days will remain as 1 month 40 days.\n     * <p>\n     * The result will always have a <code>PeriodType</code> of standard, thus\n     * days will be grouped into weeks.\n     * \n     * @return a normalized period equivalent to this period\n     * @throws ArithmeticException if any field is too large to be represented\n     * @since 1.5\n     */"}}
{"code": {"body": "public Period normalizedStandard(PeriodType type) {\n        long millis = getMillis();  \n        millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n        millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n        millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n        millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n        millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n        Period result = new Period(millis, DateTimeUtils.getPeriodType(type), ISOChronology.getInstanceUTC());\n        int years = getYears();\n        int months = getMonths();\n        if (years != 0 || months != 0) {\n            years = FieldUtils.safeAdd(years, months / 12);\n            months = months % 12;\n            if (years != 0) {\n                result = result.withYears(years);\n            }\n            if (months != 0) {\n                result = result.withMonths(months);\n            }\n        }\n        return result;\n    }", "comment": "/**\n     * Normalizes this period using standard rules, assuming a 12 month year,\n     * 7 day week, 24 hour day, 60 minute hour and 60 second minute,\n     * providing control over how the result is split into fields.\n     * <p>\n     * This method allows you to normalize a period.\n     * However to achieve this it makes the assumption that all years are\n     * 12 months, all weeks are 7 days, all days are 24 hours,\n     * all hours are 60 minutes and all minutes are 60 seconds. This is not\n     * true when daylight savings time is considered, and may also not be true\n     * for some chronologies. However, it is included as it is a useful operation\n     * for many applications and business rules.\n     * <p>\n     * If the period contains years or months, then the months will be\n     * normalized to be between 0 and 11. The days field and below will be\n     * normalized as necessary, however this will not overflow into the months\n     * field. Thus a period of 1 year 15 months will normalize to 2 years 3 months.\n     * But a period of 1 month 40 days will remain as 1 month 40 days.\n     * <p>\n     * The PeriodType parameter controls how the result is created. It allows\n     * you to omit certain fields from the result if desired. For example,\n     * you may not want the result to include weeks, in which case you pass\n     * in <code>PeriodType.yearMonthDayTime()</code>.\n     * \n     * @param type  the period type of the new period, null means standard type\n     * @return a normalized period equivalent to this period\n     * @throws ArithmeticException if any field is too large to be represented\n     * @throws UnsupportedOperationException if this period contains non-zero\n     *  years or months but the specified period type does not support them\n     * @since 1.5\n     */"}}
{"code": {"body": "    public static Period parse(String str, PeriodFormatter formatter) {\n        return formatter.parsePeriod(str);\n    }", "comment": "/**\n     * Parses a {@code Period} from the specified string using a formatter.\n     * \n     * @param str  the string to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @since 2.0\n     */"}}
{"code": {"body": "    public static Period years(int years) {\n        return new Period(new int[] {years, 0, 0, 0, 0, 0, 0, 0, 0}, PeriodType.standard());\n    }", "comment": "/**\n     * Create a period with a specified number of years.\n     * <p>\n     * The standard period type is used, thus you can add other fields such\n     * as months or days using the <code>withXxx()</code> methods.\n     * For example, <code>Period.years(2).withMonths(6);</code>\n     * <p>\n     * If you want a year-based period that cannot have other fields added,\n     * then you should consider using {@link Years}.\n     *\n     * @param years  the amount of years in this period\n     * @return the period\n     */"}}
{"code": {"body": "    public static Period months(int months) {\n        return new Period(new int[] {0, months, 0, 0, 0, 0, 0, 0}, PeriodType.standard());\n    }", "comment": "/**\n     * Create a period with a specified number of months.\n     * <p>\n     * The standard period type is used, thus you can add other fields such\n     * as years or days using the <code>withXxx()</code> methods.\n     * For example, <code>Period.months(2).withDays(6);</code>\n     * <p>\n     * If you want a month-based period that cannot have other fields added,\n     * then you should consider using {@link Months}.\n     *\n     * @param months  the amount of months in this period\n     * @return the period\n     */"}}
{"code": {"body": "    public static Period weeks(int weeks) {\n        return new Period(new int[] {0, 0, weeks, 0, 0, 0, 0, 0}, PeriodType.standard());\n    }", "comment": "/**\n     * Create a period with a specified number of weeks.\n     * <p>\n     * The standard period type is used, thus you can add other fields such\n     * as months or days using the <code>withXxx()</code> methods.\n     * For example, <code>Period.weeks(2).withDays(6);</code>\n     * <p>\n     * If you want a week-based period that cannot have other fields added,\n     * then you should consider using {@link Weeks}.\n     *\n     * @param weeks  the amount of weeks in this period\n     * @return the period\n     */"}}
{"code": {"body": "    public static Period days(int days) {\n        return new Period(new int[] {0, 0, 0, days, 0, 0, 0, 0}, PeriodType.standard());\n    }", "comment": "/**\n     * Create a period with a specified number of days.\n     * <p>\n     * The standard period type is used, thus you can add other fields such\n     * as months or weeks using the <code>withXxx()</code> methods.\n     * For example, <code>Period.days(2).withHours(6);</code>\n     * <p>\n     * If you want a day-based period that cannot have other fields added,\n     * then you should consider using {@link Days}.\n     *\n     * @param days  the amount of days in this period\n     * @return the period\n     */"}}
{"code": {"body": "    public static Period hours(int hours) {\n        return new Period(new int[] {0, 0, 0, 0, hours, 0, 0, 0}, PeriodType.standard());\n    }", "comment": "/**\n     * Create a period with a specified number of hours.\n     * <p>\n     * The standard period type is used, thus you can add other fields such\n     * as months or days using the <code>withXxx()</code> methods.\n     * For example, <code>Period.hours(2).withMinutes(30);</code>\n     * <p>\n     * If you want a hour-based period that cannot have other fields added,\n     * then you should consider using {@link Hours}.\n     *\n     * @param hours  the amount of hours in this period\n     * @return the period\n     */"}}
{"code": {"body": "    public static Period minutes(int minutes) {\n        return new Period(new int[] {0, 0, 0, 0, 0, minutes, 0, 0}, PeriodType.standard());\n    }", "comment": "/**\n     * Create a period with a specified number of minutes.\n     * <p>\n     * The standard period type is used, thus you can add other fields such\n     * as days or hours using the <code>withXxx()</code> methods.\n     * For example, <code>Period.minutes(2).withSeconds(30);</code>\n     * <p>\n     * If you want a minute-based period that cannot have other fields added,\n     * then you should consider using {@link Minutes}.\n     *\n     * @param minutes  the amount of minutes in this period\n     * @return the period\n     */"}}
{"code": {"body": "    public static Period seconds(int seconds) {\n        return new Period(new int[] {0, 0, 0, 0, 0, 0, seconds, 0}, PeriodType.standard());\n    }", "comment": "/**\n     * Create a period with a specified number of seconds.\n     * <p>\n     * The standard period type is used, thus you can add other fields such\n     * as days or hours using the <code>withXxx()</code> methods.\n     * For example, <code>Period.seconds(2).withMillis(30);</code>\n     * <p>\n     * If you want a second-based period that cannot have other fields added,\n     * then you should consider using {@link Seconds}.\n     *\n     * @param seconds  the amount of seconds in this period\n     * @return the period\n     */"}}
{"code": {"body": "    public static Period millis(int millis) {\n        return new Period(new int[] {0, 0, 0, 0, 0, 0, 0, millis}, PeriodType.standard());\n    }", "comment": "/**\n     * Create a period with a specified number of millis.\n     * <p>\n     * The standard period type is used, thus you can add other fields such\n     * as days or hours using the <code>withXxx()</code> methods.\n     * For example, <code>Period.millis(20).withSeconds(30);</code>\n     *\n     * @param millis  the amount of millis in this period\n     * @return the period\n     */"}}
{"code": {"body": "    public static Period fieldDifference(ReadablePartial start, ReadablePartial end) {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (start.size() != end.size()) {\n            throw new IllegalArgumentException(\"\");\n        }\n        DurationFieldType[] types = new DurationFieldType[start.size()];\n        int[] values = new int[start.size()];\n        for (int i = 0, isize = start.size(); i < isize; i++) {\n            if (start.getFieldType(i) != end.getFieldType(i)) {\n                throw new IllegalArgumentException(\"\");\n            }\n            types[i] = start.getFieldType(i).getDurationType();\n            if (i > 0 && types[i - 1] == types[i]) {\n                throw new IllegalArgumentException(\"\");\n            }\n            values[i] = end.getValue(i) - start.getValue(i);\n        }\n        return new Period(values, PeriodType.forFields(types));\n    }", "comment": "/**\n     * Creates a period from two partially specified times, calculating\n     * by field difference.\n     * <p>\n     * The two partials must contain the same fields, thus you can specify\n     * two <code>LocalDate</code> objects, or two <code>LocalTime</code> objects,\n     * but not one of each. Also, the partial may not contain overlapping\n     * fields, such as dayOfWeek and dayOfMonth.\n     * <p>\n     * Calculation by field difference works by extracting the difference\n     * one field at a time and not wrapping into other fields.\n     * Thus 2005-06-09/2007-04-12 will yield P1Y-2M3D.\n     * <p>\n     * For example, you have an event that always runs from the 27th of\n     * each month to the 2nd of the next month. If you calculate this\n     * period using a standard constructor, then you will get between\n     * P3D and P6D depending on the month. If you use this method, then\n     * you will get P1M-25D. This field-difference based period can\n     * be successfully applied to each month of the year to obtain the\n     * correct end date for a given start date.\n     *\n     * @param start  the start of the period, must not be null\n     * @param end  the end of the period, must not be null\n     * @throws IllegalArgumentException if the partials are null or invalid\n     * @since 1.1\n     */"}}
{"code": {"body": "    public Period toPeriod() {\n        return this;\n    }", "comment": "/**\n     * Get this period as an immutable <code>Period</code> object\n     * by returning <code>this</code>.\n     * \n     * @return <code>this</code>\n     */"}}
{"code": {"body": "    public int getYears() {\n        return getPeriodType().getIndexedField(this, PeriodType.YEAR_INDEX);\n    }", "comment": "/**\n     * Gets the years field part of the period.\n     * \n     * @return the number of years in the period, zero if unsupported\n     */"}}
{"code": {"body": "    public int getMonths() {\n        return getPeriodType().getIndexedField(this, PeriodType.MONTH_INDEX);\n    }", "comment": "/**\n     * Gets the months field part of the period.\n     * \n     * @return the number of months in the period, zero if unsupported\n     */"}}
{"code": {"body": "    public int getWeeks() {\n        return getPeriodType().getIndexedField(this, PeriodType.WEEK_INDEX);\n    }", "comment": "/**\n     * Gets the weeks field part of the period.\n     * \n     * @return the number of weeks in the period, zero if unsupported\n     */"}}
{"code": {"body": "    public int getDays() {\n        return getPeriodType().getIndexedField(this, PeriodType.DAY_INDEX);\n    }", "comment": "/**\n     * Gets the days field part of the period.\n     * \n     * @return the number of days in the period, zero if unsupported\n     */"}}
{"code": {"body": "    public int getHours() {\n        return getPeriodType().getIndexedField(this, PeriodType.HOUR_INDEX);\n    }", "comment": "/**\n     * Gets the hours field part of the period.\n     * \n     * @return the number of hours in the period, zero if unsupported\n     */"}}
{"code": {"body": "    public int getMinutes() {\n        return getPeriodType().getIndexedField(this, PeriodType.MINUTE_INDEX);\n    }", "comment": "/**\n     * Gets the minutes field part of the period.\n     * \n     * @return the number of minutes in the period, zero if unsupported\n     */"}}
{"code": {"body": "    public int getSeconds() {\n        return getPeriodType().getIndexedField(this, PeriodType.SECOND_INDEX);\n    }", "comment": "/**\n     * Gets the seconds field part of the period.\n     * \n     * @return the number of seconds in the period, zero if unsupported\n     */"}}
{"code": {"body": "    public int getMillis() {\n        return getPeriodType().getIndexedField(this, PeriodType.MILLI_INDEX);\n    }", "comment": "/**\n     * Gets the millis field part of the period.\n     * \n     * @return the number of millis in the period, zero if unsupported\n     */"}}
{"code": {"body": "    public Period withPeriodType(PeriodType type) {\n        type = DateTimeUtils.getPeriodType(type);\n        if (type.equals(getPeriodType())) {\n            return this;\n        }\n        return new Period(this, type);\n    }", "comment": "/**\n     * Creates a new Period instance with the same field values but\n     * different PeriodType.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     * \n     * @param type  the period type to use, null means standard\n     * @return the new period instance\n     * @throws IllegalArgumentException if the new period won't accept all of the current fields\n     */"}}
{"code": {"body": "    public Period withFields(ReadablePeriod period) {\n        if (period == null) {\n            return this;\n        }\n        int[] newValues = getValues();  \n        newValues = super.mergePeriodInto(newValues, period);\n        return new Period(newValues, getPeriodType());\n    }", "comment": "/**\n     * Creates a new Period instance with the fields from the specified period\n     * copied on top of those from this period.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     * \n     * @param period  the period to copy from, null ignored\n     * @return the new period instance\n     * @throws IllegalArgumentException if a field type is unsupported\n     */"}}
{"code": {"body": "    public Period withField(DurationFieldType field, int value) {\n        if (field == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        int[] newValues = getValues();  \n        super.setFieldInto(newValues, field, value);\n        return new Period(newValues, getPeriodType());\n    }", "comment": "/**\n     * Creates a new Period instance with the specified field set to a new value.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     * \n     * @param field  the field to set, not null\n     * @param value  the value to set to\n     * @return the new period instance\n     * @throws IllegalArgumentException if the field type is null or unsupported\n     */"}}
{"code": {"body": "    public Period withFieldAdded(DurationFieldType field, int value) {\n        if (field == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (value == 0) {\n            return this;\n        }\n        int[] newValues = getValues();  \n        super.addFieldInto(newValues, field, value);\n        return new Period(newValues, getPeriodType());\n    }", "comment": "/**\n     * Creates a new Period instance with the valueToAdd added to the specified field.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     * \n     * @param field  the field to set, not null\n     * @param value  the value to add\n     * @return the new period instance\n     * @throws IllegalArgumentException if the field type is null or unsupported\n     */"}}
{"code": {"body": "    public Period withYears(int years) {\n        int[] values = getValues();  \n        getPeriodType().setIndexedField(this, PeriodType.YEAR_INDEX, values, years);\n        return new Period(values, getPeriodType());\n    }", "comment": "/**\n     * Returns a new period with the specified number of years.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param years  the amount of years to add, may be negative\n     * @return the new period with the increased years\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "    public Period withMonths(int months) {\n        int[] values = getValues();  \n        getPeriodType().setIndexedField(this, PeriodType.MONTH_INDEX, values, months);\n        return new Period(values, getPeriodType());\n    }", "comment": "/**\n     * Returns a new period with the specified number of months.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param months  the amount of months to add, may be negative\n     * @return the new period with the increased months\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "    public Period withWeeks(int weeks) {\n        int[] values = getValues();  \n        getPeriodType().setIndexedField(this, PeriodType.WEEK_INDEX, values, weeks);\n        return new Period(values, getPeriodType());\n    }", "comment": "/**\n     * Returns a new period with the specified number of weeks.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the amount of weeks to add, may be negative\n     * @return the new period with the increased weeks\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "    public Period withDays(int days) {\n        int[] values = getValues();  \n        getPeriodType().setIndexedField(this, PeriodType.DAY_INDEX, values, days);\n        return new Period(values, getPeriodType());\n    }", "comment": "/**\n     * Returns a new period with the specified number of days.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param days  the amount of days to add, may be negative\n     * @return the new period with the increased days\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "    public Period withHours(int hours) {\n        int[] values = getValues();  \n        getPeriodType().setIndexedField(this, PeriodType.HOUR_INDEX, values, hours);\n        return new Period(values, getPeriodType());\n    }", "comment": "/**\n     * Returns a new period with the specified number of hours.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the amount of hours to add, may be negative\n     * @return the new period with the increased hours\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "    public Period withMinutes(int minutes) {\n        int[] values = getValues();  \n        getPeriodType().setIndexedField(this, PeriodType.MINUTE_INDEX, values, minutes);\n        return new Period(values, getPeriodType());\n    }", "comment": "/**\n     * Returns a new period with the specified number of minutes.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the amount of minutes to add, may be negative\n     * @return the new period with the increased minutes\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "    public Period withSeconds(int seconds) {\n        int[] values = getValues();  \n        getPeriodType().setIndexedField(this, PeriodType.SECOND_INDEX, values, seconds);\n        return new Period(values, getPeriodType());\n    }", "comment": "/**\n     * Returns a new period with the specified number of seconds.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the amount of seconds to add, may be negative\n     * @return the new period with the increased seconds\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "    public Period withMillis(int millis) {\n        int[] values = getValues();  \n        getPeriodType().setIndexedField(this, PeriodType.MILLI_INDEX, values, millis);\n        return new Period(values, getPeriodType());\n    }", "comment": "/**\n     * Returns a new period with the specified number of millis.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param millis  the amount of millis to add, may be negative\n     * @return the new period with the increased millis\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "    public Period plus(ReadablePeriod period) {\n        if (period == null) {\n            return this;\n        }\n        int[] values = getValues();  \n        getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, period.get(DurationFieldType.YEARS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, period.get(DurationFieldType.MONTHS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, period.get(DurationFieldType.WEEKS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, period.get(DurationFieldType.DAYS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, period.get(DurationFieldType.HOURS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, period.get(DurationFieldType.MINUTES_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, period.get(DurationFieldType.SECONDS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, period.get(DurationFieldType.MILLIS_TYPE));\n        return new Period(values, getPeriodType());\n    }", "comment": "/**\n     * Returns a new period with the specified period added.\n     * <p>\n     * Each field of the period is added separately. Thus a period of\n     * 2 hours 30 minutes plus 3 hours 40 minutes will produce a result\n     * of 5 hours 70 minutes - see {@link #normalizedStandard()}.\n     * <p>\n     * If the period being added contains a non-zero amount for a field that\n     * is not supported in this period then an exception is thrown.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param period  the period to add, null adds zero and returns this\n     * @return the new updated period\n     * @throws UnsupportedOperationException if any field is not supported\n     * @since 1.5\n     */"}}
{"code": {"body": "    public Period plusYears(int years) {\n        if (years == 0) {\n            return this;\n        }\n        int[] values = getValues();  \n        getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, years);\n        return new Period(values, getPeriodType());\n    }", "comment": "/**\n     * Returns a new period with the specified number of years added.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param years  the amount of years to add, may be negative\n     * @return the new period with the increased years\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "    public Period plusMonths(int months) {\n        if (months == 0) {\n            return this;\n        }\n        int[] values = getValues();  \n        getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, months);\n        return new Period(values, getPeriodType());\n    }", "comment": "/**\n     * Returns a new period plus the specified number of months added.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param months  the amount of months to add, may be negative\n     * @return the new period plus the increased months\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "    public Period plusWeeks(int weeks) {\n        if (weeks == 0) {\n            return this;\n        }\n        int[] values = getValues();  \n        getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, weeks);\n        return new Period(values, getPeriodType());\n    }", "comment": "/**\n     * Returns a new period plus the specified number of weeks added.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the amount of weeks to add, may be negative\n     * @return the new period plus the increased weeks\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "    public Period plusDays(int days) {\n        if (days == 0) {\n            return this;\n        }\n        int[] values = getValues();  \n        getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, days);\n        return new Period(values, getPeriodType());\n    }", "comment": "/**\n     * Returns a new period plus the specified number of days added.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param days  the amount of days to add, may be negative\n     * @return the new period plus the increased days\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "    public Period plusHours(int hours) {\n        if (hours == 0) {\n            return this;\n        }\n        int[] values = getValues();  \n        getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, hours);\n        return new Period(values, getPeriodType());\n    }", "comment": "/**\n     * Returns a new period plus the specified number of hours added.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the amount of hours to add, may be negative\n     * @return the new period plus the increased hours\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "    public Period plusMinutes(int minutes) {\n        if (minutes == 0) {\n            return this;\n        }\n        int[] values = getValues();  \n        getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, minutes);\n        return new Period(values, getPeriodType());\n    }", "comment": "/**\n     * Returns a new period plus the specified number of minutes added.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the amount of minutes to add, may be negative\n     * @return the new period plus the increased minutes\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "    public Period plusSeconds(int seconds) {\n        if (seconds == 0) {\n            return this;\n        }\n        int[] values = getValues();  \n        getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, seconds);\n        return new Period(values, getPeriodType());\n    }", "comment": "/**\n     * Returns a new period plus the specified number of seconds added.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the amount of seconds to add, may be negative\n     * @return the new period plus the increased seconds\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "    public Period plusMillis(int millis) {\n        if (millis == 0) {\n            return this;\n        }\n        int[] values = getValues();  \n        getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, millis);\n        return new Period(values, getPeriodType());\n    }", "comment": "/**\n     * Returns a new period plus the specified number of millis added.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param millis  the amount of millis to add, may be negative\n     * @return the new period plus the increased millis\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "    public Period minus(ReadablePeriod period) {\n        if (period == null) {\n            return this;\n        }\n        int[] values = getValues();  \n        getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, -period.get(DurationFieldType.YEARS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, -period.get(DurationFieldType.MONTHS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, -period.get(DurationFieldType.WEEKS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, -period.get(DurationFieldType.DAYS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, -period.get(DurationFieldType.HOURS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, -period.get(DurationFieldType.MINUTES_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, -period.get(DurationFieldType.SECONDS_TYPE));\n        getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, -period.get(DurationFieldType.MILLIS_TYPE));\n        return new Period(values, getPeriodType());\n    }", "comment": "/**\n     * Returns a new period with the specified period subtracted.\n     * <p>\n     * Each field of the period is subtracted separately. Thus a period of\n     * 3 hours 30 minutes minus 2 hours 40 minutes will produce a result\n     * of 1 hour and -10 minutes - see {@link #normalizedStandard()}.\n     * <p>\n     * If the period being added contains a non-zero amount for a field that\n     * is not supported in this period then an exception is thrown.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param period  the period to add, null adds zero and returns this\n     * @return the new updated period\n     * @throws UnsupportedOperationException if any field is not supported\n     * @since 1.5\n     */"}}
{"code": {"body": "    public Period minusYears(int years) {\n        return plusYears(-years);\n    }", "comment": "/**\n     * Returns a new period with the specified number of years taken away.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param years  the amount of years to take away, may be negative\n     * @return the new period with the increased years\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "    public Period minusMonths(int months) {\n        return plusMonths(-months);\n    }", "comment": "/**\n     * Returns a new period minus the specified number of months taken away.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param months  the amount of months to take away, may be negative\n     * @return the new period minus the increased months\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "    public Period minusWeeks(int weeks) {\n        return plusWeeks(-weeks);\n    }", "comment": "/**\n     * Returns a new period minus the specified number of weeks taken away.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the amount of weeks to take away, may be negative\n     * @return the new period minus the increased weeks\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "    public Period minusDays(int days) {\n        return plusDays(-days);\n    }", "comment": "/**\n     * Returns a new period minus the specified number of days taken away.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param days  the amount of days to take away, may be negative\n     * @return the new period minus the increased days\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "    public Period minusHours(int hours) {\n        return plusHours(-hours);\n    }", "comment": "/**\n     * Returns a new period minus the specified number of hours taken away.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the amount of hours to take away, may be negative\n     * @return the new period minus the increased hours\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "    public Period minusMinutes(int minutes) {\n        return plusMinutes(-minutes);\n    }", "comment": "/**\n     * Returns a new period minus the specified number of minutes taken away.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the amount of minutes to take away, may be negative\n     * @return the new period minus the increased minutes\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "    public Period minusSeconds(int seconds) {\n        return plusSeconds(-seconds);\n    }", "comment": "/**\n     * Returns a new period minus the specified number of seconds taken away.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the amount of seconds to take away, may be negative\n     * @return the new period minus the increased seconds\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "    public Period minusMillis(int millis) {\n        return plusMillis(-millis);\n    }", "comment": "/**\n     * Returns a new period minus the specified number of millis taken away.\n     * <p>\n     * This period instance is immutable and unaffected by this method call.\n     *\n     * @param millis  the amount of millis to take away, may be negative\n     * @return the new period minus the increased millis\n     * @throws UnsupportedOperationException if the field is not supported\n     */"}}
{"code": {"body": "    public Period multipliedBy(int scalar) {\n        if (this == ZERO || scalar == 1) {\n            return this;\n        }\n        int[] values = getValues();  \n        for (int i = 0; i < values.length; i++) {\n            values[i] = FieldUtils.safeMultiply(values[i], scalar);\n        }\n        return new Period(values, getPeriodType());\n    }", "comment": "/**\n     * Returns a new instance with each element in this period multiplied\n     * by the specified scalar.\n     *\n     * @param scalar  the scalar to multiply by, not null\n     * @return a {@code Period} based on this period with the amounts multiplied by the scalar, never null\n     * @throws ArithmeticException if the capacity of any field is exceeded\n     * @since 2.1\n     */"}}
{"code": {"body": "    public Period negated() {\n        return multipliedBy(-1);\n    }", "comment": "/**\n     * Returns a new instance with each amount in this period negated.\n     *\n     * @return a {@code Period} based on this period with the amounts negated, never null\n     * @throws ArithmeticException if any field has the minimum value\n     * @since 2.1\n     */"}}
{"code": {"body": "    public Weeks toStandardWeeks() {\n        checkYearsAndMonths(\"\");\n        long millis = getMillis();  \n        millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;\n        millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;\n        millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR;\n        millis += ((long) getDays()) * DateTimeConstants.MILLIS_PER_DAY;\n        long weeks = ((long) getWeeks()) + millis / DateTimeConstants.MILLIS_PER_WEEK;\n        return Weeks.weeks(FieldUtils.safeToInt(weeks));\n    }", "comment": "/**\n     * Converts this period to a period in weeks assuming a\n     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n     * <p>\n     * This method allows you to convert between different types of period.\n     * However to achieve this it makes the assumption that all\n     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and\n     * all minutes are 60 seconds. This is not true when daylight savings time\n     * is considered, and may also not be true for some unusual chronologies.\n     * However, it is included as it is a useful operation for many\n     * applications and business rules.\n     * <p>\n     * If the period contains years or months, an exception will be thrown.\n     * \n     * @return a period representing the number of standard weeks in this period\n     * @throws UnsupportedOperationException if the period contains years or months\n     * @throws ArithmeticException if the number of weeks is too large to be represented\n     * @since 1.5\n     */"}}
{"code": {"body": "    public Days toStandardDays() {\n        checkYearsAndMonths(\"\");\n        long millis = getMillis();  \n        millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;\n        millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;\n        millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR;\n        long days = millis / DateTimeConstants.MILLIS_PER_DAY;\n        days = FieldUtils.safeAdd(days, getDays());\n        days = FieldUtils.safeAdd(days, ((long) getWeeks()) * ((long) DateTimeConstants.DAYS_PER_WEEK));\n        return Days.days(FieldUtils.safeToInt(days));\n    }", "comment": "/**\n     * Converts this period to a period in days assuming a\n     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n     * <p>\n     * This method allows you to convert between different types of period.\n     * However to achieve this it makes the assumption that all\n     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and\n     * all minutes are 60 seconds. This is not true when daylight savings time\n     * is considered, and may also not be true for some unusual chronologies.\n     * However, it is included as it is a useful operation for many\n     * applications and business rules.\n     * <p>\n     * If the period contains years or months, an exception will be thrown.\n     * \n     * @return a period representing the number of standard days in this period\n     * @throws UnsupportedOperationException if the period contains years or months\n     * @throws ArithmeticException if the number of days is too large to be represented\n     * @since 1.5\n     */"}}
{"code": {"body": "    public Hours toStandardHours() {\n        checkYearsAndMonths(\"\");\n        long millis = getMillis();  \n        millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;\n        millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;\n        long hours = millis / DateTimeConstants.MILLIS_PER_HOUR;\n        hours = FieldUtils.safeAdd(hours, getHours());\n        hours = FieldUtils.safeAdd(hours, ((long) getDays()) * ((long) DateTimeConstants.HOURS_PER_DAY));\n        hours = FieldUtils.safeAdd(hours, ((long) getWeeks()) * ((long) DateTimeConstants.HOURS_PER_WEEK));\n        return Hours.hours(FieldUtils.safeToInt(hours));\n    }", "comment": "/**\n     * Converts this period to a period in hours assuming a\n     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n     * <p>\n     * This method allows you to convert between different types of period.\n     * However to achieve this it makes the assumption that all\n     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and\n     * all minutes are 60 seconds. This is not true when daylight savings time\n     * is considered, and may also not be true for some unusual chronologies.\n     * However, it is included as it is a useful operation for many\n     * applications and business rules.\n     * <p>\n     * If the period contains years or months, an exception will be thrown.\n     * \n     * @return a period representing the number of standard hours in this period\n     * @throws UnsupportedOperationException if the period contains years or months\n     * @throws ArithmeticException if the number of hours is too large to be represented\n     * @since 1.5\n     */"}}
{"code": {"body": "    public Minutes toStandardMinutes() {\n        checkYearsAndMonths(\"\");\n        long millis = getMillis();  \n        millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;\n        long minutes = millis / DateTimeConstants.MILLIS_PER_MINUTE;\n        minutes = FieldUtils.safeAdd(minutes, getMinutes());\n        minutes = FieldUtils.safeAdd(minutes, ((long) getHours()) * ((long) DateTimeConstants.MINUTES_PER_HOUR));\n        minutes = FieldUtils.safeAdd(minutes, ((long) getDays()) * ((long) DateTimeConstants.MINUTES_PER_DAY));\n        minutes = FieldUtils.safeAdd(minutes, ((long) getWeeks()) * ((long) DateTimeConstants.MINUTES_PER_WEEK));\n        return Minutes.minutes(FieldUtils.safeToInt(minutes));\n    }", "comment": "/**\n     * Converts this period to a period in minutes assuming a\n     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n     * <p>\n     * This method allows you to convert between different types of period.\n     * However to achieve this it makes the assumption that all\n     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and\n     * all minutes are 60 seconds. This is not true when daylight savings time\n     * is considered, and may also not be true for some unusual chronologies.\n     * However, it is included as it is a useful operation for many\n     * applications and business rules.\n     * <p>\n     * If the period contains years or months, an exception will be thrown.\n     * \n     * @return a period representing the number of standard minutes in this period\n     * @throws UnsupportedOperationException if the period contains years or months\n     * @throws ArithmeticException if the number of minutes is too large to be represented\n     * @since 1.5\n     */"}}
{"code": {"body": "    public Seconds toStandardSeconds() {\n        checkYearsAndMonths(\"\");\n        long seconds = getMillis() / DateTimeConstants.MILLIS_PER_SECOND;\n        seconds = FieldUtils.safeAdd(seconds, getSeconds());\n        seconds = FieldUtils.safeAdd(seconds, ((long) getMinutes()) * ((long) DateTimeConstants.SECONDS_PER_MINUTE));\n        seconds = FieldUtils.safeAdd(seconds, ((long) getHours()) * ((long) DateTimeConstants.SECONDS_PER_HOUR));\n        seconds = FieldUtils.safeAdd(seconds, ((long) getDays()) * ((long) DateTimeConstants.SECONDS_PER_DAY));\n        seconds = FieldUtils.safeAdd(seconds, ((long) getWeeks()) * ((long) DateTimeConstants.SECONDS_PER_WEEK));\n        return Seconds.seconds(FieldUtils.safeToInt(seconds));\n    }", "comment": "/**\n     * Converts this period to a period in seconds assuming a\n     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n     * <p>\n     * This method allows you to convert between different types of period.\n     * However to achieve this it makes the assumption that all\n     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and\n     * all minutes are 60 seconds. This is not true when daylight savings time\n     * is considered, and may also not be true for some unusual chronologies.\n     * However, it is included as it is a useful operation for many\n     * applications and business rules.\n     * <p>\n     * If the period contains years or months, an exception will be thrown.\n     * \n     * @return a period representing the number of standard seconds in this period\n     * @throws UnsupportedOperationException if the period contains years or months\n     * @throws ArithmeticException if the number of seconds is too large to be represented\n     * @since 1.5\n     */"}}
{"code": {"body": "    public Duration toStandardDuration() {\n        checkYearsAndMonths(\"\");\n        long millis = getMillis();  \n        millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n        millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n        millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n        millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n        millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n        return new Duration(millis);\n    }", "comment": "/**\n     * Converts this period to a duration assuming a\n     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n     * <p>\n     * This method allows you to convert from a period to a duration.\n     * However to achieve this it makes the assumption that all\n     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and\n     * all minutes are 60 seconds. This is not true when daylight savings time\n     * is considered, and may also not be true for some unusual chronologies.\n     * However, it is included as it is a useful operation for many\n     * applications and business rules.\n     * <p>\n     * If the period contains years or months, an exception will be thrown.\n     * \n     * @return a duration equivalent to this period\n     * @throws UnsupportedOperationException if the period contains years or months\n     * @since 1.5\n     */"}}
{"code": {"body": "    private void checkYearsAndMonths(String destintionType) {\n        if (getMonths() != 0) {\n            throw new UnsupportedOperationException(\"\" + destintionType + \"\");\n        }\n        if (getYears() != 0) {\n            throw new UnsupportedOperationException(\"\" + destintionType + \"\");\n        }\n    }", "comment": "/**\n     * Check that there are no years or months in the period.\n     * \n     * @param destintionType  the destination type, not null\n     * @throws UnsupportedOperationException if the period contains years or months\n     */"}}
{"code": {"body": "    public Period normalizedStandard(PeriodType type) {\n        long millis = getMillis();  \n        millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n        millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n        millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n        millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n        millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n        Period result = new Period(millis, DateTimeUtils.getPeriodType(type), ISOChronology.getInstanceUTC());\n        int years = getYears();\n        int months = getMonths();\n        if (years != 0 || months != 0) {\n            years = FieldUtils.safeAdd(years, months / 12);\n            months = months % 12;\n            if (years != 0) {\n                result = result.withYears(years);\n            }\n            if (months != 0) {\n                result = result.withMonths(months);\n            }\n        }\n        return result;\n    }", "comment": "/**\n     * Normalizes this period using standard rules, assuming a 12 month year,\n     * 7 day week, 24 hour day, 60 minute hour and 60 second minute,\n     * providing control over how the result is split into fields.\n     * <p>\n     * This method allows you to normalize a period.\n     * However to achieve this it makes the assumption that all years are\n     * 12 months, all weeks are 7 days, all days are 24 hours,\n     * all hours are 60 minutes and all minutes are 60 seconds. This is not\n     * true when daylight savings time is considered, and may also not be true\n     * for some chronologies. However, it is included as it is a useful operation\n     * for many applications and business rules.\n     * <p>\n     * If the period contains years or months, then the months will be\n     * normalized to be between 0 and 11. The days field and below will be\n     * normalized as necessary, however this will not overflow into the months\n     * field. Thus a period of 1 year 15 months will normalize to 2 years 3 months.\n     * But a period of 1 month 40 days will remain as 1 month 40 days.\n     * <p>\n     * The PeriodType parameter controls how the result is created. It allows\n     * you to omit certain fields from the result if desired. For example,\n     * you may not want the result to include weeks, in which case you pass\n     * in <code>PeriodType.yearMonthDayTime()</code>.\n     * \n     * @param type  the period type of the new period, null means standard type\n     * @return a normalized period equivalent to this period\n     * @throws ArithmeticException if any field is too large to be represented\n     * @throws UnsupportedOperationException if this period contains non-zero\n     *  years or months but the specified period type does not support them\n     * @since 1.5\n     */"}}
{"code": {"body": "public PeriodType withYearsRemoved() {\n        return withFieldRemoved(0, \"\");\n    }", "comment": "/**\n     * Returns a version of this PeriodType instance that does not support years.\n     * \n     * @return a new period type that supports the original set of fields except years\n     */"}}
{"code": {"body": "public PeriodType withMonthsRemoved() {\n        return withFieldRemoved(1, \"\");\n    }", "comment": "/**\n     * Returns a version of this PeriodType instance that does not support months.\n     * \n     * @return a new period type that supports the original set of fields except months\n     */"}}
{"code": {"body": "public PeriodType withWeeksRemoved() {\n        return withFieldRemoved(2, \"\");\n    }", "comment": "/**\n     * Returns a version of this PeriodType instance that does not support weeks.\n     * \n     * @return a new period type that supports the original set of fields except weeks\n     */"}}
{"code": {"body": "public PeriodType withDaysRemoved() {\n        return withFieldRemoved(3, \"\");\n    }", "comment": "/**\n     * Returns a version of this PeriodType instance that does not support days.\n     * \n     * @return a new period type that supports the original set of fields except days\n     */"}}
{"code": {"body": "public PeriodType withHoursRemoved() {\n        return withFieldRemoved(4, \"\");\n    }", "comment": "/**\n     * Returns a version of this PeriodType instance that does not support hours.\n     * \n     * @return a new period type that supports the original set of fields except hours\n     */"}}
{"code": {"body": "public PeriodType withMinutesRemoved() {\n        return withFieldRemoved(5, \"\");\n    }", "comment": "/**\n     * Returns a version of this PeriodType instance that does not support minutes.\n     * \n     * @return a new period type that supports the original set of fields except minutes\n     */"}}
{"code": {"body": "public PeriodType withSecondsRemoved() {\n        return withFieldRemoved(6, \"\");\n    }", "comment": "/**\n     * Returns a version of this PeriodType instance that does not support seconds.\n     * \n     * @return a new period type that supports the original set of fields except seconds\n     */"}}
{"code": {"body": "public PeriodType withMillisRemoved() {\n        return withFieldRemoved(7, \"\");\n    }", "comment": "/**\n     * Returns a version of this PeriodType instance that does not support milliseconds.\n     * \n     * @return a new period type that supports the original set of fields except milliseconds\n     */"}}
{"code": {"body": "    public static PeriodType standard() {\n        PeriodType type = cStandard;\n        if (type == null) {\n            type = new PeriodType(\n                \"\",\n                new DurationFieldType[] {\n                    DurationFieldType.years(), DurationFieldType.months(),\n                    DurationFieldType.weeks(), DurationFieldType.days(),\n                    DurationFieldType.hours(), DurationFieldType.minutes(),\n                    DurationFieldType.seconds(), DurationFieldType.millis(),\n                },\n                new int[] { 0, 1, 2, 3, 4, 5, 6, 7, }\n            );\n            cStandard = type;\n        }\n        return type;\n    }", "comment": "/**\n     * Gets a type that defines all standard fields.\n     * <ul>\n     * <li>years\n     * <li>months\n     * <li>weeks\n     * <li>days\n     * <li>hours\n     * <li>minutes\n     * <li>seconds\n     * <li>milliseconds\n     * </ul>\n     *\n     * @return the period type\n     */"}}
{"code": {"body": "    public static PeriodType yearMonthDayTime() {\n        PeriodType type = cYMDTime;\n        if (type == null) {\n            type = new PeriodType(\n                \"\",\n                new DurationFieldType[] {\n                    DurationFieldType.years(), DurationFieldType.months(),\n                    DurationFieldType.days(),\n                    DurationFieldType.hours(), DurationFieldType.minutes(),\n                    DurationFieldType.seconds(), DurationFieldType.millis(),\n                },\n                new int[] { 0, 1, -1, 2, 3, 4, 5, 6, }\n            );\n            cYMDTime = type;\n        }\n        return type;\n    }", "comment": "/**\n     * Gets a type that defines all standard fields except weeks.\n     * <ul>\n     * <li>years\n     * <li>months\n     * <li>days\n     * <li>hours\n     * <li>minutes\n     * <li>seconds\n     * <li>milliseconds\n     * </ul>\n     *\n     * @return the period type\n     */"}}
{"code": {"body": "    public static PeriodType yearMonthDay() {\n        PeriodType type = cYMD;\n        if (type == null) {\n            type = new PeriodType(\n                \"\",\n                new DurationFieldType[] {\n                    DurationFieldType.years(), DurationFieldType.months(),\n                    DurationFieldType.days(),\n                },\n                new int[] { 0, 1, -1, 2, -1, -1, -1, -1, }\n            );\n            cYMD = type;\n        }\n        return type;\n    }", "comment": "/**\n     * Gets a type that defines the year, month and day fields.\n     * <ul>\n     * <li>years\n     * <li>months\n     * <li>days\n     * </ul>\n     *\n     * @return the period type\n     * @since 1.1\n     */"}}
{"code": {"body": "    public static PeriodType yearWeekDayTime() {\n        PeriodType type = cYWDTime;\n        if (type == null) {\n            type = new PeriodType(\n                \"\",\n                new DurationFieldType[] {\n                    DurationFieldType.years(),\n                    DurationFieldType.weeks(), DurationFieldType.days(),\n                    DurationFieldType.hours(), DurationFieldType.minutes(),\n                    DurationFieldType.seconds(), DurationFieldType.millis(),\n                },\n                new int[] { 0, -1, 1, 2, 3, 4, 5, 6, }\n            );\n            cYWDTime = type;\n        }\n        return type;\n    }", "comment": "/**\n     * Gets a type that defines all standard fields except months.\n     * <ul>\n     * <li>years\n     * <li>weeks\n     * <li>days\n     * <li>hours\n     * <li>minutes\n     * <li>seconds\n     * <li>milliseconds\n     * </ul>\n     *\n     * @return the period type\n     */"}}
{"code": {"body": "    public static PeriodType yearWeekDay() {\n        PeriodType type = cYWD;\n        if (type == null) {\n            type = new PeriodType(\n                \"\",\n                new DurationFieldType[] {\n                    DurationFieldType.years(),\n                    DurationFieldType.weeks(), DurationFieldType.days(),\n                },\n                new int[] { 0, -1, 1, 2, -1, -1, -1, -1, }\n            );\n            cYWD = type;\n        }\n        return type;\n    }", "comment": "/**\n     * Gets a type that defines year, week and day fields.\n     * <ul>\n     * <li>years\n     * <li>weeks\n     * <li>days\n     * </ul>\n     *\n     * @return the period type\n     * @since 1.1\n     */"}}
{"code": {"body": "    public static PeriodType yearDayTime() {\n        PeriodType type = cYDTime;\n        if (type == null) {\n            type = new PeriodType(\n                \"\",\n                new DurationFieldType[] {\n                    DurationFieldType.years(), DurationFieldType.days(),\n                    DurationFieldType.hours(), DurationFieldType.minutes(),\n                    DurationFieldType.seconds(), DurationFieldType.millis(),\n                },\n                new int[] { 0, -1, -1, 1, 2, 3, 4, 5, }\n            );\n            cYDTime = type;\n        }\n        return type;\n    }", "comment": "/**\n     * Gets a type that defines all standard fields except months and weeks.\n     * <ul>\n     * <li>years\n     * <li>days\n     * <li>hours\n     * <li>minutes\n     * <li>seconds\n     * <li>milliseconds\n     * </ul>\n     *\n     * @return the period type\n     */"}}
{"code": {"body": "    public static PeriodType yearDay() {\n        PeriodType type = cYD;\n        if (type == null) {\n            type = new PeriodType(\n                \"\",\n                new DurationFieldType[] {\n                    DurationFieldType.years(), DurationFieldType.days(),\n                },\n                new int[] { 0, -1, -1, 1, -1, -1, -1, -1, }\n            );\n            cYD = type;\n        }\n        return type;\n    }", "comment": "/**\n     * Gets a type that defines the year and day fields.\n     * <ul>\n     * <li>years\n     * <li>days\n     * </ul>\n     *\n     * @return the period type\n     * @since 1.1\n     */"}}
{"code": {"body": "    public static PeriodType dayTime() {\n        PeriodType type = cDTime;\n        if (type == null) {\n            type = new PeriodType(\n                \"\",\n                new DurationFieldType[] {\n                    DurationFieldType.days(),\n                    DurationFieldType.hours(), DurationFieldType.minutes(),\n                    DurationFieldType.seconds(), DurationFieldType.millis(),\n                },\n                new int[] { -1, -1, -1, 0, 1, 2, 3, 4, }\n            );\n            cDTime = type;\n        }\n        return type;\n    }", "comment": "/**\n     * Gets a type that defines all standard fields from days downwards.\n     * <ul>\n     * <li>days\n     * <li>hours\n     * <li>minutes\n     * <li>seconds\n     * <li>milliseconds\n     * </ul>\n     *\n     * @return the period type\n     */"}}
{"code": {"body": "    public static PeriodType time() {\n        PeriodType type = cTime;\n        if (type == null) {\n            type = new PeriodType(\n                \"\",\n                new DurationFieldType[] {\n                    DurationFieldType.hours(), DurationFieldType.minutes(),\n                    DurationFieldType.seconds(), DurationFieldType.millis(),\n                },\n                new int[] { -1, -1, -1, -1, 0, 1, 2, 3, }\n            );\n            cTime = type;\n        }\n        return type;\n    }", "comment": "/**\n     * Gets a type that defines all standard time fields.\n     * <ul>\n     * <li>hours\n     * <li>minutes\n     * <li>seconds\n     * <li>milliseconds\n     * </ul>\n     *\n     * @return the period type\n     */"}}
{"code": {"body": "    public static PeriodType years() {\n        PeriodType type = cYears;\n        if (type == null) {\n            type = new PeriodType(\n                \"\",\n                new DurationFieldType[] { DurationFieldType.years() },\n                new int[] { 0, -1, -1, -1, -1, -1, -1, -1, }\n            );\n            cYears = type;\n        }\n        return type;\n    }", "comment": "/**\n     * Gets a type that defines just the years field.\n     *\n     * @return the period type\n     */"}}
{"code": {"body": "    public static PeriodType months() {\n        PeriodType type = cMonths;\n        if (type == null) {\n            type = new PeriodType(\n                \"\",\n                new DurationFieldType[] { DurationFieldType.months() },\n                new int[] { -1, 0, -1, -1, -1, -1, -1, -1, }\n            );\n            cMonths = type;\n        }\n        return type;\n    }", "comment": "/**\n     * Gets a type that defines just the months field.\n     *\n     * @return the period type\n     */"}}
{"code": {"body": "    public static PeriodType weeks() {\n        PeriodType type = cWeeks;\n        if (type == null) {\n            type = new PeriodType(\n                \"\",\n                new DurationFieldType[] { DurationFieldType.weeks() },\n                new int[] { -1, -1, 0, -1, -1, -1, -1, -1, }\n            );\n            cWeeks = type;\n        }\n        return type;\n    }", "comment": "/**\n     * Gets a type that defines just the weeks field.\n     *\n     * @return the period type\n     */"}}
{"code": {"body": "    public static PeriodType days() {\n        PeriodType type = cDays;\n        if (type == null) {\n            type = new PeriodType(\n                \"\",\n                new DurationFieldType[] { DurationFieldType.days() },\n                new int[] { -1, -1, -1, 0, -1, -1, -1, -1, }\n            );\n            cDays = type;\n        }\n        return type;\n    }", "comment": "/**\n     * Gets a type that defines just the days field.\n     *\n     * @return the period type\n     */"}}
{"code": {"body": "    public static PeriodType hours() {\n        PeriodType type = cHours;\n        if (type == null) {\n            type = new PeriodType(\n                \"\",\n                new DurationFieldType[] { DurationFieldType.hours() },\n                new int[] { -1, -1, -1, -1, 0, -1, -1, -1, }\n            );\n            cHours = type;\n        }\n        return type;\n    }", "comment": "/**\n     * Gets a type that defines just the hours field.\n     *\n     * @return the period type\n     */"}}
{"code": {"body": "    public static PeriodType minutes() {\n        PeriodType type = cMinutes;\n        if (type == null) {\n            type = new PeriodType(\n                \"\",\n                new DurationFieldType[] { DurationFieldType.minutes() },\n                new int[] { -1, -1, -1, -1, -1, 0, -1, -1, }\n            );\n            cMinutes = type;\n        }\n        return type;\n    }", "comment": "/**\n     * Gets a type that defines just the minutes field.\n     *\n     * @return the period type\n     */"}}
{"code": {"body": "    public static PeriodType seconds() {\n        PeriodType type = cSeconds;\n        if (type == null) {\n            type = new PeriodType(\n                \"\",\n                new DurationFieldType[] { DurationFieldType.seconds() },\n                new int[] { -1, -1, -1, -1, -1, -1, 0, -1, }\n            );\n            cSeconds = type;\n        }\n        return type;\n    }", "comment": "/**\n     * Gets a type that defines just the seconds field.\n     *\n     * @return the period type\n     */"}}
{"code": {"body": "    public static PeriodType millis() {\n        PeriodType type = cMillis;\n        if (type == null) {\n            type = new PeriodType(\n                \"\",\n                new DurationFieldType[] { DurationFieldType.millis() },\n                new int[] { -1, -1, -1, -1, -1, -1, -1, 0, }\n            );\n            cMillis = type;\n        }\n        return type;\n    }", "comment": "/**\n     * Gets a type that defines just the millis field.\n     *\n     * @return the period type\n     */"}}
{"code": {"body": "    public static synchronized PeriodType forFields(DurationFieldType[] types) {\n        if (types == null || types.length == 0) {\n            throw new IllegalArgumentException(\"\");\n        }\n        for (int i = 0; i < types.length; i++) {\n            if (types[i] == null) {\n                throw new IllegalArgumentException(\"\");\n            }\n        }\n        Map<PeriodType, Object> cache = cTypes;\n        if (cache.isEmpty()) {\n            cache.put(standard(), standard());\n            cache.put(yearMonthDayTime(), yearMonthDayTime());\n            cache.put(yearMonthDay(), yearMonthDay());\n            cache.put(yearWeekDayTime(), yearWeekDayTime());\n            cache.put(yearWeekDay(), yearWeekDay());\n            cache.put(yearDayTime(), yearDayTime());\n            cache.put(yearDay(), yearDay());\n            cache.put(dayTime(), dayTime());\n            cache.put(time(), time());\n            cache.put(years(), years());\n            cache.put(months(), months());\n            cache.put(weeks(), weeks());\n            cache.put(days(), days());\n            cache.put(hours(), hours());\n            cache.put(minutes(), minutes());\n            cache.put(seconds(), seconds());\n            cache.put(millis(), millis());\n        }\n        PeriodType inPartType = new PeriodType(null, types, null);\n        Object cached = cache.get(inPartType);\n        if (cached instanceof PeriodType) {\n            return (PeriodType) cached;\n        }\n        if (cached != null) {\n            throw new IllegalArgumentException(\"\" + cached);\n        }\n        PeriodType type = standard();\n        List<DurationFieldType> list = new ArrayList<DurationFieldType>(Arrays.asList(types));\n        if (list.remove(DurationFieldType.years()) == false) {\n            type = type.withYearsRemoved();\n        }\n        if (list.remove(DurationFieldType.months()) == false) {\n            type = type.withMonthsRemoved();\n        }\n        if (list.remove(DurationFieldType.weeks()) == false) {\n            type = type.withWeeksRemoved();\n        }\n        if (list.remove(DurationFieldType.days()) == false) {\n            type = type.withDaysRemoved();\n        }\n        if (list.remove(DurationFieldType.hours()) == false) {\n            type = type.withHoursRemoved();\n        }\n        if (list.remove(DurationFieldType.minutes()) == false) {\n            type = type.withMinutesRemoved();\n        }\n        if (list.remove(DurationFieldType.seconds()) == false) {\n            type = type.withSecondsRemoved();\n        }\n        if (list.remove(DurationFieldType.millis()) == false) {\n            type = type.withMillisRemoved();\n        }\n        if (list.size() > 0) {\n            cache.put(inPartType, list);\n            throw new IllegalArgumentException(\"\" + list);\n        }\n        \n        PeriodType checkPartType = new PeriodType(null, type.iTypes, null);\n        PeriodType checkedType = (PeriodType) cache.get(checkPartType);\n        if (checkedType != null) {\n            cache.put(checkPartType, checkedType);\n            return checkedType;\n        }\n        cache.put(checkPartType, type);\n        return type;\n    }", "comment": "/**\n     * Gets a period type that contains the duration types of the array.\n     * <p>\n     * Only the 8 standard duration field types are supported.\n     *\n     * @param types  the types to include in the array.\n     * @return the period type\n     * @since 1.1\n     */"}}
{"code": {"body": "    public String getName() {\n        return iName;\n    }", "comment": "/**\n     * Gets the name of the period type.\n     * \n     * @return the name\n     */"}}
{"code": {"body": "    public int size() {\n        return iTypes.length;\n    }", "comment": "/**\n     * Gets the number of fields in the period type.\n     * \n     * @return the number of fields\n     */"}}
{"code": {"body": "    public DurationFieldType getFieldType(int index) {\n        return iTypes[index];\n    }", "comment": "/**\n     * Gets the field type by index.\n     * \n     * @param index  the index to retrieve\n     * @return the field type\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */"}}
{"code": {"body": "    public boolean isSupported(DurationFieldType type) {\n        return (indexOf(type) >= 0);\n    }", "comment": "/**\n     * Checks whether the field specified is supported by this period.\n     *\n     * @param type  the type to check, may be null which returns false\n     * @return true if the field is supported\n     */"}}
{"code": {"body": "    public int indexOf(DurationFieldType type) {\n        for (int i = 0, isize = size(); i < isize; i++) {\n            if (iTypes[i] == type) {\n                return i;\n            }\n        }\n        return -1;\n    }", "comment": "/**\n     * Gets the index of the field in this period.\n     *\n     * @param type  the type to check, may be null which returns -1\n     * @return the index of -1 if not supported\n     */"}}
{"code": {"body": "    public String toString() {\n        return \"\" + getName() + \"\";\n    }", "comment": "/**\n     * Gets a debugging to string.\n     * \n     * @return a string\n     */"}}
{"code": {"body": "    int getIndexedField(ReadablePeriod period, int index) {\n        int realIndex = iIndices[index];\n        return (realIndex == -1 ? 0 : period.getValue(realIndex));\n    }", "comment": "/**\n     * Gets the indexed field part of the period.\n     * \n     * @param period  the period to query\n     * @param index  the index to use\n     * @return the value of the field, zero if unsupported\n     */"}}
{"code": {"body": "    boolean setIndexedField(ReadablePeriod period, int index, int[] values, int newValue) {\n        int realIndex = iIndices[index];\n        if (realIndex == -1) {\n            throw new UnsupportedOperationException(\"\");\n        }\n        values[realIndex] = newValue;\n        return true;\n    }", "comment": "/**\n     * Sets the indexed field part of the period.\n     * \n     * @param period  the period to query\n     * @param index  the index to use\n     * @param values  the array to populate\n     * @param newValue  the value to set\n     * @throws UnsupportedOperationException if not supported\n     */"}}
{"code": {"body": "    boolean addIndexedField(ReadablePeriod period, int index, int[] values, int valueToAdd) {\n        if (valueToAdd == 0) {\n            return false;\n        }\n        int realIndex = iIndices[index];\n        if (realIndex == -1) {\n            throw new UnsupportedOperationException(\"\");\n        }\n        values[realIndex] = FieldUtils.safeAdd(values[realIndex], valueToAdd);\n        return true;\n    }", "comment": "/**\n     * Adds to the indexed field part of the period.\n     * \n     * @param period  the period to query\n     * @param index  the index to use\n     * @param values  the array to populate\n     * @param valueToAdd  the value to add\n     * @return true if the array is updated\n     * @throws UnsupportedOperationException if not supported\n     */"}}
{"code": {"body": "    public PeriodType withYearsRemoved() {\n        return withFieldRemoved(0, \"\");\n    }", "comment": "/**\n     * Returns a version of this PeriodType instance that does not support years.\n     * \n     * @return a new period type that supports the original set of fields except years\n     */"}}
{"code": {"body": "    public PeriodType withMonthsRemoved() {\n        return withFieldRemoved(1, \"\");\n    }", "comment": "/**\n     * Returns a version of this PeriodType instance that does not support months.\n     * \n     * @return a new period type that supports the original set of fields except months\n     */"}}
{"code": {"body": "    public PeriodType withWeeksRemoved() {\n        return withFieldRemoved(2, \"\");\n    }", "comment": "/**\n     * Returns a version of this PeriodType instance that does not support weeks.\n     * \n     * @return a new period type that supports the original set of fields except weeks\n     */"}}
{"code": {"body": "    public PeriodType withDaysRemoved() {\n        return withFieldRemoved(3, \"\");\n    }", "comment": "/**\n     * Returns a version of this PeriodType instance that does not support days.\n     * \n     * @return a new period type that supports the original set of fields except days\n     */"}}
{"code": {"body": "    public PeriodType withHoursRemoved() {\n        return withFieldRemoved(4, \"\");\n    }", "comment": "/**\n     * Returns a version of this PeriodType instance that does not support hours.\n     * \n     * @return a new period type that supports the original set of fields except hours\n     */"}}
{"code": {"body": "    public PeriodType withMinutesRemoved() {\n        return withFieldRemoved(5, \"\");\n    }", "comment": "/**\n     * Returns a version of this PeriodType instance that does not support minutes.\n     * \n     * @return a new period type that supports the original set of fields except minutes\n     */"}}
{"code": {"body": "    public PeriodType withSecondsRemoved() {\n        return withFieldRemoved(6, \"\");\n    }", "comment": "/**\n     * Returns a version of this PeriodType instance that does not support seconds.\n     * \n     * @return a new period type that supports the original set of fields except seconds\n     */"}}
{"code": {"body": "    public PeriodType withMillisRemoved() {\n        return withFieldRemoved(7, \"\");\n    }", "comment": "/**\n     * Returns a version of this PeriodType instance that does not support milliseconds.\n     * \n     * @return a new period type that supports the original set of fields except milliseconds\n     */"}}
{"code": {"body": "    private PeriodType withFieldRemoved(int indicesIndex, String name) {\n        int fieldIndex = iIndices[indicesIndex];\n        if (fieldIndex == -1) {\n            return this;\n        }\n        \n        DurationFieldType[] types = new DurationFieldType[size() - 1];\n        for (int i = 0; i < iTypes.length; i++) {\n            if (i < fieldIndex) {\n                types[i] = iTypes[i];\n            } else if (i > fieldIndex) {\n                types[i - 1] = iTypes[i];\n            }\n        }\n        \n        int[] indices = new int[8];\n        for (int i = 0; i < indices.length; i++) {\n            if (i < indicesIndex) {\n                indices[i] = iIndices[i];\n            } else if (i > indicesIndex) {\n                indices[i] = (iIndices[i] == -1 ? -1 : iIndices[i] - 1);\n            } else {\n                indices[i] = -1;\n            }\n        }\n        return new PeriodType(getName() + name, types, indices);\n    }", "comment": "/**\n     * Removes the field specified by indices index.\n     * \n     * @param indicesIndex  the index to remove\n     * @param name  the name addition\n     * @return the new type\n     */"}}
{"code": {"body": "    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj instanceof PeriodType == false) {\n            return false;\n        }\n        PeriodType other = (PeriodType) obj;\n        return (Arrays.equals(iTypes, other.iTypes));\n    }", "comment": "/**\n     * Compares this type to another object.\n     * To be equal, the object must be a PeriodType with the same set of fields.\n     * \n     * @param obj  the object to compare to\n     * @return true if equal\n     */"}}
{"code": {"body": "    public int hashCode() {\n        int hash = 0;\n        for (int i = 0; i < iTypes.length; i++) {\n            hash += iTypes[i].hashCode();\n        }\n        return hash;\n    }", "comment": "/**\n     * Returns a hashcode based on the field types.\n     * \n     * @return a suitable hashcode\n     */"}}
{"code": {"body": "public Seconds plus(int seconds) {\n        if (seconds == 0) {\n            return this;\n        }\n        return Seconds.seconds(FieldUtils.safeAdd(getValue(), seconds));\n    }", "comment": "/**\n     * Returns a new instance with the specified number of seconds added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the amount of seconds to add, may be negative\n     * @return the new period plus the specified number of seconds\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "public Seconds plus(Seconds seconds) {\n        if (seconds == null) {\n            return this;\n        }\n        return plus(seconds.getValue());\n    }", "comment": "/**\n     * Returns a new instance with the specified number of seconds added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the amount of seconds to add, may be negative, null means zero\n     * @return the new period plus the specified number of seconds\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "public Seconds minus(int seconds) {\n        return plus(FieldUtils.safeNegate(seconds));\n    }", "comment": "/**\n     * Returns a new instance with the specified number of seconds taken away.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the amount of seconds to take away, may be negative\n     * @return the new period minus the specified number of seconds\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "public Seconds minus(Seconds seconds) {\n        if (seconds == null) {\n            return this;\n        }\n        return minus(seconds.getValue());\n    }", "comment": "/**\n     * Returns a new instance with the specified number of seconds taken away.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the amount of seconds to take away, may be negative, null means zero\n     * @return the new period minus the specified number of seconds\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "public Seconds multipliedBy(int scalar) {\n        return Seconds.seconds(FieldUtils.safeMultiply(getValue(), scalar));\n    }", "comment": "/**\n     * Returns a new instance with the seconds multiplied by the specified scalar.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param scalar  the amount to multiply by, may be negative\n     * @return the new period multiplied by the specified scalar\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "public Seconds dividedBy(int divisor) {\n        if (divisor == 1) {\n            return this;\n        }\n        return Seconds.seconds(getValue() / divisor);\n    }", "comment": "/**\n     * Returns a new instance with the seconds divided by the specified divisor.\n     * The calculation uses integer division, thus 3 divided by 2 is 1.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param divisor  the amount to divide by, may be negative\n     * @return the new period divided by the specified divisor\n     * @throws ArithmeticException if the divisor is zero\n     */"}}
{"code": {"body": "public Seconds negated() {\n        return Seconds.seconds(FieldUtils.safeNegate(getValue()));\n    }", "comment": "/**\n     * Returns a new instance with the seconds value negated.\n     *\n     * @return the new period with a negated value\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "    public static Seconds seconds(int seconds) {\n        switch (seconds) {\n            case 0:\n                return ZERO;\n            case 1:\n                return ONE;\n            case 2:\n                return TWO;\n            case 3:\n                return THREE;\n            case Integer.MAX_VALUE:\n                return MAX_VALUE;\n            case Integer.MIN_VALUE:\n                return MIN_VALUE;\n            default:\n                return new Seconds(seconds);\n        }\n    }", "comment": "/**\n     * Obtains an instance of <code>Seconds</code> that may be cached.\n     * <code>Seconds</code> is immutable, so instances can be cached and shared.\n     * This factory method provides access to shared instances.\n     *\n     * @param seconds  the number of seconds to obtain an instance for\n     * @return the instance of Seconds\n     */"}}
{"code": {"body": "    public static Seconds secondsBetween(ReadablePartial start, ReadablePartial end) {\n        if (start instanceof LocalTime && end instanceof LocalTime)   {\n            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n            int seconds = chrono.seconds().getDifference(\n                    ((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis());\n            return Seconds.seconds(seconds);\n        }\n        int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\n        return Seconds.seconds(amount);\n    }", "comment": "/**\n     * Creates a <code>Seconds</code> representing the number of whole seconds\n     * between the two specified partial datetimes.\n     * <p>\n     * The two partials must contain the same fields, for example you can specify\n     * two <code>LocalTime</code> objects.\n     *\n     * @param start  the start partial date, must not be null\n     * @param end  the end partial date, must not be null\n     * @return the period in seconds\n     * @throws IllegalArgumentException if the partials are null or invalid\n     */"}}
{"code": {"body": "    public static Seconds secondsIn(ReadableInterval interval) {\n        if (interval == null)   {\n            return Seconds.ZERO;\n        }\n        int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.seconds());\n        return Seconds.seconds(amount);\n    }", "comment": "/**\n     * Creates a <code>Seconds</code> representing the number of whole seconds\n     * in the specified interval.\n     *\n     * @param interval  the interval to extract seconds from, null returns zero\n     * @return the period in seconds\n     * @throws IllegalArgumentException if the partials are null or invalid\n     */"}}
{"code": {"body": "    public static Seconds standardSecondsIn(ReadablePeriod period) {\n        int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_SECOND);\n        return Seconds.seconds(amount);\n    }", "comment": "/**\n     * Creates a new <code>Seconds</code> representing the number of complete\n     * standard length seconds in the specified period.\n     * <p>\n     * This factory method converts all fields from the period to hours using standardised\n     * durations for each field. Only those fields which have a precise duration in\n     * the ISO UTC chronology can be converted.\n     * <ul>\n     * <li>One week consists of 7 seconds.\n     * <li>One day consists of 24 hours.\n     * <li>One hour consists of 60 minutes.\n     * <li>One minute consists of 60 seconds.\n     * <li>One second consists of 1000 milliseconds.\n     * </ul>\n     * Months and Years are imprecise and periods containing these values cannot be converted.\n     *\n     * @param period  the period to get the number of hours from, null returns zero\n     * @return the period in seconds\n     * @throws IllegalArgumentException if the period contains imprecise duration values\n     */"}}
{"code": {"body": "    private Object readResolve() {\n        return Seconds.seconds(getValue());\n    }", "comment": "/**\n     * Resolves singletons.\n     * \n     * @return the singleton instance\n     */"}}
{"code": {"body": "    public DurationFieldType getFieldType() {\n        return DurationFieldType.seconds();\n    }", "comment": "/**\n     * Gets the duration field type, which is <code>seconds</code>.\n     *\n     * @return the period type\n     */"}}
{"code": {"body": "    public PeriodType getPeriodType() {\n        return PeriodType.seconds();\n    }", "comment": "/**\n     * Gets the period type, which is <code>seconds</code>.\n     *\n     * @return the period type\n     */"}}
{"code": {"body": "    public Weeks toStandardWeeks() {\n        return Weeks.weeks(getValue() / DateTimeConstants.SECONDS_PER_WEEK);\n    }", "comment": "/**\n     * Converts this period in seconds to a period in weeks assuming a\n     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n     * <p>\n     * This method allows you to convert between different types of period.\n     * However to achieve this it makes the assumption that all weeks are 7 days\n     * long, all days are 24 hours long, all hours are 60 minutes long and\n     * all minutes are 60 seconds long.\n     * This is not true when daylight savings time is considered, and may also\n     * not be true for some unusual chronologies. However, it is included as it\n     * is a useful operation for many applications and business rules.\n     * \n     * @return a period representing the number of whole weeks for this number of seconds\n     */"}}
{"code": {"body": "    public Days toStandardDays() {\n        return Days.days(getValue() / DateTimeConstants.SECONDS_PER_DAY);\n    }", "comment": "/**\n     * Converts this period in seconds to a period in days assuming a\n     * 24 hour day, 60 minute hour and 60 second minute.\n     * <p>\n     * This method allows you to convert between different types of period.\n     * However to achieve this it makes the assumption that all days are 24 hours\n     * long, all hours are 60 minutes long and all minutes are 60 seconds long.\n     * This is not true when daylight savings is considered and may also not\n     * be true for some unusual chronologies. However, it is included\n     * as it is a useful operation for many applications and business rules.\n     * \n     * @return a period representing the number of days for this number of seconds\n     */"}}
{"code": {"body": "    public Hours toStandardHours() {\n        return Hours.hours(getValue() / DateTimeConstants.SECONDS_PER_HOUR);\n    }", "comment": "/**\n     * Converts this period in seconds to a period in hours assuming a\n     * 60 minute hour and 60 second minute.\n     * <p>\n     * This method allows you to convert between different types of period.\n     * However to achieve this it makes the assumption that all hours are\n     * 60 minutes long and all minutes are 60 seconds long.\n     * This may not be true for some unusual chronologies. However, it is included\n     * as it is a useful operation for many applications and business rules.\n     * \n     * @return a period representing the number of hours for this number of seconds\n     */"}}
{"code": {"body": "    public Minutes toStandardMinutes() {\n        return Minutes.minutes(getValue() / DateTimeConstants.SECONDS_PER_MINUTE);\n    }", "comment": "/**\n     * Converts this period in seconds to a period in minutes assuming a\n     * 60 second minute.\n     * <p>\n     * This method allows you to convert between different types of period.\n     * However to achieve this it makes the assumption that all minutes are\n     * 60 seconds long.\n     * This may not be true for some unusual chronologies. However, it is included\n     * as it is a useful operation for many applications and business rules.\n     * \n     * @return a period representing the number of minutes for this number of seconds\n     */"}}
{"code": {"body": "    public Duration toStandardDuration() {\n        long seconds = getValue();  \n        return new Duration(seconds * DateTimeConstants.MILLIS_PER_SECOND);\n    }", "comment": "/**\n     * Converts this period in seconds to a duration in milliseconds assuming a\n     * 24 hour day, 60 minute hour and 60 second minute.\n     * <p>\n     * This method allows you to convert from a period to a duration.\n     * However to achieve this it makes the assumption that all seconds are 24 hours\n     * long, all hours are 60 minutes and all minutes are 60 seconds.\n     * This is not true when daylight savings time is considered, and may also\n     * not be true for some unusual chronologies. However, it is included as it\n     * is a useful operation for many applications and business rules.\n     * \n     * @return a duration equivalent to this number of seconds\n     */"}}
{"code": {"body": "    public int getSeconds() {\n        return getValue();\n    }", "comment": "/**\n     * Gets the number of seconds that this period represents.\n     *\n     * @return the number of seconds in the period\n     */"}}
{"code": {"body": "    public Seconds plus(Seconds seconds) {\n        if (seconds == null) {\n            return this;\n        }\n        return plus(seconds.getValue());\n    }", "comment": "/**\n     * Returns a new instance with the specified number of seconds added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the amount of seconds to add, may be negative, null means zero\n     * @return the new period plus the specified number of seconds\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "    public Seconds minus(Seconds seconds) {\n        if (seconds == null) {\n            return this;\n        }\n        return minus(seconds.getValue());\n    }", "comment": "/**\n     * Returns a new instance with the specified number of seconds taken away.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the amount of seconds to take away, may be negative, null means zero\n     * @return the new period minus the specified number of seconds\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "    public Seconds multipliedBy(int scalar) {\n        return Seconds.seconds(FieldUtils.safeMultiply(getValue(), scalar));\n    }", "comment": "/**\n     * Returns a new instance with the seconds multiplied by the specified scalar.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param scalar  the amount to multiply by, may be negative\n     * @return the new period multiplied by the specified scalar\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "    public Seconds dividedBy(int divisor) {\n        if (divisor == 1) {\n            return this;\n        }\n        return Seconds.seconds(getValue() / divisor);\n    }", "comment": "/**\n     * Returns a new instance with the seconds divided by the specified divisor.\n     * The calculation uses integer division, thus 3 divided by 2 is 1.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param divisor  the amount to divide by, may be negative\n     * @return the new period divided by the specified divisor\n     * @throws ArithmeticException if the divisor is zero\n     */"}}
{"code": {"body": "    public Seconds negated() {\n        return Seconds.seconds(FieldUtils.safeNegate(getValue()));\n    }", "comment": "/**\n     * Returns a new instance with the seconds value negated.\n     *\n     * @return the new period with a negated value\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "    public boolean isGreaterThan(Seconds other) {\n        if (other == null) {\n            return getValue() > 0;\n        }\n        return getValue() > other.getValue();\n    }", "comment": "/**\n     * Is this seconds instance greater than the specified number of seconds.\n     *\n     * @param other  the other period, null means zero\n     * @return true if this seconds instance is greater than the specified one\n     */"}}
{"code": {"body": "    public boolean isLessThan(Seconds other) {\n        if (other == null) {\n            return getValue() < 0;\n        }\n        return getValue() < other.getValue();\n    }", "comment": "/**\n     * Is this seconds instance less than the specified number of seconds.\n     *\n     * @param other  the other period, null means zero\n     * @return true if this seconds instance is less than the specified one\n     */"}}
{"code": {"body": "public TimeOfDay() {\n        super();\n    }", "comment": "/**\n     * Constructs a TimeOfDay with the current time, using ISOChronology in\n     * the default zone to extract the fields.\n     * <p>\n     * The constructor uses the default time zone, resulting in the local time\n     * being initialised. Once the constructor is complete, all further calculations\n     * are performed without reference to a timezone (by switching to UTC).\n     */"}}
{"code": {"body": "public TimeOfDay(DateTimeZone zone) {\n        super(ISOChronology.getInstance(zone));\n    }", "comment": "/**\n     * Constructs a TimeOfDay with the current time, using ISOChronology in\n     * the specified zone to extract the fields.\n     * <p>\n     * The constructor uses the specified time zone to obtain the current time.\n     * Once the constructor is complete, all further calculations\n     * are performed without reference to a timezone (by switching to UTC).\n     * \n     * @param zone  the zone to use, null means default zone\n     * @since 1.1\n     */"}}
{"code": {"body": "public TimeOfDay(Chronology chronology) {\n        super(chronology);\n    }", "comment": "/**\n     * Constructs a TimeOfDay with the current time, using the specified chronology\n     * and zone to extract the fields.\n     * <p>\n     * The constructor uses the time zone of the chronology specified.\n     * Once the constructor is complete, all further calculations are performed\n     * without reference to a timezone (by switching to UTC).\n     *\n     * @param chronology  the chronology, null means ISOChronology in the default zone\n     */"}}
{"code": {"body": "public TimeOfDay(long instant) {\n        super(instant);\n    }", "comment": "/**\n     * Constructs a TimeOfDay extracting the partial fields from the specified\n     * milliseconds using the ISOChronology in the default zone.\n     * <p>\n     * The constructor uses the default time zone, resulting in the local time\n     * being initialised. Once the constructor is complete, all further calculations\n     * are performed without reference to a timezone (by switching to UTC).\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     */"}}
{"code": {"body": "public TimeOfDay(long instant, Chronology chronology) {\n        super(instant, chronology);\n    }", "comment": "/**\n     * Constructs a TimeOfDay extracting the partial fields from the specified\n     * milliseconds using the chronology provided.\n     * <p>\n     * The constructor uses the time zone of the chronology specified.\n     * Once the constructor is complete, all further calculations are performed\n     * without reference to a timezone (by switching to UTC).\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     * @param chronology  the chronology, null means ISOChronology in the default zone\n     */"}}
{"code": {"body": "public TimeOfDay(Object instant) {\n        super(instant, null, ISODateTimeFormat.timeParser());\n    }", "comment": "/**\n     * Constructs a TimeOfDay from an Object that represents a time.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadableInstant, String, Calendar and Date.\n     * The String formats are described by {@link ISODateTimeFormat#timeParser()}.\n     * <p>\n     * The chronology used will be derived from the object, defaulting to ISO.\n     * <p>\n     * NOTE: Prior to v1.3 the string format was described by\n     * {@link ISODateTimeFormat#dateTimeParser()}. Dates are now rejected.\n     *\n     * @param instant  the datetime object, null means now\n     * @throws IllegalArgumentException if the instant is invalid\n     */"}}
{"code": {"body": "public TimeOfDay(Object instant, Chronology chronology) {\n        super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.timeParser());\n    }", "comment": "/**\n     * Constructs a TimeOfDay from an Object that represents a time, using the\n     * specified chronology.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadableInstant, String, Calendar and Date.\n     * The String formats are described by {@link ISODateTimeFormat#timeParser()}.\n     * <p>\n     * The constructor uses the time zone of the chronology specified.\n     * Once the constructor is complete, all further calculations are performed\n     * without reference to a timezone (by switching to UTC).\n     * The specified chronology overrides that of the object.\n     * <p>\n     * NOTE: Prior to v1.3 the string format was described by\n     * {@link ISODateTimeFormat#dateTimeParser()}. Dates are now rejected.\n     *\n     * @param instant  the datetime object, null means now\n     * @param chronology  the chronology, null means ISO default\n     * @throws IllegalArgumentException if the instant is invalid\n     */"}}
{"code": {"body": "public TimeOfDay(int hourOfDay, int minuteOfHour) {\n        this(hourOfDay, minuteOfHour, 0, 0, null);\n    }", "comment": "/**\n     * Constructs a TimeOfDay with specified hour and minute and zero seconds and milliseconds\n     * using <code>ISOChronology</code> in the default zone.\n     * <p>\n     * The constructor uses the no time zone initialising the fields as provided.\n     * Once the constructor is complete, all further calculations\n     * are performed without reference to a timezone (by switching to UTC).\n     *\n     * @param hourOfDay  the hour of the day\n     * @param minuteOfHour  the minute of the hour\n     */"}}
{"code": {"body": "public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology) {\n        this(hourOfDay, minuteOfHour, 0, 0, chronology);\n    }", "comment": "/**\n     * Constructs a TimeOfDay with specified hour and minute and zero seconds and milliseconds.\n     * <p>\n     * The constructor uses the time zone of the chronology specified.\n     * Once the constructor is complete, all further calculations are performed\n     * without reference to a timezone (by switching to UTC).\n     *\n     * @param hourOfDay  the hour of the day\n     * @param minuteOfHour  the minute of the hour\n     * @param chronology  the chronology, null means ISOChronology in the default zone\n     */"}}
{"code": {"body": "public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute) {\n        this(hourOfDay, minuteOfHour, secondOfMinute, 0, null);\n    }", "comment": "/**\n     * Constructs a TimeOfDay with specified time field values and zero milliseconds\n     * using <code>ISOChronology</code> in the default zone.\n     * <p>\n     * The constructor uses the no time zone initialising the fields as provided.\n     * Once the constructor is complete, all further calculations\n     * are performed without reference to a timezone (by switching to UTC).\n     *\n     * @param hourOfDay  the hour of the day\n     * @param minuteOfHour  the minute of the hour\n     * @param secondOfMinute  the second of the minute\n     */"}}
{"code": {"body": "public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology) {\n        this(hourOfDay, minuteOfHour, secondOfMinute, 0, chronology);\n    }", "comment": "/**\n     * Constructs a TimeOfDay with specified time field values and zero milliseconds.\n     * <p>\n     * The constructor uses the time zone of the chronology specified.\n     * Once the constructor is complete, all further calculations are performed\n     * without reference to a timezone (by switching to UTC).\n     *\n     * @param hourOfDay  the hour of the day\n     * @param minuteOfHour  the minute of the hour\n     * @param secondOfMinute  the second of the minute\n     * @param chronology  the chronology, null means ISOChronology in the default zone\n     */"}}
{"code": {"body": "public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) {\n        this(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, null);\n    }", "comment": "/**\n     * Constructs a TimeOfDay with specified time field values using\n     * <code>ISOChronology</code> in the default zone.\n     * <p>\n     * The constructor uses the no time zone initialising the fields as provided.\n     * Once the constructor is complete, all further calculations\n     * are performed without reference to a timezone (by switching to UTC).\n     *\n     * @param hourOfDay  the hour of the day\n     * @param minuteOfHour  the minute of the hour\n     * @param secondOfMinute  the second of the minute\n     * @param millisOfSecond  the millisecond of the second\n     */"}}
{"code": {"body": "public TimeOfDay(int hourOfDay, int minuteOfHour)", "comment": "/**\n     * Constructs a TimeOfDay with specified hour and minute and zero seconds and milliseconds\n     * using <code>ISOChronology</code> in the default zone.\n     * <p>\n     * The constructor uses the no time zone initialising the fields as provided.\n     * Once the constructor is complete, all further calculations\n     * are performed without reference to a timezone (by switching to UTC).\n     *\n     * @param hourOfDay  the hour of the day\n     * @param minuteOfHour  the minute of the hour\n     */"}}
{"code": {"body": "public TimeOfDay withChronologyRetainFields(Chronology newChronology) {\n        newChronology = DateTimeUtils.getChronology(newChronology);\n        newChronology = newChronology.withUTC();\n        if (newChronology == getChronology()) {\n            return this;\n        } else {\n            TimeOfDay newTimeOfDay = new TimeOfDay(this, newChronology);\n            newChronology.validate(newTimeOfDay, getValues());\n            return newTimeOfDay;\n        }\n    }", "comment": "/**\n     * Returns a copy of this time with the specified chronology.\n     * This instance is immutable and unaffected by this method call.\n     * <p>\n     * This method retains the values of the fields, thus the result will\n     * typically refer to a different instant.\n     * <p>\n     * The time zone of the specified chronology is ignored, as TimeOfDay\n     * operates without a time zone.\n     *\n     * @param newChronology  the new chronology, null means ISO\n     * @return a copy of this datetime with a different chronology\n     * @throws IllegalArgumentException if the values are invalid for the new chronology\n     */"}}
{"code": {"body": "public TimeOfDay withField(DateTimeFieldType fieldType, int value) {\n        int index = indexOfSupported(fieldType);\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new TimeOfDay(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this time with the specified field set to a new value.\n     * <p>\n     * For example, if the field type is <code>minuteOfHour</code> then the day\n     * would be changed in the returned instance.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * TimeOfDay updated = tod.withField(DateTimeFieldType.minuteOfHour(), 6);\n     * TimeOfDay updated = tod.minuteOfHour().setCopy(6);\n     * TimeOfDay updated = tod.property(DateTimeFieldType.minuteOfHour()).setCopy(6);\n     * </pre>\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this instance with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     */"}}
{"code": {"body": "public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount) {\n        int index = indexOfSupported(fieldType);\n        if (amount == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).addWrapPartial(this, index, newValues, amount);\n        return new TimeOfDay(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this time with the value of the specified field increased,\n     * wrapping to what would be a new day if required.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * TimeOfDay added = tod.withFieldAdded(DurationFieldType.minutes(), 6);\n     * TimeOfDay added = tod.plusMinutes(6);\n     * TimeOfDay added = tod.minuteOfHour().addToCopy(6);\n     * </pre>\n     * \n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this instance with the field updated\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the new datetime exceeds the capacity\n     */"}}
{"code": {"body": "public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar) {\n        if (period == null || scalar == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        for (int i = 0; i < period.size(); i++) {\n            DurationFieldType fieldType = period.getFieldType(i);\n            int index = indexOf(fieldType);\n            if (index >= 0) {\n                newValues = getField(index).addWrapPartial(this, index, newValues,\n                        FieldUtils.safeMultiply(period.getValue(i), scalar));\n            }\n        }\n        return new TimeOfDay(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this time with the specified period added,\n     * wrapping to what would be a new day if required.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * Fields in the period that aren't present in the partial are ignored.\n     * <p>\n     * This method is typically used to add multiple copies of complex\n     * period instances. Adding one field is best achieved using methods\n     * like {@link #withFieldAdded(DurationFieldType, int)}\n     * or {@link #plusHours(int)}.\n     * \n     * @param period  the period to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this instance with the period added\n     * @throws ArithmeticException if the new datetime exceeds the capacity\n     */"}}
{"code": {"body": "public TimeOfDay plus(ReadablePeriod period) {\n        return withPeriodAdded(period, 1);\n    }", "comment": "/**\n     * Returns a copy of this time with the specified period added,\n     * wrapping to what would be a new day if required.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to add complex period instances.\n     * Adding one field is best achieved using methods\n     * like {@link #plusHours(int)}.\n     * \n     * @param period  the duration to add to this one, null means zero\n     * @return a copy of this instance with the period added\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "public TimeOfDay plusHours(int hours) {\n        return withFieldAdded(DurationFieldType.hours(), hours);\n    }", "comment": "/**\n     * Returns a copy of this time plus the specified number of hours.\n     * <p>\n     * This time instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * TimeOfDay added = dt.plusHours(6);\n     * TimeOfDay added = dt.plus(Period.hours(6));\n     * TimeOfDay added = dt.withFieldAdded(DurationFieldType.hours(), 6);\n     * </pre>\n     *\n     * @param hours  the amount of hours to add, may be negative\n     * @return the new time plus the increased hours\n     * @since 1.1\n     */"}}
{"code": {"body": "public TimeOfDay plusMinutes(int minutes) {\n        return withFieldAdded(DurationFieldType.minutes(), minutes);\n    }", "comment": "/**\n     * Returns a copy of this time plus the specified number of minutes.\n     * <p>\n     * This time instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * TimeOfDay added = dt.plusMinutes(6);\n     * TimeOfDay added = dt.plus(Period.minutes(6));\n     * TimeOfDay added = dt.withFieldAdded(DurationFieldType.minutes(), 6);\n     * </pre>\n     *\n     * @param minutes  the amount of minutes to add, may be negative\n     * @return the new time plus the increased minutes\n     * @since 1.1\n     */"}}
{"code": {"body": "public TimeOfDay plusSeconds(int seconds) {\n        return withFieldAdded(DurationFieldType.seconds(), seconds);\n    }", "comment": "/**\n     * Returns a copy of this time plus the specified number of seconds.\n     * <p>\n     * This time instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * TimeOfDay added = dt.plusSeconds(6);\n     * TimeOfDay added = dt.plus(Period.seconds(6));\n     * TimeOfDay added = dt.withFieldAdded(DurationFieldType.seconds(), 6);\n     * </pre>\n     *\n     * @param seconds  the amount of seconds to add, may be negative\n     * @return the new time plus the increased seconds\n     * @since 1.1\n     */"}}
{"code": {"body": "public TimeOfDay plusMillis(int millis) {\n        return withFieldAdded(DurationFieldType.millis(), millis);\n    }", "comment": "/**\n     * Returns a copy of this time plus the specified number of millis.\n     * <p>\n     * This time instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * TimeOfDay added = dt.plusMillis(6);\n     * TimeOfDay added = dt.plus(Period.millis(6));\n     * TimeOfDay added = dt.withFieldAdded(DurationFieldType.millis(), 6);\n     * </pre>\n     *\n     * @param millis  the amount of millis to add, may be negative\n     * @return the new time plus the increased millis\n     * @since 1.1\n     */"}}
{"code": {"body": "public TimeOfDay minus(ReadablePeriod period) {\n        return withPeriodAdded(period, -1);\n    }", "comment": "/**\n     * Returns a copy of this time with the specified period taken away,\n     * wrapping to what would be a new day if required.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to subtract complex period instances.\n     * Subtracting one field is best achieved using methods\n     * like {@link #minusHours(int)}.\n     * \n     * @param period  the period to reduce this instant by\n     * @return a copy of this instance with the period taken away\n     * @throws ArithmeticException if the new time exceeds capacity\n     */"}}
{"code": {"body": "public TimeOfDay minusHours(int hours) {\n        return withFieldAdded(DurationFieldType.hours(), FieldUtils.safeNegate(hours));\n    }", "comment": "/**\n     * Returns a copy of this time minus the specified number of hours.\n     * <p>\n     * This time instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * TimeOfDay subtracted = dt.minusHours(6);\n     * TimeOfDay subtracted = dt.minus(Period.hours(6));\n     * TimeOfDay subtracted = dt.withFieldAdded(DurationFieldType.hours(), -6);\n     * </pre>\n     *\n     * @param hours  the amount of hours to subtract, may be negative\n     * @return the new time minus the increased hours\n     * @since 1.1\n     */"}}
{"code": {"body": "public TimeOfDay minusMinutes(int minutes) {\n        return withFieldAdded(DurationFieldType.minutes(), FieldUtils.safeNegate(minutes));\n    }", "comment": "/**\n     * Returns a copy of this time minus the specified number of minutes.\n     * <p>\n     * This time instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * TimeOfDay subtracted = dt.minusMinutes(6);\n     * TimeOfDay subtracted = dt.minus(Period.minutes(6));\n     * TimeOfDay subtracted = dt.withFieldAdded(DurationFieldType.minutes(), -6);\n     * </pre>\n     *\n     * @param minutes  the amount of minutes to subtract, may be negative\n     * @return the new time minus the increased minutes\n     * @since 1.1\n     */"}}
{"code": {"body": "public TimeOfDay minusSeconds(int seconds) {\n        return withFieldAdded(DurationFieldType.seconds(), FieldUtils.safeNegate(seconds));\n    }", "comment": "/**\n     * Returns a copy of this time minus the specified number of seconds.\n     * <p>\n     * This time instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * TimeOfDay subtracted = dt.minusSeconds(6);\n     * TimeOfDay subtracted = dt.minus(Period.seconds(6));\n     * TimeOfDay subtracted = dt.withFieldAdded(DurationFieldType.seconds(), -6);\n     * </pre>\n     *\n     * @param seconds  the amount of seconds to subtract, may be negative\n     * @return the new time minus the increased seconds\n     * @since 1.1\n     */"}}
{"code": {"body": "public TimeOfDay minusMillis(int millis) {\n        return withFieldAdded(DurationFieldType.millis(), FieldUtils.safeNegate(millis));\n    }", "comment": "/**\n     * Returns a copy of this time minus the specified number of millis.\n     * <p>\n     * This time instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * TimeOfDay subtracted = dt.minusMillis(6);\n     * TimeOfDay subtracted = dt.minus(Period.millis(6));\n     * TimeOfDay subtracted = dt.withFieldAdded(DurationFieldType.millis(), -6);\n     * </pre>\n     *\n     * @param millis  the amount of millis to subtract, may be negative\n     * @return the new time minus the increased millis\n     * @since 1.1\n     */"}}
{"code": {"body": "public TimeOfDay withHourOfDay(int hour) {\n        int[] newValues = getValues();\n        newValues = getChronology().hourOfDay().set(this, HOUR_OF_DAY, newValues, hour);\n        return new TimeOfDay(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this time with the hour of day field updated.\n     * <p>\n     * TimeOfDay is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * hour of day changed.\n     *\n     * @param hour  the hour of day to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "public TimeOfDay withMinuteOfHour(int minute) {\n        int[] newValues = getValues();\n        newValues = getChronology().minuteOfHour().set(this, MINUTE_OF_HOUR, newValues, minute);\n        return new TimeOfDay(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this time with the minute of hour field updated.\n     * <p>\n     * TimeOfDay is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * minute of hour changed.\n     *\n     * @param minute  the minute of hour to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "public TimeOfDay withSecondOfMinute(int second) {\n        int[] newValues = getValues();\n        newValues = getChronology().secondOfMinute().set(this, SECOND_OF_MINUTE, newValues, second);\n        return new TimeOfDay(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this time with the second of minute field updated.\n     * <p>\n     * TimeOfDay is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * second of minute changed.\n     *\n     * @param second  the second of minute to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "public TimeOfDay withMillisOfSecond(int millis) {\n        int[] newValues = getValues();\n        newValues = getChronology().millisOfSecond().set(this, MILLIS_OF_SECOND, newValues, millis);\n        return new TimeOfDay(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this time with the millis of second field updated.\n     * <p>\n     * TimeOfDay is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * millis of second changed.\n     *\n     * @param millis  the millis of second to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "public TimeOfDay getTimeOfDay() {\n            return iTimeOfDay;\n        }", "comment": "/**\n         * Gets the partial that this property belongs to.\n         * \n         * @return the partial\n         */"}}
{"code": {"body": "public TimeOfDay addToCopy(int valueToAdd) {\n            int[] newValues = iTimeOfDay.getValues();\n            newValues = getField().addWrapPartial(iTimeOfDay, iFieldIndex, newValues, valueToAdd);\n            return new TimeOfDay(iTimeOfDay, newValues);\n        }", "comment": "/**\n         * Adds to the value of this field in a copy of this TimeOfDay,\n         * wrapping to what would be the next day if necessary.\n         * <p>\n         * The value will be added to this field. If the value is too large to be\n         * added solely to this field then it will affect larger fields.\n         * Smaller fields are unaffected.\n         * <p>\n         * If the result would be too large, beyond 23:59:59:999, then the\n         * calculation wraps to 00:00:00.000. For the alternate strict behaviour\n         * with no wrapping see {@link #addNoWrapToCopy(int)}.\n         * <p>\n         * The TimeOfDay attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param valueToAdd  the value to add to the field in the copy\n         * @return a copy of the TimeOfDay with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "public TimeOfDay addNoWrapToCopy(int valueToAdd) {\n            int[] newValues = iTimeOfDay.getValues();\n            newValues = getField().add(iTimeOfDay, iFieldIndex, newValues, valueToAdd);\n            return new TimeOfDay(iTimeOfDay, newValues);\n        }", "comment": "/**\n         * Adds to the value of this field in a copy of this TimeOfDay,\n         * throwing an Exception if the bounds are exceeded.\n         * <p>\n         * The value will be added to this field. If the value is too large to be\n         * added solely to this field then it will affect larger fields.\n         * Smaller fields are unaffected.\n         * <p>\n         * If the result would be too large (beyond 23:59:59:999) or too\n         * small (less than 00:00:00.000) then an Execption is thrown.\n         * For the alternate behaviour which wraps to the next 'day',\n         * see {@link #addToCopy(int)}.\n         * <p>\n         * The TimeOfDay attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param valueToAdd  the value to add to the field in the copy\n         * @return a copy of the TimeOfDay with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "public TimeOfDay addWrapFieldToCopy(int valueToAdd) {\n            int[] newValues = iTimeOfDay.getValues();\n            newValues = getField().addWrapField(iTimeOfDay, iFieldIndex, newValues, valueToAdd);\n            return new TimeOfDay(iTimeOfDay, newValues);\n        }", "comment": "/**\n         * Adds to the value of this field in a copy of this TimeOfDay wrapping\n         * within this field if the maximum value is reached.\n         * <p>\n         * The value will be added to this field. If the value is too large to be\n         * added solely to this field then it wraps within this field.\n         * Other fields are unaffected.\n         * <p>\n         * For example,\n         * <code>12:59:37</code> addWrapField one minute returns <code>12:00:37</code>.\n         * <p>\n         * The TimeOfDay attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param valueToAdd  the value to add to the field in the copy\n         * @return a copy of the TimeOfDay with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "public TimeOfDay setCopy(int value) {\n            int[] newValues = iTimeOfDay.getValues();\n            newValues = getField().set(iTimeOfDay, iFieldIndex, newValues, value);\n            return new TimeOfDay(iTimeOfDay, newValues);\n        }", "comment": "/**\n         * Sets this field in a copy of the TimeOfDay.\n         * <p>\n         * The TimeOfDay attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param value  the value to set the field in the copy to\n         * @return a copy of the TimeOfDay with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "public TimeOfDay setCopy(String text, Locale locale) {\n            int[] newValues = iTimeOfDay.getValues();\n            newValues = getField().set(iTimeOfDay, iFieldIndex, newValues, text, locale);\n            return new TimeOfDay(iTimeOfDay, newValues);\n        }", "comment": "/**\n         * Sets this field in a copy of the TimeOfDay to a parsed text value.\n         * <p>\n         * The TimeOfDay attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param text  the text value to set\n         * @param locale  optional locale to use for selecting a text symbol\n         * @return a copy of the TimeOfDay with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */"}}
{"code": {"body": "public TimeOfDay setCopy(String text) {\n            return setCopy(text, null);\n        }", "comment": "/**\n         * Sets this field in a copy of the TimeOfDay to a parsed text value.\n         * <p>\n         * The TimeOfDay attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param text  the text value to set\n         * @return a copy of the TimeOfDay with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */"}}
{"code": {"body": "public TimeOfDay withMaximumValue() {\n            return setCopy(getMaximumValue());\n        }", "comment": "/**\n         * Returns a new TimeOfDay with this field set to the maximum value\n         * for this field.\n         * <p>\n         * The TimeOfDay attached to this property is unchanged by this call.\n         *\n         * @return a copy of the TimeOfDay with this field set to its maximum\n         * @since 1.2\n         */"}}
{"code": {"body": "public TimeOfDay withMinimumValue() {\n            return setCopy(getMinimumValue());\n        }", "comment": "/**\n         * Returns a new TimeOfDay with this field set to the minimum value\n         * for this field.\n         * <p>\n         * The TimeOfDay attached to this property is unchanged by this call.\n         *\n         * @return a copy of the TimeOfDay with this field set to its minimum\n         * @since 1.2\n         */"}}
{"code": {"body": "    public static TimeOfDay fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        return new TimeOfDay(\n            calendar.get(Calendar.HOUR_OF_DAY),\n            calendar.get(Calendar.MINUTE),\n            calendar.get(Calendar.SECOND),\n            calendar.get(Calendar.MILLISECOND)\n        );\n    }", "comment": "/**\n     * Constructs a TimeOfDay from a <code>java.util.Calendar</code>\n     * using exactly the same field values avoiding any time zone effects.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the TimeOfDay.\n     * This is useful to ensure that the field values are the same in the\n     * created TimeOfDay no matter what the time zone is. For example, if\n     * the Calendar states that the time is 04:29, then the created TimeOfDay\n     * will always have the time 04:29 irrespective of time zone issues.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a TimeOfDay with ISO chronology.\n     *\n     * @param calendar  the Calendar to extract fields from\n     * @return the created TimeOfDay\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the time is invalid for the ISO chronology\n     * @since 1.2\n     */"}}
{"code": {"body": "    public static TimeOfDay fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        return new TimeOfDay(\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            (((int) (date.getTime() % 1000)) + 1000) % 1000\n        );\n    }", "comment": "/**\n     * Constructs a TimeOfDay from a <code>java.util.Date</code>\n     * using exactly the same field values avoiding any time zone effects.\n     * <p>\n     * Each field is queried from the Date and assigned to the TimeOfDay.\n     * This is useful to ensure that the field values are the same in the\n     * created TimeOfDay no matter what the time zone is. For example, if\n     * the Calendar states that the time is 04:29, then the created TimeOfDay\n     * will always have the time 04:29 irrespective of time zone issues.\n     * <p>\n     * This factory method always creates a TimeOfDay with ISO chronology.\n     *\n     * @param date  the Date to extract fields from\n     * @return the created TimeOfDay\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     * @since 1.2\n     */"}}
{"code": {"body": "    public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono) {\n        chrono = DateTimeUtils.getChronology(chrono);\n        chrono = chrono.withUTC();\n        return new TimeOfDay(millisOfDay, chrono);\n    }", "comment": "/**\n     * Constructs a TimeOfDay from the specified millis of day using the\n     * specified chronology.\n     * <p>\n     * The millisOfDay value may exceed the number of millis in one day,\n     * but additional days will be ignored.\n     * This method uses the UTC time zone internally.\n     *\n     * @param millisOfDay  the number of milliseconds into a day to convert\n     * @param chrono  the chronology, null means ISO chronology\n     */"}}
{"code": {"body": "    public int size() {\n        return 4;\n    }", "comment": "/**\n     * Gets the number of fields in this partial.\n     * \n     * @return the field count\n     */"}}
{"code": {"body": "        public DateTimeField getField() {\n            return iTimeOfDay.getField(iFieldIndex);\n        }", "comment": "/**\n         * Gets the field that this property uses.\n         * \n         * @return the field\n         */"}}
{"code": {"body": "    public DateTimeFieldType getFieldType(int index) {\n        return FIELD_TYPES[index];\n    }", "comment": "/**\n     * Gets the field type at the specified index.\n     *\n     * @param index  the index to retrieve\n     * @return the field at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */"}}
{"code": {"body": "    public DateTimeFieldType[] getFieldTypes() {\n        return (DateTimeFieldType[]) FIELD_TYPES.clone();\n    }", "comment": "/**\n     * Gets an array of the field type of each of the fields that this partial supports.\n     * <p>\n     * The fields are returned largest to smallest, Hour, Minute, Second, Millis.\n     *\n     * @return the array of field types (cloned), largest to smallest\n     */"}}
{"code": {"body": "    public TimeOfDay withChronologyRetainFields(Chronology newChronology) {\n        newChronology = DateTimeUtils.getChronology(newChronology);\n        newChronology = newChronology.withUTC();\n        if (newChronology == getChronology()) {\n            return this;\n        } else {\n            TimeOfDay newTimeOfDay = new TimeOfDay(this, newChronology);\n            newChronology.validate(newTimeOfDay, getValues());\n            return newTimeOfDay;\n        }\n    }", "comment": "/**\n     * Returns a copy of this time with the specified chronology.\n     * This instance is immutable and unaffected by this method call.\n     * <p>\n     * This method retains the values of the fields, thus the result will\n     * typically refer to a different instant.\n     * <p>\n     * The time zone of the specified chronology is ignored, as TimeOfDay\n     * operates without a time zone.\n     *\n     * @param newChronology  the new chronology, null means ISO\n     * @return a copy of this datetime with a different chronology\n     * @throws IllegalArgumentException if the values are invalid for the new chronology\n     */"}}
{"code": {"body": "    public TimeOfDay withField(DateTimeFieldType fieldType, int value) {\n        int index = indexOfSupported(fieldType);\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new TimeOfDay(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this time with the specified field set to a new value.\n     * <p>\n     * For example, if the field type is <code>minuteOfHour</code> then the day\n     * would be changed in the returned instance.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * TimeOfDay updated = tod.withField(DateTimeFieldType.minuteOfHour(), 6);\n     * TimeOfDay updated = tod.minuteOfHour().setCopy(6);\n     * TimeOfDay updated = tod.property(DateTimeFieldType.minuteOfHour()).setCopy(6);\n     * </pre>\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this instance with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     */"}}
{"code": {"body": "    public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount) {\n        int index = indexOfSupported(fieldType);\n        if (amount == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).addWrapPartial(this, index, newValues, amount);\n        return new TimeOfDay(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this time with the value of the specified field increased,\n     * wrapping to what would be a new day if required.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * TimeOfDay added = tod.withFieldAdded(DurationFieldType.minutes(), 6);\n     * TimeOfDay added = tod.plusMinutes(6);\n     * TimeOfDay added = tod.minuteOfHour().addToCopy(6);\n     * </pre>\n     * \n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this instance with the field updated\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the new datetime exceeds the capacity\n     */"}}
{"code": {"body": "    public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar) {\n        if (period == null || scalar == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        for (int i = 0; i < period.size(); i++) {\n            DurationFieldType fieldType = period.getFieldType(i);\n            int index = indexOf(fieldType);\n            if (index >= 0) {\n                newValues = getField(index).addWrapPartial(this, index, newValues,\n                        FieldUtils.safeMultiply(period.getValue(i), scalar));\n            }\n        }\n        return new TimeOfDay(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this time with the specified period added,\n     * wrapping to what would be a new day if required.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * Fields in the period that aren't present in the partial are ignored.\n     * <p>\n     * This method is typically used to add multiple copies of complex\n     * period instances. Adding one field is best achieved using methods\n     * like {@link #withFieldAdded(DurationFieldType, int)}\n     * or {@link #plusHours(int)}.\n     * \n     * @param period  the period to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this instance with the period added\n     * @throws ArithmeticException if the new datetime exceeds the capacity\n     */"}}
{"code": {"body": "    public TimeOfDay plus(ReadablePeriod period) {\n        return withPeriodAdded(period, 1);\n    }", "comment": "/**\n     * Returns a copy of this time with the specified period added,\n     * wrapping to what would be a new day if required.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to add complex period instances.\n     * Adding one field is best achieved using methods\n     * like {@link #plusHours(int)}.\n     * \n     * @param period  the duration to add to this one, null means zero\n     * @return a copy of this instance with the period added\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "    public TimeOfDay plusHours(int hours) {\n        return withFieldAdded(DurationFieldType.hours(), hours);\n    }", "comment": "/**\n     * Returns a copy of this time plus the specified number of hours.\n     * <p>\n     * This time instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * TimeOfDay added = dt.plusHours(6);\n     * TimeOfDay added = dt.plus(Period.hours(6));\n     * TimeOfDay added = dt.withFieldAdded(DurationFieldType.hours(), 6);\n     * </pre>\n     *\n     * @param hours  the amount of hours to add, may be negative\n     * @return the new time plus the increased hours\n     * @since 1.1\n     */"}}
{"code": {"body": "    public TimeOfDay plusMinutes(int minutes) {\n        return withFieldAdded(DurationFieldType.minutes(), minutes);\n    }", "comment": "/**\n     * Returns a copy of this time plus the specified number of minutes.\n     * <p>\n     * This time instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * TimeOfDay added = dt.plusMinutes(6);\n     * TimeOfDay added = dt.plus(Period.minutes(6));\n     * TimeOfDay added = dt.withFieldAdded(DurationFieldType.minutes(), 6);\n     * </pre>\n     *\n     * @param minutes  the amount of minutes to add, may be negative\n     * @return the new time plus the increased minutes\n     * @since 1.1\n     */"}}
{"code": {"body": "    public TimeOfDay plusSeconds(int seconds) {\n        return withFieldAdded(DurationFieldType.seconds(), seconds);\n    }", "comment": "/**\n     * Returns a copy of this time plus the specified number of seconds.\n     * <p>\n     * This time instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * TimeOfDay added = dt.plusSeconds(6);\n     * TimeOfDay added = dt.plus(Period.seconds(6));\n     * TimeOfDay added = dt.withFieldAdded(DurationFieldType.seconds(), 6);\n     * </pre>\n     *\n     * @param seconds  the amount of seconds to add, may be negative\n     * @return the new time plus the increased seconds\n     * @since 1.1\n     */"}}
{"code": {"body": "    public TimeOfDay plusMillis(int millis) {\n        return withFieldAdded(DurationFieldType.millis(), millis);\n    }", "comment": "/**\n     * Returns a copy of this time plus the specified number of millis.\n     * <p>\n     * This time instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * TimeOfDay added = dt.plusMillis(6);\n     * TimeOfDay added = dt.plus(Period.millis(6));\n     * TimeOfDay added = dt.withFieldAdded(DurationFieldType.millis(), 6);\n     * </pre>\n     *\n     * @param millis  the amount of millis to add, may be negative\n     * @return the new time plus the increased millis\n     * @since 1.1\n     */"}}
{"code": {"body": "    public TimeOfDay minus(ReadablePeriod period) {\n        return withPeriodAdded(period, -1);\n    }", "comment": "/**\n     * Returns a copy of this time with the specified period taken away,\n     * wrapping to what would be a new day if required.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to subtract complex period instances.\n     * Subtracting one field is best achieved using methods\n     * like {@link #minusHours(int)}.\n     * \n     * @param period  the period to reduce this instant by\n     * @return a copy of this instance with the period taken away\n     * @throws ArithmeticException if the new time exceeds capacity\n     */"}}
{"code": {"body": "    public TimeOfDay minusHours(int hours) {\n        return withFieldAdded(DurationFieldType.hours(), FieldUtils.safeNegate(hours));\n    }", "comment": "/**\n     * Returns a copy of this time minus the specified number of hours.\n     * <p>\n     * This time instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * TimeOfDay subtracted = dt.minusHours(6);\n     * TimeOfDay subtracted = dt.minus(Period.hours(6));\n     * TimeOfDay subtracted = dt.withFieldAdded(DurationFieldType.hours(), -6);\n     * </pre>\n     *\n     * @param hours  the amount of hours to subtract, may be negative\n     * @return the new time minus the increased hours\n     * @since 1.1\n     */"}}
{"code": {"body": "    public TimeOfDay minusMinutes(int minutes) {\n        return withFieldAdded(DurationFieldType.minutes(), FieldUtils.safeNegate(minutes));\n    }", "comment": "/**\n     * Returns a copy of this time minus the specified number of minutes.\n     * <p>\n     * This time instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * TimeOfDay subtracted = dt.minusMinutes(6);\n     * TimeOfDay subtracted = dt.minus(Period.minutes(6));\n     * TimeOfDay subtracted = dt.withFieldAdded(DurationFieldType.minutes(), -6);\n     * </pre>\n     *\n     * @param minutes  the amount of minutes to subtract, may be negative\n     * @return the new time minus the increased minutes\n     * @since 1.1\n     */"}}
{"code": {"body": "    public TimeOfDay minusSeconds(int seconds) {\n        return withFieldAdded(DurationFieldType.seconds(), FieldUtils.safeNegate(seconds));\n    }", "comment": "/**\n     * Returns a copy of this time minus the specified number of seconds.\n     * <p>\n     * This time instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * TimeOfDay subtracted = dt.minusSeconds(6);\n     * TimeOfDay subtracted = dt.minus(Period.seconds(6));\n     * TimeOfDay subtracted = dt.withFieldAdded(DurationFieldType.seconds(), -6);\n     * </pre>\n     *\n     * @param seconds  the amount of seconds to subtract, may be negative\n     * @return the new time minus the increased seconds\n     * @since 1.1\n     */"}}
{"code": {"body": "    public TimeOfDay minusMillis(int millis) {\n        return withFieldAdded(DurationFieldType.millis(), FieldUtils.safeNegate(millis));\n    }", "comment": "/**\n     * Returns a copy of this time minus the specified number of millis.\n     * <p>\n     * This time instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * TimeOfDay subtracted = dt.minusMillis(6);\n     * TimeOfDay subtracted = dt.minus(Period.millis(6));\n     * TimeOfDay subtracted = dt.withFieldAdded(DurationFieldType.millis(), -6);\n     * </pre>\n     *\n     * @param millis  the amount of millis to subtract, may be negative\n     * @return the new time minus the increased millis\n     * @since 1.1\n     */"}}
{"code": {"body": "    public Property property(DateTimeFieldType type) {\n        return new Property(this, indexOfSupported(type));\n    }", "comment": "/**\n     * Gets the property object for the specified type, which contains\n     * many useful methods.\n     *\n     * @param type  the field type to get the property for\n     * @return the property object\n     * @throws IllegalArgumentException if the field is null or unsupported\n     */"}}
{"code": {"body": "    public LocalTime toLocalTime() {\n        return new LocalTime(getHourOfDay(), getMinuteOfHour(),\n                getSecondOfMinute(), getMillisOfSecond(), getChronology());\n    }", "comment": "/**\n     * Converts this object to a LocalTime with the same time and chronology.\n     *\n     * @return a LocalTime with the same time and chronology\n     * @since 1.3\n     */"}}
{"code": {"body": "    public DateTime toDateTimeToday(DateTimeZone zone) {\n        Chronology chrono = getChronology().withZone(zone);\n        long instantMillis = DateTimeUtils.currentTimeMillis();\n        long resolved = chrono.set(this, instantMillis);\n        return new DateTime(resolved, chrono);\n    }", "comment": "/**\n     * Converts this partial to a full datetime using the specified time zone\n     * setting the time fields from this instance and the date fields from\n     * the current time.\n     * <p>\n     * This method uses the chronology from this instance plus the time zone\n     * specified.\n     *\n     * @param zone  the zone to use, null means default\n     * @return this date as a datetime with the time as the current time\n     */"}}
{"code": {"body": "    public int getHourOfDay() {\n        return getValue(HOUR_OF_DAY);\n    }", "comment": "/**\n     * Get the hour of day (0-23) field value.\n     *\n     * @return the hour of day\n     */"}}
{"code": {"body": "    public int getMinuteOfHour() {\n        return getValue(MINUTE_OF_HOUR);\n    }", "comment": "/**\n     * Get the minute of hour field value.\n     *\n     * @return the minute of hour\n     */"}}
{"code": {"body": "    public int getSecondOfMinute() {\n        return getValue(SECOND_OF_MINUTE);\n    }", "comment": "/**\n     * Get the second of minute field value.\n     *\n     * @return the second of minute\n     */"}}
{"code": {"body": "    public int getMillisOfSecond() {\n        return getValue(MILLIS_OF_SECOND);\n    }", "comment": "/**\n     * Get the millis of second field value.\n     *\n     * @return the millis of second\n     */"}}
{"code": {"body": "    public TimeOfDay withHourOfDay(int hour) {\n        int[] newValues = getValues();\n        newValues = getChronology().hourOfDay().set(this, HOUR_OF_DAY, newValues, hour);\n        return new TimeOfDay(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this time with the hour of day field updated.\n     * <p>\n     * TimeOfDay is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * hour of day changed.\n     *\n     * @param hour  the hour of day to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "    public TimeOfDay withMinuteOfHour(int minute) {\n        int[] newValues = getValues();\n        newValues = getChronology().minuteOfHour().set(this, MINUTE_OF_HOUR, newValues, minute);\n        return new TimeOfDay(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this time with the minute of hour field updated.\n     * <p>\n     * TimeOfDay is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * minute of hour changed.\n     *\n     * @param minute  the minute of hour to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "    public TimeOfDay withSecondOfMinute(int second) {\n        int[] newValues = getValues();\n        newValues = getChronology().secondOfMinute().set(this, SECOND_OF_MINUTE, newValues, second);\n        return new TimeOfDay(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this time with the second of minute field updated.\n     * <p>\n     * TimeOfDay is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * second of minute changed.\n     *\n     * @param second  the second of minute to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "    public TimeOfDay withMillisOfSecond(int millis) {\n        int[] newValues = getValues();\n        newValues = getChronology().millisOfSecond().set(this, MILLIS_OF_SECOND, newValues, millis);\n        return new TimeOfDay(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this time with the millis of second field updated.\n     * <p>\n     * TimeOfDay is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * millis of second changed.\n     *\n     * @param millis  the millis of second to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "    public Property hourOfDay() {\n        return new Property(this, HOUR_OF_DAY);\n    }", "comment": "/**\n     * Get the hour of day field property which provides access to advanced functionality.\n     * \n     * @return the hour of day property\n     */"}}
{"code": {"body": "    public Property minuteOfHour() {\n        return new Property(this, MINUTE_OF_HOUR);\n    }", "comment": "/**\n     * Get the minute of hour field property which provides access to advanced functionality.\n     * \n     * @return the minute of hour property\n     */"}}
{"code": {"body": "    public Property secondOfMinute() {\n        return new Property(this, SECOND_OF_MINUTE);\n    }", "comment": "/**\n     * Get the second of minute field property which provides access to advanced functionality.\n     * \n     * @return the second of minute property\n     */"}}
{"code": {"body": "    public Property millisOfSecond() {\n        return new Property(this, MILLIS_OF_SECOND);\n    }", "comment": "/**\n     * Get the millis of second property which provides access to advanced functionality.\n     * \n     * @return the millis of second property\n     */"}}
{"code": {"body": "    public String toString() {\n        return ISODateTimeFormat.tTime().print(this);\n    }", "comment": "/**\n     * Output the time in the ISO8601 format THH:mm:ss.SSS.\n     * \n     * @return ISO8601 formatted string\n     */"}}
{"code": {"body": "        protected ReadablePartial getReadablePartial() {\n            return iTimeOfDay;\n        }", "comment": "/**\n         * Gets the partial that this property belongs to.\n         * \n         * @return the partial\n         */"}}
{"code": {"body": "        public TimeOfDay getTimeOfDay() {\n            return iTimeOfDay;\n        }", "comment": "/**\n         * Gets the partial that this property belongs to.\n         * \n         * @return the partial\n         */"}}
{"code": {"body": "        public int get() {\n            return iTimeOfDay.getValue(iFieldIndex);\n        }", "comment": "/**\n         * Gets the value of this field.\n         * \n         * @return the field value\n         */"}}
{"code": {"body": "        public TimeOfDay addToCopy(int valueToAdd) {\n            int[] newValues = iTimeOfDay.getValues();\n            newValues = getField().addWrapPartial(iTimeOfDay, iFieldIndex, newValues, valueToAdd);\n            return new TimeOfDay(iTimeOfDay, newValues);\n        }", "comment": "/**\n         * Adds to the value of this field in a copy of this TimeOfDay,\n         * wrapping to what would be the next day if necessary.\n         * <p>\n         * The value will be added to this field. If the value is too large to be\n         * added solely to this field then it will affect larger fields.\n         * Smaller fields are unaffected.\n         * <p>\n         * If the result would be too large, beyond 23:59:59:999, then the\n         * calculation wraps to 00:00:00.000. For the alternate strict behaviour\n         * with no wrapping see {@link #addNoWrapToCopy(int)}.\n         * <p>\n         * The TimeOfDay attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param valueToAdd  the value to add to the field in the copy\n         * @return a copy of the TimeOfDay with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "        public TimeOfDay addNoWrapToCopy(int valueToAdd) {\n            int[] newValues = iTimeOfDay.getValues();\n            newValues = getField().add(iTimeOfDay, iFieldIndex, newValues, valueToAdd);\n            return new TimeOfDay(iTimeOfDay, newValues);\n        }", "comment": "/**\n         * Adds to the value of this field in a copy of this TimeOfDay,\n         * throwing an Exception if the bounds are exceeded.\n         * <p>\n         * The value will be added to this field. If the value is too large to be\n         * added solely to this field then it will affect larger fields.\n         * Smaller fields are unaffected.\n         * <p>\n         * If the result would be too large (beyond 23:59:59:999) or too\n         * small (less than 00:00:00.000) then an Execption is thrown.\n         * For the alternate behaviour which wraps to the next 'day',\n         * see {@link #addToCopy(int)}.\n         * <p>\n         * The TimeOfDay attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param valueToAdd  the value to add to the field in the copy\n         * @return a copy of the TimeOfDay with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "        public TimeOfDay addWrapFieldToCopy(int valueToAdd) {\n            int[] newValues = iTimeOfDay.getValues();\n            newValues = getField().addWrapField(iTimeOfDay, iFieldIndex, newValues, valueToAdd);\n            return new TimeOfDay(iTimeOfDay, newValues);\n        }", "comment": "/**\n         * Adds to the value of this field in a copy of this TimeOfDay wrapping\n         * within this field if the maximum value is reached.\n         * <p>\n         * The value will be added to this field. If the value is too large to be\n         * added solely to this field then it wraps within this field.\n         * Other fields are unaffected.\n         * <p>\n         * For example,\n         * <code>12:59:37</code> addWrapField one minute returns <code>12:00:37</code>.\n         * <p>\n         * The TimeOfDay attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param valueToAdd  the value to add to the field in the copy\n         * @return a copy of the TimeOfDay with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "        public TimeOfDay setCopy(String text) {\n            return setCopy(text, null);\n        }", "comment": "/**\n         * Sets this field in a copy of the TimeOfDay to a parsed text value.\n         * <p>\n         * The TimeOfDay attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param text  the text value to set\n         * @return a copy of the TimeOfDay with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */"}}
{"code": {"body": "        public TimeOfDay withMaximumValue() {\n            return setCopy(getMaximumValue());\n        }", "comment": "/**\n         * Returns a new TimeOfDay with this field set to the maximum value\n         * for this field.\n         * <p>\n         * The TimeOfDay attached to this property is unchanged by this call.\n         *\n         * @return a copy of the TimeOfDay with this field set to its maximum\n         * @since 1.2\n         */"}}
{"code": {"body": "        public TimeOfDay withMinimumValue() {\n            return setCopy(getMinimumValue());\n        }", "comment": "/**\n         * Returns a new TimeOfDay with this field set to the minimum value\n         * for this field.\n         * <p>\n         * The TimeOfDay attached to this property is unchanged by this call.\n         *\n         * @return a copy of the TimeOfDay with this field set to its minimum\n         * @since 1.2\n         */"}}
{"code": {"body": "public Weeks plus(int weeks) {\n        if (weeks == 0) {\n            return this;\n        }\n        return Weeks.weeks(FieldUtils.safeAdd(getValue(), weeks));\n    }", "comment": "/**\n     * Returns a new instance with the specified number of weeks added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the amount of weeks to add, may be negative\n     * @return the new period plus the specified number of weeks\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "public Weeks plus(Weeks weeks) {\n        if (weeks == null) {\n            return this;\n        }\n        return plus(weeks.getValue());\n    }", "comment": "/**\n     * Returns a new instance with the specified number of weeks added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the amount of weeks to add, may be negative, null means zero\n     * @return the new period plus the specified number of weeks\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "public Weeks minus(int weeks) {\n        return plus(FieldUtils.safeNegate(weeks));\n    }", "comment": "/**\n     * Returns a new instance with the specified number of weeks taken away.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the amount of weeks to take away, may be negative\n     * @return the new period minus the specified number of weeks\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "public Weeks minus(Weeks weeks) {\n        if (weeks == null) {\n            return this;\n        }\n        return minus(weeks.getValue());\n    }", "comment": "/**\n     * Returns a new instance with the specified number of weeks taken away.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the amount of weeks to take away, may be negative, null means zero\n     * @return the new period minus the specified number of weeks\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "public Weeks multipliedBy(int scalar) {\n        return Weeks.weeks(FieldUtils.safeMultiply(getValue(), scalar));\n    }", "comment": "/**\n     * Returns a new instance with the weeks multiplied by the specified scalar.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param scalar  the amount to multiply by, may be negative\n     * @return the new period multiplied by the specified scalar\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "public Weeks dividedBy(int divisor) {\n        if (divisor == 1) {\n            return this;\n        }\n        return Weeks.weeks(getValue() / divisor);\n    }", "comment": "/**\n     * Returns a new instance with the weeks divided by the specified divisor.\n     * The calculation uses integer division, thus 3 divided by 2 is 1.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param divisor  the amount to divide by, may be negative\n     * @return the new period divided by the specified divisor\n     * @throws ArithmeticException if the divisor is zero\n     */"}}
{"code": {"body": "public Weeks negated() {\n        return Weeks.weeks(FieldUtils.safeNegate(getValue()));\n    }", "comment": "/**\n     * Returns a new instance with the weeks value negated.\n     *\n     * @return the new period with a negated value\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "    public static Weeks weeks(int weeks) {\n        switch (weeks) {\n            case 0:\n                return ZERO;\n            case 1:\n                return ONE;\n            case 2:\n                return TWO;\n            case 3:\n                return THREE;\n            case Integer.MAX_VALUE:\n                return MAX_VALUE;\n            case Integer.MIN_VALUE:\n                return MIN_VALUE;\n            default:\n                return new Weeks(weeks);\n        }\n    }", "comment": "/**\n     * Obtains an instance of <code>Weeks</code> that may be cached.\n     * <code>Weeks</code> is immutable, so instances can be cached and shared.\n     * This factory method provides access to shared instances.\n     *\n     * @param weeks  the number of weeks to obtain an instance for\n     * @return the instance of Weeks\n     */"}}
{"code": {"body": "    public static Weeks weeksBetween(ReadablePartial start, ReadablePartial end) {\n        if (start instanceof LocalDate && end instanceof LocalDate)   {\n            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n            int weeks = chrono.weeks().getDifference(\n                    ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n            return Weeks.weeks(weeks);\n        }\n        int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\n        return Weeks.weeks(amount);\n    }", "comment": "/**\n     * Creates a <code>Weeks</code> representing the number of whole weeks\n     * between the two specified partial datetimes.\n     * <p>\n     * The two partials must contain the same fields, for example you can specify\n     * two <code>LocalDate</code> objects.\n     *\n     * @param start  the start partial date, must not be null\n     * @param end  the end partial date, must not be null\n     * @return the period in weeks\n     * @throws IllegalArgumentException if the partials are null or invalid\n     */"}}
{"code": {"body": "    public static Weeks weeksIn(ReadableInterval interval) {\n        if (interval == null)   {\n            return Weeks.ZERO;\n        }\n        int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.weeks());\n        return Weeks.weeks(amount);\n    }", "comment": "/**\n     * Creates a <code>Weeks</code> representing the number of whole weeks\n     * in the specified interval.\n     *\n     * @param interval  the interval to extract weeks from, null returns zero\n     * @return the period in weeks\n     * @throws IllegalArgumentException if the partials are null or invalid\n     */"}}
{"code": {"body": "    public static Weeks standardWeeksIn(ReadablePeriod period) {\n        int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_WEEK);\n        return Weeks.weeks(amount);\n    }", "comment": "/**\n     * Creates a new <code>Weeks</code> representing the number of complete\n     * standard length weeks in the specified period.\n     * <p>\n     * This factory method converts all fields from the period to hours using standardised\n     * durations for each field. Only those fields which have a precise duration in\n     * the ISO UTC chronology can be converted.\n     * <ul>\n     * <li>One week consists of 7 days.\n     * <li>One day consists of 24 hours.\n     * <li>One hour consists of 60 minutes.\n     * <li>One minute consists of 60 weeks.\n     * <li>One second consists of 1000 milliseconds.\n     * </ul>\n     * Months and Years are imprecise and periods containing these values cannot be converted.\n     *\n     * @param period  the period to get the number of hours from, null returns zero\n     * @return the period in weeks\n     * @throws IllegalArgumentException if the period contains imprecise duration values\n     */"}}
{"code": {"body": "    private Object readResolve() {\n        return Weeks.weeks(getValue());\n    }", "comment": "/**\n     * Resolves singletons.\n     * \n     * @return the singleton instance\n     */"}}
{"code": {"body": "    public DurationFieldType getFieldType() {\n        return DurationFieldType.weeks();\n    }", "comment": "/**\n     * Gets the duration field type, which is <code>weeks</code>.\n     *\n     * @return the period type\n     */"}}
{"code": {"body": "    public PeriodType getPeriodType() {\n        return PeriodType.weeks();\n    }", "comment": "/**\n     * Gets the period type, which is <code>weeks</code>.\n     *\n     * @return the period type\n     */"}}
{"code": {"body": "    public Days toStandardDays() {\n        return Days.days(FieldUtils.safeMultiply(getValue(), DateTimeConstants.DAYS_PER_WEEK));\n    }", "comment": "/**\n     * Converts this period in weeks to a period in days assuming a\n     * 7 day week.\n     * <p>\n     * This method allows you to convert between different types of period.\n     * However to achieve this it makes the assumption that all weeks are\n     * 7 days long.\n     * This may not be true for some unusual chronologies. However, it is included\n     * as it is a useful operation for many applications and business rules.\n     * \n     * @return a period representing the number of days for this number of weeks\n     * @throws ArithmeticException if the number of days is too large to be represented\n     */"}}
{"code": {"body": "    public Hours toStandardHours() {\n        return Hours.hours(FieldUtils.safeMultiply(getValue(), DateTimeConstants.HOURS_PER_WEEK));\n    }", "comment": "/**\n     * Converts this period in weeks to a period in hours assuming a\n     * 7 day week and 24 hour day.\n     * <p>\n     * This method allows you to convert between different types of period.\n     * However to achieve this it makes the assumption that all weeks are\n     * 7 days long and all days are 24 hours long.\n     * This is not true when daylight savings is considered and may also not\n     * be true for some unusual chronologies. However, it is included\n     * as it is a useful operation for many applications and business rules.\n     * \n     * @return a period representing the number of hours for this number of weeks\n     * @throws ArithmeticException if the number of hours is too large to be represented\n     */"}}
{"code": {"body": "    public Minutes toStandardMinutes() {\n        return Minutes.minutes(FieldUtils.safeMultiply(getValue(), DateTimeConstants.MINUTES_PER_WEEK));\n    }", "comment": "/**\n     * Converts this period in weeks to a period in minutes assuming a\n     * 7 day week, 24 hour day and 60 minute hour.\n     * <p>\n     * This method allows you to convert between different types of period.\n     * However to achieve this it makes the assumption that all weeks are\n     * 7 days long, all days are 24 hours long and all hours are 60 minutes long.\n     * This is not true when daylight savings is considered and may also not\n     * be true for some unusual chronologies. However, it is included\n     * as it is a useful operation for many applications and business rules.\n     * \n     * @return a period representing the number of minutes for this number of weeks\n     * @throws ArithmeticException if the number of minutes is too large to be represented\n     */"}}
{"code": {"body": "    public Seconds toStandardSeconds() {\n        return Seconds.seconds(FieldUtils.safeMultiply(getValue(), DateTimeConstants.SECONDS_PER_WEEK));\n    }", "comment": "/**\n     * Converts this period in weeks to a period in seconds assuming a\n     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n     * <p>\n     * This method allows you to convert between different types of period.\n     * However to achieve this it makes the assumption that all weeks are\n     * 7 days long, all days are 24 hours long, all hours are 60 minutes long\n     * and all minutes are 60 seconds long.\n     * This is not true when daylight savings is considered and may also not\n     * be true for some unusual chronologies. However, it is included\n     * as it is a useful operation for many applications and business rules.\n     * \n     * @return a period representing the number of seconds for this number of weeks\n     * @throws ArithmeticException if the number of seconds is too large to be represented\n     */"}}
{"code": {"body": "    public Duration toStandardDuration() {\n        long weeks = getValue();  \n        return new Duration(weeks * DateTimeConstants.MILLIS_PER_WEEK);\n    }", "comment": "/**\n     * Converts this period in weeks to a duration in milliweeks assuming a\n     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n     * <p>\n     * This method allows you to convert from a period to a duration.\n     * However to achieve this it makes the assumption that all weeks are\n     * 7 days long, all days are 24 hours long, all hours are 60 minutes long\n     * and all minutes are 60 seconds long.\n     * This is not true when daylight savings time is considered, and may also\n     * not be true for some unusual chronologies. However, it is included as it\n     * is a useful operation for many applications and business rules.\n     * \n     * @return a duration equivalent to this number of weeks\n     */"}}
{"code": {"body": "    public int getWeeks() {\n        return getValue();\n    }", "comment": "/**\n     * Gets the number of weeks that this period represents.\n     *\n     * @return the number of weeks in the period\n     */"}}
{"code": {"body": "    public Weeks plus(Weeks weeks) {\n        if (weeks == null) {\n            return this;\n        }\n        return plus(weeks.getValue());\n    }", "comment": "/**\n     * Returns a new instance with the specified number of weeks added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the amount of weeks to add, may be negative, null means zero\n     * @return the new period plus the specified number of weeks\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "    public Weeks minus(Weeks weeks) {\n        if (weeks == null) {\n            return this;\n        }\n        return minus(weeks.getValue());\n    }", "comment": "/**\n     * Returns a new instance with the specified number of weeks taken away.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the amount of weeks to take away, may be negative, null means zero\n     * @return the new period minus the specified number of weeks\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "    public Weeks multipliedBy(int scalar) {\n        return Weeks.weeks(FieldUtils.safeMultiply(getValue(), scalar));\n    }", "comment": "/**\n     * Returns a new instance with the weeks multiplied by the specified scalar.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param scalar  the amount to multiply by, may be negative\n     * @return the new period multiplied by the specified scalar\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "    public Weeks dividedBy(int divisor) {\n        if (divisor == 1) {\n            return this;\n        }\n        return Weeks.weeks(getValue() / divisor);\n    }", "comment": "/**\n     * Returns a new instance with the weeks divided by the specified divisor.\n     * The calculation uses integer division, thus 3 divided by 2 is 1.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param divisor  the amount to divide by, may be negative\n     * @return the new period divided by the specified divisor\n     * @throws ArithmeticException if the divisor is zero\n     */"}}
{"code": {"body": "    public Weeks negated() {\n        return Weeks.weeks(FieldUtils.safeNegate(getValue()));\n    }", "comment": "/**\n     * Returns a new instance with the weeks value negated.\n     *\n     * @return the new period with a negated value\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "    public boolean isGreaterThan(Weeks other) {\n        if (other == null) {\n            return getValue() > 0;\n        }\n        return getValue() > other.getValue();\n    }", "comment": "/**\n     * Is this weeks instance greater than the specified number of weeks.\n     *\n     * @param other  the other period, null means zero\n     * @return true if this weeks instance is greater than the specified one\n     */"}}
{"code": {"body": "    public boolean isLessThan(Weeks other) {\n        if (other == null) {\n            return getValue() < 0;\n        }\n        return getValue() < other.getValue();\n    }", "comment": "/**\n     * Is this weeks instance less than the specified number of weeks.\n     *\n     * @param other  the other period, null means zero\n     * @return true if this weeks instance is less than the specified one\n     */"}}
{"code": {"body": "public YearMonth() {\n        super();\n    }", "comment": "/**\n     * Constructs a YearMonth with the current year-month, using ISOChronology in\n     * the default zone to extract the fields.\n     * <p>\n     * The constructor uses the default time zone, resulting in the local time\n     * being initialised. Once the constructor is complete, all further calculations\n     * are performed without reference to a time-zone (by switching to UTC).\n     * \n     * @see #now()\n     */"}}
{"code": {"body": "public YearMonth(DateTimeZone zone) {\n        super(ISOChronology.getInstance(zone));\n    }", "comment": "/**\n     * Constructs a YearMonth with the current year-month, using ISOChronology in\n     * the specified zone to extract the fields.\n     * <p>\n     * The constructor uses the specified time zone to obtain the current year-month.\n     * Once the constructor is complete, all further calculations\n     * are performed without reference to a time-zone (by switching to UTC).\n     * \n     * @param zone  the zone to use, null means default zone\n     * @see #now(DateTimeZone)\n     */"}}
{"code": {"body": "public YearMonth(Chronology chronology) {\n        super(chronology);\n    }", "comment": "/**\n     * Constructs a YearMonth with the current year-month, using the specified chronology\n     * and zone to extract the fields.\n     * <p>\n     * The constructor uses the time zone of the chronology specified.\n     * Once the constructor is complete, all further calculations are performed\n     * without reference to a time-zone (by switching to UTC).\n     *\n     * @param chronology  the chronology, null means ISOChronology in the default zone\n     * @see #now(Chronology)\n     */"}}
{"code": {"body": "public YearMonth(long instant) {\n        super(instant);\n    }", "comment": "/**\n     * Constructs a YearMonth extracting the partial fields from the specified\n     * milliseconds using the ISOChronology in the default zone.\n     * <p>\n     * The constructor uses the default time zone, resulting in the local time\n     * being initialised. Once the constructor is complete, all further calculations\n     * are performed without reference to a time-zone (by switching to UTC).\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     */"}}
{"code": {"body": "public YearMonth(long instant, Chronology chronology) {\n        super(instant, chronology);\n    }", "comment": "/**\n     * Constructs a YearMonth extracting the partial fields from the specified\n     * milliseconds using the chronology provided.\n     * <p>\n     * The constructor uses the time zone of the chronology specified.\n     * Once the constructor is complete, all further calculations are performed\n     * without reference to a time-zone (by switching to UTC).\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     * @param chronology  the chronology, null means ISOChronology in the default zone\n     */"}}
{"code": {"body": "public YearMonth(Object instant) {\n        super(instant, null, ISODateTimeFormat.localDateParser());\n    }", "comment": "/**\n     * Constructs a YearMonth from an Object that represents some form of time.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadableInstant, String, Calendar and Date.\n     * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.\n     * <p>\n     * The chronology used will be derived from the object, defaulting to ISO.\n     *\n     * @param instant  the date-time object, null means now\n     * @throws IllegalArgumentException if the instant is invalid\n     */"}}
{"code": {"body": "public YearMonth(Object instant, Chronology chronology) {\n        super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.localDateParser());\n    }", "comment": "/**\n     * Constructs a YearMonth from an Object that represents some form of time,\n     * using the specified chronology.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadableInstant, String, Calendar and Date.\n     * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.\n     * <p>\n     * The constructor uses the time zone of the chronology specified.\n     * Once the constructor is complete, all further calculations are performed\n     * without reference to a time-zone (by switching to UTC).\n     * The specified chronology overrides that of the object.\n     *\n     * @param instant  the date-time object, null means now\n     * @param chronology  the chronology, null means ISO default\n     * @throws IllegalArgumentException if the instant is invalid\n     */"}}
{"code": {"body": "public YearMonth(int year, int monthOfYear) {\n        this(year, monthOfYear, null);\n    }", "comment": "/**\n     * Constructs a YearMonth with specified year and month\n     * using <code>ISOChronology</code>.\n     * <p>\n     * The constructor uses the no time zone initialising the fields as provided.\n     * Once the constructor is complete, all further calculations\n     * are performed without reference to a time-zone (by switching to UTC).\n     *\n     * @param year  the year\n     * @param monthOfYear  the month of the year\n     */"}}
{"code": {"body": "public YearMonth(int year, int monthOfYear, Chronology chronology) {\n        super(new int[] {year, monthOfYear}, chronology);\n    }", "comment": "/**\n     * Constructs an instance set to the specified year and month\n     * using the specified chronology, whose zone is ignored.\n     * <p>\n     * If the chronology is null, <code>ISOChronology</code> is used.\n     * <p>\n     * The constructor uses the time zone of the chronology specified.\n     * Once the constructor is complete, all further calculations are performed\n     * without reference to a time-zone (by switching to UTC).\n     *\n     * @param year  the year\n     * @param monthOfYear  the month of the year\n     * @param chronology  the chronology, null means ISOChronology in the default zone\n     */"}}
{"code": {"body": "public YearMonth withChronologyRetainFields(Chronology newChronology) {\n        newChronology = DateTimeUtils.getChronology(newChronology);\n        newChronology = newChronology.withUTC();\n        if (newChronology == getChronology()) {\n            return this;\n        } else {\n            YearMonth newYearMonth = new YearMonth(this, newChronology);\n            newChronology.validate(newYearMonth, getValues());\n            return newYearMonth;\n        }\n    }", "comment": "/**\n     * Returns a copy of this year-month with the specified chronology.\n     * This instance is immutable and unaffected by this method call.\n     * <p>\n     * This method retains the values of the fields, thus the result will\n     * typically refer to a different instant.\n     * <p>\n     * The time zone of the specified chronology is ignored, as YearMonth\n     * operates without a time zone.\n     *\n     * @param newChronology  the new chronology, null means ISO\n     * @return a copy of this year-month with a different chronology, never null\n     * @throws IllegalArgumentException if the values are invalid for the new chronology\n     */"}}
{"code": {"body": "public YearMonth withField(DateTimeFieldType fieldType, int value) {\n        int index = indexOfSupported(fieldType);\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new YearMonth(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this year-month with the specified field set to a new value.\n     * <p>\n     * For example, if the field type is <code>monthOfYear</code> then the month\n     * would be changed in the returned instance.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * YearMonth updated = ym.withField(DateTimeFieldType.monthOfYear(), 6);\n     * YearMonth updated = ym.monthOfYear().setCopy(6);\n     * YearMonth updated = ym.property(DateTimeFieldType.monthOfYear()).setCopy(6);\n     * </pre>\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this instance with the field set, never null\n     * @throws IllegalArgumentException if the value is null or invalid\n     */"}}
{"code": {"body": "public YearMonth withFieldAdded(DurationFieldType fieldType, int amount) {\n        int index = indexOfSupported(fieldType);\n        if (amount == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).add(this, index, newValues, amount);\n        return new YearMonth(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this year-month with the value of the specified field increased.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * YearMonth added = ym.withFieldAdded(DurationFieldType.months(), 6);\n     * YearMonth added = ym.plusMonths(6);\n     * YearMonth added = ym.monthOfYear().addToCopy(6);\n     * </pre>\n     * \n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this instance with the field updated, never null\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the new date-time exceeds the capacity\n     */"}}
{"code": {"body": "public YearMonth withPeriodAdded(ReadablePeriod period, int scalar) {\n        if (period == null || scalar == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        for (int i = 0; i < period.size(); i++) {\n            DurationFieldType fieldType = period.getFieldType(i);\n            int index = indexOf(fieldType);\n            if (index >= 0) {\n                newValues = getField(index).add(this, index, newValues,\n                        FieldUtils.safeMultiply(period.getValue(i), scalar));\n            }\n        }\n        return new YearMonth(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this year-month with the specified period added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * Fields in the period that aren't present in the partial are ignored.\n     * <p>\n     * This method is typically used to add multiple copies of complex\n     * period instances. Adding one field is best achieved using methods\n     * like {@link #withFieldAdded(DurationFieldType, int)}\n     * or {@link #plusYears(int)}.\n     * \n     * @param period  the period to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this instance with the period added, never null\n     * @throws ArithmeticException if the new date-time exceeds the capacity\n     */"}}
{"code": {"body": "public YearMonth plus(ReadablePeriod period) {\n        return withPeriodAdded(period, 1);\n    }", "comment": "/**\n     * Returns a copy of this year-month with the specified period added.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to add complex period instances.\n     * Adding one field is best achieved using methods\n     * like {@link #plusYears(int)}.\n     * \n     * @param period  the duration to add to this one, null means zero\n     * @return a copy of this instance with the period added, never null\n     * @throws ArithmeticException if the new year-month exceeds the capacity\n     */"}}
{"code": {"body": "public YearMonth plusYears(int years) {\n        return withFieldAdded(DurationFieldType.years(), years);\n    }", "comment": "/**\n     * Returns a copy of this year-month plus the specified number of years.\n     * <p>\n     * This year-month instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * YearMonth added = ym.plusYears(6);\n     * YearMonth added = ym.plus(Period.years(6));\n     * YearMonth added = ym.withFieldAdded(DurationFieldType.years(), 6);\n     * </pre>\n     *\n     * @param years  the amount of years to add, may be negative\n     * @return the new year-month plus the increased years, never null\n     */"}}
{"code": {"body": "public YearMonth plusMonths(int months) {\n        return withFieldAdded(DurationFieldType.months(), months);\n    }", "comment": "/**\n     * Returns a copy of this year-month plus the specified number of months.\n     * <p>\n     * This year-month instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * YearMonth added = ym.plusMonths(6);\n     * YearMonth added = ym.plus(Period.months(6));\n     * YearMonth added = ym.withFieldAdded(DurationFieldType.months(), 6);\n     * </pre>\n     *\n     * @param months  the amount of months to add, may be negative\n     * @return the new year-month plus the increased months, never null\n     */"}}
{"code": {"body": "public YearMonth minus(ReadablePeriod period) {\n        return withPeriodAdded(period, -1);\n    }", "comment": "/**\n     * Returns a copy of this year-month with the specified period taken away.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to subtract complex period instances.\n     * Subtracting one field is best achieved using methods\n     * like {@link #minusYears(int)}.\n     * \n     * @param period  the period to reduce this instant by\n     * @return a copy of this instance with the period taken away, never null\n     * @throws ArithmeticException if the new year-month exceeds the capacity\n     */"}}
{"code": {"body": "public YearMonth minusYears(int years) {\n        return withFieldAdded(DurationFieldType.years(), FieldUtils.safeNegate(years));\n    }", "comment": "/**\n     * Returns a copy of this year-month minus the specified number of years.\n     * <p>\n     * This year-month instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * YearMonth subtracted = ym.minusYears(6);\n     * YearMonth subtracted = ym.minus(Period.years(6));\n     * YearMonth subtracted = ym.withFieldAdded(DurationFieldType.years(), -6);\n     * </pre>\n     *\n     * @param years  the amount of years to subtract, may be negative\n     * @return the new year-month minus the increased years, never null\n     */"}}
{"code": {"body": "public YearMonth minusMonths(int months) {\n        return withFieldAdded(DurationFieldType.months(), FieldUtils.safeNegate(months));\n    }", "comment": "/**\n     * Returns a copy of this year-month minus the specified number of months.\n     * <p>\n     * This year-month instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * YearMonth subtracted = ym.minusMonths(6);\n     * YearMonth subtracted = ym.minus(Period.months(6));\n     * YearMonth subtracted = ym.withFieldAdded(DurationFieldType.months(), -6);\n     * </pre>\n     *\n     * @param months  the amount of months to subtract, may be negative\n     * @return the new year-month minus the increased months, never null\n     */"}}
{"code": {"body": "public YearMonth withYear(int year) {\n        int[] newValues = getValues();\n        newValues = getChronology().year().set(this, YEAR, newValues, year);\n        return new YearMonth(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this year-month with the year field updated.\n     * <p>\n     * YearMonth is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year changed.\n     *\n     * @param year  the year to set\n     * @return a copy of this object with the field set, never null\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "public YearMonth withMonthOfYear(int monthOfYear) {\n        int[] newValues = getValues();\n        newValues = getChronology().monthOfYear().set(this, MONTH_OF_YEAR, newValues, monthOfYear);\n        return new YearMonth(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this year-month with the month of year field updated.\n     * <p>\n     * YearMonth is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * month of year changed.\n     *\n     * @param monthOfYear  the month of year to set\n     * @return a copy of this object with the field set, never null\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "public YearMonth getYearMonth() {\n            return iBase;\n        }", "comment": "/**\n         * Gets the partial that this property belongs to.\n         * \n         * @return the partial\n         */"}}
{"code": {"body": "public YearMonth addToCopy(int valueToAdd) {\n            int[] newValues = iBase.getValues();\n            newValues = getField().add(iBase, iFieldIndex, newValues, valueToAdd);\n            return new YearMonth(iBase, newValues);\n        }", "comment": "/**\n         * Adds to the value of this field in a copy of this YearMonth.\n         * <p>\n         * The value will be added to this field. If the value is too large to be\n         * added solely to this field then it will affect larger fields.\n         * Smaller fields are unaffected.\n         * <p>\n         * If the result would be too large, beyond the maximum year, then an\n         * IllegalArgumentException is thrown.\n         * <p>\n         * The YearMonth attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param valueToAdd  the value to add to the field in the copy\n         * @return a copy of the YearMonth with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "public YearMonth addWrapFieldToCopy(int valueToAdd) {\n            int[] newValues = iBase.getValues();\n            newValues = getField().addWrapField(iBase, iFieldIndex, newValues, valueToAdd);\n            return new YearMonth(iBase, newValues);\n        }", "comment": "/**\n         * Adds to the value of this field in a copy of this YearMonth wrapping\n         * within this field if the maximum value is reached.\n         * <p>\n         * The value will be added to this field. If the value is too large to be\n         * added solely to this field then it wraps within this field.\n         * Other fields are unaffected.\n         * <p>\n         * For example,\n         * <code>2004-12</code> addWrapField one month returns <code>2004-01</code>.\n         * <p>\n         * The YearMonth attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param valueToAdd  the value to add to the field in the copy\n         * @return a copy of the YearMonth with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "public YearMonth setCopy(int value) {\n            int[] newValues = iBase.getValues();\n            newValues = getField().set(iBase, iFieldIndex, newValues, value);\n            return new YearMonth(iBase, newValues);\n        }", "comment": "/**\n         * Sets this field in a copy of the YearMonth.\n         * <p>\n         * The YearMonth attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param value  the value to set the field in the copy to\n         * @return a copy of the YearMonth with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "public YearMonth setCopy(String text, Locale locale) {\n            int[] newValues = iBase.getValues();\n            newValues = getField().set(iBase, iFieldIndex, newValues, text, locale);\n            return new YearMonth(iBase, newValues);\n        }", "comment": "/**\n         * Sets this field in a copy of the YearMonth to a parsed text value.\n         * <p>\n         * The YearMonth attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param text  the text value to set\n         * @param locale  optional locale to use for selecting a text symbol\n         * @return a copy of the YearMonth with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */"}}
{"code": {"body": "public YearMonth setCopy(String text) {\n            return setCopy(text, null);\n        }", "comment": "/**\n         * Sets this field in a copy of the YearMonth to a parsed text value.\n         * <p>\n         * The YearMonth attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param text  the text value to set\n         * @return a copy of the YearMonth with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */"}}
{"code": {"body": "    public static YearMonth now(Chronology chronology) {\n        if (chronology == null) {\n            throw new NullPointerException(\"\");\n        }\n        return new YearMonth(chronology);\n    }", "comment": "/**\n     * Obtains a {@code YearMonth} set to the current system millisecond time\n     * using the specified chronology.\n     * The resulting object does not use the zone.\n     *\n     * @param chronology  the chronology, not null\n     * @return the current year-month, not null\n     * @since 2.0\n     */"}}
{"code": {"body": "    public static YearMonth parse(String str, DateTimeFormatter formatter) {\n        LocalDate date = formatter.parseLocalDate(str);\n        return new YearMonth(date.getYear(), date.getMonthOfYear());\n    }", "comment": "/**\n     * Parses a {@code YearMonth} from the specified string using a formatter.\n     * \n     * @param str  the string to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @since 2.0\n     */"}}
{"code": {"body": "    public static YearMonth fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        return new YearMonth(calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH) + 1);\n    }", "comment": "/**\n     * Constructs a YearMonth from a <code>java.util.Calendar</code>\n     * using exactly the same field values avoiding any time zone effects.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the YearMonth.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a YearMonth with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from\n     * @return the created YearMonth, never null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the year or month is invalid for the ISO chronology\n     */"}}
{"code": {"body": "    private Object readResolve() {\n        if (DateTimeZone.UTC.equals(getChronology().getZone()) == false) {\n            return new YearMonth(this, getChronology().withUTC());\n        }\n        return this;\n    }", "comment": "/**\n     * Handle broken serialization from other tools.\n     * @return the resolved object, not null\n     */"}}
{"code": {"body": "    public int size() {\n        return 2;\n    }", "comment": "/**\n     * Gets the number of fields in this partial, which is two.\n     * The supported fields are Year and MonthOfYear.\n     * Note that only these fields may be queried.\n     *\n     * @return the field count, two\n     */"}}
{"code": {"body": "        public DateTimeField getField() {\n            return iBase.getField(iFieldIndex);\n        }", "comment": "/**\n         * Gets the field that this property uses.\n         * \n         * @return the field\n         */"}}
{"code": {"body": "    public DateTimeFieldType getFieldType(int index) {\n        return FIELD_TYPES[index];\n    }", "comment": "/**\n     * Gets the field type at the specified index.\n     *\n     * @param index  the index to retrieve\n     * @return the field at the specified index, never null\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */"}}
{"code": {"body": "    public DateTimeFieldType[] getFieldTypes() {\n        return (DateTimeFieldType[]) FIELD_TYPES.clone();\n    }", "comment": "/**\n     * Gets an array of the field type of each of the fields that this partial supports.\n     * <p>\n     * The fields are returned largest to smallest, Year, Month.\n     *\n     * @return the array of field types (cloned), largest to smallest, never null\n     */"}}
{"code": {"body": "    public YearMonth withChronologyRetainFields(Chronology newChronology) {\n        newChronology = DateTimeUtils.getChronology(newChronology);\n        newChronology = newChronology.withUTC();\n        if (newChronology == getChronology()) {\n            return this;\n        } else {\n            YearMonth newYearMonth = new YearMonth(this, newChronology);\n            newChronology.validate(newYearMonth, getValues());\n            return newYearMonth;\n        }\n    }", "comment": "/**\n     * Returns a copy of this year-month with the specified chronology.\n     * This instance is immutable and unaffected by this method call.\n     * <p>\n     * This method retains the values of the fields, thus the result will\n     * typically refer to a different instant.\n     * <p>\n     * The time zone of the specified chronology is ignored, as YearMonth\n     * operates without a time zone.\n     *\n     * @param newChronology  the new chronology, null means ISO\n     * @return a copy of this year-month with a different chronology, never null\n     * @throws IllegalArgumentException if the values are invalid for the new chronology\n     */"}}
{"code": {"body": "    public YearMonth withField(DateTimeFieldType fieldType, int value) {\n        int index = indexOfSupported(fieldType);\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new YearMonth(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this year-month with the specified field set to a new value.\n     * <p>\n     * For example, if the field type is <code>monthOfYear</code> then the month\n     * would be changed in the returned instance.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * YearMonth updated = ym.withField(DateTimeFieldType.monthOfYear(), 6);\n     * YearMonth updated = ym.monthOfYear().setCopy(6);\n     * YearMonth updated = ym.property(DateTimeFieldType.monthOfYear()).setCopy(6);\n     * </pre>\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this instance with the field set, never null\n     * @throws IllegalArgumentException if the value is null or invalid\n     */"}}
{"code": {"body": "    public YearMonth withFieldAdded(DurationFieldType fieldType, int amount) {\n        int index = indexOfSupported(fieldType);\n        if (amount == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).add(this, index, newValues, amount);\n        return new YearMonth(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this year-month with the value of the specified field increased.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * YearMonth added = ym.withFieldAdded(DurationFieldType.months(), 6);\n     * YearMonth added = ym.plusMonths(6);\n     * YearMonth added = ym.monthOfYear().addToCopy(6);\n     * </pre>\n     * \n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this instance with the field updated, never null\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the new date-time exceeds the capacity\n     */"}}
{"code": {"body": "    public YearMonth withPeriodAdded(ReadablePeriod period, int scalar) {\n        if (period == null || scalar == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        for (int i = 0; i < period.size(); i++) {\n            DurationFieldType fieldType = period.getFieldType(i);\n            int index = indexOf(fieldType);\n            if (index >= 0) {\n                newValues = getField(index).add(this, index, newValues,\n                        FieldUtils.safeMultiply(period.getValue(i), scalar));\n            }\n        }\n        return new YearMonth(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this year-month with the specified period added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * Fields in the period that aren't present in the partial are ignored.\n     * <p>\n     * This method is typically used to add multiple copies of complex\n     * period instances. Adding one field is best achieved using methods\n     * like {@link #withFieldAdded(DurationFieldType, int)}\n     * or {@link #plusYears(int)}.\n     * \n     * @param period  the period to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this instance with the period added, never null\n     * @throws ArithmeticException if the new date-time exceeds the capacity\n     */"}}
{"code": {"body": "    public YearMonth plus(ReadablePeriod period) {\n        return withPeriodAdded(period, 1);\n    }", "comment": "/**\n     * Returns a copy of this year-month with the specified period added.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to add complex period instances.\n     * Adding one field is best achieved using methods\n     * like {@link #plusYears(int)}.\n     * \n     * @param period  the duration to add to this one, null means zero\n     * @return a copy of this instance with the period added, never null\n     * @throws ArithmeticException if the new year-month exceeds the capacity\n     */"}}
{"code": {"body": "    public YearMonth plusYears(int years) {\n        return withFieldAdded(DurationFieldType.years(), years);\n    }", "comment": "/**\n     * Returns a copy of this year-month plus the specified number of years.\n     * <p>\n     * This year-month instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * YearMonth added = ym.plusYears(6);\n     * YearMonth added = ym.plus(Period.years(6));\n     * YearMonth added = ym.withFieldAdded(DurationFieldType.years(), 6);\n     * </pre>\n     *\n     * @param years  the amount of years to add, may be negative\n     * @return the new year-month plus the increased years, never null\n     */"}}
{"code": {"body": "    public YearMonth plusMonths(int months) {\n        return withFieldAdded(DurationFieldType.months(), months);\n    }", "comment": "/**\n     * Returns a copy of this year-month plus the specified number of months.\n     * <p>\n     * This year-month instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * YearMonth added = ym.plusMonths(6);\n     * YearMonth added = ym.plus(Period.months(6));\n     * YearMonth added = ym.withFieldAdded(DurationFieldType.months(), 6);\n     * </pre>\n     *\n     * @param months  the amount of months to add, may be negative\n     * @return the new year-month plus the increased months, never null\n     */"}}
{"code": {"body": "    public YearMonth minus(ReadablePeriod period) {\n        return withPeriodAdded(period, -1);\n    }", "comment": "/**\n     * Returns a copy of this year-month with the specified period taken away.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to subtract complex period instances.\n     * Subtracting one field is best achieved using methods\n     * like {@link #minusYears(int)}.\n     * \n     * @param period  the period to reduce this instant by\n     * @return a copy of this instance with the period taken away, never null\n     * @throws ArithmeticException if the new year-month exceeds the capacity\n     */"}}
{"code": {"body": "    public YearMonth minusYears(int years) {\n        return withFieldAdded(DurationFieldType.years(), FieldUtils.safeNegate(years));\n    }", "comment": "/**\n     * Returns a copy of this year-month minus the specified number of years.\n     * <p>\n     * This year-month instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * YearMonth subtracted = ym.minusYears(6);\n     * YearMonth subtracted = ym.minus(Period.years(6));\n     * YearMonth subtracted = ym.withFieldAdded(DurationFieldType.years(), -6);\n     * </pre>\n     *\n     * @param years  the amount of years to subtract, may be negative\n     * @return the new year-month minus the increased years, never null\n     */"}}
{"code": {"body": "    public YearMonth minusMonths(int months) {\n        return withFieldAdded(DurationFieldType.months(), FieldUtils.safeNegate(months));\n    }", "comment": "/**\n     * Returns a copy of this year-month minus the specified number of months.\n     * <p>\n     * This year-month instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * YearMonth subtracted = ym.minusMonths(6);\n     * YearMonth subtracted = ym.minus(Period.months(6));\n     * YearMonth subtracted = ym.withFieldAdded(DurationFieldType.months(), -6);\n     * </pre>\n     *\n     * @param months  the amount of months to subtract, may be negative\n     * @return the new year-month minus the increased months, never null\n     */"}}
{"code": {"body": "    public LocalDate toLocalDate(int dayOfMonth) {\n        return new LocalDate(getYear(), getMonthOfYear(), dayOfMonth, getChronology());\n    }", "comment": "/**\n     * Converts this object to a LocalDate with the same year-month and chronology.\n     *\n     * @param dayOfMonth the day of month to use, valid for chronology, such as 1-31 for ISO\n     * @return a LocalDate with the same year-month and chronology, never null\n     */"}}
{"code": {"body": "    public Interval toInterval(DateTimeZone zone) {\n        zone = DateTimeUtils.getZone(zone);\n        DateTime start = toLocalDate(1).toDateTimeAtStartOfDay(zone);\n        DateTime end = plusMonths(1).toLocalDate(1).toDateTimeAtStartOfDay(zone);\n        return new Interval(start, end);\n    }", "comment": "/**\n     * Converts this object to an Interval representing the whole month.\n     * <p>\n     * The interval will use the chronology of the year-month in the specified zone.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param zone  the zone to get the Interval in, null means default\n     * @return an interval over the month, never null\n     */"}}
{"code": {"body": "    public int getYear() {\n        return getValue(YEAR);\n    }", "comment": "/**\n     * Get the year field value.\n     *\n     * @return the year\n     */"}}
{"code": {"body": "    public int getMonthOfYear() {\n        return getValue(MONTH_OF_YEAR);\n    }", "comment": "/**\n     * Get the month of year field value.\n     *\n     * @return the month of year\n     */"}}
{"code": {"body": "    public YearMonth withYear(int year) {\n        int[] newValues = getValues();\n        newValues = getChronology().year().set(this, YEAR, newValues, year);\n        return new YearMonth(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this year-month with the year field updated.\n     * <p>\n     * YearMonth is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year changed.\n     *\n     * @param year  the year to set\n     * @return a copy of this object with the field set, never null\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public YearMonth withMonthOfYear(int monthOfYear) {\n        int[] newValues = getValues();\n        newValues = getChronology().monthOfYear().set(this, MONTH_OF_YEAR, newValues, monthOfYear);\n        return new YearMonth(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this year-month with the month of year field updated.\n     * <p>\n     * YearMonth is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * month of year changed.\n     *\n     * @param monthOfYear  the month of year to set\n     * @return a copy of this object with the field set, never null\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public Property property(DateTimeFieldType type) {\n        return new Property(this, indexOfSupported(type));\n    }", "comment": "/**\n     * Gets the property object for the specified type, which contains\n     * many useful methods.\n     *\n     * @param type  the field type to get the property for\n     * @return the property object\n     * @throws IllegalArgumentException if the field is null or unsupported\n     */"}}
{"code": {"body": "    public Property year() {\n        return new Property(this, YEAR);\n    }", "comment": "/**\n     * Get the year field property which provides access to advanced functionality.\n     * \n     * @return the year property\n     */"}}
{"code": {"body": "    public Property monthOfYear() {\n        return new Property(this, MONTH_OF_YEAR);\n    }", "comment": "/**\n     * Get the month of year field property which provides access to advanced functionality.\n     * \n     * @return the month of year property\n     */"}}
{"code": {"body": "    public String toString(String pattern, Locale locale) throws IllegalArgumentException {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n    }", "comment": "/**\n     * Output the year-month using the specified format pattern.\n     *\n     * @param pattern  the pattern specification, null means use <code>toString</code>\n     * @param locale  Locale to use, null means default\n     * @see org.joda.time.format.DateTimeFormat\n     */"}}
{"code": {"body": "        protected ReadablePartial getReadablePartial() {\n            return iBase;\n        }", "comment": "/**\n         * Gets the partial that this property belongs to.\n         * \n         * @return the partial\n         */"}}
{"code": {"body": "        public YearMonth getYearMonth() {\n            return iBase;\n        }", "comment": "/**\n         * Gets the partial that this property belongs to.\n         * \n         * @return the partial\n         */"}}
{"code": {"body": "        public int get() {\n            return iBase.getValue(iFieldIndex);\n        }", "comment": "/**\n         * Gets the value of this field.\n         * \n         * @return the field value\n         */"}}
{"code": {"body": "        public YearMonth addToCopy(int valueToAdd) {\n            int[] newValues = iBase.getValues();\n            newValues = getField().add(iBase, iFieldIndex, newValues, valueToAdd);\n            return new YearMonth(iBase, newValues);\n        }", "comment": "/**\n         * Adds to the value of this field in a copy of this YearMonth.\n         * <p>\n         * The value will be added to this field. If the value is too large to be\n         * added solely to this field then it will affect larger fields.\n         * Smaller fields are unaffected.\n         * <p>\n         * If the result would be too large, beyond the maximum year, then an\n         * IllegalArgumentException is thrown.\n         * <p>\n         * The YearMonth attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param valueToAdd  the value to add to the field in the copy\n         * @return a copy of the YearMonth with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "        public YearMonth addWrapFieldToCopy(int valueToAdd) {\n            int[] newValues = iBase.getValues();\n            newValues = getField().addWrapField(iBase, iFieldIndex, newValues, valueToAdd);\n            return new YearMonth(iBase, newValues);\n        }", "comment": "/**\n         * Adds to the value of this field in a copy of this YearMonth wrapping\n         * within this field if the maximum value is reached.\n         * <p>\n         * The value will be added to this field. If the value is too large to be\n         * added solely to this field then it wraps within this field.\n         * Other fields are unaffected.\n         * <p>\n         * For example,\n         * <code>2004-12</code> addWrapField one month returns <code>2004-01</code>.\n         * <p>\n         * The YearMonth attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param valueToAdd  the value to add to the field in the copy\n         * @return a copy of the YearMonth with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "        public YearMonth setCopy(String text) {\n            return setCopy(text, null);\n        }", "comment": "/**\n         * Sets this field in a copy of the YearMonth to a parsed text value.\n         * <p>\n         * The YearMonth attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param text  the text value to set\n         * @return a copy of the YearMonth with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */"}}
{"code": {"body": "public YearMonthDay() {\n        super();\n    }", "comment": "/**\n     * Constructs a YearMonthDay with the current date, using ISOChronology in\n     * the default zone to extract the fields.\n     * <p>\n     * The constructor uses the default time zone, resulting in the local time\n     * being initialised. Once the constructor is complete, all further calculations\n     * are performed without reference to a timezone (by switching to UTC).\n     */"}}
{"code": {"body": "public YearMonthDay(DateTimeZone zone) {\n        super(ISOChronology.getInstance(zone));\n    }", "comment": "/**\n     * Constructs a YearMonthDay with the current date, using ISOChronology in\n     * the specified zone to extract the fields.\n     * <p>\n     * The constructor uses the specified time zone to obtain the current date.\n     * Once the constructor is complete, all further calculations\n     * are performed without reference to a timezone (by switching to UTC).\n     * \n     * @param zone  the zone to use, null means default zone\n     * @since 1.1\n     */"}}
{"code": {"body": "public YearMonthDay(Chronology chronology) {\n        super(chronology);\n    }", "comment": "/**\n     * Constructs a YearMonthDay with the current date, using the specified chronology\n     * and zone to extract the fields.\n     * <p>\n     * The constructor uses the time zone of the chronology specified.\n     * Once the constructor is complete, all further calculations are performed\n     * without reference to a timezone (by switching to UTC).\n     *\n     * @param chronology  the chronology, null means ISOChronology in the default zone\n     */"}}
{"code": {"body": "public YearMonthDay(long instant) {\n        super(instant);\n    }", "comment": "/**\n     * Constructs a YearMonthDay extracting the partial fields from the specified\n     * milliseconds using the ISOChronology in the default zone.\n     * <p>\n     * The constructor uses the default time zone, resulting in the local time\n     * being initialised. Once the constructor is complete, all further calculations\n     * are performed without reference to a timezone (by switching to UTC).\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     */"}}
{"code": {"body": "public YearMonthDay(long instant, Chronology chronology) {\n        super(instant, chronology);\n    }", "comment": "/**\n     * Constructs a YearMonthDay extracting the partial fields from the specified\n     * milliseconds using the chronology provided.\n     * <p>\n     * The constructor uses the time zone of the chronology specified.\n     * Once the constructor is complete, all further calculations are performed\n     * without reference to a timezone (by switching to UTC).\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     * @param chronology  the chronology, null means ISOChronology in the default zone\n     */"}}
{"code": {"body": "public YearMonthDay(Object instant) {\n        super(instant, null, ISODateTimeFormat.dateOptionalTimeParser());\n    }", "comment": "/**\n     * Constructs a YearMonthDay from an Object that represents a time.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadableInstant, String, Calendar and Date.\n     * The String formats are described by {@link ISODateTimeFormat#dateOptionalTimeParser()}.\n     * <p>\n     * The chronology used will be derived from the object, defaulting to ISO.\n     * <p>\n     * NOTE: Prior to v1.3 the string format was described by\n     * {@link ISODateTimeFormat#dateTimeParser()}. Time ony strings are now rejected.\n     *\n     * @param instant  the datetime object, null means now\n     * @throws IllegalArgumentException if the instant is invalid\n     */"}}
{"code": {"body": "public YearMonthDay(Object instant, Chronology chronology) {\n        super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.dateOptionalTimeParser());\n    }", "comment": "/**\n     * Constructs a YearMonthDay from an Object that represents a time, using the\n     * specified chronology.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadableInstant, String, Calendar and Date.\n     * The String formats are described by {@link ISODateTimeFormat#dateOptionalTimeParser()}.\n     * <p>\n     * The constructor uses the time zone of the chronology specified.\n     * Once the constructor is complete, all further calculations are performed\n     * without reference to a timezone (by switching to UTC).\n     * The specified chronology overrides that of the object.\n     * <p>\n     * NOTE: Prior to v1.3 the string format was described by\n     * {@link ISODateTimeFormat#dateTimeParser()}. Time only strings are now rejected.\n     *\n     * @param instant  the datetime object, null means now\n     * @param chronology  the chronology, null means ISO default\n     * @throws IllegalArgumentException if the instant is invalid\n     */"}}
{"code": {"body": "public YearMonthDay(int year, int monthOfYear, int dayOfMonth) {\n        this(year, monthOfYear, dayOfMonth, null);\n    }", "comment": "/**\n     * Constructs a YearMonthDay with specified time field values\n     * using <code>ISOChronology</code> in the default zone.\n     * <p>\n     * The constructor uses the no time zone initialising the fields as provided.\n     * Once the constructor is complete, all further calculations\n     * are performed without reference to a timezone (by switching to UTC).\n     *\n     * @param year  the year\n     * @param monthOfYear  the month of the year\n     * @param dayOfMonth  the day of the month\n     */"}}
{"code": {"body": "public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology) {\n        super(new int[] {year, monthOfYear, dayOfMonth}, chronology);\n    }", "comment": "/**\n     * Constructs a YearMonthDay with specified time field values.\n     * <p>\n     * The constructor uses the time zone of the chronology specified.\n     * Once the constructor is complete, all further calculations are performed\n     * without reference to a timezone (by switching to UTC).\n     *\n     * @param year  the year\n     * @param monthOfYear  the month of the year\n     * @param dayOfMonth  the day of the month\n     * @param chronology  the chronology, null means ISOChronology in the default zone\n     */"}}
{"code": {"body": "public YearMonthDay withChronologyRetainFields(Chronology newChronology) {\n        newChronology = DateTimeUtils.getChronology(newChronology);\n        newChronology = newChronology.withUTC();\n        if (newChronology == getChronology()) {\n            return this;\n        } else {\n            YearMonthDay newYearMonthDay = new YearMonthDay(this, newChronology);\n            newChronology.validate(newYearMonthDay, getValues());\n            return newYearMonthDay;\n        }\n    }", "comment": "/**\n     * Returns a copy of this date with the specified chronology.\n     * This instance is immutable and unaffected by this method call.\n     * <p>\n     * This method retains the values of the fields, thus the result will\n     * typically refer to a different instant.\n     * <p>\n     * The time zone of the specified chronology is ignored, as YearMonthDay\n     * operates without a time zone.\n     *\n     * @param newChronology  the new chronology, null means ISO\n     * @return a copy of this datetime with a different chronology\n     * @throws IllegalArgumentException if the values are invalid for the new chronology\n     */"}}
{"code": {"body": "public YearMonthDay withField(DateTimeFieldType fieldType, int value) {\n        int index = indexOfSupported(fieldType);\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new YearMonthDay(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this date with the specified field set to a new value.\n     * <p>\n     * For example, if the field type is <code>dayOfMonth</code> then the day\n     * would be changed in the returned instance.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * YearMonthDay updated = ymd.withField(DateTimeFieldType.dayOfMonth(), 6);\n     * YearMonthDay updated = ymd.dayOfMonth().setCopy(6);\n     * YearMonthDay updated = ymd.property(DateTimeFieldType.dayOfMonth()).setCopy(6);\n     * </pre>\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this instance with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     */"}}
{"code": {"body": "public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount) {\n        int index = indexOfSupported(fieldType);\n        if (amount == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).add(this, index, newValues, amount);\n        return new YearMonthDay(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this date with the value of the specified field increased.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * YearMonthDay added = ymd.withFieldAdded(DurationFieldType.days(), 6);\n     * YearMonthDay added = ymd.plusDays(6);\n     * YearMonthDay added = ymd.dayOfMonth().addToCopy(6);\n     * </pre>\n     * \n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this instance with the field updated\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the new datetime exceeds the capacity\n     */"}}
{"code": {"body": "public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar) {\n        if (period == null || scalar == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        for (int i = 0; i < period.size(); i++) {\n            DurationFieldType fieldType = period.getFieldType(i);\n            int index = indexOf(fieldType);\n            if (index >= 0) {\n                newValues = getField(index).add(this, index, newValues,\n                        FieldUtils.safeMultiply(period.getValue(i), scalar));\n            }\n        }\n        return new YearMonthDay(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this date with the specified period added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * Fields in the period that aren't present in the partial are ignored.\n     * <p>\n     * This method is typically used to add multiple copies of complex\n     * period instances. Adding one field is best achieved using methods\n     * like {@link #withFieldAdded(DurationFieldType, int)}\n     * or {@link #plusYears(int)}.\n     * \n     * @param period  the period to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this instance with the period added\n     * @throws ArithmeticException if the new datetime exceeds the capacity\n     */"}}
{"code": {"body": "public YearMonthDay plus(ReadablePeriod period) {\n        return withPeriodAdded(period, 1);\n    }", "comment": "/**\n     * Returns a copy of this date with the specified period added.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to add complex period instances.\n     * Adding one field is best achieved using methods\n     * like {@link #plusYears(int)}.\n     * \n     * @param period  the duration to add to this one, null means zero\n     * @return a copy of this instance with the period added\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "public YearMonthDay plusYears(int years) {\n        return withFieldAdded(DurationFieldType.years(), years);\n    }", "comment": "/**\n     * Returns a copy of this date plus the specified number of years.\n     * <p>\n     * This date instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * YearMonthDay added = dt.plusYears(6);\n     * YearMonthDay added = dt.plus(Period.years(6));\n     * YearMonthDay added = dt.withFieldAdded(DurationFieldType.years(), 6);\n     * </pre>\n     *\n     * @param years  the amount of years to add, may be negative\n     * @return the new date plus the increased years\n     * @since 1.1\n     */"}}
{"code": {"body": "public YearMonthDay plusMonths(int months) {\n        return withFieldAdded(DurationFieldType.months(), months);\n    }", "comment": "/**\n     * Returns a copy of this date plus the specified number of months.\n     * <p>\n     * This date instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * YearMonthDay added = dt.plusMonths(6);\n     * YearMonthDay added = dt.plus(Period.months(6));\n     * YearMonthDay added = dt.withFieldAdded(DurationFieldType.months(), 6);\n     * </pre>\n     *\n     * @param months  the amount of months to add, may be negative\n     * @return the new date plus the increased months\n     * @since 1.1\n     */"}}
{"code": {"body": "public YearMonthDay plusDays(int days) {\n        return withFieldAdded(DurationFieldType.days(), days);\n    }", "comment": "/**\n     * Returns a copy of this date plus the specified number of days.\n     * <p>\n     * This date instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * YearMonthDay added = dt.plusDays(6);\n     * YearMonthDay added = dt.plus(Period.days(6));\n     * YearMonthDay added = dt.withFieldAdded(DurationFieldType.days(), 6);\n     * </pre>\n     *\n     * @param days  the amount of days to add, may be negative\n     * @return the new date plus the increased days\n     * @since 1.1\n     */"}}
{"code": {"body": "public YearMonthDay minus(ReadablePeriod period) {\n        return withPeriodAdded(period, -1);\n    }", "comment": "/**\n     * Returns a copy of this date with the specified period taken away.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to subtract complex period instances.\n     * Subtracting one field is best achieved using methods\n     * like {@link #minusYears(int)}.\n     * \n     * @param period  the period to reduce this instant by\n     * @return a copy of this instance with the period taken away\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "public YearMonthDay minusYears(int years) {\n        return withFieldAdded(DurationFieldType.years(), FieldUtils.safeNegate(years));\n    }", "comment": "/**\n     * Returns a copy of this date minus the specified number of years.\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * YearMonthDay subtracted = dt.minusYears(6);\n     * YearMonthDay subtracted = dt.minus(Period.years(6));\n     * YearMonthDay subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);\n     * </pre>\n     *\n     * @param years  the amount of years to subtract, may be negative\n     * @return the new datetime minus the increased years\n     * @since 1.1\n     */"}}
{"code": {"body": "public YearMonthDay minusMonths(int months) {\n        return withFieldAdded(DurationFieldType.months(), FieldUtils.safeNegate(months));\n    }", "comment": "/**\n     * Returns a copy of this date minus the specified number of months.\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * YearMonthDay subtracted = dt.minusMonths(6);\n     * YearMonthDay subtracted = dt.minus(Period.months(6));\n     * YearMonthDay subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);\n     * </pre>\n     *\n     * @param months  the amount of months to subtract, may be negative\n     * @return the new datetime minus the increased months\n     * @since 1.1\n     */"}}
{"code": {"body": "public YearMonthDay minusDays(int days) {\n        return withFieldAdded(DurationFieldType.days(), FieldUtils.safeNegate(days));\n    }", "comment": "/**\n     * Returns a copy of this date minus the specified number of days.\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * YearMonthDay subtracted = dt.minusDays(6);\n     * YearMonthDay subtracted = dt.minus(Period.days(6));\n     * YearMonthDay subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);\n     * </pre>\n     *\n     * @param days  the amount of days to subtract, may be negative\n     * @return the new datetime minus the increased days\n     * @since 1.1\n     */"}}
{"code": {"body": "public YearMonthDay withYear(int year) {\n        int[] newValues = getValues();\n        newValues = getChronology().year().set(this, YEAR, newValues, year);\n        return new YearMonthDay(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this date with the year field updated.\n     * <p>\n     * YearMonthDay is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year changed.\n     *\n     * @param year  the year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "public YearMonthDay withMonthOfYear(int monthOfYear) {\n        int[] newValues = getValues();\n        newValues = getChronology().monthOfYear().set(this, MONTH_OF_YEAR, newValues, monthOfYear);\n        return new YearMonthDay(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this date with the month of year field updated.\n     * <p>\n     * YearMonthDay is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * month of year changed.\n     *\n     * @param monthOfYear  the month of year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "public YearMonthDay withDayOfMonth(int dayOfMonth) {\n        int[] newValues = getValues();\n        newValues = getChronology().dayOfMonth().set(this, DAY_OF_MONTH, newValues, dayOfMonth);\n        return new YearMonthDay(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this date with the day of month field updated.\n     * <p>\n     * YearMonthDay is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of month changed.\n     *\n     * @param dayOfMonth  the day of month to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "public YearMonthDay getYearMonthDay() {\n            return iYearMonthDay;\n        }", "comment": "/**\n         * Gets the partial that this property belongs to.\n         * \n         * @return the partial\n         */"}}
{"code": {"body": "public YearMonthDay addToCopy(int valueToAdd) {\n            int[] newValues = iYearMonthDay.getValues();\n            newValues = getField().add(iYearMonthDay, iFieldIndex, newValues, valueToAdd);\n            return new YearMonthDay(iYearMonthDay, newValues);\n        }", "comment": "/**\n         * Adds to the value of this field in a copy of this YearMonthDay.\n         * <p>\n         * The value will be added to this field. If the value is too large to be\n         * added solely to this field then it will affect larger fields.\n         * Smaller fields are unaffected.\n         * <p>\n         * If the result would be too large, beyond the maximum year, then an\n         * IllegalArgumentException is thrown.\n         * <p>\n         * The YearMonthDay attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param valueToAdd  the value to add to the field in the copy\n         * @return a copy of the YearMonthDay with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "public YearMonthDay addWrapFieldToCopy(int valueToAdd) {\n            int[] newValues = iYearMonthDay.getValues();\n            newValues = getField().addWrapField(iYearMonthDay, iFieldIndex, newValues, valueToAdd);\n            return new YearMonthDay(iYearMonthDay, newValues);\n        }", "comment": "/**\n         * Adds to the value of this field in a copy of this YearMonthDay wrapping\n         * within this field if the maximum value is reached.\n         * <p>\n         * The value will be added to this field. If the value is too large to be\n         * added solely to this field then it wraps within this field.\n         * Other fields are unaffected.\n         * <p>\n         * For example,\n         * <code>2004-12-20</code> addWrapField one month returns <code>2004-01-20</code>.\n         * <p>\n         * The YearMonthDay attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param valueToAdd  the value to add to the field in the copy\n         * @return a copy of the YearMonthDay with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "public YearMonthDay setCopy(int value) {\n            int[] newValues = iYearMonthDay.getValues();\n            newValues = getField().set(iYearMonthDay, iFieldIndex, newValues, value);\n            return new YearMonthDay(iYearMonthDay, newValues);\n        }", "comment": "/**\n         * Sets this field in a copy of the YearMonthDay.\n         * <p>\n         * The YearMonthDay attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param value  the value to set the field in the copy to\n         * @return a copy of the YearMonthDay with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "public YearMonthDay setCopy(String text, Locale locale) {\n            int[] newValues = iYearMonthDay.getValues();\n            newValues = getField().set(iYearMonthDay, iFieldIndex, newValues, text, locale);\n            return new YearMonthDay(iYearMonthDay, newValues);\n        }", "comment": "/**\n         * Sets this field in a copy of the YearMonthDay to a parsed text value.\n         * <p>\n         * The YearMonthDay attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param text  the text value to set\n         * @param locale  optional locale to use for selecting a text symbol\n         * @return a copy of the YearMonthDay with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */"}}
{"code": {"body": "public YearMonthDay setCopy(String text) {\n            return setCopy(text, null);\n        }", "comment": "/**\n         * Sets this field in a copy of the YearMonthDay to a parsed text value.\n         * <p>\n         * The YearMonthDay attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param text  the text value to set\n         * @return a copy of the YearMonthDay with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */"}}
{"code": {"body": "public YearMonthDay withMaximumValue() {\n            return setCopy(getMaximumValue());\n        }", "comment": "/**\n         * Returns a new YearMonthDay with this field set to the maximum value\n         * for this field.\n         * <p>\n         * This operation is useful for obtaining a DateTime on the last day\n         * of the month, as month lengths vary.\n         * <pre>\n         * YearMonthDay lastDayOfMonth = dt.dayOfMonth().withMaximumValue();\n         * </pre>\n         * <p>\n         * The YearMonthDay attached to this property is unchanged by this call.\n         *\n         * @return a copy of the YearMonthDay with this field set to its maximum\n         * @since 1.2\n         */"}}
{"code": {"body": "public YearMonthDay withMinimumValue() {\n            return setCopy(getMinimumValue());\n        }", "comment": "/**\n         * Returns a new YearMonthDay with this field set to the minimum value\n         * for this field.\n         * <p>\n         * The YearMonthDay attached to this property is unchanged by this call.\n         *\n         * @return a copy of the YearMonthDay with this field set to its minimum\n         * @since 1.2\n         */"}}
{"code": {"body": "    public static YearMonthDay fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        return new YearMonthDay(\n            calendar.get(Calendar.YEAR),\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }", "comment": "/**\n     * Constructs a YearMonthDay from a <code>java.util.Calendar</code>\n     * using exactly the same field values avoiding any time zone effects.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the YearMonthDay.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoing the zone.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a YearMonthDay with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from\n     * @return the created YearMonthDay\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     * @since 1.2\n     */"}}
{"code": {"body": "    public static YearMonthDay fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        return new YearMonthDay(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }", "comment": "/**\n     * Constructs a YearMonthDay from a <code>java.util.Date</code>\n     * using exactly the same field values avoiding any time zone effects.\n     * <p>\n     * Each field is queried from the Date and assigned to the YearMonthDay.\n     * This is useful if you have been using the Date as a local date,\n     * ignoing the zone.\n     * <p>\n     * This factory method always creates a YearMonthDay with ISO chronology.\n     *\n     * @param date  the Date to extract fields from\n     * @return the created YearMonthDay\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     * @since 1.2\n     */"}}
{"code": {"body": "    public int size() {\n        return 3;\n    }", "comment": "/**\n     * Gets the number of fields in this partial.\n     * \n     * @return the field count\n     */"}}
{"code": {"body": "        public DateTimeField getField() {\n            return iYearMonthDay.getField(iFieldIndex);\n        }", "comment": "/**\n         * Gets the field that this property uses.\n         * \n         * @return the field\n         */"}}
{"code": {"body": "    public DateTimeFieldType getFieldType(int index) {\n        return FIELD_TYPES[index];\n    }", "comment": "/**\n     * Gets the field type at the specified index.\n     *\n     * @param index  the index to retrieve\n     * @return the field at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */"}}
{"code": {"body": "    public DateTimeFieldType[] getFieldTypes() {\n        return (DateTimeFieldType[]) FIELD_TYPES.clone();\n    }", "comment": "/**\n     * Gets an array of the field type of each of the fields that this partial supports.\n     * <p>\n     * The fields are returned largest to smallest, Year, Month, Day\n     *\n     * @return the array of field types (cloned), largest to smallest\n     */"}}
{"code": {"body": "    public YearMonthDay withChronologyRetainFields(Chronology newChronology) {\n        newChronology = DateTimeUtils.getChronology(newChronology);\n        newChronology = newChronology.withUTC();\n        if (newChronology == getChronology()) {\n            return this;\n        } else {\n            YearMonthDay newYearMonthDay = new YearMonthDay(this, newChronology);\n            newChronology.validate(newYearMonthDay, getValues());\n            return newYearMonthDay;\n        }\n    }", "comment": "/**\n     * Returns a copy of this date with the specified chronology.\n     * This instance is immutable and unaffected by this method call.\n     * <p>\n     * This method retains the values of the fields, thus the result will\n     * typically refer to a different instant.\n     * <p>\n     * The time zone of the specified chronology is ignored, as YearMonthDay\n     * operates without a time zone.\n     *\n     * @param newChronology  the new chronology, null means ISO\n     * @return a copy of this datetime with a different chronology\n     * @throws IllegalArgumentException if the values are invalid for the new chronology\n     */"}}
{"code": {"body": "    public YearMonthDay withField(DateTimeFieldType fieldType, int value) {\n        int index = indexOfSupported(fieldType);\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new YearMonthDay(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this date with the specified field set to a new value.\n     * <p>\n     * For example, if the field type is <code>dayOfMonth</code> then the day\n     * would be changed in the returned instance.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * YearMonthDay updated = ymd.withField(DateTimeFieldType.dayOfMonth(), 6);\n     * YearMonthDay updated = ymd.dayOfMonth().setCopy(6);\n     * YearMonthDay updated = ymd.property(DateTimeFieldType.dayOfMonth()).setCopy(6);\n     * </pre>\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this instance with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     */"}}
{"code": {"body": "    public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount) {\n        int index = indexOfSupported(fieldType);\n        if (amount == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).add(this, index, newValues, amount);\n        return new YearMonthDay(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this date with the value of the specified field increased.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * YearMonthDay added = ymd.withFieldAdded(DurationFieldType.days(), 6);\n     * YearMonthDay added = ymd.plusDays(6);\n     * YearMonthDay added = ymd.dayOfMonth().addToCopy(6);\n     * </pre>\n     * \n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this instance with the field updated\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the new datetime exceeds the capacity\n     */"}}
{"code": {"body": "    public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar) {\n        if (period == null || scalar == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        for (int i = 0; i < period.size(); i++) {\n            DurationFieldType fieldType = period.getFieldType(i);\n            int index = indexOf(fieldType);\n            if (index >= 0) {\n                newValues = getField(index).add(this, index, newValues,\n                        FieldUtils.safeMultiply(period.getValue(i), scalar));\n            }\n        }\n        return new YearMonthDay(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this date with the specified period added.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * Fields in the period that aren't present in the partial are ignored.\n     * <p>\n     * This method is typically used to add multiple copies of complex\n     * period instances. Adding one field is best achieved using methods\n     * like {@link #withFieldAdded(DurationFieldType, int)}\n     * or {@link #plusYears(int)}.\n     * \n     * @param period  the period to add to this one, null means zero\n     * @param scalar  the amount of times to add, such as -1 to subtract once\n     * @return a copy of this instance with the period added\n     * @throws ArithmeticException if the new datetime exceeds the capacity\n     */"}}
{"code": {"body": "    public YearMonthDay plus(ReadablePeriod period) {\n        return withPeriodAdded(period, 1);\n    }", "comment": "/**\n     * Returns a copy of this date with the specified period added.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to add complex period instances.\n     * Adding one field is best achieved using methods\n     * like {@link #plusYears(int)}.\n     * \n     * @param period  the duration to add to this one, null means zero\n     * @return a copy of this instance with the period added\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "    public YearMonthDay plusYears(int years) {\n        return withFieldAdded(DurationFieldType.years(), years);\n    }", "comment": "/**\n     * Returns a copy of this date plus the specified number of years.\n     * <p>\n     * This date instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * YearMonthDay added = dt.plusYears(6);\n     * YearMonthDay added = dt.plus(Period.years(6));\n     * YearMonthDay added = dt.withFieldAdded(DurationFieldType.years(), 6);\n     * </pre>\n     *\n     * @param years  the amount of years to add, may be negative\n     * @return the new date plus the increased years\n     * @since 1.1\n     */"}}
{"code": {"body": "    public YearMonthDay plusMonths(int months) {\n        return withFieldAdded(DurationFieldType.months(), months);\n    }", "comment": "/**\n     * Returns a copy of this date plus the specified number of months.\n     * <p>\n     * This date instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * YearMonthDay added = dt.plusMonths(6);\n     * YearMonthDay added = dt.plus(Period.months(6));\n     * YearMonthDay added = dt.withFieldAdded(DurationFieldType.months(), 6);\n     * </pre>\n     *\n     * @param months  the amount of months to add, may be negative\n     * @return the new date plus the increased months\n     * @since 1.1\n     */"}}
{"code": {"body": "    public YearMonthDay plusDays(int days) {\n        return withFieldAdded(DurationFieldType.days(), days);\n    }", "comment": "/**\n     * Returns a copy of this date plus the specified number of days.\n     * <p>\n     * This date instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * YearMonthDay added = dt.plusDays(6);\n     * YearMonthDay added = dt.plus(Period.days(6));\n     * YearMonthDay added = dt.withFieldAdded(DurationFieldType.days(), 6);\n     * </pre>\n     *\n     * @param days  the amount of days to add, may be negative\n     * @return the new date plus the increased days\n     * @since 1.1\n     */"}}
{"code": {"body": "    public YearMonthDay minus(ReadablePeriod period) {\n        return withPeriodAdded(period, -1);\n    }", "comment": "/**\n     * Returns a copy of this date with the specified period taken away.\n     * <p>\n     * If the amount is zero or null, then <code>this</code> is returned.\n     * <p>\n     * This method is typically used to subtract complex period instances.\n     * Subtracting one field is best achieved using methods\n     * like {@link #minusYears(int)}.\n     * \n     * @param period  the period to reduce this instant by\n     * @return a copy of this instance with the period taken away\n     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n     */"}}
{"code": {"body": "    public YearMonthDay minusYears(int years) {\n        return withFieldAdded(DurationFieldType.years(), FieldUtils.safeNegate(years));\n    }", "comment": "/**\n     * Returns a copy of this date minus the specified number of years.\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * YearMonthDay subtracted = dt.minusYears(6);\n     * YearMonthDay subtracted = dt.minus(Period.years(6));\n     * YearMonthDay subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);\n     * </pre>\n     *\n     * @param years  the amount of years to subtract, may be negative\n     * @return the new datetime minus the increased years\n     * @since 1.1\n     */"}}
{"code": {"body": "    public YearMonthDay minusMonths(int months) {\n        return withFieldAdded(DurationFieldType.months(), FieldUtils.safeNegate(months));\n    }", "comment": "/**\n     * Returns a copy of this date minus the specified number of months.\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * YearMonthDay subtracted = dt.minusMonths(6);\n     * YearMonthDay subtracted = dt.minus(Period.months(6));\n     * YearMonthDay subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);\n     * </pre>\n     *\n     * @param months  the amount of months to subtract, may be negative\n     * @return the new datetime minus the increased months\n     * @since 1.1\n     */"}}
{"code": {"body": "    public YearMonthDay minusDays(int days) {\n        return withFieldAdded(DurationFieldType.days(), FieldUtils.safeNegate(days));\n    }", "comment": "/**\n     * Returns a copy of this date minus the specified number of days.\n     * <p>\n     * This datetime instance is immutable and unaffected by this method call.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * YearMonthDay subtracted = dt.minusDays(6);\n     * YearMonthDay subtracted = dt.minus(Period.days(6));\n     * YearMonthDay subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);\n     * </pre>\n     *\n     * @param days  the amount of days to subtract, may be negative\n     * @return the new datetime minus the increased days\n     * @since 1.1\n     */"}}
{"code": {"body": "    public Property property(DateTimeFieldType type) {\n        return new Property(this, indexOfSupported(type));\n    }", "comment": "/**\n     * Gets the property object for the specified type, which contains\n     * many useful methods.\n     *\n     * @param type  the field type to get the property for\n     * @return the property object\n     * @throws IllegalArgumentException if the field is null or unsupported\n     */"}}
{"code": {"body": "    public LocalDate toLocalDate() {\n        return new LocalDate(getYear(), getMonthOfYear(), getDayOfMonth(), getChronology());\n    }", "comment": "/**\n     * Converts this object to a LocalDate with the same date and chronology.\n     *\n     * @return a LocalDate with the same date and chronology\n     * @since 1.3\n     */"}}
{"code": {"body": "    public DateTime toDateTimeAtMidnight(DateTimeZone zone) {\n        Chronology chrono = getChronology().withZone(zone);\n        return new DateTime(getYear(), getMonthOfYear(), getDayOfMonth(), 0, 0, 0, 0, chrono);\n    }", "comment": "/**\n     * Converts this YearMonthDay to a full datetime at midnight using the\n     * specified time zone.\n     * <p>\n     * This method uses the chronology from this instance plus the time zone\n     * specified.\n     *\n     * @param zone  the zone to use, null means default\n     * @return this date as a datetime at midnight\n     */"}}
{"code": {"body": "    public DateTime toDateTimeAtCurrentTime(DateTimeZone zone) {\n        Chronology chrono = getChronology().withZone(zone);\n        long instantMillis = DateTimeUtils.currentTimeMillis();\n        long resolved = chrono.set(this, instantMillis);\n        return new DateTime(resolved, chrono);\n    }", "comment": "/**\n     * Converts this partial to a full datetime using the specified time zone\n     * setting the date fields from this instance and the time fields from\n     * the current time.\n     * <p>\n     * This method uses the chronology from this instance plus the time zone\n     * specified.\n     *\n     * @param zone  the zone to use, null means default\n     * @return this date as a datetime with the time as the current time\n     */"}}
{"code": {"body": "    public DateMidnight toDateMidnight(DateTimeZone zone) {\n        Chronology chrono = getChronology().withZone(zone);\n        return new DateMidnight(getYear(), getMonthOfYear(), getDayOfMonth(), chrono);\n    }", "comment": "/**\n     * Converts this object to a DateMidnight.\n     *\n     * @param zone  the zone to get the DateMidnight in, null means default\n     * @return the DateMidnight instance\n     */"}}
{"code": {"body": "    public DateTime toDateTime(TimeOfDay time, DateTimeZone zone) {\n        Chronology chrono = getChronology().withZone(zone);\n        long instant = DateTimeUtils.currentTimeMillis();\n        instant = chrono.set(this, instant);\n        if (time != null) {\n            instant = chrono.set(time, instant);\n        }\n        return new DateTime(instant, chrono);\n    }", "comment": "/**\n     * Converts this object to a DateTime using a TimeOfDay to fill in the\n     * missing fields.\n     * This instance is immutable and unaffected by this method call.\n     * <p>\n     * The resulting chronology is determined by the chronology of this\n     * YearMonthDay plus the time zone.\n     * The chronology of the time is ignored - only the field values are used.\n     *\n     * @param time  the time of day to use, null means current time\n     * @param zone  the zone to get the DateTime in, null means default\n     * @return the DateTime instance\n     */"}}
{"code": {"body": "    public Interval toInterval(DateTimeZone zone) {\n        zone = DateTimeUtils.getZone(zone);\n        return toDateMidnight(zone).toInterval();\n    }", "comment": "/**\n     * Converts this object to an Interval representing the whole day.\n     *\n     * @param zone  the zone to get the Interval in, null means default\n     * @return a interval over the day\n     */"}}
{"code": {"body": "    public int getYear() {\n        return getValue(YEAR);\n    }", "comment": "/**\n     * Get the year field value.\n     *\n     * @return the year\n     */"}}
{"code": {"body": "    public int getMonthOfYear() {\n        return getValue(MONTH_OF_YEAR);\n    }", "comment": "/**\n     * Get the month of year field value.\n     *\n     * @return the month of year\n     */"}}
{"code": {"body": "    public int getDayOfMonth() {\n        return getValue(DAY_OF_MONTH);\n    }", "comment": "/**\n     * Get the day of month field value.\n     *\n     * @return the day of month\n     */"}}
{"code": {"body": "    public YearMonthDay withYear(int year) {\n        int[] newValues = getValues();\n        newValues = getChronology().year().set(this, YEAR, newValues, year);\n        return new YearMonthDay(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this date with the year field updated.\n     * <p>\n     * YearMonthDay is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * year changed.\n     *\n     * @param year  the year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "    public YearMonthDay withMonthOfYear(int monthOfYear) {\n        int[] newValues = getValues();\n        newValues = getChronology().monthOfYear().set(this, MONTH_OF_YEAR, newValues, monthOfYear);\n        return new YearMonthDay(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this date with the month of year field updated.\n     * <p>\n     * YearMonthDay is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * month of year changed.\n     *\n     * @param monthOfYear  the month of year to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "    public YearMonthDay withDayOfMonth(int dayOfMonth) {\n        int[] newValues = getValues();\n        newValues = getChronology().dayOfMonth().set(this, DAY_OF_MONTH, newValues, dayOfMonth);\n        return new YearMonthDay(this, newValues);\n    }", "comment": "/**\n     * Returns a copy of this date with the day of month field updated.\n     * <p>\n     * YearMonthDay is immutable, so there are no set methods.\n     * Instead, this method returns a new instance with the value of\n     * day of month changed.\n     *\n     * @param dayOfMonth  the day of month to set\n     * @return a copy of this object with the field set\n     * @throws IllegalArgumentException if the value is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "    public Property year() {\n        return new Property(this, YEAR);\n    }", "comment": "/**\n     * Get the year field property which provides access to advanced functionality.\n     * \n     * @return the year property\n     */"}}
{"code": {"body": "    public Property monthOfYear() {\n        return new Property(this, MONTH_OF_YEAR);\n    }", "comment": "/**\n     * Get the month of year field property which provides access to advanced functionality.\n     * \n     * @return the month of year property\n     */"}}
{"code": {"body": "    public Property dayOfMonth() {\n        return new Property(this, DAY_OF_MONTH);\n    }", "comment": "/**\n     * Get the day of month field property which provides access to advanced functionality.\n     * \n     * @return the day of month property\n     */"}}
{"code": {"body": "    public String toString() {\n        return ISODateTimeFormat.yearMonthDay().print(this);\n    }", "comment": "/**\n     * Output the date in the ISO8601 format YYYY-MM-DD.\n     * \n     * @return ISO8601 formatted string\n     */"}}
{"code": {"body": "        protected ReadablePartial getReadablePartial() {\n            return iYearMonthDay;\n        }", "comment": "/**\n         * Gets the partial that this property belongs to.\n         * \n         * @return the partial\n         */"}}
{"code": {"body": "        public YearMonthDay getYearMonthDay() {\n            return iYearMonthDay;\n        }", "comment": "/**\n         * Gets the partial that this property belongs to.\n         * \n         * @return the partial\n         */"}}
{"code": {"body": "        public int get() {\n            return iYearMonthDay.getValue(iFieldIndex);\n        }", "comment": "/**\n         * Gets the value of this field.\n         * \n         * @return the field value\n         */"}}
{"code": {"body": "        public YearMonthDay addToCopy(int valueToAdd) {\n            int[] newValues = iYearMonthDay.getValues();\n            newValues = getField().add(iYearMonthDay, iFieldIndex, newValues, valueToAdd);\n            return new YearMonthDay(iYearMonthDay, newValues);\n        }", "comment": "/**\n         * Adds to the value of this field in a copy of this YearMonthDay.\n         * <p>\n         * The value will be added to this field. If the value is too large to be\n         * added solely to this field then it will affect larger fields.\n         * Smaller fields are unaffected.\n         * <p>\n         * If the result would be too large, beyond the maximum year, then an\n         * IllegalArgumentException is thrown.\n         * <p>\n         * The YearMonthDay attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param valueToAdd  the value to add to the field in the copy\n         * @return a copy of the YearMonthDay with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "        public YearMonthDay addWrapFieldToCopy(int valueToAdd) {\n            int[] newValues = iYearMonthDay.getValues();\n            newValues = getField().addWrapField(iYearMonthDay, iFieldIndex, newValues, valueToAdd);\n            return new YearMonthDay(iYearMonthDay, newValues);\n        }", "comment": "/**\n         * Adds to the value of this field in a copy of this YearMonthDay wrapping\n         * within this field if the maximum value is reached.\n         * <p>\n         * The value will be added to this field. If the value is too large to be\n         * added solely to this field then it wraps within this field.\n         * Other fields are unaffected.\n         * <p>\n         * For example,\n         * <code>2004-12-20</code> addWrapField one month returns <code>2004-01-20</code>.\n         * <p>\n         * The YearMonthDay attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param valueToAdd  the value to add to the field in the copy\n         * @return a copy of the YearMonthDay with the field value changed\n         * @throws IllegalArgumentException if the value isn't valid\n         */"}}
{"code": {"body": "        public YearMonthDay setCopy(String text) {\n            return setCopy(text, null);\n        }", "comment": "/**\n         * Sets this field in a copy of the YearMonthDay to a parsed text value.\n         * <p>\n         * The YearMonthDay attached to this property is unchanged by this call.\n         * Instead, a new instance is returned.\n         * \n         * @param text  the text value to set\n         * @return a copy of the YearMonthDay with the field value changed\n         * @throws IllegalArgumentException if the text value isn't valid\n         */"}}
{"code": {"body": "        public YearMonthDay withMaximumValue() {\n            return setCopy(getMaximumValue());\n        }", "comment": "/**\n         * Returns a new YearMonthDay with this field set to the maximum value\n         * for this field.\n         * <p>\n         * This operation is useful for obtaining a DateTime on the last day\n         * of the month, as month lengths vary.\n         * <pre>\n         * YearMonthDay lastDayOfMonth = dt.dayOfMonth().withMaximumValue();\n         * </pre>\n         * <p>\n         * The YearMonthDay attached to this property is unchanged by this call.\n         *\n         * @return a copy of the YearMonthDay with this field set to its maximum\n         * @since 1.2\n         */"}}
{"code": {"body": "        public YearMonthDay withMinimumValue() {\n            return setCopy(getMinimumValue());\n        }", "comment": "/**\n         * Returns a new YearMonthDay with this field set to the minimum value\n         * for this field.\n         * <p>\n         * The YearMonthDay attached to this property is unchanged by this call.\n         *\n         * @return a copy of the YearMonthDay with this field set to its minimum\n         * @since 1.2\n         */"}}
{"code": {"body": "public Years plus(int years) {\n        if (years == 0) {\n            return this;\n        }\n        return Years.years(FieldUtils.safeAdd(getValue(), years));\n    }", "comment": "/**\n     * Returns a new instance with the specified number of years added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param years  the amount of years to add, may be negative\n     * @return the new period plus the specified number of years\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "public Years plus(Years years) {\n        if (years == null) {\n            return this;\n        }\n        return plus(years.getValue());\n    }", "comment": "/**\n     * Returns a new instance with the specified number of years added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param years  the amount of years to add, may be negative, null means zero\n     * @return the new period plus the specified number of years\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "public Years minus(int years) {\n        return plus(FieldUtils.safeNegate(years));\n    }", "comment": "/**\n     * Returns a new instance with the specified number of years taken away.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param years  the amount of years to take away, may be negative\n     * @return the new period minus the specified number of years\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "public Years minus(Years years) {\n        if (years == null) {\n            return this;\n        }\n        return minus(years.getValue());\n    }", "comment": "/**\n     * Returns a new instance with the specified number of years taken away.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param years  the amount of years to take away, may be negative, null means zero\n     * @return the new period minus the specified number of years\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "public Years multipliedBy(int scalar) {\n        return Years.years(FieldUtils.safeMultiply(getValue(), scalar));\n    }", "comment": "/**\n     * Returns a new instance with the years multiplied by the specified scalar.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param scalar  the amount to multiply by, may be negative\n     * @return the new period multiplied by the specified scalar\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "public Years dividedBy(int divisor) {\n        if (divisor == 1) {\n            return this;\n        }\n        return Years.years(getValue() / divisor);\n    }", "comment": "/**\n     * Returns a new instance with the years divided by the specified divisor.\n     * The calculation uses integer division, thus 3 divided by 2 is 1.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param divisor  the amount to divide by, may be negative\n     * @return the new period divided by the specified divisor\n     * @throws ArithmeticException if the divisor is zero\n     */"}}
{"code": {"body": "public Years negated() {\n        return Years.years(FieldUtils.safeNegate(getValue()));\n    }", "comment": "/**\n     * Returns a new instance with the years value negated.\n     *\n     * @return the new period with a negated value\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "    public static Years years(int years) {\n        switch (years) {\n            case 0:\n                return ZERO;\n            case 1:\n                return ONE;\n            case 2:\n                return TWO;\n            case 3:\n                return THREE;\n            case Integer.MAX_VALUE:\n                return MAX_VALUE;\n            case Integer.MIN_VALUE:\n                return MIN_VALUE;\n            default:\n                return new Years(years);\n        }\n    }", "comment": "/**\n     * Obtains an instance of <code>Years</code> that may be cached.\n     * <code>Years</code> is immutable, so instances can be cached and shared.\n     * This factory method provides access to shared instances.\n     *\n     * @param years  the number of years to obtain an instance for\n     * @return the instance of Years\n     */"}}
{"code": {"body": "    public static Years yearsBetween(ReadablePartial start, ReadablePartial end) {\n        if (start instanceof LocalDate && end instanceof LocalDate)   {\n            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n            int years = chrono.years().getDifference(\n                    ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n            return Years.years(years);\n        }\n        int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\n        return Years.years(amount);\n    }", "comment": "/**\n     * Creates a <code>Years</code> representing the number of whole years\n     * between the two specified partial datetimes.\n     * <p>\n     * The two partials must contain the same fields, for example you can specify\n     * two <code>LocalDate</code> objects.\n     *\n     * @param start  the start partial date, must not be null\n     * @param end  the end partial date, must not be null\n     * @return the period in years\n     * @throws IllegalArgumentException if the partials are null or invalid\n     */"}}
{"code": {"body": "    public static Years yearsIn(ReadableInterval interval) {\n        if (interval == null)   {\n            return Years.ZERO;\n        }\n        int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.years());\n        return Years.years(amount);\n    }", "comment": "/**\n     * Creates a <code>Years</code> representing the number of whole years\n     * in the specified interval. This method corectly handles any daylight\n     * savings time changes that may occur during the interval.\n     *\n     * @param interval  the interval to extract years from, null returns zero\n     * @return the period in years\n     * @throws IllegalArgumentException if the partials are null or invalid\n     */"}}
{"code": {"body": "    private Object readResolve() {\n        return Years.years(getValue());\n    }", "comment": "/**\n     * Resolves singletons.\n     * \n     * @return the singleton instance\n     */"}}
{"code": {"body": "    public DurationFieldType getFieldType() {\n        return DurationFieldType.years();\n    }", "comment": "/**\n     * Gets the duration field type, which is <code>years</code>.\n     *\n     * @return the period type\n     */"}}
{"code": {"body": "    public PeriodType getPeriodType() {\n        return PeriodType.years();\n    }", "comment": "/**\n     * Gets the period type, which is <code>years</code>.\n     *\n     * @return the period type\n     */"}}
{"code": {"body": "    public int getYears() {\n        return getValue();\n    }", "comment": "/**\n     * Gets the number of years that this period represents.\n     *\n     * @return the number of years in the period\n     */"}}
{"code": {"body": "    public Years plus(Years years) {\n        if (years == null) {\n            return this;\n        }\n        return plus(years.getValue());\n    }", "comment": "/**\n     * Returns a new instance with the specified number of years added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param years  the amount of years to add, may be negative, null means zero\n     * @return the new period plus the specified number of years\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "    public Years minus(Years years) {\n        if (years == null) {\n            return this;\n        }\n        return minus(years.getValue());\n    }", "comment": "/**\n     * Returns a new instance with the specified number of years taken away.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param years  the amount of years to take away, may be negative, null means zero\n     * @return the new period minus the specified number of years\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "    public Years multipliedBy(int scalar) {\n        return Years.years(FieldUtils.safeMultiply(getValue(), scalar));\n    }", "comment": "/**\n     * Returns a new instance with the years multiplied by the specified scalar.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param scalar  the amount to multiply by, may be negative\n     * @return the new period multiplied by the specified scalar\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "    public Years dividedBy(int divisor) {\n        if (divisor == 1) {\n            return this;\n        }\n        return Years.years(getValue() / divisor);\n    }", "comment": "/**\n     * Returns a new instance with the years divided by the specified divisor.\n     * The calculation uses integer division, thus 3 divided by 2 is 1.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param divisor  the amount to divide by, may be negative\n     * @return the new period divided by the specified divisor\n     * @throws ArithmeticException if the divisor is zero\n     */"}}
{"code": {"body": "    public Years negated() {\n        return Years.years(FieldUtils.safeNegate(getValue()));\n    }", "comment": "/**\n     * Returns a new instance with the years value negated.\n     *\n     * @return the new period with a negated value\n     * @throws ArithmeticException if the result overflows an int\n     */"}}
{"code": {"body": "    public boolean isGreaterThan(Years other) {\n        if (other == null) {\n            return getValue() > 0;\n        }\n        return getValue() > other.getValue();\n    }", "comment": "/**\n     * Is this years instance greater than the specified number of years.\n     *\n     * @param other  the other period, null means zero\n     * @return true if this years instance is greater than the specified one\n     */"}}
{"code": {"body": "    public boolean isLessThan(Years other) {\n        if (other == null) {\n            return getValue() < 0;\n        }\n        return getValue() < other.getValue();\n    }", "comment": "/**\n     * Is this years instance less than the specified number of years.\n     *\n     * @param other  the other period, null means zero\n     * @return true if this years instance is less than the specified one\n     */"}}
{"code": {"body": "    public int get(DateTimeFieldType type) {\n        if (type == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        return type.getField(getChronology()).get(getMillis());\n    }", "comment": "/**\n     * Get the value of one of the fields of a datetime.\n     * <p>\n     * This method uses the chronology of the datetime to obtain the value.\n     * It is essentially a generic way of calling one of the get methods.\n     *\n     * @param type  a field type, usually obtained from DateTimeFieldType\n     * @return the value of that field\n     * @throws IllegalArgumentException if the field type is null\n     */"}}
{"code": {"body": "    public int getEra() {\n        return getChronology().era().get(getMillis());\n    }", "comment": "/**\n     * Get the era field value.\n     * \n     * @return the era\n     */"}}
{"code": {"body": "    public int getCenturyOfEra() {\n        return getChronology().centuryOfEra().get(getMillis());\n    }", "comment": "/**\n     * Get the year of era field value.\n     * \n     * @return the year of era\n     */"}}
{"code": {"body": "    public int getYearOfEra() {\n        return getChronology().yearOfEra().get(getMillis());\n    }", "comment": "/**\n     * Get the year of era field value.\n     * \n     * @return the year of era\n     */"}}
{"code": {"body": "    public int getYearOfCentury() {\n        return getChronology().yearOfCentury().get(getMillis());\n    }", "comment": "/**\n     * Get the year of century field value.\n     * \n     * @return the year of century\n     */"}}
{"code": {"body": "    public int getYear() {\n        return getChronology().year().get(getMillis());\n    }", "comment": "/**\n     * Get the year field value.\n     * \n     * @return the year\n     */"}}
{"code": {"body": "    public int getWeekyear() {\n        return getChronology().weekyear().get(getMillis());\n    }", "comment": "/**\n     * Get the weekyear field value.\n     * <p>\n     * The weekyear is the year that matches with the weekOfWeekyear field.\n     * In the standard ISO8601 week algorithm, the first week of the year\n     * is that in which at least 4 days are in the year. As a result of this\n     * definition, day 1 of the first week may be in the previous year.\n     * The weekyear allows you to query the effective year for that day.\n     * \n     * @return the year of a week based year\n     */"}}
{"code": {"body": "    public int getMonthOfYear() {\n        return getChronology().monthOfYear().get(getMillis());\n    }", "comment": "/**\n     * Get the month of year field value.\n     * \n     * @return the month of year\n     */"}}
{"code": {"body": "    public int getWeekOfWeekyear() {\n        return getChronology().weekOfWeekyear().get(getMillis());\n    }", "comment": "/**\n     * Get the week of weekyear field value.\n     * <p>\n     * This field is associated with the \"weekyear\" via {@link #getWeekyear()}.\n     * In the standard ISO8601 week algorithm, the first week of the year\n     * is that in which at least 4 days are in the year. As a result of this\n     * definition, day 1 of the first week may be in the previous year.\n     * \n     * @return the week of a week based year\n     */"}}
{"code": {"body": "    public int getDayOfYear() {\n        return getChronology().dayOfYear().get(getMillis());\n    }", "comment": "/**\n     * Get the day of year field value.\n     * \n     * @return the day of year\n     */"}}
{"code": {"body": "    public int getDayOfMonth() {\n        return getChronology().dayOfMonth().get(getMillis());\n    }", "comment": "/**\n     * Get the day of month field value.\n     * <p>\n     * The values for the day of month are defined in {@link org.joda.time.DateTimeConstants}.\n     * \n     * @return the day of month\n     */"}}
{"code": {"body": "    public int getDayOfWeek() {\n        return getChronology().dayOfWeek().get(getMillis());\n    }", "comment": "/**\n     * Get the day of week field value.\n     * <p>\n     * The values for the day of week are defined in {@link org.joda.time.DateTimeConstants}.\n     * \n     * @return the day of week\n     */"}}
{"code": {"body": "    public int getHourOfDay() {\n        return getChronology().hourOfDay().get(getMillis());\n    }", "comment": "/**\n     * Get the hour of day field value.\n     *\n     * @return the hour of day\n     */"}}
{"code": {"body": "    public int getMinuteOfDay() {\n        return getChronology().minuteOfDay().get(getMillis());\n    }", "comment": "/**\n     * Get the minute of day field value.\n     *\n     * @return the minute of day\n     */"}}
{"code": {"body": "    public int getMinuteOfHour() {\n        return getChronology().minuteOfHour().get(getMillis());\n    }", "comment": "/**\n     * Get the minute of hour field value.\n     *\n     * @return the minute of hour\n     */"}}
{"code": {"body": "    public int getSecondOfDay() {\n        return getChronology().secondOfDay().get(getMillis());\n    }", "comment": "/**\n     * Get the second of day field value.\n     *\n     * @return the second of day\n     */"}}
{"code": {"body": "    public int getSecondOfMinute() {\n        return getChronology().secondOfMinute().get(getMillis());\n    }", "comment": "/**\n     * Get the second of minute field value.\n     *\n     * @return the second of minute\n     */"}}
{"code": {"body": "    public int getMillisOfDay() {\n        return getChronology().millisOfDay().get(getMillis());\n    }", "comment": "/**\n     * Get the millis of day field value.\n     *\n     * @return the millis of day\n     */"}}
{"code": {"body": "    public int getMillisOfSecond() {\n        return getChronology().millisOfSecond().get(getMillis());\n    }", "comment": "/**\n     * Get the millis of second field value.\n     *\n     * @return the millis of second\n     */"}}
{"code": {"body": "    public Calendar toCalendar(Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        DateTimeZone zone = getZone();\n        Calendar cal = Calendar.getInstance(zone.toTimeZone(), locale);\n        cal.setTime(toDate());\n        return cal;\n    }", "comment": "/**\n     * Get the date time as a <code>java.util.Calendar</code>, assigning\n     * exactly the same millisecond instant.\n     * The locale is passed in, enabling Calendar to select the correct\n     * localized subclass.\n     * <p>\n     * The JDK and Joda-Time both have time zone implementations and these\n     * differ in accuracy. Joda-Time's implementation is generally more up to\n     * date and thus more accurate - for example JDK1.3 has no historical data.\n     * The effect of this is that the field values of the <code>Calendar</code>\n     * may differ from those of this object, even though the milliseond value\n     * is the same. Most of the time this just means that the JDK field values\n     * are wrong, as our time zone information is more up to date.\n     *\n     * @param locale  the locale to get the Calendar for, or default if null\n     * @return a localized Calendar initialised with this datetime\n     */"}}
{"code": {"body": "    public GregorianCalendar toGregorianCalendar() {\n        DateTimeZone zone = getZone();\n        GregorianCalendar cal = new GregorianCalendar(zone.toTimeZone());\n        cal.setTime(toDate());\n        return cal;\n    }", "comment": "/**\n     * Get the date time as a <code>java.util.GregorianCalendar</code>,\n     * assigning exactly the same millisecond instant.\n     * <p>\n     * The JDK and Joda-Time both have time zone implementations and these\n     * differ in accuracy. Joda-Time's implementation is generally more up to\n     * date and thus more accurate - for example JDK1.3 has no historical data.\n     * The effect of this is that the field values of the <code>Calendar</code>\n     * may differ from those of this object, even though the milliseond value\n     * is the same. Most of the time this just means that the JDK field values\n     * are wrong, as our time zone information is more up to date.\n     *\n     * @return a GregorianCalendar initialised with this datetime\n     */"}}
{"code": {"body": "    public String toString(String pattern, Locale locale) throws IllegalArgumentException {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n    }", "comment": "/**\n     * Output the instant using the specified format pattern.\n     *\n     * @param pattern  the pattern specification, null means use <code>toString</code>\n     * @param locale  Locale to use, null means default\n     * @see  org.joda.time.format.DateTimeFormat\n     */"}}
{"code": {"body": "    public Duration toDuration() {\n        return new Duration(getMillis());\n    }", "comment": "/**\n     * Get this duration as an immutable <code>Duration</code> object.\n     * \n     * @return a Duration created using the millisecond duration from this instance\n     */"}}
{"code": {"body": "    public Period toPeriod() {\n        return new Period(getMillis());\n    }", "comment": "/**\n     * Converts this duration to a Period instance using the standard period type\n     * and the ISO chronology.\n     * <p>\n     * Only precise fields in the period type will be used. Thus, only the hour,\n     * minute, second and millisecond fields on the period will be used.\n     * The year, month, week and day fields will not be populated.\n     * <p>\n     * If the duration is small, less than one day, then this method will perform\n     * as you might expect and split the fields evenly.\n     * If the duration is larger than one day then all the remaining duration will\n     * be stored in the largest available field, hours in this case.\n     * <p>\n     * For example, a duration effectively equal to (365 + 60 + 5) days will be\n     * converted to ((365 + 60 + 5) * 24) hours by this constructor.\n     * <p>\n     * For more control over the conversion process, you must pair the duration with\n     * an instant, see {@link Period#Period(ReadableInstant,ReadableDuration)}.\n     * \n     * @return a Period created using the millisecond duration from this instance\n     */"}}
{"code": {"body": "    public int compareTo(ReadableDuration other) {\n        long thisMillis = this.getMillis();\n        long otherMillis = other.getMillis();\n        \n        \n        if (thisMillis < otherMillis) {\n            return -1;\n        }\n        if (thisMillis > otherMillis) {\n            return 1;\n        }\n        return 0;\n    }", "comment": "/**\n     * Compares this duration with the specified duration based on length.\n     *\n     * @param other  a duration to check against\n     * @return negative value if this is less, 0 if equal, or positive value if greater\n     * @throws NullPointerException if the object is null\n     * @throws ClassCastException if the given object is not supported\n     */"}}
{"code": {"body": "    public boolean isEqual(ReadableDuration duration) {\n        if (duration == null) {\n            duration = Duration.ZERO;\n        }\n        return compareTo(duration) == 0;\n    }", "comment": "/**\n     * Is the length of this duration equal to the duration passed in.\n     *\n     * @param duration  another duration to compare to, null means zero milliseconds\n     * @return true if this duration is equal to than the duration passed in\n     */"}}
{"code": {"body": "    public boolean isLongerThan(ReadableDuration duration) {\n        if (duration == null) {\n            duration = Duration.ZERO;\n        }\n        return compareTo(duration) > 0;\n    }", "comment": "/**\n     * Is the length of this duration longer than the duration passed in.\n     *\n     * @param duration  another duration to compare to, null means zero milliseconds\n     * @return true if this duration is equal to than the duration passed in\n     */"}}
{"code": {"body": "    public boolean isShorterThan(ReadableDuration duration) {\n        if (duration == null) {\n            duration = Duration.ZERO;\n        }\n        return compareTo(duration) < 0;\n    }", "comment": "/**\n     * Is the length of this duration shorter than the duration passed in.\n     *\n     * @param duration  another duration to compare to, null means zero milliseconds\n     * @return true if this duration is equal to than the duration passed in\n     */"}}
{"code": {"body": "    public boolean equals(Object duration) {\n        if (this == duration) {\n            return true;\n        }\n        if (duration instanceof ReadableDuration == false) {\n            return false;\n        }\n        ReadableDuration other = (ReadableDuration) duration;\n        return (getMillis() == other.getMillis());\n    }", "comment": "/**\n     * Compares this object with the specified object for equality based\n     * on the millisecond length. All ReadableDuration instances are accepted.\n     *\n     * @param duration  a readable duration to check against\n     * @return true if the length of the duration is equal\n     */"}}
{"code": {"body": "    public int hashCode() {\n        long len = getMillis();\n        return (int) (len ^ (len >>> 32));\n    }", "comment": "/**\n     * Gets a hash code for the duration that is compatible with the \n     * equals method.\n     *\n     * @return a hash code\n     */"}}
{"code": {"body": "    public DateTimeZone getZone() {\n        return getChronology().getZone();\n    }", "comment": "/**\n     * Gets the time zone of the instant from the chronology.\n     * \n     * @return the DateTimeZone that the instant is using, never null\n     */"}}
{"code": {"body": "    public int get(DateTimeField field) {\n        if (field == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        return field.get(getMillis());\n    }", "comment": "/**\n     * Get the value of one of the fields of a datetime.\n     * <p>\n     * This could be used to get a field using a different Chronology.\n     * For example:\n     * <pre>\n     * Instant dt = new Instant();\n     * int gjYear = dt.get(Chronology.getCoptic().year());\n     * </pre>\n     * \n     * @param field  the DateTimeField to use, not null\n     * @return the value\n     * @throws IllegalArgumentException if the field is null\n     */"}}
{"code": {"body": "    public boolean isSupported(DateTimeFieldType type) {\n        if (type == null) {\n            return false;\n        }\n        return type.getField(getChronology()).isSupported();\n    }", "comment": "/**\n     * Checks if the field type specified is supported by this instant and chronology.\n     * This can be used to avoid exceptions in {@link #get(DateTimeFieldType)}.\n     *\n     * @param type  a field type, usually obtained from DateTimeFieldType\n     * @return true if the field type is supported\n     */"}}
{"code": {"body": "    public Instant toInstant() {\n        return new Instant(getMillis());\n    }", "comment": "/**\n     * Get this object as an Instant.\n     * \n     * @return an Instant using the same millis\n     */"}}
{"code": {"body": "    public DateTime toDateTime(Chronology chronology) {\n        return new DateTime(getMillis(), chronology);\n    }", "comment": "/**\n     * Get this object as a DateTime using the given chronology and its zone.\n     * \n     * @param chronology chronology to apply, or ISOChronology if null\n     * @return a DateTime using the same millis\n     */"}}
{"code": {"body": "    public DateTime toDateTimeISO() {\n        return new DateTime(getMillis(), ISOChronology.getInstance(getZone()));\n    }", "comment": "/**\n     * Get this object as a DateTime using ISOChronology in the same zone.\n     *\n     * @return a DateTime using the same millis with ISOChronology\n     */"}}
{"code": {"body": "    public MutableDateTime toMutableDateTime(Chronology chronology) {\n        return new MutableDateTime(getMillis(), chronology);\n    }", "comment": "/**\n     * Get this object as a MutableDateTime using the given chronology and its zone.\n     * \n     * @param chronology chronology to apply, or ISOChronology if null\n     * @return a MutableDateTime using the same millis\n     */"}}
{"code": {"body": "    public MutableDateTime toMutableDateTimeISO() {\n        return new MutableDateTime(getMillis(), ISOChronology.getInstance(getZone()));\n    }", "comment": "/**\n     * Get this object as a MutableDateTime using ISOChronology in the same zone.\n     *\n     * @return a MutableDateTime using the same millis with ISOChronology\n     */"}}
{"code": {"body": "    public Date toDate() {\n        return new Date(getMillis());\n    }", "comment": "/**\n     * Get the date time as a <code>java.util.Date</code>.\n     * <p>\n     * The <code>Date</code> object created has exactly the same millisecond\n     * instant as this object.\n     *\n     * @return a Date initialised with this datetime\n     */"}}
{"code": {"body": "    public boolean equals(Object readableInstant) {\n        \n        if (this == readableInstant) {\n            return true;\n        }\n        if (readableInstant instanceof ReadableInstant == false) {\n            return false;\n        }\n        ReadableInstant otherInstant = (ReadableInstant) readableInstant;\n        return\n            getMillis() == otherInstant.getMillis() &&\n            FieldUtils.equals(getChronology(), otherInstant.getChronology());\n    }", "comment": "/**\n     * Compares this object with the specified object for equality based\n     * on the millisecond instant, chronology and time zone.\n     * <p>\n     * Two objects which represent the same instant in time, but are in\n     * different time zones (based on time zone id), will be considered to\n     * be different. Only two objects with the same {@link DateTimeZone},\n     * {@link Chronology} and instant are equal.\n     * <p>\n     * See {@link #isEqual(ReadableInstant)} for an equals method that\n     * ignores the Chronology and time zone.\n     * <p>\n     * All ReadableInstant instances are accepted.\n     *\n     * @param readableInstant  a readable instant to check against\n     * @return true if millisecond and chronology are equal, false if\n     *  not or the instant is null or of an incorrect type\n     */"}}
{"code": {"body": "    public int hashCode() {\n        \n        return\n            ((int) (getMillis() ^ (getMillis() >>> 32))) +\n            (getChronology().hashCode());\n    }", "comment": "/**\n     * Gets a hash code for the instant as defined in <code>ReadableInstant</code>.\n     *\n     * @return a suitable hash code\n     */"}}
{"code": {"body": "    public int compareTo(ReadableInstant other) {\n        if (this == other) {\n            return 0;\n        }\n        \n        long otherMillis = other.getMillis();\n        long thisMillis = getMillis();\n        \n        \n        if (thisMillis == otherMillis) {\n            return 0;\n        }\n        if (thisMillis < otherMillis) {\n            return -1;\n        } else {\n            return 1;\n        }\n    }", "comment": "/**\n     * Compares this object with the specified object for ascending\n     * millisecond instant order. This ordering is inconsistent with\n     * equals, as it ignores the Chronology.\n     * <p>\n     * All ReadableInstant instances are accepted.\n     *\n     * @param other  a readable instant to check against\n     * @return negative value if this is less, 0 if equal, or positive value if greater\n     * @throws NullPointerException if the object is null\n     * @throws ClassCastException if the object type is not supported\n     */"}}
{"code": {"body": "    public boolean isAfter(ReadableInstant instant) {\n        long instantMillis = DateTimeUtils.getInstantMillis(instant);\n        return isAfter(instantMillis);\n    }", "comment": "/**\n     * Is this instant after the instant passed in\n     * comparing solely by millisecond.\n     *\n     * @param instant  an instant to check against, null means now\n     * @return true if the instant is after the instant passed in\n     */"}}
{"code": {"body": "    public boolean isAfterNow() {\n        return isAfter(DateTimeUtils.currentTimeMillis());\n    }", "comment": "/**\n     * Is this instant after the current instant\n     * comparing solely by millisecond.\n     * \n     * @return true if this instant is after the current instant\n     */"}}
{"code": {"body": "    public boolean isBefore(ReadableInstant instant) {\n        long instantMillis = DateTimeUtils.getInstantMillis(instant);\n        return isBefore(instantMillis);\n    }", "comment": "/**\n     * Is this instant before the instant passed in\n     * comparing solely by millisecond.\n     *\n     * @param instant  an instant to check against, null means now\n     * @return true if the instant is before the instant passed in\n     */"}}
{"code": {"body": "    public boolean isBeforeNow() {\n        return isBefore(DateTimeUtils.currentTimeMillis());\n    }", "comment": "/**\n     * Is this instant before the current instant\n     * comparing solely by millisecond.\n     * \n     * @return true if this instant is before the current instant\n     */"}}
{"code": {"body": "    public boolean isEqual(ReadableInstant instant) {\n        long instantMillis = DateTimeUtils.getInstantMillis(instant);\n        return isEqual(instantMillis);\n    }", "comment": "/**\n     * Is this instant equal to the instant passed in\n     * comparing solely by millisecond.\n     *\n     * @param instant  an instant to check against, null means now\n     * @return true if the instant is equal to the instant passed in\n     */"}}
{"code": {"body": "    public boolean isEqualNow() {\n        return isEqual(DateTimeUtils.currentTimeMillis());\n    }", "comment": "/**\n     * Is this instant equal to the current instant\n     * comparing solely by millisecond.\n     * \n     * @return true if this instant is before the current instant\n     */"}}
{"code": {"body": "    public String toString(DateTimeFormatter formatter) {\n        if (formatter == null) {\n            return toString();\n        }\n        return formatter.print(this);\n    }", "comment": "/**\n     * Uses the specified formatter to convert this partial to a String.\n     *\n     * @param formatter  the formatter to use, null means use <code>toString()</code>.\n     * @return the formatted string\n     * @since 1.1\n     */"}}
{"code": {"body": "    protected void checkInterval(long start, long end) {\n        if (end < start) {\n            throw new IllegalArgumentException(\"\");\n        }\n    }", "comment": "/**\n     * Validates an interval.\n     * \n     * @param start  the start instant in milliseconds\n     * @param end  the end instant in milliseconds\n     * @throws IllegalArgumentException if the interval is invalid\n     */"}}
{"code": {"body": "    public DateTime getStart() {\n        return new DateTime(getStartMillis(), getChronology());\n    }", "comment": "/**\n     * Gets the start of this time interval, which is inclusive, as a DateTime.\n     *\n     * @return the start of the time interval\n     */"}}
{"code": {"body": "    public DateTime getEnd() {\n        return new DateTime(getEndMillis(), getChronology());\n    }", "comment": "/** \n     * Gets the end of this time interval, which is exclusive, as a DateTime.\n     *\n     * @return the end of the time interval\n     */"}}
{"code": {"body": "    public boolean contains(ReadableInterval interval) {\n        if (interval == null) {\n            return containsNow();\n        }\n        long otherStart = interval.getStartMillis();\n        long otherEnd = interval.getEndMillis();\n        long thisStart = getStartMillis();\n        long thisEnd = getEndMillis();\n        return (thisStart <= otherStart && otherStart < thisEnd && otherEnd <= thisEnd);\n    }", "comment": "/**\n     * Does this time interval contain the specified time interval.\n     * <p>\n     * Non-zero duration intervals are inclusive of the start instant and\n     * exclusive of the end. The other interval is contained if this interval\n     * wholly contains, starts, finishes or equals it.\n     * A zero duration interval cannot contain anything.\n     * <p>\n     * When two intervals are compared the result is one of three states:\n     * (a) they abut, (b) there is a gap between them, (c) they overlap.\n     * The <code>contains</code> method is not related to these states.\n     * In particular, a zero duration interval is contained at the start of\n     * a larger interval, but does not overlap (it abuts instead).\n     * <p>\n     * For example:\n     * <pre>\n     * [09:00 to 10:00) contains [09:00 to 10:00)  = true\n     * [09:00 to 10:00) contains [09:00 to 09:30)  = true\n     * [09:00 to 10:00) contains [09:30 to 10:00)  = true\n     * [09:00 to 10:00) contains [09:15 to 09:45)  = true\n     * [09:00 to 10:00) contains [09:00 to 09:00)  = true\n     * \n     * [09:00 to 10:00) contains [08:59 to 10:00)  = false (otherStart before thisStart)\n     * [09:00 to 10:00) contains [09:00 to 10:01)  = false (otherEnd after thisEnd)\n     * [09:00 to 10:00) contains [10:00 to 10:00)  = false (otherStart equals thisEnd)\n     * \n     * [14:00 to 14:00) contains [14:00 to 14:00)  = false (zero duration contains nothing)\n     * </pre>\n     * Passing in a <code>null</code> parameter will have the same effect as\n     * calling {@link #containsNow()}.\n     *\n     * @param interval  the time interval to compare to, null means a zero duration interval now\n     * @return true if this time interval contains the time interval\n     */"}}
{"code": {"body": "    public boolean containsNow() {\n        return contains(DateTimeUtils.currentTimeMillis());\n    }", "comment": "/**\n     * Does this time interval contain the current instant.\n     * <p>\n     * Non-zero duration intervals are inclusive of the start instant and\n     * exclusive of the end. A zero duration interval cannot contain anything.\n     *\n     * @return true if this time interval contains the current instant\n     */"}}
{"code": {"body": "    public boolean overlaps(ReadableInterval interval) {\n        long thisStart = getStartMillis();\n        long thisEnd = getEndMillis();\n        if (interval == null) {\n            long now = DateTimeUtils.currentTimeMillis();\n            return (thisStart < now && now < thisEnd);\n        }  else {\n            long otherStart = interval.getStartMillis();\n            long otherEnd = interval.getEndMillis();\n            return (thisStart < otherEnd && otherStart < thisEnd);\n        }\n    }", "comment": "/**\n     * Does this time interval overlap the specified time interval.\n     * <p>\n     * Intervals are inclusive of the start instant and exclusive of the end.\n     * An interval overlaps another if it shares some common part of the\n     * datetime continuum. \n     * <p>\n     * When two intervals are compared the result is one of three states:\n     * (a) they abut, (b) there is a gap between them, (c) they overlap.\n     * The abuts state takes precedence over the other two, thus a zero duration\n     * interval at the start of a larger interval abuts and does not overlap.\n     * <p>\n     * For example:\n     * <pre>\n     * [09:00 to 10:00) overlaps [08:00 to 08:30)  = false (completely before)\n     * [09:00 to 10:00) overlaps [08:00 to 09:00)  = false (abuts before)\n     * [09:00 to 10:00) overlaps [08:00 to 09:30)  = true\n     * [09:00 to 10:00) overlaps [08:00 to 10:00)  = true\n     * [09:00 to 10:00) overlaps [08:00 to 11:00)  = true\n     * \n     * [09:00 to 10:00) overlaps [09:00 to 09:00)  = false (abuts before)\n     * [09:00 to 10:00) overlaps [09:00 to 09:30)  = true\n     * [09:00 to 10:00) overlaps [09:00 to 10:00)  = true\n     * [09:00 to 10:00) overlaps [09:00 to 11:00)  = true\n     * \n     * [09:00 to 10:00) overlaps [09:30 to 09:30)  = true\n     * [09:00 to 10:00) overlaps [09:30 to 10:00)  = true\n     * [09:00 to 10:00) overlaps [09:30 to 11:00)  = true\n     * \n     * [09:00 to 10:00) overlaps [10:00 to 10:00)  = false (abuts after)\n     * [09:00 to 10:00) overlaps [10:00 to 11:00)  = false (abuts after)\n     * \n     * [09:00 to 10:00) overlaps [10:30 to 11:00)  = false (completely after)\n     * \n     * [14:00 to 14:00) overlaps [14:00 to 14:00)  = false (abuts before and after)\n     * [14:00 to 14:00) overlaps [13:00 to 15:00)  = true\n     * </pre>\n     *\n     * @param interval  the time interval to compare to, null means a zero length interval now\n     * @return true if the time intervals overlap\n     */"}}
{"code": {"body": "    public boolean isEqual(ReadableInterval other) {\n        return getStartMillis() == other.getStartMillis() &&\n                getEndMillis() == other.getEndMillis();\n    }", "comment": "/**\n     * Is this interval equal to the specified interval ignoring the chronology.\n     * <p>\n     * This compares the underlying instants, ignoring the chronology.\n     *\n     * @param other  a readable interval to check against\n     * @return true if the intervals are equal comparing the start and end millis\n     * @since 2.3\n     */"}}
{"code": {"body": "    public boolean isBefore(ReadableInterval interval) {\n        if (interval == null) {\n            return isBeforeNow();\n        }\n        return isBefore(interval.getStartMillis());\n    }", "comment": "/**\n     * Is this time interval entirely before the specified instant.\n     * <p>\n     * Intervals are inclusive of the start instant and exclusive of the end.\n     * \n     * @param interval  the interval to compare to, null means now\n     * @return true if this time interval is before the interval specified\n     */"}}
{"code": {"body": "    public boolean isBeforeNow() {\n        return isBefore(DateTimeUtils.currentTimeMillis());\n    }", "comment": "/**\n     * Is this time interval before the current instant.\n     * <p>\n     * Intervals are inclusive of the start instant and exclusive of the end.\n     * \n     * @return true if this time interval is before the current instant\n     */"}}
{"code": {"body": "    public boolean isAfter(ReadableInterval interval) {\n        long endMillis;\n        if (interval == null) {\n            endMillis = DateTimeUtils.currentTimeMillis();\n        } else {\n            endMillis = interval.getEndMillis();\n        }\n        return (getStartMillis() >= endMillis);\n    }", "comment": "/**\n     * Is this time interval entirely after the specified interval.\n     * <p>\n     * Intervals are inclusive of the start instant and exclusive of the end.\n     * Only the end time of the specified interval is used in the comparison.\n     * \n     * @param interval  the interval to compare to, null means now\n     * @return true if this time interval is after the interval specified\n     */"}}
{"code": {"body": "    public boolean isAfterNow() {\n        return isAfter(DateTimeUtils.currentTimeMillis());\n    }", "comment": "/**\n     * Is this time interval after the current instant.\n     * <p>\n     * Intervals are inclusive of the start instant and exclusive of the end.\n     * \n     * @return true if this time interval is after the current instant\n     */"}}
{"code": {"body": "    public Interval toInterval() {\n        return new Interval(getStartMillis(), getEndMillis(), getChronology());\n    }", "comment": "/**\n     * Get this interval as an immutable <code>Interval</code> object.\n     *\n     * @return the interval as an Interval object\n     */"}}
{"code": {"body": "    public MutableInterval toMutableInterval() {\n        return new MutableInterval(getStartMillis(), getEndMillis(), getChronology());\n    }", "comment": "/**\n     * Get this time interval as a <code>MutableInterval</code>.\n     * <p>\n     * This will always return a new <code>MutableInterval</code> with the same interval.\n     *\n     * @return the time interval as a MutableInterval object\n     */"}}
{"code": {"body": "    public long toDurationMillis() {\n        return FieldUtils.safeAdd(getEndMillis(), -getStartMillis());\n    }", "comment": "/**\n     * Gets the duration of this time interval in milliseconds.\n     * <p>\n     * The duration is equal to the end millis minus the start millis.\n     *\n     * @return the duration of the time interval in milliseconds\n     * @throws ArithmeticException if the duration exceeds the capacity of a long\n     */"}}
{"code": {"body": "    public Duration toDuration() {\n        long durMillis = toDurationMillis();\n        if (durMillis == 0) {\n            return Duration.ZERO;\n        } else {\n            return new Duration(durMillis);\n        }\n    }", "comment": "/**\n     * Gets the duration of this time interval.\n     * <p>\n     * The duration is equal to the end millis minus the start millis.\n     *\n     * @return the duration of the time interval\n     * @throws ArithmeticException if the duration exceeds the capacity of a long\n     */"}}
{"code": {"body": "    public Period toPeriod(PeriodType type) {\n        return new Period(getStartMillis(), getEndMillis(), type, getChronology());\n    }", "comment": "/**\n     * Converts the duration of the interval to a <code>Period</code> using the\n     * specified period type.\n     * <p>\n     * This method should be used to exract the field values describing the\n     * difference between the start and end instants.\n     *\n     * @param type  the requested type of the duration, null means AllType\n     * @return a time period derived from the interval\n     */"}}
{"code": {"body": "    public boolean equals(Object readableInterval) {\n        if (this == readableInterval) {\n            return true;\n        }\n        if (readableInterval instanceof ReadableInterval == false) {\n            return false;\n        }\n        ReadableInterval other = (ReadableInterval) readableInterval;\n        return \n            getStartMillis() == other.getStartMillis() &&\n            getEndMillis() == other.getEndMillis() &&\n            FieldUtils.equals(getChronology(), other.getChronology());\n    }", "comment": "/**\n     * Compares this object with the specified object for equality based\n     * on start and end millis plus the chronology.\n     * All ReadableInterval instances are accepted.\n     * <p>\n     * To compare the duration of two time intervals, use {@link #toDuration()}\n     * to get the durations and compare those.\n     *\n     * @param readableInterval  a readable interval to check against\n     * @return true if the intervals are equal comparing the start millis,\n     *  end millis and chronology\n     */"}}
{"code": {"body": "    public int hashCode() {\n        long start = getStartMillis();\n        long end = getEndMillis();\n        int result = 97;\n        result = 31 * result + ((int) (start ^ (start >>> 32)));\n        result = 31 * result + ((int) (end ^ (end >>> 32)));\n        result = 31 * result + getChronology().hashCode();\n        return result;\n    }", "comment": "/**\n     * Hashcode compatible with equals method.\n     *\n     * @return suitable hashcode\n     */"}}
{"code": {"body": "    public String toString() {\n        DateTimeFormatter printer = ISODateTimeFormat.dateTime();\n        printer = printer.withChronology(getChronology());\n        StringBuffer buf = new StringBuffer(48);\n        printer.printTo(buf, getStartMillis());\n        buf.append('');\n        printer.printTo(buf, getEndMillis());\n        return buf.toString();\n    }", "comment": "/**\n     * Output a string in ISO8601 interval format.\n     * <p>\n     * From version 2.1, the string includes the time zone offset.\n     *\n     * @return re-parsable string (in the default zone)\n     */"}}
{"code": {"body": "    public DateTimeField getField(int index) {\n        return getField(index, getChronology());\n    }", "comment": "/**\n     * Gets the field at the specifed index.\n     * \n     * @param index  the index\n     * @return the field\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */"}}
{"code": {"body": "    public DateTimeFieldType getFieldType(int index) {\n        return getField(index, getChronology()).getType();\n    }", "comment": "/**\n     * Gets the field type at the specifed index.\n     * \n     * @param index  the index\n     * @return the field type\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */"}}
{"code": {"body": "    public DateTimeFieldType[] getFieldTypes() {\n        DateTimeFieldType[] result = new DateTimeFieldType[size()];\n        for (int i = 0; i < result.length; i++) {\n            result[i] = getFieldType(i);\n        }\n        return result;\n    }", "comment": "/**\n     * Gets an array of the field types that this partial supports.\n     * <p>\n     * The fields are returned largest to smallest, for example Hour, Minute, Second.\n     *\n     * @return the fields supported in an array that may be altered, largest to smallest\n     */"}}
{"code": {"body": "    public DateTimeField[] getFields() {\n        DateTimeField[] result = new DateTimeField[size()];\n        for (int i = 0; i < result.length; i++) {\n            result[i] = getField(i);\n        }\n        return result;\n    }", "comment": "/**\n     * Gets an array of the fields that this partial supports.\n     * <p>\n     * The fields are returned largest to smallest, for example Hour, Minute, Second.\n     *\n     * @return the fields supported in an array that may be altered, largest to smallest\n     */"}}
{"code": {"body": "    public int[] getValues() {\n        int[] result = new int[size()];\n        for (int i = 0; i < result.length; i++) {\n            result[i] = getValue(i);\n        }\n        return result;\n    }", "comment": "/**\n     * Gets an array of the value of each of the fields that this partial supports.\n     * <p>\n     * The fields are returned largest to smallest, for example Hour, Minute, Second.\n     * Each value corresponds to the same array index as <code>getFields()</code>\n     *\n     * @return the current values of each field in an array that may be altered, largest to smallest\n     */"}}
{"code": {"body": "    public int get(DateTimeFieldType type) {\n        return getValue(indexOfSupported(type));\n    }", "comment": "/**\n     * Get the value of one of the fields of a datetime.\n     * <p>\n     * The field specified must be one of those that is supported by the partial.\n     *\n     * @param type  a DateTimeFieldType instance that is supported by this partial\n     * @return the value of that field\n     * @throws IllegalArgumentException if the field is null or not supported\n     */"}}
{"code": {"body": "    public boolean isSupported(DateTimeFieldType type) {\n        return (indexOf(type) != -1);\n    }", "comment": "/**\n     * Checks whether the field specified is supported by this partial.\n     *\n     * @param type  the type to check, may be null which returns false\n     * @return true if the field is supported\n     */"}}
{"code": {"body": "    protected int indexOf(DurationFieldType type) {\n        for (int i = 0, isize = size(); i < isize; i++) {\n            if (getFieldType(i).getDurationType() == type) {\n                return i;\n            }\n        }\n        return -1;\n    }", "comment": "/**\n     * Gets the index of the first fields to have the specified duration,\n     * or -1 if the field is unsupported.\n     *\n     * @param type  the type to check, may be null which returns -1\n     * @return the index of the field, -1 if unsupported\n     */"}}
{"code": {"body": "    protected int indexOfSupported(DurationFieldType type) {\n        int index = indexOf(type);\n        if (index == -1) {\n            throw new IllegalArgumentException(\"\" + type + \"\");\n        }\n        return index;\n    }", "comment": "/**\n     * Gets the index of the first fields to have the specified duration,\n     * throwing an exception if the field is unsupported.\n     *\n     * @param type  the type to check, not null\n     * @return the index of the field\n     * @throws IllegalArgumentException if the field is null or not supported\n     */"}}
{"code": {"body": "    public DateTime toDateTime(ReadableInstant baseInstant) {\n        Chronology chrono = DateTimeUtils.getInstantChronology(baseInstant);\n        long instantMillis = DateTimeUtils.getInstantMillis(baseInstant);\n        long resolved = chrono.set(this, instantMillis);\n        return new DateTime(resolved, chrono);\n    }", "comment": "/**\n     * Resolves this partial against another complete instant to create a new\n     * full instant. The combination is performed using the chronology of the\n     * specified instant.\n     * <p>\n     * For example, if this partial represents a time, then the result of this\n     * method will be the datetime from the specified base instant plus the\n     * time from this partial.\n     *\n     * @param baseInstant  the instant that provides the missing fields, null means now\n     * @return the combined datetime\n     */"}}
{"code": {"body": "    public boolean equals(Object partial) {\n        if (this == partial) {\n            return true;\n        }\n        if (partial instanceof ReadablePartial == false) {\n            return false;\n        }\n        ReadablePartial other = (ReadablePartial) partial;\n        if (size() != other.size()) {\n            return false;\n        }\n        for (int i = 0, isize = size(); i < isize; i++) {\n            if (getValue(i) != other.getValue(i) || getFieldType(i) != other.getFieldType(i)) {\n                return false;\n            }\n        }\n        return FieldUtils.equals(getChronology(), other.getChronology());\n    }", "comment": "/**\n     * Compares this ReadablePartial with another returning true if the chronology,\n     * field types and values are equal.\n     *\n     * @param partial  an object to check against\n     * @return true if fields and values are equal\n     */"}}
{"code": {"body": "    public int hashCode() {\n        int total = 157;\n        for (int i = 0, isize = size(); i < isize; i++) {\n            total = 23 * total + getValue(i);\n            total = 23 * total + getFieldType(i).hashCode();\n        }\n        total += getChronology().hashCode();\n        return total;\n    }", "comment": "/**\n     * Gets a hash code for the ReadablePartial that is compatible with the \n     * equals method.\n     *\n     * @return a suitable hash code\n     */"}}
{"code": {"body": "    public int compareTo(ReadablePartial other) {\n        if (this == other) {\n            return 0;\n        }\n        if (size() != other.size()) {\n            throw new ClassCastException(\"\");\n        }\n        for (int i = 0, isize = size(); i < isize; i++) {\n            if (getFieldType(i) != other.getFieldType(i)) {\n                throw new ClassCastException(\"\");\n            }\n        }\n        \n        for (int i = 0, isize = size(); i < isize; i++) {\n            if (getValue(i) > other.getValue(i)) {\n                return 1;\n            }\n            if (getValue(i) < other.getValue(i)) {\n                return -1;\n            }\n        }\n        return 0;\n    }", "comment": "/**\n     * Compares this partial with another returning an integer\n     * indicating the order.\n     * <p>\n     * The fields are compared in order, from largest to smallest.\n     * The first field that is non-equal is used to determine the result.\n     * <p>\n     * The specified object must be a partial instance whose field types\n     * match those of this partial.\n     * <p>\n     * NOTE: Prior to v2.0, the {@code Comparable} interface was only implemented\n     * in this class and not in the {@code ReadablePartial} interface.\n     *\n     * @param other  an object to check against\n     * @return negative if this is less, zero if equal, positive if greater\n     * @throws ClassCastException if the partial is the wrong class\n     *  or if it has field types that don't match\n     * @throws NullPointerException if the partial is null\n     * @since 1.1\n     */"}}
{"code": {"body": "    public boolean isAfter(ReadablePartial partial) {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        return compareTo(partial) > 0;\n    }", "comment": "/**\n     * Is this partial later than the specified partial.\n     * <p>\n     * The fields are compared in order, from largest to smallest.\n     * The first field that is non-equal is used to determine the result.\n     * <p>\n     * You may not pass null into this method. This is because you need\n     * a time zone to accurately determine the current date.\n     *\n     * @param partial  a partial to check against, must not be null\n     * @return true if this date is after the date passed in\n     * @throws IllegalArgumentException if the specified partial is null\n     * @throws ClassCastException if the partial has field types that don't match\n     * @since 1.1\n     */"}}
{"code": {"body": "    public boolean isBefore(ReadablePartial partial) {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        return compareTo(partial) < 0;\n    }", "comment": "/**\n     * Is this partial earlier than the specified partial.\n     * <p>\n     * The fields are compared in order, from largest to smallest.\n     * The first field that is non-equal is used to determine the result.\n     * <p>\n     * You may not pass null into this method. This is because you need\n     * a time zone to accurately determine the current date.\n     *\n     * @param partial  a partial to check against, must not be null\n     * @return true if this date is before the date passed in\n     * @throws IllegalArgumentException if the specified partial is null\n     * @throws ClassCastException if the partial has field types that don't match\n     * @since 1.1\n     */"}}
{"code": {"body": "    public boolean isEqual(ReadablePartial partial) {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        return compareTo(partial) == 0;\n    }", "comment": "/**\n     * Is this partial the same as the specified partial.\n     * <p>\n     * The fields are compared in order, from largest to smallest.\n     * If all fields are equal, the result is true.\n     * <p>\n     * You may not pass null into this method. This is because you need\n     * a time zone to accurately determine the current date.\n     *\n     * @param partial  a partial to check against, must not be null\n     * @return true if this date is the same as the date passed in\n     * @throws IllegalArgumentException if the specified partial is null\n     * @throws ClassCastException if the partial has field types that don't match\n     * @since 1.1\n     */"}}
{"code": {"body": "    public String toString(DateTimeFormatter formatter) {\n        if (formatter == null) {\n            return toString();\n        }\n        return formatter.print(this);\n    }", "comment": "/**\n     * Uses the specified formatter to convert this partial to a String.\n     *\n     * @param formatter  the formatter to use, null means use <code>toString()</code>.\n     * @return the formatted string\n     * @since 1.1\n     */"}}
{"code": {"body": "    public int size() {\n        return getPeriodType().size();\n    }", "comment": "/**\n     * Gets the number of fields that this period supports.\n     *\n     * @return the number of fields supported\n     * @since 2.0 (previously on BasePeriod)\n     */"}}
{"code": {"body": "    public DurationFieldType getFieldType(int index) {\n        return getPeriodType().getFieldType(index);\n    }", "comment": "/**\n     * Gets the field type at the specified index.\n     *\n     * @param index  the index to retrieve\n     * @return the field at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     * @since 2.0 (previously on BasePeriod)\n     */"}}
{"code": {"body": "    public DurationFieldType[] getFieldTypes() {\n        DurationFieldType[] result = new DurationFieldType[size()];\n        for (int i = 0; i < result.length; i++) {\n            result[i] = getFieldType(i);\n        }\n        return result;\n    }", "comment": "/**\n     * Gets an array of the field types that this period supports.\n     * <p>\n     * The fields are returned largest to smallest, for example Hours, Minutes, Seconds.\n     *\n     * @return the fields supported in an array that may be altered, largest to smallest\n     */"}}
{"code": {"body": "    public int[] getValues() {\n        int[] result = new int[size()];\n        for (int i = 0; i < result.length; i++) {\n            result[i] = getValue(i);\n        }\n        return result;\n    }", "comment": "/**\n     * Gets an array of the value of each of the fields that this period supports.\n     * <p>\n     * The fields are returned largest to smallest, for example Hours, Minutes, Seconds.\n     * Each value corresponds to the same array index as <code>getFields()</code>\n     *\n     * @return the current values of each field in an array that may be altered, largest to smallest\n     */"}}
{"code": {"body": "    public int get(DurationFieldType type) {\n        int index = indexOf(type);\n        if (index == -1) {\n            return 0;\n        }\n        return getValue(index);\n    }", "comment": "/**\n     * Gets the value of one of the fields.\n     * <p>\n     * If the field type specified is not supported by the period then zero\n     * is returned.\n     *\n     * @param type  the field type to query, null returns zero\n     * @return the value of that field, zero if field not supported\n     */"}}
{"code": {"body": "    public boolean isSupported(DurationFieldType type) {\n        return getPeriodType().isSupported(type);\n    }", "comment": "/**\n     * Checks whether the field specified is supported by this period.\n     *\n     * @param type  the type to check, may be null which returns false\n     * @return true if the field is supported\n     */"}}
{"code": {"body": "    public int indexOf(DurationFieldType type) {\n        return getPeriodType().indexOf(type);\n    }", "comment": "/**\n     * Gets the index of the field in this period.\n     *\n     * @param type  the type to check, may be null which returns -1\n     * @return the index of -1 if not supported\n     */"}}
{"code": {"body": "    public Period toPeriod() {\n        return new Period(this);\n    }", "comment": "/**\n     * Get this period as an immutable <code>Period</code> object.\n     * \n     * @return a Period using the same field set and values\n     */"}}
{"code": {"body": "    public MutablePeriod toMutablePeriod() {\n        return new MutablePeriod(this);\n    }", "comment": "/**\n     * Get this object as a <code>MutablePeriod</code>.\n     * <p>\n     * This will always return a new <code>MutablePeriod</code> with the same fields.\n     * \n     * @return a MutablePeriod using the same field set and values\n     */"}}
{"code": {"body": "    public boolean equals(Object period) {\n        if (this == period) {\n            return true;\n        }\n        if (period instanceof ReadablePeriod == false) {\n            return false;\n        }\n        ReadablePeriod other = (ReadablePeriod) period;\n        if (size() != other.size()) {\n            return false;\n        }\n        for (int i = 0, isize = size(); i < isize; i++) {\n            if (getValue(i) != other.getValue(i) || getFieldType(i) != other.getFieldType(i)) {\n                return false;\n            }\n        }\n        return true;\n    }", "comment": "/**\n     * Compares this object with the specified object for equality based\n     * on the value of each field. All ReadablePeriod instances are accepted.\n     * <p>\n     * Note that a period of 1 day is not equal to a period of 24 hours,\n     * nor is 1 hour equal to 60 minutes. Only periods with the same amount\n     * in each field are equal.\n     * <p>\n     * This is because periods represent an abstracted definition of a time\n     * period (eg. a day may not actually be 24 hours, it might be 23 or 25\n     * at daylight savings boundary).\n     * <p>\n     * To compare the actual duration of two periods, convert both to\n     * {@link org.joda.time.Duration Duration}s, an operation that emphasises\n     * that the result may differ according to the date you choose.\n     *\n     * @param period  a readable period to check against\n     * @return true if all the field values are equal, false if\n     *  not or the period is null or of an incorrect type\n     */"}}
{"code": {"body": "    public int hashCode() {\n        int total = 17;\n        for (int i = 0, isize = size(); i < isize; i++) {\n            total = 27 * total + getValue(i);\n            total = 27 * total + getFieldType(i).hashCode();\n        }\n        return total;\n    }", "comment": "/**\n     * Gets a hash code for the period as defined by ReadablePeriod.\n     *\n     * @return a hash code\n     */"}}
{"code": {"body": "    public String toString(PeriodFormatter formatter) {\n        if (formatter == null) {\n            return toString();\n        }\n        return formatter.print(this);\n    }", "comment": "/**\n     * Uses the specified formatter to convert this period to a String.\n     *\n     * @param formatter  the formatter to use, null means use <code>toString()</code>.\n     * @return the formatted string\n     * @since 1.5\n     */"}}
{"code": {"body": "public BaseDateTime() {\n        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance());\n    }", "comment": "/**\n     * Constructs an instance set to the current system millisecond time\n     * using <code>ISOChronology</code> in the default time zone.\n     */"}}
{"code": {"body": "public BaseDateTime(DateTimeZone zone) {\n        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone));\n    }", "comment": "/**\n     * Constructs an instance set to the current system millisecond time\n     * using <code>ISOChronology</code> in the specified time zone.\n     * <p>\n     * If the specified time zone is null, the default zone is used.\n     *\n     * @param zone  the time zone, null means default zone\n     */"}}
{"code": {"body": "public BaseDateTime(Chronology chronology) {\n        this(DateTimeUtils.currentTimeMillis(), chronology);\n    }", "comment": "/**\n     * Constructs an instance set to the current system millisecond time\n     * using the specified chronology.\n     * <p>\n     * If the chronology is null, <code>ISOChronology</code>\n     * in the default time zone is used.\n     *\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     */"}}
{"code": {"body": "public BaseDateTime(long instant) {\n        this(instant, ISOChronology.getInstance());\n    }", "comment": "/**\n     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n     * using <code>ISOChronology</code> in the default time zone.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     */"}}
{"code": {"body": "public BaseDateTime(long instant, DateTimeZone zone) {\n        this(instant, ISOChronology.getInstance(zone));\n    }", "comment": "/**\n     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n     * using <code>ISOChronology</code> in the specified time zone.\n     * <p>\n     * If the specified time zone is null, the default zone is used.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     * @param zone  the time zone, null means default zone\n     */"}}
{"code": {"body": "public BaseDateTime(long instant, Chronology chronology) {\n        super();\n        iChronology = checkChronology(chronology);\n        iMillis = checkInstant(instant, iChronology);\n    }", "comment": "/**\n     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n     * using the specified chronology.\n     * <p>\n     * If the chronology is null, <code>ISOChronology</code>\n     * in the default time zone is used.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     */"}}
{"code": {"body": "public BaseDateTime(Object instant, DateTimeZone zone) {\n        super();\n        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n        Chronology chrono = checkChronology(converter.getChronology(instant, zone));\n        iChronology = chrono;\n        iMillis = checkInstant(converter.getInstantMillis(instant, chrono), chrono);\n    }", "comment": "/**\n     * Constructs an instance from an Object that represents a datetime,\n     * forcing the time zone to that specified.\n     * <p>\n     * If the object contains no chronology, <code>ISOChronology</code> is used.\n     * If the specified time zone is null, the default zone is used.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadableInstant, String, Calendar and Date.\n     *\n     * @param instant  the datetime object\n     * @param zone  the time zone\n     * @throws IllegalArgumentException if the instant is invalid\n     */"}}
{"code": {"body": "public BaseDateTime(Object instant, Chronology chronology) {\n        super();\n        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n        iChronology = checkChronology(converter.getChronology(instant, chronology));\n        iMillis = checkInstant(converter.getInstantMillis(instant, chronology), iChronology);\n    }", "comment": "/**\n     * Constructs an instance from an Object that represents a datetime,\n     * using the specified chronology.\n     * <p>\n     * If the chronology is null, ISO in the default time zone is used.\n     * <p>\n     * The recognised object types are defined in\n     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n     * include ReadableInstant, String, Calendar and Date.\n     *\n     * @param instant  the datetime object\n     * @param chronology  the chronology\n     * @throws IllegalArgumentException if the instant is invalid\n     */"}}
{"code": {"body": "    protected Chronology checkChronology(Chronology chronology) {\n        return DateTimeUtils.getChronology(chronology);\n    }", "comment": "/**\n     * Checks the specified chronology before storing it, potentially altering it.\n     * This method must not access any instance variables.\n     * <p>\n     * This implementation converts nulls to ISOChronology in the default zone.\n     *\n     * @param chronology  the chronology to use, may be null\n     * @return the chronology to store in this datetime, not null\n     */"}}
{"code": {"body": "    protected long checkInstant(long instant, Chronology chronology) {\n        return instant;\n    }", "comment": "/**\n     * Checks the specified instant before storing it, potentially altering it.\n     * This method must not access any instance variables.\n     * <p>\n     * This implementation simply returns the instant.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n     * @param chronology  the chronology to use, not null\n     * @return the instant to store in this datetime\n     */"}}
{"code": {"body": "    public long getMillis() {\n        return iMillis;\n    }", "comment": "/**\n     * Gets the milliseconds of the datetime instant from the Java epoch\n     * of 1970-01-01T00:00:00Z.\n     * \n     * @return the number of milliseconds since 1970-01-01T00:00:00Z\n     */"}}
{"code": {"body": "    public Chronology getChronology() {\n        return iChronology;\n    }", "comment": "/**\n     * Gets the chronology of the datetime.\n     * \n     * @return the Chronology that the datetime is using\n     */"}}
{"code": {"body": "    protected void setMillis(long instant) {\n        iMillis = checkInstant(instant, iChronology);\n    }", "comment": "/**\n     * Sets the milliseconds of the datetime.\n     * <p>\n     * All changes to the millisecond field occurs via this method.\n     * Override and block this method to make a subclass immutable.\n     *\n     * @param instant  the milliseconds since 1970-01-01T00:00:00Z to set the datetime to\n     */"}}
{"code": {"body": "    protected void setChronology(Chronology chronology) {\n        iChronology = checkChronology(chronology);\n    }", "comment": "/**\n     * Sets the chronology of the datetime.\n     * <p>\n     * All changes to the chronology field occurs via this method.\n     * Override and block this method to make a subclass immutable.\n     *\n     * @param chronology  the chronology to set\n     */"}}
{"code": {"body": "    public long getMillis() {\n        return iMillis;\n    }", "comment": "/**\n     * Gets the length of this duration in milliseconds.\n     *\n     * @return the length of the duration in milliseconds.\n     */"}}
{"code": {"body": "    protected void setMillis(long duration) {\n        iMillis = duration;\n    }", "comment": "/**\n     * Sets the length of this duration in milliseconds.\n     * \n     * @param duration  the new length of the duration\n     */"}}
{"code": {"body": "    public Period toPeriod(PeriodType type, Chronology chrono) {\n        return new Period(getMillis(), type, chrono);\n    }", "comment": "/**\n     * Converts this duration to a Period instance using the specified period type\n     * and chronology.\n     * <p>\n     * Only precise fields in the period type will be used.\n     * Exactly which fields are precise depends on the chronology.\n     * Only the time fields are precise for ISO chronology with a time zone.\n     * However, ISO UTC also has precise days and weeks.\n     * <p>\n     * For more control over the conversion process, you must pair the duration with\n     * an instant, see {@link #toPeriodFrom(ReadableInstant, PeriodType)} and\n     * {@link #toPeriodTo(ReadableInstant, PeriodType)}\n     * \n     * @param type  the period type to use, null means standard\n     * @param chrono  the chronology to use, null means ISO default\n     * @return a Period created using the millisecond duration from this instance\n     */"}}
{"code": {"body": "    public Period toPeriodFrom(ReadableInstant startInstant, PeriodType type) {\n        return new Period(startInstant, this, type);\n    }", "comment": "/**\n     * Converts this duration to a Period instance by adding the duration to a start\n     * instant to obtain an interval.\n     * <p>\n     * This conversion will determine the fields of a period accurately.\n     * The results are based on the instant millis, the chronology of the instant,\n     * the period type and the length of this duration.\n     * \n     * @param startInstant  the instant to calculate the period from, null means now\n     * @param type  the period type determining how to split the duration into fields, null means All type\n     * @return a Period created using the millisecond duration from this instance\n     */"}}
{"code": {"body": "    public Period toPeriodTo(ReadableInstant endInstant, PeriodType type) {\n        return new Period(this, endInstant, type);\n    }", "comment": "/**\n     * Converts this duration to a Period instance by subtracting the duration\n     * from an end instant to obtain an interval using the standard period\n     * type.\n     * <p>\n     * This conversion will determine the fields of a period accurately.\n     * The results are based on the instant millis, the chronology of the instant,\n     * the period type and the length of this duration.\n     * \n     * @param endInstant  the instant to calculate the period to, null means now\n     * @param type  the period type determining how to split the duration into fields, null means All type\n     * @return a Period created using the millisecond duration from this instance\n     */"}}
{"code": {"body": "    public Interval toIntervalFrom(ReadableInstant startInstant) {\n        return new Interval(startInstant, this);\n    }", "comment": "/**\n     * Converts this duration to an Interval starting at the specified instant.\n     * \n     * @param startInstant  the instant to start the interval at, null means now\n     * @return an Interval starting at the specified instant\n     */"}}
{"code": {"body": "    public Interval toIntervalTo(ReadableInstant endInstant) {\n        return new Interval(this, endInstant);\n    }", "comment": "/**\n     * Converts this duration to an Interval ending at the specified instant.\n     * \n     * @param endInstant  the instant to end the interval at, null means now\n     * @return an Interval ending at the specified instant\n     */"}}
{"code": {"body": "    public Chronology getChronology() {\n        return iChronology;\n    }", "comment": "/**\n     * Gets the chronology of this interval.\n     *\n     * @return the chronology\n     */"}}
{"code": {"body": "    public long getStartMillis() {\n        return iStartMillis;\n    }", "comment": "/**\n     * Gets the start of this time interval which is inclusive.\n     *\n     * @return the start of the time interval,\n     *  millisecond instant from 1970-01-01T00:00:00Z\n     */"}}
{"code": {"body": "    public long getEndMillis() {\n        return iEndMillis;\n    }", "comment": "/**\n     * Gets the end of this time interval which is exclusive.\n     *\n     * @return the end of the time interval,\n     *  millisecond instant from 1970-01-01T00:00:00Z\n     */"}}
{"code": {"body": "    protected void setInterval(long startInstant, long endInstant, Chronology chrono) {\n        checkInterval(startInstant, endInstant);\n        iStartMillis = startInstant;\n        iEndMillis = endInstant;\n        iChronology = DateTimeUtils.getChronology(chrono);\n    }", "comment": "/**\n     * Sets this interval from two millisecond instants and a chronology.\n     *\n     * @param startInstant  the start of the time interval\n     * @param endInstant  the start of the time interval\n     * @param chrono  the chronology, not null\n     * @throws IllegalArgumentException if the end is before the start\n     */"}}
{"code": {"body": "    public int getValue(int index) {\n        return iValues[index];\n    }", "comment": "/**\n     * Gets the value of the field at the specifed index.\n     * \n     * @param index  the index\n     * @return the value\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */"}}
{"code": {"body": "    public int[] getValues() {\n        return (int[]) iValues.clone();\n    }", "comment": "/**\n     * Gets an array of the value of each of the fields that this partial supports.\n     * <p>\n     * The fields are returned largest to smallest, for example Hour, Minute, Second.\n     * Each value corresponds to the same array index as <code>getFields()</code>\n     *\n     * @return the current values of each field (cloned), largest to smallest\n     */"}}
{"code": {"body": "    public Chronology getChronology() {\n        return iChronology;\n    }", "comment": "/**\n     * Gets the chronology of the partial which is never null.\n     * <p>\n     * The {@link Chronology} is the calculation engine behind the partial and\n     * provides conversion and validation of the fields in a particular calendar system.\n     * \n     * @return the chronology, never null\n     */"}}
{"code": {"body": "    protected void setValue(int index, int value) {\n        DateTimeField field = getField(index);\n        int[] values = field.set(this, index, iValues, value);\n        System.arraycopy(values, 0, iValues, 0, iValues.length);\n    }", "comment": "/**\n     * Sets the value of the field at the specified index.\n     * <p>\n     * In version 2.0 and later, this method copies the array into the original.\n     * This is because the instance variable has been changed to be final to satisfy the Java Memory Model.\n     * This only impacts subclasses that are mutable.\n     * \n     * @param index  the index\n     * @param value  the value to set\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */"}}
{"code": {"body": "    protected void setValues(int[] values) {\n        getChronology().validate(this, values);\n        System.arraycopy(values, 0, iValues, 0, iValues.length);\n    }", "comment": "/**\n     * Sets the values of all fields.\n     * <p>\n     * In version 2.0 and later, this method copies the array into the original.\n     * This is because the instance variable has been changed to be final to satisfy the Java Memory Model.\n     * This only impacts subclasses that are mutable.\n     * \n     * @param values  the array of values\n     */"}}
{"code": {"body": "    public String toString(String pattern, Locale locale) throws IllegalArgumentException {\n        if (pattern == null) {\n            return toString();\n        }\n        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n    }", "comment": "/**\n     * Output the date using the specified format pattern.\n     *\n     * @param pattern  the pattern specification, null means use <code>toString</code>\n     * @param locale  Locale to use, null means default\n     * @see org.joda.time.format.DateTimeFormat\n     */"}}
{"code": {"body": "    protected PeriodType checkPeriodType(PeriodType type) {\n        return DateTimeUtils.getPeriodType(type);\n    }", "comment": "/**\n     * Validates a period type, converting nulls to a default value and\n     * checking the type is suitable for this instance.\n     * \n     * @param type  the type to check, may be null\n     * @return the validated type to use, not null\n     * @throws IllegalArgumentException if the period type is invalid\n     */"}}
{"code": {"body": "    public Duration toDurationFrom(ReadableInstant startInstant) {\n        long startMillis = DateTimeUtils.getInstantMillis(startInstant);\n        Chronology chrono = DateTimeUtils.getInstantChronology(startInstant);\n        long endMillis = chrono.add(this, startMillis, 1);\n        return new Duration(startMillis, endMillis);\n    }", "comment": "/**\n     * Gets the total millisecond duration of this period relative to a start instant.\n     * <p>\n     * This method adds the period to the specified instant in order to\n     * calculate the duration.\n     * <p>\n     * An instant must be supplied as the duration of a period varies.\n     * For example, a period of 1 month could vary between the equivalent of\n     * 28 and 31 days in milliseconds due to different length months.\n     * Similarly, a day can vary at Daylight Savings cutover, typically between\n     * 23 and 25 hours.\n     *\n     * @param startInstant  the instant to add the period to, thus obtaining the duration\n     * @return the total length of the period as a duration relative to the start instant\n     * @throws ArithmeticException if the millis exceeds the capacity of the duration\n     */"}}
{"code": {"body": "    public Duration toDurationTo(ReadableInstant endInstant) {\n        long endMillis = DateTimeUtils.getInstantMillis(endInstant);\n        Chronology chrono = DateTimeUtils.getInstantChronology(endInstant);\n        long startMillis = chrono.add(this, endMillis, -1);\n        return new Duration(startMillis, endMillis);\n    }", "comment": "/**\n     * Gets the total millisecond duration of this period relative to an\n     * end instant.\n     * <p>\n     * This method subtracts the period from the specified instant in order\n     * to calculate the duration.\n     * <p>\n     * An instant must be supplied as the duration of a period varies.\n     * For example, a period of 1 month could vary between the equivalent of\n     * 28 and 31 days in milliseconds due to different length months.\n     * Similarly, a day can vary at Daylight Savings cutover, typically between\n     * 23 and 25 hours.\n     *\n     * @param endInstant  the instant to subtract the period from, thus obtaining the duration\n     * @return the total length of the period as a duration relative to the end instant\n     * @throws ArithmeticException if the millis exceeds the capacity of the duration\n     */"}}
{"code": {"body": "    private void checkAndUpdate(DurationFieldType type, int[] values, int newValue) {\n        int index = indexOf(type);\n        if (index == -1) {\n            if (newValue != 0) {\n                throw new IllegalArgumentException(\n                    \"\" + type.getName() + \"\");\n            }\n        } else {\n            values[index] = newValue;\n        }\n    }", "comment": "/**\n     * Checks whether a field type is supported, and if so adds the new value\n     * to the relevant index in the specified array.\n     * \n     * @param type  the field type\n     * @param values  the array to update\n     * @param newValue  the new value to store if successful\n     */"}}
{"code": {"body": "    protected void setPeriod(int years, int months, int weeks, int days,\n                             int hours, int minutes, int seconds, int millis) {\n        int[] newValues = setPeriodInternal(years, months, weeks, days, hours, minutes, seconds, millis);\n        setValues(newValues);\n    }", "comment": "/**\n     * Sets the eight standard the fields in one go.\n     * \n     * @param years  amount of years in this period, which must be zero if unsupported\n     * @param months  amount of months in this period, which must be zero if unsupported\n     * @param weeks  amount of weeks in this period, which must be zero if unsupported\n     * @param days  amount of days in this period, which must be zero if unsupported\n     * @param hours  amount of hours in this period, which must be zero if unsupported\n     * @param minutes  amount of minutes in this period, which must be zero if unsupported\n     * @param seconds  amount of seconds in this period, which must be zero if unsupported\n     * @param millis  amount of milliseconds in this period, which must be zero if unsupported\n     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n     */"}}
{"code": {"body": "    private int[] setPeriodInternal(int years, int months, int weeks, int days,\n                                   int hours, int minutes, int seconds, int millis) {\n        int[] newValues = new int[size()];\n        checkAndUpdate(DurationFieldType.years(), newValues, years);\n        checkAndUpdate(DurationFieldType.months(), newValues, months);\n        checkAndUpdate(DurationFieldType.weeks(), newValues, weeks);\n        checkAndUpdate(DurationFieldType.days(), newValues, days);\n        checkAndUpdate(DurationFieldType.hours(), newValues, hours);\n        checkAndUpdate(DurationFieldType.minutes(), newValues, minutes);\n        checkAndUpdate(DurationFieldType.seconds(), newValues, seconds);\n        checkAndUpdate(DurationFieldType.millis(), newValues, millis);\n        return newValues;\n    }", "comment": "/**\n     * Private method called from constructor.\n     */"}}
{"code": {"body": "    protected void setField(DurationFieldType field, int value) {\n        setFieldInto(iValues, field, value);\n    }", "comment": "/**\n     * Sets the value of a field in this period.\n     * \n     * @param field  the field to set\n     * @param value  the value to set\n     * @throws IllegalArgumentException if field is is null or not supported.\n     */"}}
{"code": {"body": "    protected void setFieldInto(int[] values, DurationFieldType field, int value) {\n        int index = indexOf(field);\n        if (index == -1) {\n            if (value != 0 || field == null) {\n                throw new IllegalArgumentException(\n                    \"\" + field + \"\");\n            }\n        } else {\n            values[index] = value;\n        }\n    }", "comment": "/**\n     * Sets the value of a field in this period.\n     * \n     * @param values  the array of values to update\n     * @param field  the field to set\n     * @param value  the value to set\n     * @throws IllegalArgumentException if field is null or not supported.\n     */"}}
{"code": {"body": "    protected void addField(DurationFieldType field, int value) {\n        addFieldInto(iValues, field, value);\n    }", "comment": "/**\n     * Adds the value of a field in this period.\n     * \n     * @param field  the field to set\n     * @param value  the value to set\n     * @throws IllegalArgumentException if field is is null or not supported.\n     */"}}
{"code": {"body": "    protected void addFieldInto(int[] values, DurationFieldType field, int value) {\n        int index = indexOf(field);\n        if (index == -1) {\n            if (value != 0 || field == null) {\n                throw new IllegalArgumentException(\n                    \"\" + field + \"\");\n            }\n        } else {\n            values[index] = FieldUtils.safeAdd(values[index], value);\n        }\n    }", "comment": "/**\n     * Adds the value of a field in this period.\n     * \n     * @param values  the array of values to update\n     * @param field  the field to set\n     * @param value  the value to set\n     * @throws IllegalArgumentException if field is is null or not supported.\n     */"}}
{"code": {"body": "    protected void mergePeriod(ReadablePeriod period) {\n        if (period != null) {\n            setValues(mergePeriodInto(getValues(), period));\n        }\n    }", "comment": "/**\n     * Merges the fields from another period.\n     * \n     * @param period  the period to add from, not null\n     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n     */"}}
{"code": {"body": "    protected int[] mergePeriodInto(int[] values, ReadablePeriod period) {\n        for (int i = 0, isize = period.size(); i < isize; i++) {\n            DurationFieldType type = period.getFieldType(i);\n            int value = period.getValue(i);\n            checkAndUpdate(type, values, value);\n        }\n        return values;\n    }", "comment": "/**\n     * Merges the fields from another period.\n     * \n     * @param values  the array of values to update\n     * @param period  the period to add from, not null\n     * @return the updated values\n     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n     */"}}
{"code": {"body": "    protected void addPeriod(ReadablePeriod period) {\n        if (period != null) {\n            setValues(addPeriodInto(getValues(), period));\n        }\n    }", "comment": "/**\n     * Adds the fields from another period.\n     * \n     * @param period  the period to add from, not null\n     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n     */"}}
{"code": {"body": "    protected int[] addPeriodInto(int[] values, ReadablePeriod period) {\n        for (int i = 0, isize = period.size(); i < isize; i++) {\n            DurationFieldType type = period.getFieldType(i);\n            int value = period.getValue(i);\n            if (value != 0) {\n                int index = indexOf(type);\n                if (index == -1) {\n                    throw new IllegalArgumentException(\n                        \"\" + type.getName() + \"\");\n                } else {\n                    values[index] = FieldUtils.safeAdd(getValue(index), value);\n                }\n            }\n        }\n        return values;\n    }", "comment": "/**\n     * Adds the fields from another period.\n     * \n     * @param values  the array of values to update\n     * @param period  the period to add from, not null\n     * @return the updated values\n     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n     */"}}
{"code": {"body": "    protected void setValue(int index, int value) {\n        iValues[index] = value;\n    }", "comment": "/**\n     * Sets the value of the field at the specified index.\n     * \n     * @param index  the index\n     * @param value  the value to set\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */"}}
{"code": {"body": "    protected void setValues(int[] values) {\n        System.arraycopy(values, 0, iValues, 0, iValues.length);\n    }", "comment": "/**\n     * Sets the values of all fields.\n     * <p>\n     * In version 2.0 and later, this method copies the array into the original.\n     * This is because the instance variable has been changed to be final to satisfy the Java Memory Model.\n     * This only impacts subclasses that are mutable.\n     * \n     * @param values  the array of values\n     */"}}
{"code": {"body": "    protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance) {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (start.size() != end.size()) {\n            throw new IllegalArgumentException(\"\");\n        }\n        for (int i = 0, isize = start.size(); i < isize; i++) {\n            if (start.getFieldType(i) != end.getFieldType(i)) {\n                throw new IllegalArgumentException(\"\");\n            }\n        }\n        if (DateTimeUtils.isContiguous(start) == false) {\n            throw new IllegalArgumentException(\"\");\n        }\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\n        int[] values = chrono.get(zeroInstance, chrono.set(start, START_1972), chrono.set(end, START_1972));\n        return values[0];\n    }", "comment": "/**\n     * Calculates the number of whole units between the two specified partial datetimes.\n     * <p>\n     * The two partials must contain the same fields, for example you can specify\n     * two <code>LocalDate</code> objects.\n     *\n     * @param start  the start partial date, validated to not be null\n     * @param end  the end partial date, validated to not be null\n     * @param zeroInstance  the zero instance constant, must not be null\n     * @return the period\n     * @throws IllegalArgumentException if the partials are null or invalid\n     */"}}
{"code": {"body": "    protected static int standardPeriodIn(ReadablePeriod period, long millisPerUnit) {\n        if (period == null) {\n            return 0;\n        }\n        Chronology iso = ISOChronology.getInstanceUTC();\n        long duration = 0L;\n        for (int i = 0; i < period.size(); i++) {\n            int value = period.getValue(i);\n            if (value != 0) {\n                DurationField field = period.getFieldType(i).getField(iso);\n                if (field.isPrecise() == false) {\n                    throw new IllegalArgumentException(\n                            \"\" + field.getName() +\n                            \"\" + period);\n                }\n                duration = FieldUtils.safeAdd(duration, FieldUtils.safeMultiply(field.getUnitMillis(), value));\n            }\n        }\n        return FieldUtils.safeToInt(duration / millisPerUnit);\n    }", "comment": "/**\n     * Creates a new instance representing the number of complete standard length units\n     * in the specified period.\n     * <p>\n     * This factory method converts all fields from the period to hours using standardised\n     * durations for each field. Only those fields which have a precise duration in\n     * the ISO UTC chronology can be converted.\n     * <ul>\n     * <li>One week consists of 7 days.\n     * <li>One day consists of 24 hours.\n     * <li>One hour consists of 60 minutes.\n     * <li>One minute consists of 60 seconds.\n     * <li>One second consists of 1000 milliseconds.\n     * </ul>\n     * Months and Years are imprecise and periods containing these values cannot be converted.\n     *\n     * @param period  the period to get the number of hours from, must not be null\n     * @param millisPerUnit  the number of milliseconds in one standard unit of this period\n     * @throws IllegalArgumentException if the period contains imprecise duration values\n     */"}}
{"code": {"body": "    public int getValue(int index) {\n        if (index != 0) {\n            throw new IndexOutOfBoundsException(String.valueOf(index));\n        }\n        return getValue();\n    }", "comment": "/**\n     * Gets the value at the specified index.\n     * <p>\n     * The only index supported by this period is zero.\n     *\n     * @param index  the index to retrieve, which must be zero\n     * @return the value of the field at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */"}}
{"code": {"body": "    protected void setValue(int value) {\n        iPeriod = value;\n    }", "comment": "/**\n     * Sets the amount of this period.\n     * To make a subclass immutable you must declare it final, or block this method.\n     *\n     * @param value  the period value\n     */"}}
{"code": {"body": "    public DurationFieldType getFieldType(int index) {\n        if (index != 0) {\n            throw new IndexOutOfBoundsException(String.valueOf(index));\n        }\n        return getFieldType();\n    }", "comment": "/**\n     * Gets the field type at the specified index.\n     * <p>\n     * The only index supported by this period is zero which returns the\n     * field type of this class.\n     *\n     * @param index  the index to retrieve, which must be zero\n     * @return the field at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */"}}
{"code": {"body": "    public int size() {\n        return 1;\n    }", "comment": "/**\n     * Gets the number of fields that this period supports, which is one.\n     *\n     * @return the number of fields supported, which is one\n     */"}}
{"code": {"body": "    public int get(DurationFieldType type) {\n        if (type == getFieldType()) {\n            return getValue();\n        }\n        return 0;\n    }", "comment": "/**\n     * Gets the value of a duration field represented by this period.\n     * <p>\n     * If the field type specified does not match the type used by this class\n     * then zero is returned.\n     *\n     * @param type  the field type to query, null returns zero\n     * @return the value of that field, zero if field not supported\n     */"}}
{"code": {"body": "    public boolean isSupported(DurationFieldType type) {\n        return (type == getFieldType());\n    }", "comment": "/**\n     * Checks whether the duration field specified is supported by this period.\n     *\n     * @param type  the type to check, may be null which returns false\n     * @return true if the field is supported\n     */"}}
{"code": {"body": "    public Period toPeriod() {\n        return Period.ZERO.withFields(this);\n    }", "comment": "/**\n     * Get this period as an immutable <code>Period</code> object.\n     * The period will use <code>PeriodType.standard()</code>.\n     *\n     * @return a <code>Period</code> representing the same number of days\n     */"}}
{"code": {"body": "    public MutablePeriod toMutablePeriod() {\n        MutablePeriod period = new MutablePeriod();\n        period.add(this);\n        return period;\n    }", "comment": "/**\n     * Get this object as a <code>MutablePeriod</code>.\n     * <p>\n     * This will always return a new <code>MutablePeriod</code> with the same fields.\n     * The period will use <code>PeriodType.standard()</code>.\n     * \n     * @return a MutablePeriod using the same field set and values\n     */"}}
{"code": {"body": "    public boolean equals(Object period) {\n        if (this == period) {\n            return true;\n        }\n        if (period instanceof ReadablePeriod == false) {\n            return false;\n        }\n        ReadablePeriod other = (ReadablePeriod) period;\n        return (other.getPeriodType() == getPeriodType() && other.getValue(0) == getValue());\n    }", "comment": "/**\n     * Compares this object with the specified object for equality based on the\n     * value of each field. All ReadablePeriod instances are accepted, but only\n     * those with a matching <code>PeriodType</code> can return true.\n     *\n     * @param period  a readable period to check against\n     * @return true if all the field values are equal, false if\n     *  not or the period is null or of an incorrect type\n     */"}}
{"code": {"body": "    public int hashCode() {\n        int total = 17;\n        total = 27 * total + getValue();\n        total = 27 * total + getFieldType().hashCode();\n        return total;\n    }", "comment": "/**\n     * Gets a hash code for the period as defined by ReadablePeriod.\n     *\n     * @return a hash code\n     */"}}
{"code": {"body": "    public int compareTo(BaseSingleFieldPeriod other) {\n        if (other.getClass() != getClass()) {\n            throw new ClassCastException(getClass() + \"\" + other.getClass());\n        }\n        int otherValue = other.getValue();\n        int thisValue = getValue();\n        if (thisValue > otherValue) {\n            return 1;\n        }\n        if (thisValue < otherValue) {\n            return -1;\n        }\n        return 0;\n    }", "comment": "/**\n     * Compares this period to another object of the same class.\n     *\n     * @param other  the other period, must not be null\n     * @return zero if equal, positive if greater, negative if less\n     * @throws NullPointerException if the other period is null\n     * @throws ClassCastException if the other period is of a different type\n     */"}}
{"code": {"body": "    protected final Chronology getBase() {\n        return iBase;\n    }", "comment": "/**\n     * Returns the same base chronology as passed into the constructor.\n     */"}}
{"code": {"body": "    protected final Object getParam() {\n        return iParam;\n    }", "comment": "/**\n     * Returns the same param object as passed into the constructor.\n     */"}}
{"code": {"body": "        public void copyFieldsFrom(Chronology chrono) {\n            {\n                DurationField f;\n                if (isSupported(f = chrono.millis())) {\n                    millis = f;\n                }\n                if (isSupported(f = chrono.seconds())) {\n                    seconds = f;\n                }\n                if (isSupported(f = chrono.minutes())) {\n                    minutes = f;\n                }\n                if (isSupported(f = chrono.hours())) {\n                    hours = f;\n                }\n                if (isSupported(f = chrono.halfdays())) {\n                    halfdays = f;\n                }\n                if (isSupported(f = chrono.days())) {\n                    days = f;\n                }\n                if (isSupported(f = chrono.weeks())) {\n                    weeks = f;\n                }\n                if (isSupported(f = chrono.weekyears())) {\n                    weekyears = f;\n                }\n                if (isSupported(f = chrono.months())) {\n                    months = f;\n                }\n                if (isSupported(f = chrono.years())) {\n                    years = f;\n                }\n                if (isSupported(f = chrono.centuries())) {\n                    centuries = f;\n                }\n                if (isSupported(f = chrono.eras())) {\n                    eras = f;\n                }\n            }\n\n            {\n                DateTimeField f;\n                if (isSupported(f = chrono.millisOfSecond())) {\n                    millisOfSecond = f;\n                }\n                if (isSupported(f = chrono.millisOfDay())) {\n                    millisOfDay = f;\n                }\n                if (isSupported(f = chrono.secondOfMinute())) {\n                    secondOfMinute = f;\n                }\n                if (isSupported(f = chrono.secondOfDay())) {\n                    secondOfDay = f;\n                }\n                if (isSupported(f = chrono.minuteOfHour())) {\n                    minuteOfHour = f;\n                }\n                if (isSupported(f = chrono.minuteOfDay())) {\n                    minuteOfDay = f;\n                }\n                if (isSupported(f = chrono.hourOfDay())) {\n                    hourOfDay = f;\n                }\n                if (isSupported(f = chrono.clockhourOfDay())) {\n                    clockhourOfDay = f;\n                }\n                if (isSupported(f = chrono.hourOfHalfday())) {\n                    hourOfHalfday = f;\n                }\n                if (isSupported(f = chrono.clockhourOfHalfday())) {\n                    clockhourOfHalfday = f;\n                }\n                if (isSupported(f = chrono.halfdayOfDay())) {\n                    halfdayOfDay = f;\n                }\n                if (isSupported(f = chrono.dayOfWeek())) {\n                    dayOfWeek = f;\n                }\n                if (isSupported(f = chrono.dayOfMonth())) {\n                    dayOfMonth = f;\n                }\n                if (isSupported(f = chrono.dayOfYear())) {\n                    dayOfYear = f;\n                }\n                if (isSupported(f = chrono.weekOfWeekyear())) {\n                    weekOfWeekyear = f;\n                }\n                if (isSupported(f = chrono.weekyear())) {\n                    weekyear = f;\n                }\n                if (isSupported(f = chrono.weekyearOfCentury())) {\n                    weekyearOfCentury = f;\n                }\n                if (isSupported(f = chrono.monthOfYear())) {\n                    monthOfYear = f;\n                }\n                if (isSupported(f = chrono.year())) {\n                    year = f;\n                }\n                if (isSupported(f = chrono.yearOfEra())) {\n                    yearOfEra = f;\n                }\n                if (isSupported(f = chrono.yearOfCentury())) {\n                    yearOfCentury = f;\n                }\n                if (isSupported(f = chrono.centuryOfEra())) {\n                    centuryOfEra = f;\n                }\n                if (isSupported(f = chrono.era())) {\n                    era = f;\n                }\n            }\n        }", "comment": "/**\n         * Copy the supported fields from a chronology into this container.\n         */"}}
{"code": {"body": "    public long getDateTimeMillis(long instant,\n                                  int hourOfDay, int minuteOfHour,\n                                  int secondOfMinute, int millisOfSecond)\n        throws IllegalArgumentException\n    {\n        instant = hourOfDay().set(instant, hourOfDay);\n        instant = minuteOfHour().set(instant, minuteOfHour);\n        instant = secondOfMinute().set(instant, secondOfMinute);\n        return millisOfSecond().set(instant, millisOfSecond);\n    }", "comment": "/**\n     * Returns a datetime millisecond instant, from from the given instant,\n     * hour, minute, second, and millisecond values. The set of given values\n     * must refer to a valid datetime, or else an IllegalArgumentException is\n     * thrown.\n     * <p>\n     * The default implementation calls upon separate DateTimeFields to\n     * determine the result. Subclasses are encouraged to provide a more\n     * efficient implementation.\n     *\n     * @param instant instant to start from\n     * @param hourOfDay hour to use\n     * @param minuteOfHour minute to use\n     * @param secondOfMinute second to use\n     * @param millisOfSecond millisecond to use\n     * @return millisecond instant from 1970-01-01T00:00:00Z\n     */"}}
{"code": {"body": "    public void validate(ReadablePartial partial, int[] values) {\n        \n        \n        int size = partial.size();\n        for (int i = 0; i < size; i++) {\n            int value = values[i];\n            DateTimeField field = partial.getField(i);\n            if (value < field.getMinimumValue()) {\n                throw new IllegalFieldValueException\n                    (field.getType(), Integer.valueOf(value),\n                     Integer.valueOf(field.getMinimumValue()), null);\n            }\n            if (value > field.getMaximumValue()) {\n                throw new IllegalFieldValueException\n                    (field.getType(), Integer.valueOf(value),\n                     null, Integer.valueOf(field.getMaximumValue()));\n            }\n        }\n        \n        for (int i = 0; i < size; i++) {\n            int value = values[i];\n            DateTimeField field = partial.getField(i);\n            if (value < field.getMinimumValue(partial, values)) {\n                throw new IllegalFieldValueException\n                    (field.getType(), Integer.valueOf(value),\n                     Integer.valueOf(field.getMinimumValue(partial, values)), null);\n            }\n            if (value > field.getMaximumValue(partial, values)) {\n                throw new IllegalFieldValueException\n                    (field.getType(), Integer.valueOf(value),\n                     null, Integer.valueOf(field.getMaximumValue(partial, values)));\n            }\n        }\n    }", "comment": "/**\n     * Validates whether the fields stored in a partial instant are valid.\n     * <p>\n     * This implementation uses {@link DateTimeField#getMinimumValue(ReadablePartial, int[])}\n     * and {@link DateTimeField#getMaximumValue(ReadablePartial, int[])}.\n     *\n     * @param partial  the partial instant to validate\n     * @param values  the values to validate, not null unless the partial is empty\n     * @throws IllegalArgumentException if the instant is invalid\n     */"}}
{"code": {"body": "    public int[] get(ReadablePeriod period, long duration) {\n        int size = period.size();\n        int[] values = new int[size];\n        if (duration != 0) {\n            long current = 0;\n            for (int i = 0; i < size; i++) {\n                DurationField field = period.getFieldType(i).getField(this);\n                if (field.isPrecise()) {\n                    int value = field.getDifference(duration, current);\n                    current = field.add(current, value);\n                    values[i] = value;\n                }\n            }\n        }\n        return values;\n    }", "comment": "/**\n     * Gets the values of a period from an interval.\n     *\n     * @param period  the period instant to use\n     * @param duration  the duration to query\n     * @return the values of the period extracted from the duration\n     */"}}
{"code": {"body": "    public long set(ReadablePartial partial, long instant) {\n        for (int i = 0, isize = partial.size(); i < isize; i++) {\n            instant = partial.getFieldType(i).getField(this).set(instant, partial.getValue(i));\n        }\n        return instant;\n    }", "comment": "/**\n     * Sets the partial into the instant.\n     *\n     * @param partial  the partial instant to use\n     * @param instant  the instant to update\n     * @return the updated instant\n     */"}}
{"code": {"body": "    public long add(long instant, long duration, int scalar) {\n        if (duration == 0 || scalar == 0) {\n            return instant;\n        }\n        long add = FieldUtils.safeMultiply(duration, scalar);\n        return FieldUtils.safeAdd(instant, add);\n    }", "comment": "/**\n     * Adds the duration to the instant, specifying the number of times to add.\n     *\n     * @param instant  the instant to add to\n     * @param duration  the duration to add\n     * @param scalar  the number of times to add\n     * @return the updated instant\n     */"}}
{"code": {"body": "    public DurationField millis() {\n        return UnsupportedDurationField.getInstance(DurationFieldType.millis());\n    }", "comment": "/**\n     * Get the millis duration field for this chronology.\n     * \n     * @return DurationField or UnsupportedDurationField if unsupported\n     */"}}
{"code": {"body": "    public DateTimeField millisOfSecond() {\n        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.millisOfSecond(), millis());\n    }", "comment": "/**\n     * Get the millis of second field for this chronology.\n     * \n     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n     */"}}
{"code": {"body": "    public DateTimeField millisOfDay() {\n        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.millisOfDay(), millis());\n    }", "comment": "/**\n     * Get the millis of day field for this chronology.\n     * \n     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n     */"}}
{"code": {"body": "    public DurationField seconds() {\n        return UnsupportedDurationField.getInstance(DurationFieldType.seconds());\n    }", "comment": "/**\n     * Get the seconds duration field for this chronology.\n     * \n     * @return DurationField or UnsupportedDurationField if unsupported\n     */"}}
{"code": {"body": "    public DateTimeField secondOfMinute() {\n        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.secondOfMinute(), seconds());\n    }", "comment": "/**\n     * Get the second of minute field for this chronology.\n     * \n     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n     */"}}
{"code": {"body": "    public DateTimeField secondOfDay() {\n        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.secondOfDay(), seconds());\n    }", "comment": "/**\n     * Get the second of day field for this chronology.\n     * \n     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n     */"}}
{"code": {"body": "    public DurationField minutes() {\n        return UnsupportedDurationField.getInstance(DurationFieldType.minutes());\n    }", "comment": "/**\n     * Get the minutes duration field for this chronology.\n     * \n     * @return DurationField or UnsupportedDurationField if unsupported\n     */"}}
{"code": {"body": "    public DateTimeField minuteOfHour() {\n        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.minuteOfHour(), minutes());\n    }", "comment": "/**\n     * Get the minute of hour field for this chronology.\n     * \n     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n     */"}}
{"code": {"body": "    public DateTimeField minuteOfDay() {\n        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.minuteOfDay(), minutes());\n    }", "comment": "/**\n     * Get the minute of day field for this chronology.\n     * \n     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n     */"}}
{"code": {"body": "    public DurationField hours() {\n        return UnsupportedDurationField.getInstance(DurationFieldType.hours());\n    }", "comment": "/**\n     * Get the hours duration field for this chronology.\n     * \n     * @return DurationField or UnsupportedDurationField if unsupported\n     */"}}
{"code": {"body": "    public DateTimeField hourOfDay() {\n        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.hourOfDay(), hours());\n    }", "comment": "/**\n     * Get the hour of day (0-23) field for this chronology.\n     * \n     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n     */"}}
{"code": {"body": "    public DateTimeField clockhourOfDay() {\n        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.clockhourOfDay(), hours());\n    }", "comment": "/**\n     * Get the hour of day (offset to 1-24) field for this chronology.\n     * \n     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n     */"}}
{"code": {"body": "    public DurationField halfdays() {\n        return UnsupportedDurationField.getInstance(DurationFieldType.halfdays());\n    }", "comment": "/**\n     * Get the halfdays duration field for this chronology.\n     * \n     * @return DurationField or UnsupportedDurationField if unsupported\n     */"}}
{"code": {"body": "    public DateTimeField hourOfHalfday() {\n        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.hourOfHalfday(), hours());\n    }", "comment": "/**\n     * Get the hour of am/pm (0-11) field for this chronology.\n     * \n     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n     */"}}
{"code": {"body": "    public DateTimeField clockhourOfHalfday() {\n        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.clockhourOfHalfday(), hours());\n    }", "comment": "/**\n     * Get the hour of am/pm (offset to 1-12) field for this chronology.\n     * \n     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n     */"}}
{"code": {"body": "    public DateTimeField halfdayOfDay() {\n        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.halfdayOfDay(), halfdays());\n    }", "comment": "/**\n     * Get the AM(0) PM(1) field for this chronology.\n     * \n     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n     */"}}
{"code": {"body": "    public DurationField days() {\n        return UnsupportedDurationField.getInstance(DurationFieldType.days());\n    }", "comment": "/**\n     * Get the days duration field for this chronology.\n     * \n     * @return DurationField or UnsupportedDurationField if unsupported\n     */"}}
{"code": {"body": "    public DateTimeField dayOfWeek() {\n        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.dayOfWeek(), days());\n    }", "comment": "/**\n     * Get the day of week field for this chronology.\n     *\n     * <p>DayOfWeek values are defined in\n     * {@link org.joda.time.DateTimeConstants DateTimeConstants}.\n     * They use the ISO definitions, where 1 is Monday and 7 is Sunday.\n     * \n     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n     */"}}
{"code": {"body": "    public DateTimeField dayOfMonth() {\n        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.dayOfMonth(), days());\n    }", "comment": "/**\n     * Get the day of month field for this chronology.\n     * \n     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n     */"}}
{"code": {"body": "    public DateTimeField dayOfYear() {\n        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.dayOfYear(), days());\n    }", "comment": "/**\n     * Get the day of year field for this chronology.\n     * \n     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n     */"}}
{"code": {"body": "    public DurationField weeks() {\n        return UnsupportedDurationField.getInstance(DurationFieldType.weeks());\n    }", "comment": "/**\n     * Get the weeks duration field for this chronology.\n     * \n     * @return DurationField or UnsupportedDurationField if unsupported\n     */"}}
{"code": {"body": "    public DateTimeField weekOfWeekyear() {\n        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.weekOfWeekyear(), weeks());\n    }", "comment": "/**\n     * Get the week of a week based year field for this chronology.\n     * \n     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n     */"}}
{"code": {"body": "    public DurationField weekyears() {\n        return UnsupportedDurationField.getInstance(DurationFieldType.weekyears());\n    }", "comment": "/**\n     * Get the weekyears duration field for this chronology.\n     * \n     * @return DurationField or UnsupportedDurationField if unsupported\n     */"}}
{"code": {"body": "    public DateTimeField weekyear() {\n        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.weekyear(), weekyears());\n    }", "comment": "/**\n     * Get the year of a week based year field for this chronology.\n     * \n     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n     */"}}
{"code": {"body": "    public DateTimeField weekyearOfCentury() {\n        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.weekyearOfCentury(), weekyears());\n    }", "comment": "/**\n     * Get the year of a week based year in a century field for this chronology.\n     * \n     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n     */"}}
{"code": {"body": "    public DurationField months() {\n        return UnsupportedDurationField.getInstance(DurationFieldType.months());\n    }", "comment": "/**\n     * Get the months duration field for this chronology.\n     * \n     * @return DurationField or UnsupportedDurationField if unsupported\n     */"}}
{"code": {"body": "    public DateTimeField monthOfYear() {\n        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.monthOfYear(), months());\n    }", "comment": "/**\n     * Get the month of year field for this chronology.\n     * \n     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n     */"}}
{"code": {"body": "    public DurationField years() {\n        return UnsupportedDurationField.getInstance(DurationFieldType.years());\n    }", "comment": "/**\n     * Get the years duration field for this chronology.\n     * \n     * @return DurationField or UnsupportedDurationField if unsupported\n     */"}}
{"code": {"body": "    public DateTimeField year() {\n        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.year(), years());\n    }", "comment": "/**\n     * Get the year field for this chronology.\n     * \n     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n     */"}}
{"code": {"body": "    public DateTimeField yearOfEra() {\n        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.yearOfEra(), years());\n    }", "comment": "/**\n     * Get the year of era field for this chronology.\n     * \n     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n     */"}}
{"code": {"body": "    public DateTimeField yearOfCentury() {\n        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.yearOfCentury(), years());\n    }", "comment": "/**\n     * Get the year of century field for this chronology.\n     * \n     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n     */"}}
{"code": {"body": "    public DurationField centuries() {\n        return UnsupportedDurationField.getInstance(DurationFieldType.centuries());\n    }", "comment": "/**\n     * Get the centuries duration field for this chronology.\n     * \n     * @return DurationField or UnsupportedDurationField if unsupported\n     */"}}
{"code": {"body": "    public DateTimeField centuryOfEra() {\n        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.centuryOfEra(), centuries());\n    }", "comment": "/**\n     * Get the century of era field for this chronology.\n     * \n     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n     */"}}
{"code": {"body": "    public DurationField eras() {\n        return UnsupportedDurationField.getInstance(DurationFieldType.eras());\n    }", "comment": "/**\n     * Get the eras duration field for this chronology.\n     * \n     * @return DurationField or UnsupportedDurationField if unsupported\n     */"}}
{"code": {"body": "    public DateTimeField era() {\n        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.era(), eras());\n    }", "comment": "/**\n     * Get the era field for this chronology.\n     * \n     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n     */"}}
{"code": {"body": "    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj != null && getClass() == obj.getClass()) {\n            BasicChronology chrono = (BasicChronology) obj;\n            return getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() &&\n                    getZone().equals(chrono.getZone());\n        }\n        return false;\n    }", "comment": "/**\n     * Checks if this chronology instance equals another.\n     * \n     * @param obj  the object to compare to\n     * @return true if equal\n     * @since 1.6\n     */"}}
{"code": {"body": "    public int hashCode() {\n        return getClass().getName().hashCode() * 11 + getZone().hashCode() + getMinimumDaysInFirstWeek();\n    }", "comment": "/**\n     * A suitable hash code for the chronology.\n     * \n     * @return the hash code\n     * @since 1.6\n     */"}}
{"code": {"body": "    public String toString() {\n        StringBuilder sb = new StringBuilder(60);\n        String name = getClass().getName();\n        int index = name.lastIndexOf('');\n        if (index >= 0) {\n            name = name.substring(index + 1);\n        }\n        sb.append(name);\n        sb.append('');\n        DateTimeZone zone = getZone();\n        if (zone != null) {\n            sb.append(zone.getID());\n        }\n        if (getMinimumDaysInFirstWeek() != 4) {\n            sb.append(\"\");\n            sb.append(getMinimumDaysInFirstWeek());\n        }\n        sb.append('');\n        return sb.toString();\n    }", "comment": "/**\n     * Gets a debugging toString.\n     * \n     * @return a debugging string\n     */"}}
{"code": {"body": "    int getDaysInYearMax() {\n        return 366;\n    }", "comment": "/**\n     * Get the number of days in the year.\n     *\n     * @return 366\n     */"}}
{"code": {"body": "    int getDaysInYear(int year) {\n        return isLeapYear(year) ? 366 : 365;\n    }", "comment": "/**\n     * Get the number of days in the year.\n     *\n     * @param year  the year to use\n     * @return 366 if a leap year, otherwise 365\n     */"}}
{"code": {"body": "    int getWeeksInYear(int year) {\n        long firstWeekMillis1 = getFirstWeekOfYearMillis(year);\n        long firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1);\n        return (int) ((firstWeekMillis2 - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK);\n    }", "comment": "/**\n     * Get the number of weeks in the year.\n     *\n     * @param year  the year to use\n     * @return number of weeks in the year\n     */"}}
{"code": {"body": "    long getFirstWeekOfYearMillis(int year) {\n        long jan1millis = getYearMillis(year);\n        int jan1dayOfWeek = getDayOfWeek(jan1millis);\n        \n        if (jan1dayOfWeek > (8 - iMinDaysInFirstWeek)) {\n            \n            return jan1millis + (8 - jan1dayOfWeek)\n                * (long)DateTimeConstants.MILLIS_PER_DAY;\n        } else {\n            \n            return jan1millis - (jan1dayOfWeek - 1)\n                * (long)DateTimeConstants.MILLIS_PER_DAY;\n        }\n    }", "comment": "/**\n     * Get the millis for the first week of a year.\n     *\n     * @param year  the year to use\n     * @return millis\n     */"}}
{"code": {"body": "    long getYearMillis(int year) {\n        return getYearInfo(year).iFirstDayMillis;\n    }", "comment": "/**\n     * Get the milliseconds for the start of a year.\n     *\n     * @param year The year to use.\n     * @return millis from 1970-01-01T00:00:00Z\n     */"}}
{"code": {"body": "    long getYearMonthMillis(int year, int month) {\n        long millis = getYearMillis(year);\n        millis += getTotalMillisByYearMonth(year, month);\n        return millis;\n    }", "comment": "/**\n     * Get the milliseconds for the start of a month.\n     *\n     * @param year The year to use.\n     * @param month The month to use\n     * @return millis from 1970-01-01T00:00:00Z\n     */"}}
{"code": {"body": "    long getYearMonthDayMillis(int year, int month, int dayOfMonth) {\n        long millis = getYearMillis(year);\n        millis += getTotalMillisByYearMonth(year, month);\n        return millis + (dayOfMonth - 1) * (long)DateTimeConstants.MILLIS_PER_DAY;\n    }", "comment": "/**\n     * Get the milliseconds for a particular date.\n     *\n     * @param year The year to use.\n     * @param month The month to use\n     * @param dayOfMonth The day of the month to use\n     * @return millis from 1970-01-01T00:00:00Z\n     */"}}
{"code": {"body": "    int getYear(long instant) {\n        \n        \n        \n\n        \n        long unitMillis = getAverageMillisPerYearDividedByTwo();\n        long i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo();\n        if (i2 < 0) {\n            i2 = i2 - unitMillis + 1;\n        }\n        int year = (int) (i2 / unitMillis);\n\n        long yearStart = getYearMillis(year);\n        long diff = instant - yearStart;\n\n        if (diff < 0) {\n            year--;\n        } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) {\n            \n            long oneYear;\n            if (isLeapYear(year)) {\n                oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L;\n            } else {\n                oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L;\n            }\n\n            yearStart += oneYear;\n\n            if (yearStart <= instant) {\n                \n                year++;\n            }\n        }\n\n        return year;\n    }", "comment": "/**\n     * @param instant millis from 1970-01-01T00:00:00Z\n     */"}}
{"code": {"body": "    int getDayOfMonth(long millis, int year, int month) {\n        long dateMillis = getYearMillis(year);\n        dateMillis += getTotalMillisByYearMonth(year, month);\n        return (int) ((millis - dateMillis) / DateTimeConstants.MILLIS_PER_DAY) + 1;\n    }", "comment": "/**\n     * @param millis from 1970-01-01T00:00:00Z\n     * @param year precalculated year of millis\n     * @param month precalculated month of millis\n     */"}}
{"code": {"body": "    int getDayOfYear(long instant, int year) {\n        long yearStart = getYearMillis(year);\n        return (int) ((instant - yearStart) / DateTimeConstants.MILLIS_PER_DAY) + 1;\n    }", "comment": "/**\n     * @param instant millis from 1970-01-01T00:00:00Z\n     * @param year precalculated year of millis\n     */"}}
{"code": {"body": "    int getWeekyear(long instant) {\n        int year = getYear(instant);\n        int week = getWeekOfWeekyear(instant, year);\n        if (week == 1) {\n            return getYear(instant + DateTimeConstants.MILLIS_PER_WEEK);\n        } else if (week > 51) {\n            return getYear(instant - (2 * DateTimeConstants.MILLIS_PER_WEEK));\n        } else {\n            return year;\n        }\n    }", "comment": "/**\n     * @param instant millis from 1970-01-01T00:00:00Z\n     */"}}
{"code": {"body": "    int getWeekOfWeekyear(long instant, int year) {\n        long firstWeekMillis1 = getFirstWeekOfYearMillis(year);\n        if (instant < firstWeekMillis1) {\n            return getWeeksInYear(year - 1);\n        }\n        long firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1);\n        if (instant >= firstWeekMillis2) {\n            return 1;\n        }\n        return (int) ((instant - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK) + 1;\n    }", "comment": "/**\n     * @param instant millis from 1970-01-01T00:00:00Z\n     * @param year precalculated year of millis\n     */"}}
{"code": {"body": "    int getDayOfWeek(long instant) {\n        \n\n        long daysSince19700101;\n        if (instant >= 0) {\n            daysSince19700101 = instant / DateTimeConstants.MILLIS_PER_DAY;\n        } else {\n            daysSince19700101 = (instant - (DateTimeConstants.MILLIS_PER_DAY - 1))\n                / DateTimeConstants.MILLIS_PER_DAY;\n            if (daysSince19700101 < -3) {\n                return 7 + (int) ((daysSince19700101 + 4) % 7);\n            }\n        }\n\n        return 1 + (int) ((daysSince19700101 + 3) % 7);\n    }", "comment": "/**\n     * @param instant millis from 1970-01-01T00:00:00Z\n     */"}}
{"code": {"body": "    int getMillisOfDay(long instant) {\n        if (instant >= 0) {\n            return (int) (instant % DateTimeConstants.MILLIS_PER_DAY);\n        } else {\n            return (DateTimeConstants.MILLIS_PER_DAY - 1)\n                + (int) ((instant + 1) % DateTimeConstants.MILLIS_PER_DAY);\n        }\n    }", "comment": "/**\n     * @param instant millis from 1970-01-01T00:00:00Z\n     */"}}
{"code": {"body": "    int getDaysInMonthMaxForSet(long instant, int value) {\n        return getDaysInMonthMax(instant);\n    }", "comment": "/**\n     * Gets the maximum number of days in the month specified by the instant.\n     * The value represents what the user is trying to set, and can be\n     * used to optimise this method.\n     * \n     * @param instant  millis from 1970-01-01T00:00:00Z\n     * @param value  the value being set\n     * @return the maximum number of days in the month\n     */"}}
{"code": {"body": "    long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth) {\n        FieldUtils.verifyValueBounds(DateTimeFieldType.year(), year, getMinYear(), getMaxYear());\n        FieldUtils.verifyValueBounds(DateTimeFieldType.monthOfYear(), monthOfYear, 1, getMaxMonth(year));\n        FieldUtils.verifyValueBounds(DateTimeFieldType.dayOfMonth(), dayOfMonth, 1, getDaysInYearMonth(year, monthOfYear));\n        return getYearMonthDayMillis(year, monthOfYear, dayOfMonth);\n    }", "comment": "/**\n     * Gets the milliseconds for a date at midnight.\n     * \n     * @param year  the year\n     * @param monthOfYear  the month\n     * @param dayOfMonth  the day\n     * @return the milliseconds\n     */"}}
{"code": {"body": "    int getMaxMonth() {\n        return 12;\n    }", "comment": "/**\n     * Gets the maximum number of months.\n     * \n     * @return 12\n     */"}}
{"code": {"body": "    private Object readResolve() {\n        return iChronology.dayOfMonth();\n    }", "comment": "/**\n     * Serialization singleton\n     */"}}
{"code": {"body": "    public int get(long instant) {\n        return iChronology.getDayOfYear(instant);\n    }", "comment": "/**\n     * Get the day of the year component of the specified time instant.\n     * \n     * @param instant  the time instant in millis to query.\n     * @return the day of the year extracted from the input.\n     */"}}
{"code": {"body": "    private Object readResolve() {\n        return iChronology.dayOfYear();\n    }", "comment": "/**\n     * Serialization singleton\n     */"}}
{"code": {"body": "    int getDaysInYearMonth(int year, int month) {\n        if (isLeapYear(year)) {\n            return MAX_DAYS_PER_MONTH_ARRAY[month - 1];\n        } else {\n            return MIN_DAYS_PER_MONTH_ARRAY[month - 1];\n        }\n    }", "comment": "/**\n     * Gets the number of days in the specified month and year.\n     * \n     * @param year  the year\n     * @param month  the month\n     * @return the number of days\n     */"}}
{"code": {"body": "    public int get(long instant) {\n        return iChronology.getMonthOfYear(instant);\n    }", "comment": "/**\n     * Get the Month component of the specified time instant.\n     *\n     * @see org.joda.time.DateTimeField#get(long)\n     * @see org.joda.time.ReadableDateTime#getMonthOfYear()\n     * @param instant  the time instant in millis to query.\n     * @return the month extracted from the input.\n     */"}}
{"code": {"body": "    public long addWrapField(long instant, int months) {\n        return set(instant, FieldUtils.getWrappedValue(get(instant), months, MIN, iMax));\n    }", "comment": "/**\n     * Add to the Month component of the specified time instant\n     * wrapping around within that component if necessary.\n     * \n     * @see org.joda.time.DateTimeField#addWrapField\n     * @param instant  the time instant in millis to update.\n     * @param months  the months to add (can be negative).\n     * @return the updated time instant.\n     */"}}
{"code": {"body": "    public long set(long instant, int month) {\n        FieldUtils.verifyValueBounds(this, month, MIN, iMax);\n        \n        int thisYear = iChronology.getYear(instant);\n        \n        int thisDom = iChronology.getDayOfMonth(instant, thisYear);\n        int maxDom = iChronology.getDaysInYearMonth(thisYear, month);\n        if (thisDom > maxDom) {\n            \n            thisDom = maxDom;\n        }\n        \n        return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\n            iChronology.getMillisOfDay(instant);\n    }", "comment": "/**\n     * Set the Month component of the specified time instant.<p>\n     * If the new month has less total days than the specified\n     * day of the month, this value is coerced to the nearest\n     * sane value. e.g.<p>\n     * 07-31 to month 6 = 06-30<p>\n     * 03-31 to month 2 = 02-28 or 02-29 depending<p>\n     * \n     * @param instant  the time instant in millis to update.\n     * @param month  the month (1,12) to update the time to.\n     * @return the updated time instant.\n     * @throws IllegalArgumentException  if month is invalid\n     */"}}
{"code": {"body": "    private Object readResolve() {\n        return iChronology.monthOfYear();\n    }", "comment": "/**\n     * Serialization singleton\n     */"}}
{"code": {"body": "    public boolean isLenient() {\n        return false;\n    }", "comment": "/** @inheritDoc */"}}
{"code": {"body": "    public int get(long instant) {\n        return ERA_VALUE;\n    }", "comment": "/** @inheritDoc */"}}
{"code": {"body": "    public long set(long instant, String text, Locale locale) {\n        if (iEraText.equals(text) == false && \"\".equals(text) == false) {\n            throw new IllegalFieldValueException(DateTimeFieldType.era(), text);\n        }\n        return instant;\n    }", "comment": "/** @inheritDoc */"}}
{"code": {"body": "    public long roundFloor(long instant) {\n        return Long.MIN_VALUE;\n    }", "comment": "/** @inheritDoc */"}}
{"code": {"body": "    public long roundCeiling(long instant) {\n        return Long.MAX_VALUE;\n    }", "comment": "/** @inheritDoc */"}}
{"code": {"body": "    public long roundHalfFloor(long instant) {\n        return Long.MIN_VALUE;\n    }", "comment": "/** @inheritDoc */"}}
{"code": {"body": "    public long roundHalfCeiling(long instant) {\n        return Long.MIN_VALUE;\n    }", "comment": "/** @inheritDoc */"}}
{"code": {"body": "    public long roundHalfEven(long instant) {\n        return Long.MIN_VALUE;\n    }", "comment": "/** @inheritDoc */"}}
{"code": {"body": "    public DurationField getDurationField() {\n        return UnsupportedDurationField.getInstance(DurationFieldType.eras());\n    }", "comment": "/** @inheritDoc */"}}
{"code": {"body": "    public DurationField getRangeDurationField() {\n        return null;\n    }", "comment": "/** @inheritDoc */"}}
{"code": {"body": "    public int getMinimumValue() {\n        return ERA_VALUE;\n    }", "comment": "/** @inheritDoc */"}}
{"code": {"body": "    public int getMaximumValue() {\n        return ERA_VALUE;\n    }", "comment": "/** @inheritDoc */"}}
{"code": {"body": "    public String getAsText(int fieldValue, Locale locale) {\n        return iEraText;\n    }", "comment": "/** @inheritDoc */"}}
{"code": {"body": "    public int getMaximumTextLength(Locale locale) {\n        return iEraText.length();\n    }", "comment": "/** @inheritDoc */"}}
{"code": {"body": "    public int get(long instant) {\n        return iChronology.getWeekOfWeekyear(instant);\n    }", "comment": "/**\n     * Get the week of a week based year component of the specified time instant.\n     * \n     * @see org.joda.time.DateTimeField#get(long)\n     * @param instant  the time instant in millis to query.\n     * @return the week of the year extracted from the input.\n     */"}}
{"code": {"body": "    private Object readResolve() {\n        return iChronology.weekOfWeekyear();\n    }", "comment": "/**\n     * Serialization singleton\n     */"}}
{"code": {"body": "    public int get(long instant) {\n        return iChronology.getWeekyear(instant);\n    }", "comment": "/**\n     * Get the Year of a week based year component of the specified time instant.\n     * \n     * @see org.joda.time.DateTimeField#get\n     * @param instant  the time instant in millis to query.\n     * @return the year extracted from the input.\n     */"}}
{"code": {"body": "    public long addWrapField(long instant, int years) {\n        return add(instant, years);\n    }", "comment": "/**\n     * Add to the year component of the specified time instant\n     * wrapping around within that component if necessary.\n     * \n     * @see org.joda.time.DateTimeField#addWrapField\n     * @param instant  the time instant in millis to update.\n     * @param years  the years to add (can be negative).\n     * @return the updated time instant.\n     */"}}
{"code": {"body": "    public long set(long instant, int year) {\n        FieldUtils.verifyValueBounds(this, Math.abs(year),\n                                     iChronology.getMinYear(), iChronology.getMaxYear());\n        \n        \n        \n        int thisWeekyear = get( instant );\n        if ( thisWeekyear == year ) {\n            return instant;\n        }\n        \n        \n        \n        int thisDow = iChronology.getDayOfWeek(instant);\n        \n        \n        \n        int weeksInFromYear = iChronology.getWeeksInYear( thisWeekyear );\n        int weeksInToYear = iChronology.getWeeksInYear( year );\n        int maxOutWeeks = (weeksInToYear < weeksInFromYear) ?\n            weeksInToYear : weeksInFromYear;\n        \n        \n        \n        \n        \n        \n        int setToWeek = iChronology.getWeekOfWeekyear(instant);\n        if ( setToWeek > maxOutWeeks ) {\n            setToWeek = maxOutWeeks;\n        }\n        \n        \n        \n        \n        long workInstant = instant; \n        \n        \n        \n        \n        \n        workInstant = iChronology.setYear( workInstant, year );\n        \n        \n        \n        \n        int workWoyYear = get( workInstant );\n\n        \n        \n        \n        \n        if ( workWoyYear < year ) {\n            workInstant += DateTimeConstants.MILLIS_PER_WEEK;\n        } else if ( workWoyYear > year ) {\n            workInstant -= DateTimeConstants.MILLIS_PER_WEEK;\n        }\n        \n        \n        \n\n        \n        int currentWoyWeek = iChronology.getWeekOfWeekyear(workInstant);\n        \n        workInstant = workInstant + (setToWeek - currentWoyWeek)\n            * (long)DateTimeConstants.MILLIS_PER_WEEK;\n        \n\n        \n        \n        \n        \n        \n        workInstant = iChronology.dayOfWeek().set( workInstant, thisDow );\n        \n        \n        \n        return workInstant;\n    }", "comment": "/**\n     * Set the Year of a week based year component of the specified time instant.\n     *\n     * @see org.joda.time.DateTimeField#set\n     * @param instant  the time instant in millis to update.\n     * @param year  the year (-9999,9999) to set the date to.\n     * @return the updated DateTime.\n     * @throws IllegalArgumentException  if year is invalid.\n     */"}}
{"code": {"body": "    private Object readResolve() {\n        return iChronology.weekyear();\n    }", "comment": "/**\n     * Serialization singleton\n     */"}}
{"code": {"body": "    private Object readResolve() {\n        return iChronology.year();\n    }", "comment": "/**\n     * Serialization singleton\n     */"}}
{"code": {"body": "    public static BuddhistChronology getInstanceUTC() {\n        return INSTANCE_UTC;\n    }", "comment": "/**\n     * Standard instance of a Buddhist Chronology, that matches\n     * Sun's BuddhistCalendar class. This means that it follows the\n     * GregorianJulian calendar rules with a cutover date.\n     * <p>\n     * The time zone of the returned instance is UTC.\n     */"}}
{"code": {"body": "    public static synchronized BuddhistChronology getInstance(DateTimeZone zone) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        BuddhistChronology chrono;\n        synchronized (cCache) {\n            chrono = cCache.get(zone);\n            if (chrono == null) {\n                \n                chrono = new BuddhistChronology(GJChronology.getInstance(zone, null), null);\n                \n                DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);\n                chrono = new BuddhistChronology(LimitChronology.getInstance(chrono, lowerLimit, null), \"\");\n                cCache.put(zone, chrono);\n            }\n        }\n        return chrono;\n    }", "comment": "/**\n     * Standard instance of a Buddhist Chronology, that matches\n     * Sun's BuddhistCalendar class. This means that it follows the\n     * GregorianJulian calendar rules with a cutover date.\n     *\n     * @param zone  the time zone to use, null is default\n     */"}}
{"code": {"body": "    private Object readResolve() {\n        Chronology base = getBase();\n        return base == null ? getInstanceUTC() : getInstance(base.getZone());\n    }", "comment": "/**\n     * Serialization singleton\n     */"}}
{"code": {"body": "    public Chronology withUTC() {\n        return INSTANCE_UTC;\n    }", "comment": "/**\n     * Gets the Chronology in the UTC time zone.\n     * \n     * @return the chronology in UTC\n     */"}}
{"code": {"body": "    public Chronology withZone(DateTimeZone zone) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        if (zone == getZone()) {\n            return this;\n        }\n        return getInstance(zone);\n    }", "comment": "/**\n     * Gets the Chronology in a specific time zone.\n     * \n     * @param zone  the zone to get the chronology in, null is default\n     * @return the chronology\n     */"}}
{"code": {"body": "    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj instanceof BuddhistChronology) {\n            BuddhistChronology chrono = (BuddhistChronology) obj;\n            return getZone().equals(chrono.getZone());\n        }\n        return false;\n    }", "comment": "/**\n     * Checks if this chronology instance equals another.\n     * \n     * @param obj  the object to compare to\n     * @return true if equal\n     * @since 1.6\n     */"}}
{"code": {"body": "    public int hashCode() {\n        return \"\".hashCode() * 11 + getZone().hashCode();\n    }", "comment": "/**\n     * A suitable hash code for the chronology.\n     * \n     * @return the hash code\n     * @since 1.6\n     */"}}
{"code": {"body": "    public String toString() {\n        String str = \"\";\n        DateTimeZone zone = getZone();\n        if (zone != null) {\n            str = str + '' + zone.getID() + '';\n        }\n        return str;\n    }", "comment": "/**\n     * Gets a debugging toString.\n     * \n     * @return a debugging string\n     */"}}
{"code": {"body": "    public static CopticChronology getInstanceUTC() {\n        return INSTANCE_UTC;\n    }", "comment": "/**\n     * Gets an instance of the CopticChronology.\n     * The time zone of the returned instance is UTC.\n     * \n     * @return a singleton UTC instance of the chronology\n     */"}}
{"code": {"body": "    public static CopticChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        CopticChronology chrono;\n        synchronized (cCache) {\n            CopticChronology[] chronos = cCache.get(zone);\n            if (chronos == null) {\n                chronos = new CopticChronology[7];\n                cCache.put(zone, chronos);\n            }\n            try {\n                chrono = chronos[minDaysInFirstWeek - 1];\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new IllegalArgumentException\n                    (\"\" + minDaysInFirstWeek);\n            }\n            if (chrono == null) {\n                if (zone == DateTimeZone.UTC) {\n                    \n                    chrono = new CopticChronology(null, null, minDaysInFirstWeek);\n                    \n                    DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);\n                    chrono = new CopticChronology\n                        (LimitChronology.getInstance(chrono, lowerLimit, null),\n                         null, minDaysInFirstWeek);\n                } else {\n                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\n                    chrono = new CopticChronology\n                        (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\n                }\n                chronos[minDaysInFirstWeek - 1] = chrono;\n            }\n        }\n        return chrono;\n    }", "comment": "/**\n     * Gets an instance of the CopticChronology in the given time zone.\n     * \n     * @param zone  the time zone to get the chronology in, null is default\n     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n     * @return a chronology in the specified time zone\n     */"}}
{"code": {"body": "    private Object readResolve() {\n        Chronology base = getBase();\n        int minDays = getMinimumDaysInFirstWeek();\n        minDays = (minDays == 0 ? 4 : minDays);  \n        return base == null ?\n                getInstance(DateTimeZone.UTC, minDays) :\n                    getInstance(base.getZone(), minDays);\n    }", "comment": "/**\n     * Serialization singleton.\n     */"}}
{"code": {"body": "    public Chronology withUTC() {\n        return INSTANCE_UTC;\n    }", "comment": "/**\n     * Gets the Chronology in the UTC time zone.\n     * \n     * @return the chronology in UTC\n     */"}}
{"code": {"body": "    public Chronology withZone(DateTimeZone zone) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        if (zone == getZone()) {\n            return this;\n        }\n        return getInstance(zone);\n    }", "comment": "/**\n     * Gets the Chronology in a specific time zone.\n     * \n     * @param zone  the zone to get the chronology in, null is default\n     * @return the chronology\n     */"}}
{"code": {"body": "    public static EthiopicChronology getInstanceUTC() {\n        return INSTANCE_UTC;\n    }", "comment": "/**\n     * Gets an instance of the EthiopicChronology.\n     * The time zone of the returned instance is UTC.\n     * \n     * @return a singleton UTC instance of the chronology\n     */"}}
{"code": {"body": "    public static EthiopicChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        EthiopicChronology chrono;\n        synchronized (cCache) {\n            EthiopicChronology[] chronos = cCache.get(zone);\n            if (chronos == null) {\n                chronos = new EthiopicChronology[7];\n                cCache.put(zone, chronos);\n            }\n            try {\n                chrono = chronos[minDaysInFirstWeek - 1];\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new IllegalArgumentException\n                    (\"\" + minDaysInFirstWeek);\n            }\n            if (chrono == null) {\n                if (zone == DateTimeZone.UTC) {\n                    \n                    chrono = new EthiopicChronology(null, null, minDaysInFirstWeek);\n                    \n                    DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);\n                    chrono = new EthiopicChronology\n                        (LimitChronology.getInstance(chrono, lowerLimit, null),\n                         null, minDaysInFirstWeek);\n                } else {\n                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\n                    chrono = new EthiopicChronology\n                        (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\n                }\n                chronos[minDaysInFirstWeek - 1] = chrono;\n            }\n        }\n        return chrono;\n    }", "comment": "/**\n     * Gets an instance of the EthiopicChronology in the given time zone.\n     * \n     * @param zone  the time zone to get the chronology in, null is default\n     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n     * @return a chronology in the specified time zone\n     */"}}
{"code": {"body": "    private Object readResolve() {\n        Chronology base = getBase();\n        return base == null ?\n                getInstance(DateTimeZone.UTC, getMinimumDaysInFirstWeek()) :\n                    getInstance(base.getZone(), getMinimumDaysInFirstWeek());\n    }", "comment": "/**\n     * Serialization singleton.\n     */"}}
{"code": {"body": "    public Chronology withUTC() {\n        return INSTANCE_UTC;\n    }", "comment": "/**\n     * Gets the Chronology in the UTC time zone.\n     * \n     * @return the chronology in UTC\n     */"}}
{"code": {"body": "    public Chronology withZone(DateTimeZone zone) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        if (zone == getZone()) {\n            return this;\n        }\n        return getInstance(zone);\n    }", "comment": "/**\n     * Gets the Chronology in a specific time zone.\n     * \n     * @param zone  the zone to get the chronology in, null is default\n     * @return the chronology\n     */"}}
{"code": {"body": "    private static long convertByYear(long instant, Chronology from, Chronology to) {\n        return to.getDateTimeMillis\n            (from.year().get(instant),\n             from.monthOfYear().get(instant),\n             from.dayOfMonth().get(instant),\n             from.millisOfDay().get(instant));\n    }", "comment": "/**\n     * Convert a datetime from one chronology to another.\n     */"}}
{"code": {"body": "    private static long convertByWeekyear(final long instant, Chronology from, Chronology to) {\n        long newInstant;\n        newInstant = to.weekyear().set(0, from.weekyear().get(instant));\n        newInstant = to.weekOfWeekyear().set(newInstant, from.weekOfWeekyear().get(instant));\n        newInstant = to.dayOfWeek().set(newInstant, from.dayOfWeek().get(instant));\n        newInstant = to.millisOfDay().set(newInstant, from.millisOfDay().get(instant));\n        return newInstant;\n    }", "comment": "/**\n     * Convert a datetime from one chronology to another.\n     */"}}
{"code": {"body": "    public static GJChronology getInstanceUTC() {\n        return getInstance(DateTimeZone.UTC, DEFAULT_CUTOVER, 4);\n    }", "comment": "/**\n     * Factory method returns instances of the default GJ cutover\n     * chronology. This uses a cutover date of October 15, 1582 (Gregorian)\n     * 00:00:00 UTC. For this value, October 4, 1582 (Julian) is followed by\n     * October 15, 1582 (Gregorian).\n     *\n     * <p>The first day of the week is designated to be\n     * {@link org.joda.time.DateTimeConstants#MONDAY Monday},\n     * and the minimum days in the first week of the year is 4.\n     *\n     * <p>The time zone of the returned instance is UTC.\n     */"}}
{"code": {"body": "    public static GJChronology getInstance(\n            DateTimeZone zone,\n            long gregorianCutover,\n            int minDaysInFirstWeek) {\n        \n        Instant cutoverInstant;\n        if (gregorianCutover == DEFAULT_CUTOVER.getMillis()) {\n            cutoverInstant = null;\n        } else {\n            cutoverInstant = new Instant(gregorianCutover);\n        }\n        return getInstance(zone, cutoverInstant, minDaysInFirstWeek);\n    }", "comment": "/**\n     * Factory method returns instances of the GJ cutover chronology. Any\n     * cutover date may be specified.\n     *\n     * @param zone  the time zone to use, null is default\n     * @param gregorianCutover  the cutover to use\n     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n     */"}}
{"code": {"body": "    private Object readResolve() {\n        return getInstance(getZone(), iCutoverInstant, getMinimumDaysInFirstWeek());\n    }", "comment": "/**\n     * Serialization singleton\n     */"}}
{"code": {"body": "    public Chronology withUTC() {\n        return withZone(DateTimeZone.UTC);\n    }", "comment": "/**\n     * Gets the Chronology in the UTC time zone.\n     * \n     * @return the chronology in UTC\n     */"}}
{"code": {"body": "    public Chronology withZone(DateTimeZone zone) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        if (zone == getZone()) {\n            return this;\n        }\n        return getInstance(zone, iCutoverInstant, getMinimumDaysInFirstWeek());\n    }", "comment": "/**\n     * Gets the Chronology in a specific time zone.\n     * \n     * @param zone  the zone to get the chronology in, null is default\n     * @return the chronology\n     */"}}
{"code": {"body": "    public Instant getGregorianCutover() {\n        return iCutoverInstant;\n    }", "comment": "/**\n     * Gets the cutover instant between Gregorian and Julian chronologies.\n     * @return the cutover instant\n     */"}}
{"code": {"body": "    public int getMinimumDaysInFirstWeek() {\n        return iGregorianChronology.getMinimumDaysInFirstWeek();\n    }", "comment": "/**\n     * Gets the minimum days needed for a week to be the first week in a year.\n     * \n     * @return the minimum days\n     */"}}
{"code": {"body": "    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj instanceof GJChronology) {\n            GJChronology chrono = (GJChronology) obj;\n            return iCutoverMillis == chrono.iCutoverMillis &&\n                    getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() &&\n                    getZone().equals(chrono.getZone());\n        }\n        return false;\n    }", "comment": "/**\n     * Checks if this chronology instance equals another.\n     * \n     * @param obj  the object to compare to\n     * @return true if equal\n     * @since 1.6\n     */"}}
{"code": {"body": "    public int hashCode() {\n        return \"\".hashCode() * 11 + getZone().hashCode() +\n                getMinimumDaysInFirstWeek() + iCutoverInstant.hashCode();\n    }", "comment": "/**\n     * A suitable hash code for the chronology.\n     * \n     * @return the hash code\n     * @since 1.6\n     */"}}
{"code": {"body": "    public String toString() {\n        StringBuffer sb = new StringBuffer(60);\n        sb.append(\"\");\n        sb.append('');\n        sb.append(getZone().getID());\n        \n        if (iCutoverMillis != DEFAULT_CUTOVER.getMillis()) {\n            sb.append(\"\");\n            DateTimeFormatter printer;\n            if (withUTC().dayOfYear().remainder(iCutoverMillis) == 0) {\n                printer = ISODateTimeFormat.date();\n            } else {\n                printer = ISODateTimeFormat.dateTime();\n            }\n            printer.withChronology(withUTC()).printTo(sb, iCutoverMillis);\n        }\n        \n        if (getMinimumDaysInFirstWeek() != 4) {\n            sb.append(\"\");\n            sb.append(getMinimumDaysInFirstWeek());\n        }\n        sb.append('');\n        \n        return sb.toString();\n    }", "comment": "/**\n     * Gets a debugging toString.\n     * \n     * @return a debugging string\n     */"}}
{"code": {"body": "    public int get(long instant) {\n        return iChronology.getDayOfWeek(instant);\n    }", "comment": "/**\n     * Get the value of the specified time instant.\n     * \n     * @param instant  the time instant in millis to query\n     * @return the day of the week extracted from the input\n     */"}}
{"code": {"body": "    public String getAsText(int fieldValue, Locale locale) {\n        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToText(fieldValue);\n    }", "comment": "/**\n     * Get the textual value of the specified time instant.\n     * \n     * @param fieldValue  the field value to query\n     * @param locale  the locale to use\n     * @return the day of the week, such as 'Monday'\n     */"}}
{"code": {"body": "    public String getAsShortText(int fieldValue, Locale locale) {\n        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToShortText(fieldValue);\n    }", "comment": "/**\n     * Get the abbreviated textual value of the specified time instant.\n     * \n     * @param fieldValue  the field value to query\n     * @param locale  the locale to use\n     * @return the day of the week, such as 'Mon'\n     */"}}
{"code": {"body": "    protected int convertText(String text, Locale locale) {\n        return GJLocaleSymbols.forLocale(locale).dayOfWeekTextToValue(text);\n    }", "comment": "/**\n     * Convert the specified text and locale into a value.\n     * \n     * @param text  the text to convert\n     * @param locale  the locale to convert using\n     * @return the value extracted from the text\n     * @throws IllegalArgumentException if the text is invalid\n     */"}}
{"code": {"body": "    public int getMinimumValue() {\n        return DateTimeConstants.MONDAY;\n    }", "comment": "/**\n     * Get the minimum value that this field can have.\n     * \n     * @return the field's minimum value\n     */"}}
{"code": {"body": "    public int getMaximumValue() {\n        return DateTimeConstants.SUNDAY;\n    }", "comment": "/**\n     * Get the maximum value that this field can have.\n     * \n     * @return the field's maximum value\n     */"}}
{"code": {"body": "    public int getMaximumTextLength(Locale locale) {\n        return GJLocaleSymbols.forLocale(locale).getDayOfWeekMaxTextLength();\n    }", "comment": "/**\n     * Get the maximum length of the text returned by this field.\n     * \n     * @param locale  the locale to use\n     * @return the maximum textual length\n     */"}}
{"code": {"body": "    public int getMaximumShortTextLength(Locale locale) {\n        return GJLocaleSymbols.forLocale(locale).getDayOfWeekMaxShortTextLength();\n    }", "comment": "/**\n     * Get the maximum length of the abbreviated text returned by this field.\n     * \n     * @param locale  the locale to use\n     * @return the maximum abbreviated textual length\n     */"}}
{"code": {"body": "    private Object readResolve() {\n        return iChronology.dayOfWeek();\n    }", "comment": "/**\n     * Serialization singleton\n     */"}}
{"code": {"body": "    public int get(long instant) {\n        if (iChronology.getYear(instant) <= 0) {\n            return DateTimeConstants.BCE;\n        } else {\n            return DateTimeConstants.CE;\n        }\n    }", "comment": "/**\n     * Get the Era component of the specified time instant.\n     * \n     * @param instant  the time instant in millis to query.\n     */"}}
{"code": {"body": "    private Object readResolve() {\n        return iChronology.era();\n    }", "comment": "/**\n     * Serialization singleton\n     */"}}
{"code": {"body": "    public long set(long instant, int year) {\n        FieldUtils.verifyValueBounds(this, year, 1, getMaximumValue());\n        if (iChronology.getYear(instant) <= 0) {\n            year = 1 - year;\n        }\n        return super.set(instant, year);\n    }", "comment": "/**\n     * Set the year component of the specified time instant.\n     * \n     * @param instant  the time instant in millis to update.\n     * @param year  the year (0,292278994) to update the time to.\n     * @return the updated time instant.\n     * @throws IllegalArgumentException  if year is invalid.\n     */"}}
{"code": {"body": "    private Object readResolve() {\n        return iChronology.yearOfEra();\n    }", "comment": "/**\n     * Serialization singleton\n     */"}}
{"code": {"body": "    public static GregorianChronology getInstanceUTC() {\n        return INSTANCE_UTC;\n    }", "comment": "/**\n     * Gets an instance of the GregorianChronology.\n     * The time zone of the returned instance is UTC.\n     * \n     * @return a singleton UTC instance of the chronology\n     */"}}
{"code": {"body": "    public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        GregorianChronology chrono;\n        synchronized (cCache) {\n            GregorianChronology[] chronos = cCache.get(zone);\n            if (chronos == null) {\n                chronos = new GregorianChronology[7];\n                cCache.put(zone, chronos);\n            }\n            try {\n                chrono = chronos[minDaysInFirstWeek - 1];\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new IllegalArgumentException\n                    (\"\" + minDaysInFirstWeek);\n            }\n            if (chrono == null) {\n                if (zone == DateTimeZone.UTC) {\n                    chrono = new GregorianChronology(null, null, minDaysInFirstWeek);\n                } else {\n                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\n                    chrono = new GregorianChronology\n                        (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\n                }\n                chronos[minDaysInFirstWeek - 1] = chrono;\n            }\n        }\n        return chrono;\n    }", "comment": "/**\n     * Gets an instance of the GregorianChronology in the given time zone.\n     * \n     * @param zone  the time zone to get the chronology in, null is default\n     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n     * @return a chronology in the specified time zone\n     */"}}
{"code": {"body": "    private Object readResolve() {\n        Chronology base = getBase();\n        int minDays = getMinimumDaysInFirstWeek();\n        minDays = (minDays == 0 ? 4 : minDays);  \n        return base == null ?\n                getInstance(DateTimeZone.UTC, minDays) :\n                    getInstance(base.getZone(), minDays);\n    }", "comment": "/**\n     * Serialization singleton\n     */"}}
{"code": {"body": "    public Chronology withUTC() {\n        return INSTANCE_UTC;\n    }", "comment": "/**\n     * Gets the Chronology in the UTC time zone.\n     * \n     * @return the chronology in UTC\n     */"}}
{"code": {"body": "    public Chronology withZone(DateTimeZone zone) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        if (zone == getZone()) {\n            return this;\n        }\n        return getInstance(zone);\n    }", "comment": "/**\n     * Gets the Chronology in a specific time zone.\n     * \n     * @param zone  the zone to get the chronology in, null is default\n     * @return the chronology\n     */"}}
{"code": {"body": "    public static IslamicChronology getInstanceUTC() {\n        return INSTANCE_UTC;\n    }", "comment": "/**\n     * Gets an instance of the IslamicChronology.\n     * The time zone of the returned instance is UTC.\n     * \n     * @return a singleton UTC instance of the chronology\n     */"}}
{"code": {"body": "    public static IslamicChronology getInstance(DateTimeZone zone, LeapYearPatternType leapYears) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        IslamicChronology chrono;\n        synchronized (cCache) {\n            IslamicChronology[] chronos = cCache.get(zone);\n            if (chronos == null) {\n                chronos = new IslamicChronology[4];\n                cCache.put(zone, chronos);\n            }\n            chrono = chronos[leapYears.index];\n            if (chrono == null) {\n                if (zone == DateTimeZone.UTC) {\n                    \n                    chrono = new IslamicChronology(null, null, leapYears);\n                    \n                    DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);\n                    chrono = new IslamicChronology(\n                        LimitChronology.getInstance(chrono, lowerLimit, null),\n                         null, leapYears);\n                } else {\n                    chrono = getInstance(DateTimeZone.UTC, leapYears);\n                    chrono = new IslamicChronology\n                        (ZonedChronology.getInstance(chrono, zone), null, leapYears);\n                }\n                chronos[leapYears.index] = chrono;\n            }\n        }\n        return chrono;\n    }", "comment": "/**\n     * Gets an instance of the IslamicChronology in the given time zone.\n     * \n     * @param zone  the time zone to get the chronology in, null is default\n     * @param leapYears  the type defining the leap year pattern\n     * @return a chronology in the specified time zone\n     */"}}
{"code": {"body": "        private Object readResolve() {\n            switch (index) {\n                case 0:\n                    return LEAP_YEAR_15_BASED;\n                case 1:\n                    return LEAP_YEAR_16_BASED;\n                case 2:\n                    return LEAP_YEAR_INDIAN;\n                case 3:\n                    return LEAP_YEAR_HABASH_AL_HASIB;\n                default:\n                    return this;\n            }\n        }", "comment": "/**\n         * Ensure a singleton is returned if possible.\n         * @return the singleton instance\n         */"}}
{"code": {"body": "    public LeapYearPatternType getLeapYearPatternType() {\n        return iLeapYears;\n    }", "comment": "/**\n     * Gets the leap year pattern type.\n     *\n     * @return the pattern type\n     */"}}
{"code": {"body": "    public Chronology withUTC() {\n        return INSTANCE_UTC;\n    }", "comment": "/**\n     * Gets the Chronology in the UTC time zone.\n     * \n     * @return the chronology in UTC\n     */"}}
{"code": {"body": "    public Chronology withZone(DateTimeZone zone) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        if (zone == getZone()) {\n            return this;\n        }\n        return getInstance(zone);\n    }", "comment": "/**\n     * Gets the Chronology in a specific time zone.\n     * \n     * @param zone  the zone to get the chronology in, null is default\n     * @return the chronology\n     */"}}
{"code": {"body": "        boolean isLeapYear(int year) {\n            int key = 1 << (year % 30);\n            return ((pattern & key) > 0);\n        }", "comment": "/**\n         * Is the year a leap year.\n         * @param year  the year to query\n         * @return true if leap\n         */"}}
{"code": {"body": "    public static ISOChronology getInstanceUTC() {\n        return INSTANCE_UTC;\n    }", "comment": "/**\n     * Gets an instance of the ISOChronology.\n     * The time zone of the returned instance is UTC.\n     * \n     * @return a singleton UTC instance of the chronology\n     */"}}
{"code": {"body": "    public static ISOChronology getInstance(DateTimeZone zone) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        int index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\n        ISOChronology chrono = cFastCache[index];\n        if (chrono != null && chrono.getZone() == zone) {\n            return chrono;\n        }\n        synchronized (cCache) {\n            chrono = cCache.get(zone);\n            if (chrono == null) {\n                chrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\n                cCache.put(zone, chrono);\n            }\n        }\n        cFastCache[index] = chrono;\n        return chrono;\n    }", "comment": "/**\n     * Gets an instance of the ISOChronology in the given time zone.\n     * \n     * @param zone  the time zone to get the chronology in, null is default\n     * @return a chronology in the specified time zone\n     */"}}
{"code": {"body": "    public Chronology withUTC() {\n        return INSTANCE_UTC;\n    }", "comment": "/**\n     * Gets the Chronology in the UTC time zone.\n     * \n     * @return the chronology in UTC\n     */"}}
{"code": {"body": "    public Chronology withZone(DateTimeZone zone) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        if (zone == getZone()) {\n            return this;\n        }\n        return getInstance(zone);\n    }", "comment": "/**\n     * Gets the Chronology in a specific time zone.\n     * \n     * @param zone  the zone to get the chronology in, null is default\n     * @return the chronology\n     */"}}
{"code": {"body": "    public String toString() {\n        String str = \"\";\n        DateTimeZone zone = getZone();\n        if (zone != null) {\n            str = str + '' + zone.getID() + '';\n        }\n        return str;\n    }", "comment": "/**\n     * Gets a debugging toString.\n     * \n     * @return a debugging string\n     */"}}
{"code": {"body": "    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj instanceof ISOChronology) {\n            ISOChronology chrono = (ISOChronology) obj;\n            return getZone().equals(chrono.getZone());\n        }\n        return false;\n    }", "comment": "/**\n     * Checks if this chronology instance equals another.\n     * \n     * @param obj  the object to compare to\n     * @return true if equal\n     * @since 1.6\n     */"}}
{"code": {"body": "    public int hashCode() {\n        return \"\".hashCode() * 11 + getZone().hashCode();\n    }", "comment": "/**\n     * A suitable hash code for the chronology.\n     * \n     * @return the hash code\n     * @since 1.6\n     */"}}
{"code": {"body": "    private Object writeReplace() {\n        return new Stub(getZone());\n    }", "comment": "/**\n     * Serialize ISOChronology instances using a small stub. This reduces the\n     * serialized size, and deserialized instances come from the cache.\n     */"}}
{"code": {"body": "    private Object readResolve() {\n        return INSTANCE;\n    }", "comment": "/**\n     * Serialization singleton\n     */"}}
{"code": {"body": "    public static JulianChronology getInstanceUTC() {\n        return INSTANCE_UTC;\n    }", "comment": "/**\n     * Gets an instance of the JulianChronology.\n     * The time zone of the returned instance is UTC.\n     * \n     * @return a singleton UTC instance of the chronology\n     */"}}
{"code": {"body": "    public static JulianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        JulianChronology chrono;\n        synchronized (cCache) {\n            JulianChronology[] chronos = cCache.get(zone);\n            if (chronos == null) {\n                chronos = new JulianChronology[7];\n                cCache.put(zone, chronos);\n            }\n            try {\n                chrono = chronos[minDaysInFirstWeek - 1];\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new IllegalArgumentException\n                    (\"\" + minDaysInFirstWeek);\n            }\n            if (chrono == null) {\n                if (zone == DateTimeZone.UTC) {\n                    chrono = new JulianChronology(null, null, minDaysInFirstWeek);\n                } else {\n                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\n                    chrono = new JulianChronology\n                        (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\n                }\n                chronos[minDaysInFirstWeek - 1] = chrono;\n            }\n        }\n        return chrono;\n    }", "comment": "/**\n     * Gets an instance of the JulianChronology in the given time zone.\n     * \n     * @param zone  the time zone to get the chronology in, null is default\n     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n     * @return a chronology in the specified time zone\n     */"}}
{"code": {"body": "    private Object readResolve() {\n        Chronology base = getBase();\n        int minDays = getMinimumDaysInFirstWeek();\n        minDays = (minDays == 0 ? 4 : minDays);  \n        return base == null ?\n                getInstance(DateTimeZone.UTC, minDays) :\n                    getInstance(base.getZone(), minDays);\n    }", "comment": "/**\n     * Serialization singleton\n     */"}}
{"code": {"body": "    public Chronology withUTC() {\n        return INSTANCE_UTC;\n    }", "comment": "/**\n     * Gets the Chronology in the UTC time zone.\n     * \n     * @return the chronology in UTC\n     */"}}
{"code": {"body": "    public Chronology withZone(DateTimeZone zone) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        if (zone == getZone()) {\n            return this;\n        }\n        return getInstance(zone);\n    }", "comment": "/**\n     * Gets the Chronology in a specific time zone.\n     * \n     * @param zone  the zone to get the chronology in, null is default\n     * @return the chronology\n     */"}}
{"code": {"body": "    public static LenientChronology getInstance(Chronology base) {\n        if (base == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        return new LenientChronology(base);\n    }", "comment": "/**\n     * Create a LenientChronology for any chronology.\n     *\n     * @param base the chronology to wrap\n     * @throws IllegalArgumentException if chronology is null\n     */"}}
{"code": {"body": "    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj instanceof LenientChronology == false) {\n            return false;\n        }\n        LenientChronology chrono = (LenientChronology) obj;\n        return getBase().equals(chrono.getBase());\n    }", "comment": "/**\n     * A lenient chronology is only equal to a lenient chronology with the\n     * same base chronology.\n     * \n     * @param obj  the object to compare to\n     * @return true if equal\n     * @since 1.4\n     */"}}
{"code": {"body": "    public int hashCode() {\n        return 236548278 + getBase().hashCode() * 7;\n    }", "comment": "/**\n     * A suitable hashcode for the chronology.\n     * \n     * @return the hashcode\n     * @since 1.4\n     */"}}
{"code": {"body": "    public String toString() {\n        return \"\" + getBase().toString() + '';\n    }", "comment": "/**\n     * A debugging string for the chronology.\n     * \n     * @return the debugging string\n     */"}}
{"code": {"body": "    public static LimitChronology getInstance(Chronology base,\n                                              ReadableDateTime lowerLimit,\n                                              ReadableDateTime upperLimit) {\n        if (base == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n\n        lowerLimit = lowerLimit == null ? null : lowerLimit.toDateTime();\n        upperLimit = upperLimit == null ? null : upperLimit.toDateTime();\n\n        if (lowerLimit != null && upperLimit != null) {\n            if (!lowerLimit.isBefore(upperLimit)) {\n                throw new IllegalArgumentException\n                    (\"\");\n            }\n        }\n\n        return new LimitChronology(base, (DateTime)lowerLimit, (DateTime)upperLimit);\n    }", "comment": "/**\n     * Wraps another chronology, with datetime limits. When withUTC or\n     * withZone is called, the returned LimitChronology instance has\n     * the same limits, except they are time zone adjusted.\n     *\n     * @param base  base chronology to wrap\n     * @param lowerLimit  inclusive lower limit, or null if none\n     * @param upperLimit  exclusive upper limit, or null if none\n     * @throws IllegalArgumentException if chronology is null or limits are invalid\n     */"}}
{"code": {"body": "    public DateTime getLowerLimit() {\n        return iLowerLimit;\n    }", "comment": "/**\n     * Returns the inclusive lower limit instant.\n     * \n     * @return lower limit\n     */"}}
{"code": {"body": "    public DateTime getUpperLimit() {\n        return iUpperLimit;\n    }", "comment": "/**\n     * Returns the inclusive upper limit instant.\n     * \n     * @return upper limit\n     */"}}
{"code": {"body": "    public Chronology withUTC() {\n        return withZone(DateTimeZone.UTC);\n    }", "comment": "/**\n     * If this LimitChronology is already UTC, then this is\n     * returned. Otherwise, a new instance is returned, with the limits\n     * adjusted to the new time zone.\n     */"}}
{"code": {"body": "    public Chronology withZone(DateTimeZone zone) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        if (zone == getZone()) {\n            return this;\n        }\n\n        if (zone == DateTimeZone.UTC && iWithUTC != null) {\n            return iWithUTC;\n        }\n\n        DateTime lowerLimit = iLowerLimit;\n        if (lowerLimit != null) {\n            MutableDateTime mdt = lowerLimit.toMutableDateTime();\n            mdt.setZoneRetainFields(zone);\n            lowerLimit = mdt.toDateTime();\n        }\n\n        DateTime upperLimit = iUpperLimit;\n        if (upperLimit != null) {\n            MutableDateTime mdt = upperLimit.toMutableDateTime();\n            mdt.setZoneRetainFields(zone);\n            upperLimit = mdt.toDateTime();\n        }\n        \n        LimitChronology chrono = getInstance\n            (getBase().withZone(zone), lowerLimit, upperLimit);\n\n        if (zone == DateTimeZone.UTC) {\n            iWithUTC = chrono;\n        }\n\n        return chrono;\n    }", "comment": "/**\n     * If this LimitChronology has the same time zone as the one given, then\n     * this is returned. Otherwise, a new instance is returned, with the limits\n     * adjusted to the new time zone.\n     */"}}
{"code": {"body": "    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj instanceof LimitChronology == false) {\n            return false;\n        }\n        LimitChronology chrono = (LimitChronology) obj;\n        return\n            getBase().equals(chrono.getBase()) &&\n            FieldUtils.equals(getLowerLimit(), chrono.getLowerLimit()) &&\n            FieldUtils.equals(getUpperLimit(), chrono.getUpperLimit());\n    }", "comment": "/**\n     * A limit chronology is only equal to a limit chronology with the\n     * same base chronology and limits.\n     * \n     * @param obj  the object to compare to\n     * @return true if equal\n     * @since 1.4\n     */"}}
{"code": {"body": "    public int hashCode() {\n        int hash = 317351877;\n        hash += (getLowerLimit() != null ? getLowerLimit().hashCode() : 0);\n        hash += (getUpperLimit() != null ? getUpperLimit().hashCode() : 0);\n        hash += getBase().hashCode() * 7;\n        return hash;\n    }", "comment": "/**\n     * A suitable hashcode for the chronology.\n     * \n     * @return the hashcode\n     * @since 1.4\n     */"}}
{"code": {"body": "    public static StrictChronology getInstance(Chronology base) {\n        if (base == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        return new StrictChronology(base);\n    }", "comment": "/**\n     * Create a StrictChronology for any chronology.\n     *\n     * @param base the chronology to wrap\n     * @throws IllegalArgumentException if chronology is null\n     */"}}
{"code": {"body": "    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj instanceof StrictChronology == false) {\n            return false;\n        }\n        StrictChronology chrono = (StrictChronology) obj;\n        return getBase().equals(chrono.getBase());\n    }", "comment": "/**\n     * A strict chronology is only equal to a strict chronology with the\n     * same base chronology.\n     * \n     * @param obj  the object to compare to\n     * @return true if equal\n     * @since 1.4\n     */"}}
{"code": {"body": "    public int hashCode() {\n        return 352831696 + getBase().hashCode() * 7;\n    }", "comment": "/**\n     * A suitable hashcode for the chronology.\n     * \n     * @return the hashcode\n     * @since 1.4\n     */"}}
{"code": {"body": "    public String toString() {\n        return \"\" + getBase().toString() + '';\n    }", "comment": "/**\n     * A debugging string for the chronology.\n     * \n     * @return the debugging string\n     */"}}
{"code": {"body": "    public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\n        if (base == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        base = base.withUTC();\n        if (base == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        return new ZonedChronology(base, zone);\n    }", "comment": "/**\n     * Create a ZonedChronology for any chronology, overriding any time zone it\n     * may already have.\n     *\n     * @param base base chronology to wrap\n     * @param zone the time zone\n     * @throws IllegalArgumentException if chronology or time zone is null\n     */"}}
{"code": {"body": "    private long localToUTC(long localInstant) {\n        DateTimeZone zone = getZone();\n        int offset = zone.getOffsetFromLocal(localInstant);\n        localInstant -= offset;\n        if (offset != zone.getOffset(localInstant)) {\n            throw new IllegalInstantException(localInstant, zone.getID());\n        }\n        return localInstant;\n    }", "comment": "/**\n     * @param localInstant  the instant from 1970-01-01T00:00:00 local time\n     * @return the instant from 1970-01-01T00:00:00Z\n     */"}}
{"code": {"body": "    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj instanceof ZonedChronology == false) {\n            return false;\n        }\n        ZonedChronology chrono = (ZonedChronology) obj;\n        return\n            getBase().equals(chrono.getBase()) &&\n            getZone().equals(chrono.getZone());\n    }", "comment": "/**\n     * A zoned chronology is only equal to a zoned chronology with the\n     * same base chronology and zone.\n     * \n     * @param obj  the object to compare to\n     * @return true if equal\n     * @since 1.4\n     */"}}
{"code": {"body": "    public int hashCode() {\n        return 326565 + getZone().hashCode() * 11 + getBase().hashCode() * 7;\n    }", "comment": "/**\n     * A suitable hashcode for the chronology.\n     * \n     * @return the hashcode\n     * @since 1.4\n     */"}}
{"code": {"body": "    public String toString() {\n        return \"\" + getBase() + \"\" + getZone().getID() + '';\n    }", "comment": "/**\n     * A debugging string for the chronology.\n     * \n     * @return the debugging string\n     */"}}
{"code": {"body": "    public long getInstantMillis(Object object, Chronology chrono) {\n        return DateTimeUtils.currentTimeMillis();\n    }", "comment": "/**\n     * Extracts the millis from an object of this convertor's type.\n     * <p>\n     * This implementation returns the current time.\n     * \n     * @param object  the object to convert\n     * @param chrono  the chronology to use, which is always non-null\n     * @return the millisecond value\n     */"}}
{"code": {"body": "    public Chronology getChronology(Object object, Chronology chrono) {\n        return DateTimeUtils.getChronology(chrono);\n    }", "comment": "/**\n     * Extracts the chronology from an object of this convertor's type\n     * where the chronology is specified.\n     * <p>\n     * This implementation returns the chronology specified, or the\n     * ISO chronology in the default zone if null passed in.\n     * \n     * @param object  the object to convert\n     * @param chrono  the chronology to use, null means ISO default\n     * @return the chronology, never null\n     */"}}
{"code": {"body": "    public int[] getPartialValues(ReadablePartial fieldSource,\n            Object object, Chronology chrono, DateTimeFormatter parser) {\n        return getPartialValues(fieldSource, object, chrono);\n    }", "comment": "/**\n     * Extracts the values of the partial from an object of this converter's type.\n     * The chrono parameter is a hint to the converter, should it require a\n     * chronology to aid in conversion.\n     * <p>\n     * This implementation calls {@link #getPartialValues(ReadablePartial, Object, Chronology)}.\n     * \n     * @param fieldSource  a partial that provides access to the fields.\n     *  This partial may be incomplete and only getFieldType(int) should be used\n     * @param object  the object to convert\n     * @param chrono  the chronology to use, which is the non-null result of getChronology()\n     * @param parser  if converting from a String, the given parser is preferred\n     * @return the array of field values that match the fieldSource, must be non-null valid\n     * @throws ClassCastException if the object is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "    public PeriodType getPeriodType(Object object) {\n        return PeriodType.standard();\n    }", "comment": "/**\n     * Selects a suitable period type for the given object.\n     *\n     * @param object  the object to examine\n     * @return the period type, never null\n     */"}}
{"code": {"body": "    public boolean isReadableInterval(Object object, Chronology chrono) {\n        return false;\n    }", "comment": "/**\n     * Checks if the input is a ReadableInterval.\n     * <p>\n     * If it is, then the calling code should cast and copy the fields directly.\n     *\n     * @param object  the object to convert\n     * @param chrono  the chronology to use, may be null\n     * @return true if the input is a ReadableInterval\n     */"}}
{"code": {"body": "    public String toString() {\n        return \"\" + (getSupportedType() == null ? \"\" : getSupportedType().getName()) + \"\";\n    }", "comment": "/**\n     * Gets a debugging string version of this converter.\n     * \n     * @return a debugging string\n     */"}}
{"code": {"body": "    public Chronology getChronology(Object object, DateTimeZone zone) {\n        if (object.getClass().getName().endsWith(\"\")) {\n            return BuddhistChronology.getInstance(zone);\n        } else if (object instanceof GregorianCalendar) {\n            GregorianCalendar gc = (GregorianCalendar) object;\n            long cutover = gc.getGregorianChange().getTime();\n            if (cutover == Long.MIN_VALUE) {\n                return GregorianChronology.getInstance(zone);\n            } else if (cutover == Long.MAX_VALUE) {\n                return JulianChronology.getInstance(zone);\n            } else {\n                return GJChronology.getInstance(zone, cutover, 4);\n            }\n        } else {\n            return ISOChronology.getInstance(zone);\n        }\n    }", "comment": "/**\n     * Gets the chronology, which is the GJChronology if a GregorianCalendar is used,\n     * BuddhistChronology if a BuddhistCalendar is used or ISOChronology otherwise.\n     * The time zone specified is used in preference to that on the calendar.\n     * \n     * @param object  the Calendar to convert, must not be null\n     * @param zone  the specified zone to use, null means default zone\n     * @return the chronology, never null\n     * @throws NullPointerException if the object is null\n     * @throws ClassCastException if the object is an invalid type\n     */"}}
{"code": {"body": "    public long getInstantMillis(Object object, Chronology chrono) {\n        Calendar calendar = (Calendar) object;\n        return calendar.getTime().getTime();\n    }", "comment": "/**\n     * Gets the millis, which is the Calendar millis value.\n     * \n     * @param object  the Calendar to convert, must not be null\n     * @param chrono  the chronology result from getChronology, non-null\n     * @return the millisecond value\n     * @throws NullPointerException if the object is null\n     * @throws ClassCastException if the object is an invalid type\n     */"}}
{"code": {"body": "    public Class<?> getSupportedType() {\n        return Calendar.class;\n    }", "comment": "/**\n     * Returns Calendar.class.\n     * \n     * @return Calendar.class\n     */"}}
{"code": {"body": "    public InstantConverter getInstantConverter(Object object) {\n        InstantConverter converter =\n            (InstantConverter)iInstantConverters.select(object == null ? null : object.getClass());\n        if (converter != null) {\n            return converter;\n        }\n        throw new IllegalArgumentException(\"\" +\n            (object == null ? \"\" : object.getClass().getName()));\n    }", "comment": "/**\n     * Gets the best converter for the object specified.\n     * \n     * @param object  the object to convert\n     * @return the converter to use\n     * @throws IllegalArgumentException if no suitable converter\n     * @throws IllegalStateException if multiple converters match the type\n     * equally well\n     */"}}
{"code": {"body": "    public InstantConverter[] getInstantConverters() {\n        ConverterSet set = iInstantConverters;\n        InstantConverter[] converters = new InstantConverter[set.size()];\n        set.copyInto(converters);\n        return converters;\n    }", "comment": "/**\n     * Gets a copy of the set of converters.\n     * \n     * @return the converters, a copy of the real data, never null\n     */"}}
{"code": {"body": "    public InstantConverter addInstantConverter(InstantConverter converter)\n            throws SecurityException {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.add(converter, removed);\n        return removed[0];\n    }", "comment": "/**\n     * Adds a converter to the set of converters. If a matching converter is\n     * already in the set, the given converter replaces it. If the converter is\n     * exactly the same as one already in the set, no changes are made.\n     * <p>\n     * The order in which converters are added is not relevent. The best\n     * converter is selected by examining the object hierarchy.\n     * \n     * @param converter  the converter to add, null ignored\n     * @return replaced converter, or null\n     */"}}
{"code": {"body": "    public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }", "comment": "/**\n     * Removes a converter from the set of converters. If the converter was\n     * not in the set, no changes are made.\n     * \n     * @param converter  the converter to remove, null ignored\n     * @return replaced converter, or null\n     */"}}
{"code": {"body": "    private void checkAlterInstantConverters() throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"\"));\n        }\n    }", "comment": "/**\n     * Checks whether the user has permission 'ConverterManager.alterInstantConverters'.\n     * \n     * @throws SecurityException if the user does not have the permission\n     */"}}
{"code": {"body": "    public PartialConverter getPartialConverter(Object object) {\n        PartialConverter converter =\n            (PartialConverter)iPartialConverters.select(object == null ? null : object.getClass());\n        if (converter != null) {\n            return converter;\n        }\n        throw new IllegalArgumentException(\"\" +\n            (object == null ? \"\" : object.getClass().getName()));\n    }", "comment": "/**\n     * Gets the best converter for the object specified.\n     * \n     * @param object  the object to convert\n     * @return the converter to use\n     * @throws IllegalArgumentException if no suitable converter\n     * @throws IllegalStateException if multiple converters match the type\n     * equally well\n     */"}}
{"code": {"body": "    public PartialConverter[] getPartialConverters() {\n        ConverterSet set = iPartialConverters;\n        PartialConverter[] converters = new PartialConverter[set.size()];\n        set.copyInto(converters);\n        return converters;\n    }", "comment": "/**\n     * Gets a copy of the set of converters.\n     * \n     * @return the converters, a copy of the real data, never null\n     */"}}
{"code": {"body": "    public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }", "comment": "/**\n     * Adds a converter to the set of converters. If a matching converter is\n     * already in the set, the given converter replaces it. If the converter is\n     * exactly the same as one already in the set, no changes are made.\n     * <p>\n     * The order in which converters are added is not relevent. The best\n     * converter is selected by examining the object hierarchy.\n     * \n     * @param converter  the converter to add, null ignored\n     * @return replaced converter, or null\n     */"}}
{"code": {"body": "    public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }", "comment": "/**\n     * Removes a converter from the set of converters. If the converter was\n     * not in the set, no changes are made.\n     * \n     * @param converter  the converter to remove, null ignored\n     * @return replaced converter, or null\n     */"}}
{"code": {"body": "    private void checkAlterPartialConverters() throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"\"));\n        }\n    }", "comment": "/**\n     * Checks whether the user has permission 'ConverterManager.alterPartialConverters'.\n     * \n     * @throws SecurityException if the user does not have the permission\n     */"}}
{"code": {"body": "    public DurationConverter getDurationConverter(Object object) {\n        DurationConverter converter =\n            (DurationConverter)iDurationConverters.select(object == null ? null : object.getClass());\n        if (converter != null) {\n            return converter;\n        }\n        throw new IllegalArgumentException(\"\" +\n            (object == null ? \"\" : object.getClass().getName()));\n    }", "comment": "/**\n     * Gets the best converter for the object specified.\n     * \n     * @param object  the object to convert\n     * @return the converter to use\n     * @throws IllegalArgumentException if no suitable converter\n     * @throws IllegalStateException if multiple converters match the type\n     * equally well\n     */"}}
{"code": {"body": "    public DurationConverter[] getDurationConverters() {\n        ConverterSet set = iDurationConverters;\n        DurationConverter[] converters = new DurationConverter[set.size()];\n        set.copyInto(converters);\n        return converters;\n    }", "comment": "/**\n     * Gets a copy of the list of converters.\n     * \n     * @return the converters, a copy of the real data, never null\n     */"}}
{"code": {"body": "    public DurationConverter addDurationConverter(DurationConverter converter)\n            throws SecurityException {\n        \n        checkAlterDurationConverters();\n        if (converter == null) {\n            return null;\n        }\n        DurationConverter[] removed = new DurationConverter[1];\n        iDurationConverters = iDurationConverters.add(converter, removed);\n        return removed[0];\n    }", "comment": "/**\n     * Adds a converter to the set of converters. If a matching converter is\n     * already in the set, the given converter replaces it. If the converter is\n     * exactly the same as one already in the set, no changes are made.\n     * <p>\n     * The order in which converters are added is not relevent. The best\n     * converter is selected by examining the object hierarchy.\n     * \n     * @param converter  the converter to add, null ignored\n     * @return replaced converter, or null\n     */"}}
{"code": {"body": "    public DurationConverter removeDurationConverter(DurationConverter converter)\n            throws SecurityException {\n        \n        checkAlterDurationConverters();\n        if (converter == null) {\n            return null;\n        }\n        DurationConverter[] removed = new DurationConverter[1];\n        iDurationConverters = iDurationConverters.remove(converter, removed);\n        return removed[0];\n    }", "comment": "/**\n     * Removes a converter from the set of converters. If the converter was\n     * not in the set, no changes are made.\n     * \n     * @param converter  the converter to remove, null ignored\n     * @return replaced converter, or null\n     */"}}
{"code": {"body": "    private void checkAlterDurationConverters() throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"\"));\n        }\n    }", "comment": "/**\n     * Checks whether the user has permission 'ConverterManager.alterDurationConverters'.\n     * \n     * @throws SecurityException if the user does not have the permission\n     */"}}
{"code": {"body": "    public PeriodConverter getPeriodConverter(Object object) {\n        PeriodConverter converter =\n            (PeriodConverter)iPeriodConverters.select(object == null ? null : object.getClass());\n        if (converter != null) {\n            return converter;\n        }\n        throw new IllegalArgumentException(\"\" +\n            (object == null ? \"\" : object.getClass().getName()));\n    }", "comment": "/**\n     * Gets the best converter for the object specified.\n     * \n     * @param object  the object to convert\n     * @return the converter to use\n     * @throws IllegalArgumentException if no suitable converter\n     * @throws IllegalStateException if multiple converters match the type\n     * equally well\n     */"}}
{"code": {"body": "    public PeriodConverter[] getPeriodConverters() {\n        ConverterSet set = iPeriodConverters;\n        PeriodConverter[] converters = new PeriodConverter[set.size()];\n        set.copyInto(converters);\n        return converters;\n    }", "comment": "/**\n     * Gets a copy of the list of converters.\n     * \n     * @return the converters, a copy of the real data, never null\n     */"}}
{"code": {"body": "    public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }", "comment": "/**\n     * Adds a converter to the set of converters. If a matching converter is\n     * already in the set, the given converter replaces it. If the converter is\n     * exactly the same as one already in the set, no changes are made.\n     * <p>\n     * The order in which converters are added is not relevent. The best\n     * converter is selected by examining the object hierarchy.\n     * \n     * @param converter  the converter to add, null ignored\n     * @return replaced converter, or null\n     */"}}
{"code": {"body": "    public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }", "comment": "/**\n     * Removes a converter from the set of converters. If the converter was\n     * not in the set, no changes are made.\n     * \n     * @param converter  the converter to remove, null ignored\n     * @return replaced converter, or null\n     */"}}
{"code": {"body": "    private void checkAlterPeriodConverters() throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"\"));\n        }\n    }", "comment": "/**\n     * Checks whether the user has permission 'ConverterManager.alterPeriodConverters'.\n     * \n     * @throws SecurityException if the user does not have the permission\n     */"}}
{"code": {"body": "    public IntervalConverter getIntervalConverter(Object object) {\n        IntervalConverter converter =\n            (IntervalConverter)iIntervalConverters.select(object == null ? null : object.getClass());\n        if (converter != null) {\n            return converter;\n        }\n        throw new IllegalArgumentException(\"\" +\n            (object == null ? \"\" : object.getClass().getName()));\n    }", "comment": "/**\n     * Gets the best converter for the object specified.\n     * \n     * @param object  the object to convert\n     * @return the converter to use\n     * @throws IllegalArgumentException if no suitable converter\n     * @throws IllegalStateException if multiple converters match the type\n     * equally well\n     */"}}
{"code": {"body": "    public IntervalConverter[] getIntervalConverters() {\n        ConverterSet set = iIntervalConverters;\n        IntervalConverter[] converters = new IntervalConverter[set.size()];\n        set.copyInto(converters);\n        return converters;\n    }", "comment": "/**\n     * Gets a copy of the list of converters.\n     * \n     * @return the converters, a copy of the real data, never null\n     */"}}
{"code": {"body": "    public IntervalConverter addIntervalConverter(IntervalConverter converter) \n            throws SecurityException {\n        \n        checkAlterIntervalConverters();\n        if (converter == null) {\n            return null;\n        }\n        IntervalConverter[] removed = new IntervalConverter[1];\n        iIntervalConverters = iIntervalConverters.add(converter, removed);\n        return removed[0];\n    }", "comment": "/**\n     * Adds a converter to the set of converters. If a matching converter is\n     * already in the set, the given converter replaces it. If the converter is\n     * exactly the same as one already in the set, no changes are made.\n     * <p>\n     * The order in which converters are added is not relevent. The best\n     * converter is selected by examining the object hierarchy.\n     * \n     * @param converter  the converter to add, null ignored\n     * @return replaced converter, or null\n     */"}}
{"code": {"body": "    public IntervalConverter removeIntervalConverter(IntervalConverter converter)\n            throws SecurityException {\n        \n        checkAlterIntervalConverters();\n        if (converter == null) {\n            return null;\n        }\n        IntervalConverter[] removed = new IntervalConverter[1];\n        iIntervalConverters = iIntervalConverters.remove(converter, removed);\n        return removed[0];\n    }", "comment": "/**\n     * Removes a converter from the set of converters. If the converter was\n     * not in the set, no changes are made.\n     * \n     * @param converter  the converter to remove, null ignored\n     * @return replaced converter, or null\n     */"}}
{"code": {"body": "    private void checkAlterIntervalConverters() throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"\"));\n        }\n    }", "comment": "/**\n     * Checks whether the user has permission 'ConverterManager.alterIntervalConverters'.\n     * \n     * @throws SecurityException if the user does not have the permission\n     */"}}
{"code": {"body": "    public String toString() {\n        return \"\" +\n            iInstantConverters.size() + \"\" +\n            iPartialConverters.size() + \"\" +\n            iDurationConverters.size() + \"\" +\n            iPeriodConverters.size() + \"\" +\n            iIntervalConverters.size() + \"\";\n    }", "comment": "/**\n     * Gets a debug representation of the object.\n     */"}}
{"code": {"body": "    Converter select(Class<?> type) throws IllegalStateException {\n        \n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        \n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        \n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        \n        \n        \n        \n        \n        \n\n        \n        \n        \n        entries = (Entry[])entries.clone();\n\n        \n        entries[index] = e;\n\n        \n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                \n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        \n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\n            index = type == null ? 0 : type.hashCode() & (newLength - 1);\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        \n        iSelectEntries = newEntries;\n        return converter;\n    }", "comment": "/**\n     * Returns the closest matching converter for the given type, or null if\n     * none found.\n     *\n     * @param type type to select, which may be null\n     * @throws IllegalStateException if multiple converters match the type\n     * equally well\n     */"}}
{"code": {"body": "    int size() {\n        return iConverters.length;\n    }", "comment": "/**\n     * Returns the amount of converters in the set.\n     */"}}
{"code": {"body": "    void copyInto(Converter[] converters) {\n        System.arraycopy(iConverters, 0, converters, 0, iConverters.length);\n    }", "comment": "/**\n     * Copies all the converters in the set to the given array.\n     */"}}
{"code": {"body": "    ConverterSet add(Converter converter, Converter[] removed) {\n        Converter[] converters = iConverters;\n        int length = converters.length;\n\n        for (int i=0; i<length; i++) {\n            Converter existing = converters[i];\n            if (converter.equals(existing)) {\n                \n                if (removed != null) {\n                    removed[0] = null;\n                }\n                return this;\n            }\n            \n            if (converter.getSupportedType() == existing.getSupportedType()) {\n                \n                Converter[] copy = new Converter[length];\n                    \n                for (int j=0; j<length; j++) {\n                    if (j != i) {\n                        copy[j] = converters[j];\n                    } else {\n                        copy[j] = converter;\n                    }\n                }\n\n                if (removed != null) {\n                    removed[0] = existing;\n                }\n                return new ConverterSet(copy);\n            }\n        }\n\n        \n        Converter[] copy = new Converter[length + 1];\n        System.arraycopy(converters, 0, copy, 0, length);\n        copy[length] = converter;\n        \n        if (removed != null) {\n            removed[0] = null;\n        }\n        return new ConverterSet(copy);\n    }", "comment": "/**\n     * Returns a copy of this set, with the given converter added. If a\n     * matching converter is already in the set, the given converter replaces\n     * it. If the converter is exactly the same as one already in the set, the\n     * original set is returned.\n     *\n     * @param converter  converter to add, must not be null\n     * @param removed  if not null, element 0 is set to the removed converter\n     * @throws NullPointerException if converter is null\n     */"}}
{"code": {"body": "    ConverterSet remove(final int index, Converter[] removed) {\n        Converter[] converters = iConverters;\n        int length = converters.length;\n        if (index >= length) {\n            throw new IndexOutOfBoundsException();\n        }\n\n        if (removed != null) {\n            removed[0] = converters[index];\n        }\n\n        Converter[] copy = new Converter[length - 1];\n                \n        int j = 0;\n        for (int i=0; i<length; i++) {\n            if (i != index) {\n                copy[j++] = converters[i];\n            }\n        }\n        \n        return new ConverterSet(copy);\n    }", "comment": "/**\n     * Returns a copy of this set, with the converter at the given index\n     * removed.\n     *\n     * @param index index of converter to remove\n     * @param removed if not null, element 0 is set to the removed converter\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */"}}
{"code": {"body": "    private static Converter selectSlow(ConverterSet set, Class<?> type) {\n        Converter[] converters = set.iConverters;\n        int length = converters.length;\n        Converter converter;\n\n        for (int i=length; --i>=0; ) {\n            converter = converters[i];\n            Class<?> supportedType = converter.getSupportedType();\n\n            if (supportedType == type) {\n                \n                return converter;\n            }\n\n            if (supportedType == null || (type != null && !supportedType.isAssignableFrom(type))) {\n                \n                set = set.remove(i, null);\n                converters = set.iConverters;\n                length = converters.length;\n            }\n        }\n\n        \n\n        if (type == null || length == 0) {\n            return null;\n        }\n        if (length == 1) {\n            \n            return converters[0];\n        }\n\n        \n\n        \n        for (int i=length; --i>=0; ) {\n            converter = converters[i];\n            Class<?> supportedType = converter.getSupportedType();\n            for (int j=length; --j>=0; ) {\n                if (j != i && converters[j].getSupportedType().isAssignableFrom(supportedType)) {\n                    \n                    set = set.remove(j, null);\n                    converters = set.iConverters;\n                    length = converters.length;\n                    i = length - 1;\n                }\n            }\n        }        \n        \n        \n\n        if (length == 1) {\n            \n            return converters[0];\n        }\n\n        \n        \n\n        StringBuilder msg = new StringBuilder();\n        msg.append(\"\");\n        msg.append(type.getName());\n        msg.append(\"\");\n        for (int i=0; i<length; i++) {\n            converter = converters[i];\n            Class<?> supportedType = converter.getSupportedType();\n\n            msg.append(converter.getClass().getName());\n            msg.append('');\n            msg.append(supportedType == null ? null : supportedType.getName());\n            msg.append(\"\");\n        }\n\n        throw new IllegalStateException(msg.toString());\n    }", "comment": "/**\n     * Returns the closest matching converter for the given type, but not very\n     * efficiently.\n     */"}}
{"code": {"body": "    public long getInstantMillis(Object object, Chronology chrono) {\n        Date date = (Date) object;\n        return date.getTime();\n    }", "comment": "/**\n     * Gets the millis, which is the Date millis value.\n     * \n     * @param object  the Date to convert, must not be null\n     * @param chrono  the non-null result of getChronology\n     * @return the millisecond value\n     * @throws NullPointerException if the object is null\n     * @throws ClassCastException if the object is an invalid type\n     */"}}
{"code": {"body": "    public Class<?> getSupportedType() {\n        return Date.class;\n    }", "comment": "/**\n     * Returns Date.class.\n     * \n     * @return Date.class\n     */"}}
{"code": {"body": "    public long getInstantMillis(Object object, Chronology chrono) {\n        return ((Long) object).longValue();\n    }", "comment": "/**\n     * Gets the millisecond instant, which is the Long value.\n     * \n     * @param object  the Long to convert, must not be null\n     * @param chrono  the chronology to use, which is always non-null\n     * @return the millisecond value\n     * @throws NullPointerException if the object is null\n     * @throws ClassCastException if the object is an invalid type\n     */"}}
{"code": {"body": "    public long getDurationMillis(Object object) {\n        return ((Long) object).longValue();\n    }", "comment": "/**\n     * Gets the millisecond duration, which is the Long value.\n     * \n     * @param object  the Long to convert, must not be null\n     * @return the millisecond duration\n     * @throws NullPointerException if the object is null\n     * @throws ClassCastException if the object is an invalid type\n     */"}}
{"code": {"body": "    public Class<?> getSupportedType() {\n        return Long.class;\n    }", "comment": "/**\n     * Returns Long.class.\n     * \n     * @return Long.class\n     */"}}
{"code": {"body": "    public long getDurationMillis(Object object) {\n        return 0L;\n    }", "comment": "/**\n     * Gets the millisecond duration, which is zero.\n     * \n     * @param object  the object to convert, which is null\n     * @return the millisecond duration\n     */"}}
{"code": {"body": "    public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) {\n        writableInterval.setChronology(chrono);\n        long now = DateTimeUtils.currentTimeMillis();\n        writableInterval.setInterval(now, now);\n    }", "comment": "/**\n     * Extracts interval endpoint values from an object of this converter's\n     * type, and sets them into the given ReadWritableInterval.\n     *\n     * @param writableInterval interval to get modified, not null\n     * @param object  the object to convert, which is null\n     * @param chrono  the chronology to use, may be null\n     * @throws NullPointerException if the interval is null\n     */"}}
{"code": {"body": "    public Class<?> getSupportedType() {\n        return null;\n    }", "comment": "/**\n     * Returns null.\n     * \n     * @return null\n     */"}}
{"code": {"body": "    public long getDurationMillis(Object object) {\n        return ((ReadableDuration) object).getMillis();\n    }", "comment": "/**\n     * Extracts the millis from an object of this convertor's type.\n     * \n     * @param object  the object to convert, must not be null\n     * @return the millisecond value\n     * @throws NullPointerException if the object is null\n     * @throws ClassCastException if the object is an invalid type\n     * @throws IllegalArgumentException if the object is invalid\n     */"}}
{"code": {"body": "    public void setInto(ReadWritablePeriod writablePeriod, Object object, Chronology chrono) {\n        ReadableDuration dur = (ReadableDuration) object;\n        chrono = DateTimeUtils.getChronology(chrono);\n        long duration = dur.getMillis();\n        int[] values = chrono.get(writablePeriod, duration);\n        for (int i = 0; i < values.length; i++) {\n            writablePeriod.setValue(i, values[i]);\n        }\n    }", "comment": "/**\n     * Extracts duration values from an object of this converter's type, and\n     * sets them into the given ReadWritableDuration.\n     *\n     * @param writablePeriod  period to get modified\n     * @param object  the object to convert, must not be null\n     * @param chrono  the chronology to use, must not be null\n     * @throws NullPointerException if the duration or object is null\n     * @throws ClassCastException if the object is an invalid type\n     * @throws IllegalArgumentException if the object is invalid\n     */"}}
{"code": {"body": "    public Class<?> getSupportedType() {\n        return ReadableDuration.class;\n    }", "comment": "/**\n     * Returns ReadableDuration.class.\n     * \n     * @return ReadableDuration.class\n     */"}}
{"code": {"body": "    public Chronology getChronology(Object object, Chronology chrono) {\n        if (chrono == null) {\n            chrono = ((ReadableInstant) object).getChronology();\n            chrono = DateTimeUtils.getChronology(chrono);\n        }\n        return chrono;\n    }", "comment": "/**\n     * Gets the chronology, which is taken from the ReadableInstant.\n     * <p>\n     * If the passed in chronology is non-null, it is used.\n     * Otherwise the chronology from the instant is used.\n     * \n     * @param object  the ReadableInstant to convert, must not be null\n     * @param chrono  the chronology to use, null means use that from object\n     * @return the chronology, never null\n     */"}}
{"code": {"body": "    public long getInstantMillis(Object object, Chronology chrono) {\n        return ((ReadableInstant) object).getMillis();\n    }", "comment": "/**\n     * Extracts the millis from an object of this convertor's type.\n     * \n     * @param object  the ReadableInstant to convert, must not be null\n     * @param chrono  the non-null result of getChronology\n     * @return the millisecond value\n     * @throws NullPointerException if the object is null\n     * @throws ClassCastException if the object is an invalid type\n     */"}}
{"code": {"body": "    public Class<?> getSupportedType() {\n        return ReadableInstant.class;\n    }", "comment": "/**\n     * Returns ReadableInstant.class.\n     * \n     * @return ReadableInstant.class\n     */"}}
{"code": {"body": "    public long getDurationMillis(Object object) {\n        return (((ReadableInterval) object)).toDurationMillis();\n    }", "comment": "/**\n     * Gets the millisecond length of the interval.\n     * \n     * @param object  the interval\n     */"}}
{"code": {"body": "    public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) {\n        ReadableInterval input = (ReadableInterval) object;\n        writableInterval.setInterval(input);\n        if (chrono != null) {\n            writableInterval.setChronology(chrono);\n        } else {\n            writableInterval.setChronology(input.getChronology());\n        }\n    }", "comment": "/**\n     * Extracts interval endpoint values from an object of this converter's\n     * type, and sets them into the given ReadWritableInterval.\n     *\n     * @param writableInterval interval to get modified, not null\n     * @param object  the object to convert, must not be null\n     * @param chrono  the chronology to use, may be null\n     * @throws ClassCastException if the object is invalid\n     */"}}
{"code": {"body": "    public boolean isReadableInterval(Object object, Chronology chrono) {\n        return true;\n    }", "comment": "/**\n     * Checks if the input is a ReadableInterval.\n     * <p>\n     * If it is, then the calling code should cast and copy the fields directly.\n     *\n     * @param object  the object to convert, must not be null\n     * @param chrono  the chronology to use, may be null\n     * @return true if the input is a ReadableInterval\n     * @throws ClassCastException if the object is invalid\n     */"}}
{"code": {"body": "    public Class<?> getSupportedType() {\n        return ReadableInterval.class;\n    }", "comment": "/**\n     * Returns ReadableInterval.class.\n     */"}}
{"code": {"body": "    public Chronology getChronology(Object object, Chronology chrono) {\n        if (chrono == null) {\n            chrono = ((ReadablePartial) object).getChronology();\n            chrono = DateTimeUtils.getChronology(chrono);\n        }\n        return chrono;\n    }", "comment": "/**\n     * Gets the chronology, which is taken from the ReadableInstant.\n     * <p>\n     * If the passed in chronology is non-null, it is used.\n     * Otherwise the chronology from the instant is used.\n     * \n     * @param object  the ReadablePartial to convert, must not be null\n     * @param chrono  the chronology to use, null means use that from object\n     * @return the chronology, never null\n     */"}}
{"code": {"body": "    public int[] getPartialValues(ReadablePartial fieldSource, Object object, Chronology chrono) {\n        ReadablePartial input = (ReadablePartial) object;\n        int size = fieldSource.size();\n        int[] values = new int[size];\n        for (int i = 0; i < size; i++) {\n            values[i] = input.get(fieldSource.getFieldType(i));\n        }\n        chrono.validate(fieldSource, values);\n        return values;\n    }", "comment": "/**\n     * Extracts the values of the partial from an object of this converter's type.\n     * The chrono parameter is a hint to the converter, should it require a\n     * chronology to aid in conversion.\n     * \n     * @param fieldSource  a partial that provides access to the fields.\n     *  This partial may be incomplete and only getFieldType(int) should be used\n     * @param object  the object to convert\n     * @param chrono  the chronology to use, which is the non-null result of getChronology()\n     * @return the array of field values that match the fieldSource, must be non-null valid\n     * @throws ClassCastException if the object is invalid\n     */"}}
{"code": {"body": "    public Class<?> getSupportedType() {\n        return ReadablePartial.class;\n    }", "comment": "/**\n     * Returns ReadableInstant.class.\n     * \n     * @return ReadableInstant.class\n     */"}}
{"code": {"body": "    public void setInto(ReadWritablePeriod duration, Object object, Chronology chrono) {\n        duration.setPeriod((ReadablePeriod) object);\n    }", "comment": "/**\n     * Extracts duration values from an object of this converter's type, and\n     * sets them into the given ReadWritablePeriod.\n     *\n     * @param duration duration to get modified\n     * @param object  the object to convert, must not be null\n     * @param chrono  the chronology to use\n     * @throws NullPointerException if the duration or object is null\n     * @throws ClassCastException if the object is an invalid type\n     * @throws IllegalArgumentException if the object is invalid\n     */"}}
{"code": {"body": "    public PeriodType getPeriodType(Object object) {\n        ReadablePeriod period = (ReadablePeriod) object;\n        return period.getPeriodType();\n    }", "comment": "/**\n     * Selects a suitable period type for the given object.\n     *\n     * @param object  the object to examine, must not be null\n     * @return the period type from the readable duration\n     * @throws NullPointerException if the object is null\n     * @throws ClassCastException if the object is an invalid type\n     */"}}
{"code": {"body": "    public Class<?> getSupportedType() {\n        return ReadablePeriod.class;\n    }", "comment": "/**\n     * Returns ReadablePeriod class.\n     * \n     * @return ReadablePeriod.class\n     */"}}
{"code": {"body": "    public long getInstantMillis(Object object, Chronology chrono) {\n        String str = (String) object;\n        DateTimeFormatter p = ISODateTimeFormat.dateTimeParser();\n        return p.withChronology(chrono).parseMillis(str);\n    }", "comment": "/**\n     * Gets the millis, which is the ISO parsed string value.\n     * \n     * @param object  the String to convert, must not be null\n     * @param chrono  the chronology to use, non-null result of getChronology\n     * @return the millisecond value\n     * @throws IllegalArgumentException if the value if invalid\n     */"}}
{"code": {"body": "    public int[] getPartialValues(ReadablePartial fieldSource, Object object, Chronology chrono, DateTimeFormatter parser) {\n        if (parser.getZone() != null) {\n            chrono = chrono.withZone(parser.getZone());\n        }\n        long millis = parser.withChronology(chrono).parseMillis((String) object);\n        return chrono.get(fieldSource, millis);\n    }", "comment": "/**\n     * Extracts the values of the partial from an object of this converter's type.\n     * This method checks if the parser has a zone, and uses it if present.\n     * This is most useful for parsing local times with UTC.\n     * \n     * @param fieldSource  a partial that provides access to the fields.\n     *  This partial may be incomplete and only getFieldType(int) should be used\n     * @param object  the object to convert\n     * @param chrono  the chronology to use, which is the non-null result of getChronology()\n     * @param parser the parser to use, may be null\n     * @return the array of field values that match the fieldSource, must be non-null valid\n     * @throws ClassCastException if the object is invalid\n     * @throws IllegalArgumentException if the value if invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "    public long getDurationMillis(Object object) {\n        \n        \n        String original = (String) object;\n        String str = original;\n        int len = str.length();\n        if (len >= 4 &&\n            (str.charAt(0) == '' || str.charAt(0) == '') &&\n            (str.charAt(1) == '' || str.charAt(1) == '') &&\n            (str.charAt(len - 1) == '' || str.charAt(len - 1) == '')) {\n            \n        } else {\n            throw new IllegalArgumentException(\"\" + original + '');\n        }\n        str = str.substring(2, len - 1);\n        int dot = -1;\n        boolean negative = false;\n        for (int i = 0; i < str.length(); i++) {\n            if (str.charAt(i) >= '' && str.charAt(i) <= '') {\n                \n            } else if (i == 0 && str.charAt(0) == '') {\n            \t\n            \tnegative = true;\n            } else if (i > (negative ? 1 : 0) && str.charAt(i) == '' && dot == -1) {\n                \n                dot = i;\n            } else {\n                throw new IllegalArgumentException(\"\" + original + '');\n            }\n        }\n        long millis = 0, seconds = 0;\n        int firstDigit = negative ? 1 : 0;\n        if (dot > 0) {\n            seconds = Long.parseLong(str.substring(firstDigit, dot));\n            str = str.substring(dot + 1);\n            if (str.length() != 3) {\n                str = (str + \"\").substring(0, 3);\n            }\n            millis = Integer.parseInt(str);\n        } else if (negative) {\n        \tseconds = Long.parseLong(str.substring(firstDigit, str.length()));\n        } else {\n            seconds = Long.parseLong(str);\n        }\n        if (negative) {\n            return FieldUtils.safeAdd(FieldUtils.safeMultiply(-seconds, 1000), -millis);\n        } else {\n            return FieldUtils.safeAdd(FieldUtils.safeMultiply(seconds, 1000), millis);\n        }\n    }", "comment": "/**\n     * Gets the duration of the string using the standard type.\n     * This matches the toString() method of ReadableDuration.\n     * \n     * @param object  the String to convert, must not be null\n     * @throws ClassCastException if the object is invalid\n     */"}}
{"code": {"body": "    public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) {\n        String str = (String) object;\n\n        int separator = str.indexOf('');\n        if (separator < 0) {\n            throw new IllegalArgumentException(\"\" + str);\n        }\n\n        String leftStr = str.substring(0, separator);\n        if (leftStr.length() <= 0) {\n            throw new IllegalArgumentException(\"\" + str);\n        }\n        String rightStr = str.substring(separator + 1);\n        if (rightStr.length() <= 0) {\n            throw new IllegalArgumentException(\"\" + str);\n        }\n\n        DateTimeFormatter dateTimeParser = ISODateTimeFormat.dateTimeParser();\n        dateTimeParser = dateTimeParser.withChronology(chrono);\n        PeriodFormatter periodParser = ISOPeriodFormat.standard();\n        long startInstant = 0, endInstant = 0;\n        Period period = null;\n        Chronology parsedChrono = null;\n        \n        \n        char c = leftStr.charAt(0);\n        if (c == '' || c == '') {\n            period = periodParser.withParseType(getPeriodType(leftStr)).parsePeriod(leftStr);\n        } else {\n            DateTime start = dateTimeParser.parseDateTime(leftStr);\n            startInstant = start.getMillis();\n            parsedChrono = start.getChronology();\n        }\n        \n        \n        c = rightStr.charAt(0);\n        if (c == '' || c == '') {\n            if (period != null) {\n                throw new IllegalArgumentException(\"\" + str);\n            }\n            period = periodParser.withParseType(getPeriodType(rightStr)).parsePeriod(rightStr);\n            chrono = (chrono != null ? chrono : parsedChrono);\n            endInstant = chrono.add(period, startInstant, 1);\n        } else {\n            DateTime end = dateTimeParser.parseDateTime(rightStr);\n            endInstant = end.getMillis();\n            parsedChrono = (parsedChrono != null ? parsedChrono : end.getChronology());\n            chrono = (chrono != null ? chrono : parsedChrono);\n            if (period != null) {\n                startInstant = chrono.add(period, endInstant, -1);\n            }\n        }\n        \n        writableInterval.setInterval(startInstant, endInstant);\n        writableInterval.setChronology(chrono);\n    }", "comment": "/**\n     * Sets the value of the mutable interval from the string.\n     * \n     * @param writableInterval  the interval to set\n     * @param object  the String to convert, must not be null\n     * @param chrono  the chronology to use, may be null\n     */"}}
{"code": {"body": "    public Class<?> getSupportedType() {\n        return String.class;\n    }", "comment": "/**\n     * Returns String.class.\n     * \n     * @return String.class\n     */"}}
{"code": {"body": "    public DateTimeFieldType getFieldType() {\n        return getField().getType();\n    }", "comment": "/**\n     * Gets the field type being used.\n     * \n     * @return the field type\n     */"}}
{"code": {"body": "    public String getName() {\n        return getField().getName();\n    }", "comment": "/**\n     * Gets the name of the field.\n     * \n     * @return the field name\n     */"}}
{"code": {"body": "    public String getAsString() {\n        return Integer.toString(get());\n    }", "comment": "/**\n     * Gets the value of this property from the instant as a string.\n     * <p>\n     * This method returns the value converted to a <code>String</code>\n     * using <code>Integer.toString</code>. This method does NOT return\n     * textual descriptions such as 'Monday' or 'January'.\n     * See {@link #getAsText()} and {@link #getAsShortText()} for those.\n     * \n     * @return the current value\n     * @see DateTimeField#get\n     * @since 1.1\n     */"}}
{"code": {"body": "    public String getAsText(Locale locale) {\n        return getField().getAsText(getReadablePartial(), get(), locale);\n    }", "comment": "/**\n     * Gets the textual value of this property from the instant as a\n     * string in the specified locale.\n     * <p>\n     * This method returns the value converted to a <code>String</code>\n     * returning the appropriate textual description wherever possible.\n     * Thus, a day of week of 1 would return 'Monday' in English.\n     * \n     * @param locale  locale to use for selecting a text symbol, null means default\n     * @return the current text value\n     * @see DateTimeField#getAsText\n     */"}}
{"code": {"body": "    public String getAsShortText(Locale locale) {\n        return getField().getAsShortText(getReadablePartial(), get(), locale);\n    }", "comment": "/**\n     * Gets the short textual value of this property from the instant as a\n     * string in the specified locale.\n     * <p>\n     * This method returns the value converted to a <code>String</code>\n     * returning the appropriate textual description wherever possible.\n     * Thus, a day of week of 1 would return 'Mon' in English.\n     * \n     * @param locale  locale to use for selecting a text symbol, null means default\n     * @return the current text value\n     * @see DateTimeField#getAsShortText\n     */"}}
{"code": {"body": "    public DurationField getDurationField() {\n        return getField().getDurationField();\n    }", "comment": "/**\n     * Returns the duration per unit value of this field. For example, if this\n     * field represents \"hour of day\", then the duration is an hour.\n     *\n     * @return the duration of this field, or UnsupportedDurationField\n     */"}}
{"code": {"body": "    public DurationField getRangeDurationField() {\n        return getField().getRangeDurationField();\n    }", "comment": "/**\n     * Returns the range duration of this field. For example, if this field\n     * represents \"hour of day\", then the range duration is a day.\n     *\n     * @return the range duration of this field, or null if field has no range\n     */"}}
{"code": {"body": "    public int getMinimumValueOverall() {\n        return getField().getMinimumValue();\n    }", "comment": "/**\n     * Gets the minimum value for the field ignoring the current time.\n     * \n     * @return the minimum value\n     * @see DateTimeField#getMinimumValue\n     */"}}
{"code": {"body": "    public int getMinimumValue() {\n        return getField().getMinimumValue(getReadablePartial());\n    }", "comment": "/**\n     * Gets the minimum value for this field given the current field values.\n     * \n     * @return the minimum value\n     * @see DateTimeField#getMinimumValue\n     */"}}
{"code": {"body": "    public int getMaximumValueOverall() {\n        return getField().getMaximumValue();\n    }", "comment": "/**\n     * Gets the maximum value for the field ignoring the current time.\n     * \n     * @return the maximum value\n     * @see DateTimeField#getMaximumValue\n     */"}}
{"code": {"body": "    public int getMaximumValue() {\n        return getField().getMaximumValue(getReadablePartial());\n    }", "comment": "/**\n     * Gets the maximum value for this field given the current field values.\n     * \n     * @return the maximum value\n     * @see DateTimeField#getMaximumValue\n     */"}}
{"code": {"body": "    public int getMaximumTextLength(Locale locale) {\n        return getField().getMaximumTextLength(locale);\n    }", "comment": "/**\n     * Gets the maximum text length for the field.\n     * \n     * @param locale  optional locale to use for selecting a text symbol\n     * @return the maximum length\n     * @see DateTimeField#getMaximumTextLength\n     */"}}
{"code": {"body": "    public int getMaximumShortTextLength(Locale locale) {\n        return getField().getMaximumShortTextLength(locale);\n    }", "comment": "/**\n     * Gets the maximum short text length for the field.\n     * \n     * @param locale  optional locale to use for selecting a text symbol\n     * @return the maximum length\n     * @see DateTimeField#getMaximumShortTextLength\n     */"}}
{"code": {"body": "    public int compareTo(ReadablePartial partial) {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        int thisValue = get();\n        int otherValue = partial.get(getFieldType());\n        if (thisValue < otherValue) {\n            return -1;\n        } else if (thisValue > otherValue) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }", "comment": "/**\n     * Compare this field to the same field on another partial instant.\n     * <p>\n     * The comparison is based on the value of the same field type, irrespective\n     * of any difference in chronology. Thus, if this property represents the\n     * hourOfDay field, then the hourOfDay field of the other partial will be queried\n     * whether in the same chronology or not.\n     * \n     * @param partial  the partial to compare to\n     * @return negative value if this is less, 0 if equal, or positive value if greater\n     * @throws IllegalArgumentException if the instant is null\n     * @throws IllegalArgumentException if the field of this property cannot be queried\n     *  on the specified instant\n     */"}}
{"code": {"body": "    public boolean equals(Object object) {\n        if (this == object) {\n            return true;\n        }\n        if (object instanceof AbstractPartialFieldProperty == false) {\n            return false;\n        }\n        AbstractPartialFieldProperty other = (AbstractPartialFieldProperty) object;\n        return\n            get() == other.get() &&\n            getFieldType() == other.getFieldType() &&\n            FieldUtils.equals(getReadablePartial().getChronology(), other.getReadablePartial().getChronology());\n    }", "comment": "/**\n     * Compares this property to another.\n     * \n     * @param object  the object to compare to\n     * @return true if equal\n     */"}}
{"code": {"body": "    public int hashCode() {\n        int hash = 19;\n        hash = 13 * hash + get();\n        hash = 13 * hash + getFieldType().hashCode();\n        hash = 13 * hash + getReadablePartial().getChronology().hashCode();\n        return hash;\n    }", "comment": "/**\n     * Gets a suitable hashcode for the object.\n     * \n     * @return the hashcode\n     * @since 1.3\n     */"}}
{"code": {"body": "    public String toString() {\n        return \"\" + getName() + \"\";\n    }", "comment": "/**\n     * Output a debugging string.\n     * \n     * @return debugging string\n     */"}}
{"code": {"body": "public AbstractReadableInstantFieldProperty() {\n        super();\n    }", "comment": "/**\n     * Constructor.\n     */"}}
{"code": {"body": "    public DateTimeFieldType getFieldType() {\n        return getField().getType();\n    }", "comment": "/**\n     * Gets the field type being used.\n     * \n     * @return the field type\n     */"}}
{"code": {"body": "    public String getName() {\n        return getField().getName();\n    }", "comment": "/**\n     * Gets the name of the field.\n     * \n     * @return the field name\n     */"}}
{"code": {"body": "    protected Chronology getChronology() {\n        throw new UnsupportedOperationException(\n                \"\" +\n                \"\");\n    }", "comment": "/**\n     * Gets the chronology of the datetime that this property is linked to.\n     * <p>\n     * This implementation throws UnsupportedOperationException, and must be\n     * implemented by subclasses to enable the equals() and hashCode() methods.\n     * \n     * @return the chronology\n     * @since 1.4\n     */"}}
{"code": {"body": "    public int get() {\n        return getField().get(getMillis());\n    }", "comment": "/**\n     * Gets the value of this property from the instant.\n     * <p>\n     * For example, the following two lines of code are equivalent:\n     * <pre>\n     * datetime.getDayOfMonth();\n     * datetime.dayOfMonth().get();\n     * </pre>\n     * \n     * @return the current value\n     * @see DateTimeField#get\n     */"}}
{"code": {"body": "    public String getAsString() {\n        return Integer.toString(get());\n    }", "comment": "/**\n     * Gets the value of this property from the instant as a string.\n     * <p>\n     * This method returns the value converted to a <code>String</code>\n     * using <code>Integer.toString</code>. This method does NOT return\n     * textual descriptions such as 'Monday' or 'January'.\n     * See {@link #getAsText()} and {@link #getAsShortText()} for those.\n     * \n     * @return the current value\n     * @see DateTimeField#get\n     * @since 1.1\n     */"}}
{"code": {"body": "    public String getAsText(Locale locale) {\n        return getField().getAsText(getMillis(), locale);\n    }", "comment": "/**\n     * Gets the textual value of this property from the instant as a\n     * string in the specified locale.\n     * <p>\n     * This method returns the value converted to a <code>String</code>\n     * returning the appropriate textual description wherever possible.\n     * Thus, a day of week of 1 would return 'Monday' in English.\n     * \n     * @param locale  locale to use for selecting a text symbol, null means default\n     * @return the current text value\n     * @see DateTimeField#getAsText\n     */"}}
{"code": {"body": "    public String getAsShortText(Locale locale) {\n        return getField().getAsShortText(getMillis(), locale);\n    }", "comment": "/**\n     * Gets the short textual value of this property from the instant as a\n     * string in the specified locale.\n     * <p>\n     * This method returns the value converted to a <code>String</code>\n     * returning the appropriate textual description wherever possible.\n     * Thus, a day of week of 1 would return 'Mon' in English.\n     * \n     * @param locale  locale to use for selecting a text symbol, null means default\n     * @return the current text value\n     * @see DateTimeField#getAsShortText\n     */"}}
{"code": {"body": "    public int getDifference(ReadableInstant instant) {\n        if (instant == null) {\n            return getField().getDifference(getMillis(), DateTimeUtils.currentTimeMillis());\n        }\n        return getField().getDifference(getMillis(), instant.getMillis());\n    }", "comment": "/**\n     * Returns the difference between this field property instant and the one\n     * passed in, in the units of this field. The sign of the difference\n     * matches that of compareTo. In other words, this field property's instant\n     * is the minuend.\n     *\n     * @param instant  the subtrahend, null means now\n     * @return the difference in the units of this field\n     * @see DateTimeField#getDifference\n     */"}}
{"code": {"body": "    public long getDifferenceAsLong(ReadableInstant instant) {\n        if (instant == null) {\n            return getField().getDifferenceAsLong(getMillis(), DateTimeUtils.currentTimeMillis());\n        }\n        return getField().getDifferenceAsLong(getMillis(), instant.getMillis());\n    }", "comment": "/**\n     * Returns the difference between this field property instant and the one\n     * passed in, in the units of this field. The sign of the difference\n     * matches that of compareTo. In other words, this field property's instant\n     * is the minuend.\n     *\n     * @param instant  the subtrahend, null means now\n     * @return the difference in the units of this field\n     * @see DateTimeField#getDifference\n     */"}}
{"code": {"body": "    public DurationField getDurationField() {\n        return getField().getDurationField();\n    }", "comment": "/**\n     * Returns the duration per unit value of this field. For example, if this\n     * field represents \"hour of day\", then the duration is an hour.\n     *\n     * @return the duration of this field, or UnsupportedDurationField\n     */"}}
{"code": {"body": "    public DurationField getRangeDurationField() {\n        return getField().getRangeDurationField();\n    }", "comment": "/**\n     * Returns the range duration of this field. For example, if this field\n     * represents \"hour of day\", then the range duration is a day.\n     *\n     * @return the range duration of this field, or null if field has no range\n     */"}}
{"code": {"body": "    public boolean isLeap() {\n        return getField().isLeap(getMillis());\n    }", "comment": "/**\n     * Gets whether this field is leap.\n     * \n     * @return true if a leap field\n     * @see DateTimeField#isLeap\n     */"}}
{"code": {"body": "    public int getLeapAmount() {\n        return getField().getLeapAmount(getMillis());\n    }", "comment": "/**\n     * Gets the amount by which this field is leap.\n     * \n     * @return the amount by which the field is leap\n     * @see DateTimeField#getLeapAmount\n     */"}}
{"code": {"body": "    public DurationField getLeapDurationField() {\n        return getField().getLeapDurationField();\n    }", "comment": "/**\n     * If this field were to leap, then it would be in units described by the\n     * returned duration. If this field doesn't ever leap, null is returned.\n     */"}}
{"code": {"body": "    public int getMinimumValueOverall() {\n        return getField().getMinimumValue();\n    }", "comment": "/**\n     * Gets the minimum value for the field ignoring the current time.\n     * \n     * @return the minimum value\n     * @see DateTimeField#getMinimumValue\n     */"}}
{"code": {"body": "    public int getMinimumValue() {\n        return getField().getMinimumValue(getMillis());\n    }", "comment": "/**\n     * Gets the minimum value for the field.\n     * \n     * @return the minimum value\n     * @see DateTimeField#getMinimumValue\n     */"}}
{"code": {"body": "    public int getMaximumValueOverall() {\n        return getField().getMaximumValue();\n    }", "comment": "/**\n     * Gets the maximum value for the field ignoring the current time.\n     * \n     * @return the maximum value\n     * @see DateTimeField#getMaximumValue\n     */"}}
{"code": {"body": "    public int getMaximumValue() {\n        return getField().getMaximumValue(getMillis());\n    }", "comment": "/**\n     * Gets the maximum value for the field.\n     * \n     * @return the maximum value\n     * @see DateTimeField#getMaximumValue\n     */"}}
{"code": {"body": "    public int getMaximumTextLength(Locale locale) {\n        return getField().getMaximumTextLength(locale);\n    }", "comment": "/**\n     * Gets the maximum text length for the field.\n     * \n     * @param locale  optional locale to use for selecting a text symbol\n     * @return the maximum length\n     * @see DateTimeField#getMaximumTextLength\n     */"}}
{"code": {"body": "    public int getMaximumShortTextLength(Locale locale) {\n        return getField().getMaximumShortTextLength(locale);\n    }", "comment": "/**\n     * Gets the maximum short text length for the field.\n     * \n     * @param locale  optional locale to use for selecting a text symbol\n     * @return the maximum length\n     * @see DateTimeField#getMaximumShortTextLength\n     */"}}
{"code": {"body": "    public long remainder() {\n        return getField().remainder(getMillis());\n    }", "comment": "/**\n     * Returns the fractional duration milliseconds of this field.\n     *\n     * @see DateTimeField#remainder\n     * @return remainder duration, in milliseconds\n     */"}}
{"code": {"body": "    public Interval toInterval() {\n        DateTimeField field = getField();\n        long start = field.roundFloor(getMillis());\n        long end = field.add(start, 1);\n        Interval interval = new Interval(start, end);\n        return interval;\n    }", "comment": "/**\n     * Returns the interval that represents the range of the minimum\n     * and maximum values of this field.\n     * <p>\n     * For example, <code>datetime.monthOfYear().toInterval()</code>\n     * will return an interval over the whole month.\n     *\n     * @return the interval of this field\n     * @since 1.2\n     */"}}
{"code": {"body": "    public int compareTo(ReadablePartial partial) {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        int thisValue = get();\n        int otherValue = partial.get(getFieldType());\n        if (thisValue < otherValue) {\n            return -1;\n        } else if (thisValue > otherValue) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }", "comment": "/**\n     * Compare this field to the same field on another partial instant.\n     * <p>\n     * The comparison is based on the value of the same field type, irrespective\n     * of any difference in chronology. Thus, if this property represents the\n     * hourOfDay field, then the hourOfDay field of the other partial will be queried\n     * whether in the same chronology or not.\n     * \n     * @param partial  the partial to compare to\n     * @return negative value if this is less, 0 if equal, or positive value if greater\n     * @throws IllegalArgumentException if the partial is null\n     * @throws IllegalArgumentException if the partial doesn't support this field\n     */"}}
{"code": {"body": "    public boolean equals(Object object) {\n        if (this == object) {\n            return true;\n        }\n        if (object instanceof AbstractReadableInstantFieldProperty == false) {\n            return false;\n        }\n        AbstractReadableInstantFieldProperty other = (AbstractReadableInstantFieldProperty) object;\n        return \n            get() == other.get() &&\n            getFieldType().equals(other.getFieldType()) &&\n            FieldUtils.equals(getChronology(), other.getChronology());\n    }", "comment": "/**\n     * Compares this property to another.\n     * \n     * @param object  the object to compare to\n     * @return true if equal\n     */"}}
{"code": {"body": "    public int hashCode() {\n        return get() * 17 + getFieldType().hashCode() + getChronology().hashCode();\n    }", "comment": "/**\n     * Returns a hashcode compatible with the equals method.\n     * \n     * @return the hashcode\n     */"}}
{"code": {"body": "    public String toString() {\n        return \"\" + getName() + \"\";\n    }", "comment": "/**\n     * Output a debugging string.\n     * \n     * @return debugging string\n     */"}}
{"code": {"body": "    public final boolean isSupported() {\n        return true;\n    }", "comment": "/**\n     * @return true always\n     */"}}
{"code": {"body": "    public String getAsText(int fieldValue, Locale locale) {\n        return Integer.toString(fieldValue);\n    }", "comment": "/**\n     * Get the human-readable, text value of this field from the field value.\n     * If the specified locale is null, the default locale is used.\n     * <p>\n     * The default implementation returns Integer.toString(get(instant)).\n     * <p>\n     * Note: subclasses that override this method should also override\n     * getMaximumTextLength.\n     *\n     * @param fieldValue  the numeric value to convert to text\n     * @param locale the locale to use for selecting a text symbol, null for default\n     * @return the text value of the field\n     */"}}
{"code": {"body": "    public String getAsShortText(int fieldValue, Locale locale) {\n        return getAsText(fieldValue, locale);\n    }", "comment": "/**\n     * Get the human-readable, short text value of this field from the field value.\n     * If the specified locale is null, the default locale is used.\n     * <p>\n     * The default implementation returns getAsText(fieldValue, locale).\n     * <p>\n     * Note: subclasses that override this method should also override\n     * getMaximumShortTextLength.\n     *\n     * @param fieldValue  the numeric value to convert to text\n     * @param locale the locale to use for selecting a text symbol, null for default\n     * @return the text value of the field\n     */"}}
{"code": {"body": "    public int[] add(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {\n        if (valueToAdd == 0) {\n            return values;\n        }\n        \n        \n        \n        DateTimeField nextField = null;\n        \n        while (valueToAdd > 0) {\n            int max = getMaximumValue(instant, values);\n            long proposed = values[fieldIndex] + valueToAdd;\n            if (proposed <= max) {\n                values[fieldIndex] = (int) proposed;\n                break;\n            }\n            if (nextField == null) {\n                if (fieldIndex == 0) {\n                    throw new IllegalArgumentException(\"\");\n                }\n                nextField = instant.getField(fieldIndex - 1);\n                \n                if (getRangeDurationField().getType() != nextField.getDurationField().getType()) {\n                    throw new IllegalArgumentException(\"\");\n                }\n            }\n            valueToAdd -= (max + 1) - values[fieldIndex];  \n            values = nextField.add(instant, fieldIndex - 1, values, 1);  \n            values[fieldIndex] = getMinimumValue(instant, values);  \n        }\n        while (valueToAdd < 0) {\n            int min = getMinimumValue(instant, values);\n            long proposed = values[fieldIndex] + valueToAdd;\n            if (proposed >= min) {\n                values[fieldIndex] = (int) proposed;\n                break;\n            }\n            if (nextField == null) {\n                if (fieldIndex == 0) {\n                    throw new IllegalArgumentException(\"\");\n                }\n                nextField = instant.getField(fieldIndex - 1);\n                if (getRangeDurationField().getType() != nextField.getDurationField().getType()) {\n                    throw new IllegalArgumentException(\"\");\n                }\n            }\n            valueToAdd -= (min - 1) - values[fieldIndex];  \n            values = nextField.add(instant, fieldIndex - 1, values, -1);  \n            values[fieldIndex] = getMaximumValue(instant, values);  \n        }\n        \n        return set(instant, fieldIndex, values, values[fieldIndex]);  \n    }", "comment": "/**\n     * Adds a value (which may be negative) to the partial instant,\n     * throwing an exception if the maximum size of the instant is reached.\n     * <p>\n     * The value will be added to this field, overflowing into larger fields\n     * if necessary. Smaller fields should be unaffected, except where the\n     * result would be an invalid value for a smaller field. In this case the\n     * smaller field is adjusted to be in range.\n     * <p>\n     * Partial instants only contain some fields. This may result in a maximum\n     * possible value, such as TimeOfDay being limited to 23:59:59:999. If this\n     * limit is breached by the add an exception is thrown.\n     * <p>\n     * For example, in the ISO chronology:<br>\n     * 2000-08-20 add six months is 2000-02-20<br>\n     * 2000-08-20 add twenty months is 2000-04-20<br>\n     * 2000-08-20 add minus nine months is 2000-11-20<br>\n     * 2001-01-31 add one month  is 2001-02-28<br>\n     * 2001-01-31 add two months is 2001-03-31<br>\n     * \n     * @param instant  the partial instant\n     * @param fieldIndex  the index of this field in the partial\n     * @param values  the values of the partial instant which should be updated\n     * @param valueToAdd  the value to add, in the units of the field\n     * @return the passed in values\n     * @throws IllegalArgumentException if the value is invalid or the maximum instant is reached\n     */"}}
{"code": {"body": "    public int[] addWrapPartial(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {\n        if (valueToAdd == 0) {\n            return values;\n        }\n        \n        \n        \n        DateTimeField nextField = null;\n        \n        while (valueToAdd > 0) {\n            int max = getMaximumValue(instant, values);\n            long proposed = values[fieldIndex] + valueToAdd;\n            if (proposed <= max) {\n                values[fieldIndex] = (int) proposed;\n                break;\n            }\n            if (nextField == null) {\n                if (fieldIndex == 0) {\n                    valueToAdd -= (max + 1) - values[fieldIndex];\n                    values[fieldIndex] = getMinimumValue(instant, values);\n                    continue;\n                }\n                nextField = instant.getField(fieldIndex - 1);\n                \n                if (getRangeDurationField().getType() != nextField.getDurationField().getType()) {\n                    throw new IllegalArgumentException(\"\");\n                }\n            }\n            valueToAdd -= (max + 1) - values[fieldIndex];  \n            values = nextField.addWrapPartial(instant, fieldIndex - 1, values, 1);  \n            values[fieldIndex] = getMinimumValue(instant, values);  \n        }\n        while (valueToAdd < 0) {\n            int min = getMinimumValue(instant, values);\n            long proposed = values[fieldIndex] + valueToAdd;\n            if (proposed >= min) {\n                values[fieldIndex] = (int) proposed;\n                break;\n            }\n            if (nextField == null) {\n                if (fieldIndex == 0) {\n                    valueToAdd -= (min - 1) - values[fieldIndex];\n                    values[fieldIndex] = getMaximumValue(instant, values);\n                    continue;\n                }\n                nextField = instant.getField(fieldIndex - 1);\n                if (getRangeDurationField().getType() != nextField.getDurationField().getType()) {\n                    throw new IllegalArgumentException(\"\");\n                }\n            }\n            valueToAdd -= (min - 1) - values[fieldIndex];  \n            values = nextField.addWrapPartial(instant, fieldIndex - 1, values, -1);  \n            values[fieldIndex] = getMaximumValue(instant, values);  \n        }\n        \n        return set(instant, fieldIndex, values, values[fieldIndex]);  \n    }", "comment": "/**\n     * Adds a value (which may be negative) to the partial instant,\n     * wrapping the whole partial if the maximum size of the partial is reached.\n     * <p>\n     * The value will be added to this field, overflowing into larger fields\n     * if necessary. Smaller fields should be unaffected, except where the\n     * result would be an invalid value for a smaller field. In this case the\n     * smaller field is adjusted to be in range.\n     * <p>\n     * Partial instants only contain some fields. This may result in a maximum\n     * possible value, such as TimeOfDay normally being limited to 23:59:59:999.\n     * If ths limit is reached by the addition, this method will wrap back to\n     * 00:00:00.000. In fact, you would generally only use this method for\n     * classes that have a limitation such as this.\n     * <p>\n     * For example, in the ISO chronology:<br>\n     * 10:20:30 add 20 minutes is 10:40:30<br>\n     * 10:20:30 add 45 minutes is 11:05:30<br>\n     * 10:20:30 add 16 hours is 02:20:30<br>\n     * \n     * @param instant  the partial instant\n     * @param fieldIndex  the index of this field in the partial\n     * @param values  the values of the partial instant which should be updated\n     * @param valueToAdd  the value to add, in the units of the field\n     * @return the passed in values\n     * @throws IllegalArgumentException if the value is invalid or the maximum instant is reached\n     */"}}
{"code": {"body": "    public int[] addWrapField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {\n        int current = values[fieldIndex];\n        int wrapped = FieldUtils.getWrappedValue\n            (current, valueToAdd, getMinimumValue(instant), getMaximumValue(instant));\n        return set(instant, fieldIndex, values, wrapped);  \n    }", "comment": "/**\n     * Adds a value (which may be negative) to the partial instant,\n     * wrapping within this field.\n     * <p>\n     * The value will be added to this field. If the value is too large to be\n     * added solely to this field then it wraps. Larger fields are always\n     * unaffected. Smaller fields should be unaffected, except where the\n     * result would be an invalid value for a smaller field. In this case the\n     * smaller field is adjusted to be in range.\n     * <p>\n     * For example, in the ISO chronology:<br>\n     * 2000-08-20 addWrapField six months is 2000-02-20<br>\n     * 2000-08-20 addWrapField twenty months is 2000-04-20<br>\n     * 2000-08-20 addWrapField minus nine months is 2000-11-20<br>\n     * 2001-01-31 addWrapField one month  is 2001-02-28<br>\n     * 2001-01-31 addWrapField two months is 2001-03-31<br>\n     * <p>\n     * The default implementation internally calls set. Subclasses are\n     * encouraged to provide a more efficient implementation.\n     * \n     * @param instant  the partial instant\n     * @param fieldIndex  the index of this field in the instant\n     * @param values  the values of the partial instant which should be updated\n     * @param valueToAdd  the value to add, in the units of the field\n     * @return the passed in values\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public int getDifference(long minuendInstant, long subtrahendInstant) {\n        return getDurationField().getDifference(minuendInstant, subtrahendInstant);\n    }", "comment": "/**\n     * Computes the difference between two instants, as measured in the units\n     * of this field. Any fractional units are dropped from the result. Calling\n     * getDifference reverses the effect of calling add. In the following code:\n     *\n     * <pre>\n     * long instant = ...\n     * int v = ...\n     * int age = getDifference(add(instant, v), instant);\n     * </pre>\n     *\n     * The value 'age' is the same as the value 'v'.\n     *\n     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to\n     * subtract from\n     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to\n     * subtract off the minuend\n     * @return the difference in the units of this field\n     */"}}
{"code": {"body": "    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n        return getDurationField().getDifferenceAsLong(minuendInstant, subtrahendInstant);\n    }", "comment": "/**\n     * Computes the difference between two instants, as measured in the units\n     * of this field. Any fractional units are dropped from the result. Calling\n     * getDifference reverses the effect of calling add. In the following code:\n     *\n     * <pre>\n     * long instant = ...\n     * long v = ...\n     * long age = getDifferenceAsLong(add(instant, v), instant);\n     * </pre>\n     *\n     * The value 'age' is the same as the value 'v'.\n     *\n     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to\n     * subtract from\n     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to\n     * subtract off the minuend\n     * @return the difference in the units of this field\n     */"}}
{"code": {"body": "    public int[] set(ReadablePartial instant, int fieldIndex, int[] values, String text, Locale locale) {\n        int value = convertText(text, locale);\n        return set(instant, fieldIndex, values, value);\n    }", "comment": "/**\n     * Sets a value in the milliseconds supplied from a human-readable, text value.\n     * If the specified locale is null, the default locale is used.\n     * <p>\n     * This implementation uses <code>convertText(String, Locale)</code> and\n     * {@link #set(ReadablePartial, int, int[], int)}.\n     *\n     * @param instant  the partial instant\n     * @param fieldIndex  the index of this field in the instant\n     * @param values  the values of the partial instant which should be updated\n     * @param text  the text value to set\n     * @param locale the locale to use for selecting a text symbol, null for default\n     * @return the passed in values\n     * @throws IllegalArgumentException if the text value is invalid\n     */"}}
{"code": {"body": "    protected int convertText(String text, Locale locale) {\n        try {\n            return Integer.parseInt(text);\n        } catch (NumberFormatException ex) {\n            throw new IllegalFieldValueException(getType(), text);\n        }\n    }", "comment": "/**\n     * Convert the specified text and locale into a value.\n     * \n     * @param text  the text to convert\n     * @param locale  the locale to convert using\n     * @return the value extracted from the text\n     * @throws IllegalArgumentException if the text is invalid\n     */"}}
{"code": {"body": "    public boolean isLeap(long instant) {\n        return false;\n    }", "comment": "/**\n     * Returns whether this field is 'leap' for the specified instant.\n     * <p>\n     * For example, a leap year would return true, a non leap year would return\n     * false.\n     * <p>\n     * This implementation returns false.\n     * \n     * @return true if the field is 'leap'\n     */"}}
{"code": {"body": "    public int getLeapAmount(long instant) {\n        return 0;\n    }", "comment": "/**\n     * Gets the amount by which this field is 'leap' for the specified instant.\n     * <p>\n     * For example, a leap year would return one, a non leap year would return\n     * zero.\n     * <p>\n     * This implementation returns zero.\n     */"}}
{"code": {"body": "    public DurationField getLeapDurationField() {\n        return null;\n    }", "comment": "/**\n     * If this field were to leap, then it would be in units described by the\n     * returned duration. If this field doesn't ever leap, null is returned.\n     * <p>\n     * This implementation returns null.\n     */"}}
{"code": {"body": "    public int getMinimumValue(ReadablePartial instant, int[] values) {\n        return getMinimumValue(instant);\n    }", "comment": "/**\n     * Get the minimum value for this field using the partial instant and\n     * the specified values.\n     * <p>\n     * This implementation returns the same as {@link #getMinimumValue(ReadablePartial)}.\n     * \n     * @param instant  the partial instant to query\n     * @param values  the values to use\n     * @return the minimum value for this field, in the units of the field\n     */"}}
{"code": {"body": "    public int getMaximumValue(ReadablePartial instant, int[] values) {\n        return getMaximumValue(instant);\n    }", "comment": "/**\n     * Get the maximum value for this field using the partial instant and\n     * the specified values.\n     * <p>\n     * This implementation returns the same as {@link #getMaximumValue(ReadablePartial)}.\n     * \n     * @param instant  the partial instant to query\n     * @param values  the values to use\n     * @return the maximum value for this field, in the units of the field\n     */"}}
{"code": {"body": "    public int getMaximumTextLength(Locale locale) {\n        int max = getMaximumValue();\n        if (max >= 0) {\n            if (max < 10) {\n                return 1;\n            } else if (max < 100) {\n                return 2;\n            } else if (max < 1000) {\n                return 3;\n            }\n        }\n        return Integer.toString(max).length();\n    }", "comment": "/**\n     * Get the maximum text value for this field. The default implementation\n     * returns the equivalent of Integer.toString(getMaximumValue()).length().\n     * \n     * @param locale  the locale to use for selecting a text symbol\n     * @return the maximum text length\n     */"}}
{"code": {"body": "    public int getMaximumShortTextLength(Locale locale) {\n        return getMaximumTextLength(locale);\n    }", "comment": "/**\n     * Get the maximum short text value for this field. The default\n     * implementation returns getMaximumTextLength().\n     * \n     * @param locale  the locale to use for selecting a text symbol\n     * @return the maximum short text length\n     */"}}
{"code": {"body": "    public long roundCeiling(long instant) {\n        long newInstant = roundFloor(instant);\n        if (newInstant != instant) {\n            instant = add(newInstant, 1);\n        }\n        return instant;\n    }", "comment": "/**\n     * Round to the highest whole unit of this field. The value of this field\n     * and all fields of a higher magnitude may be incremented in order to\n     * achieve this result. The fractional millis that cannot be expressed in\n     * whole increments of this field are set to minimum.\n     * <p>\n     * For example, a datetime of 2002-11-02T23:34:56.789, rounded to the\n     * highest whole hour is 2002-11-03T00:00:00.000.\n     * <p>\n     * The default implementation calls roundFloor, and if the instant is\n     * modified as a result, adds one field unit. Subclasses are encouraged to\n     * provide a more efficient implementation.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n     * @return rounded milliseconds\n     */"}}
{"code": {"body": "    public long roundHalfFloor(long instant) {\n        long floor = roundFloor(instant);\n        long ceiling = roundCeiling(instant);\n\n        long diffFromFloor = instant - floor;\n        long diffToCeiling = ceiling - instant;\n\n        if (diffFromFloor <= diffToCeiling) {\n            \n            return floor;\n        } else {\n            return ceiling;\n        }\n    }", "comment": "/**\n     * Round to the nearest whole unit of this field. If the given millisecond\n     * value is closer to the floor or is exactly halfway, this function\n     * behaves like roundFloor. If the millisecond value is closer to the\n     * ceiling, this function behaves like roundCeiling.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n     * @return rounded milliseconds\n     */"}}
{"code": {"body": "    public long roundHalfCeiling(long instant) {\n        long floor = roundFloor(instant);\n        long ceiling = roundCeiling(instant);\n\n        long diffFromFloor = instant - floor;\n        long diffToCeiling = ceiling - instant;\n\n        if (diffToCeiling <= diffFromFloor) {\n            \n            return ceiling;\n        } else {\n            return floor;\n        }\n    }", "comment": "/**\n     * Round to the nearest whole unit of this field. If the given millisecond\n     * value is closer to the floor, this function behaves like roundFloor. If\n     * the millisecond value is closer to the ceiling or is exactly halfway,\n     * this function behaves like roundCeiling.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n     * @return rounded milliseconds\n     */"}}
{"code": {"body": "    public long roundHalfEven(long instant) {\n        long floor = roundFloor(instant);\n        long ceiling = roundCeiling(instant);\n\n        long diffFromFloor = instant - floor;\n        long diffToCeiling = ceiling - instant;\n\n        if (diffFromFloor < diffToCeiling) {\n            \n            return floor;\n        } else if (diffToCeiling < diffFromFloor) {\n            \n            return ceiling;\n        } else {\n            \n            \n            if ((get(ceiling) & 1) == 0) {\n                return ceiling;\n            }\n            return floor;\n        }\n    }", "comment": "/**\n     * Round to the nearest whole unit of this field. If the given millisecond\n     * value is closer to the floor, this function behaves like roundFloor. If\n     * the millisecond value is closer to the ceiling, this function behaves\n     * like roundCeiling.\n     * <p>\n     * If the millisecond value is exactly halfway between the floor and\n     * ceiling, the ceiling is chosen over the floor only if it makes this\n     * field's value even.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n     * @return rounded milliseconds\n     */"}}
{"code": {"body": "    public long remainder(long instant) {\n        return instant - roundFloor(instant);\n    }", "comment": "/**\n     * Returns the fractional duration milliseconds of this field. In other\n     * words, calling remainder returns the duration that roundFloor would\n     * subtract.\n     * <p>\n     * For example, on a datetime of 2002-11-02T23:34:56.789, the remainder by\n     * hour is 34 minutes and 56.789 seconds.\n     * <p>\n     * The default implementation computes\n     * <code>instant - roundFloor(instant)</code>. Subclasses are encouraged to\n     * provide a more efficient implementation.\n     *\n     * @param instant the milliseconds from 1970-01-01T00:00:00Z to get the\n     * remainder\n     * @return remainder duration, in milliseconds\n     */"}}
{"code": {"body": "    public String toString() {\n        return \"\" + getName() + '';\n    }", "comment": "/**\n     * Get a suitable debug string.\n     * \n     * @return debug string\n     */"}}
{"code": {"body": "    public final boolean isSupported() {\n        return true;\n    }", "comment": "/**\n     * @return true always\n     */"}}
{"code": {"body": "    public int getValue(long duration, long instant) {\n        return FieldUtils.safeToInt(getValueAsLong(duration, instant));\n    }", "comment": "/**\n     * Get the value of this field from the milliseconds relative to an\n     * instant.\n     *\n     * <p>If the milliseconds is positive, then the instant is treated as a\n     * \"start instant\". If negative, the instant is treated as an \"end\n     * instant\".\n     *\n     * <p>The default implementation returns\n     * <code>Utils.safeToInt(getAsLong(millisDuration, instant))</code>.\n     * \n     * @param duration  the milliseconds to query, which may be negative\n     * @param instant  the start instant to calculate relative to\n     * @return the value of the field, in the units of the field, which may be\n     * negative\n     */"}}
{"code": {"body": "    public long getValueAsLong(long duration) {\n        return duration / getUnitMillis();\n    }", "comment": "/**\n     * Get the value of this field from the milliseconds, which is approximate\n     * if this field is imprecise.\n     *\n     * @param duration  the milliseconds to query, which may be negative\n     * @return the value of the field, in the units of the field, which may be\n     * negative\n     */"}}
{"code": {"body": "    public long getMillis(long value) {\n        return FieldUtils.safeMultiply(value, getUnitMillis());\n    }", "comment": "/**\n     * Get the millisecond duration of this field from its value, which is\n     * approximate if this field is imprecise.\n     * \n     * @param value  the value of the field, which may be negative\n     * @return the milliseconds that the field represents, which may be\n     * negative\n     */"}}
{"code": {"body": "    public String toString() {\n        return \"\" + getName() + '';\n    }", "comment": "/**\n     * Get a suitable debug string.\n     * \n     * @return debug string\n     */"}}
{"code": {"body": "    public final DateTimeField getWrappedField() {\n        return iField;\n    }", "comment": "/**\n     * Gets the wrapped date time field.\n     * \n     * @return the wrapped DateTimeField\n     */"}}
{"code": {"body": "public DecoratedDurationField(DurationField field, DurationFieldType type) {\n        super(type);\n        if (field == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (!field.isSupported()) {\n            throw new IllegalArgumentException(\"\");\n        }\n        iField = field;\n    }", "comment": "/**\n     * Constructor.\n     * \n     * @param field  the base field\n     * @param type  the type to actually use\n     */"}}
{"code": {"body": "    public final DurationField getWrappedField() {\n        return iField;\n    }", "comment": "/**\n     * Gets the wrapped duration field.\n     * \n     * @return the wrapped DurationField\n     */"}}
{"code": {"body": "public DelegatedDateTimeField(DateTimeField field) {\n        this(field, null);\n    }", "comment": "/**\n     * Constructor.\n     * \n     * @param field  the field being decorated\n     */"}}
{"code": {"body": "public DelegatedDateTimeField(DateTimeField field, DateTimeFieldType type) {\n        super();\n        if (field == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        iField = field;\n        iType = (type == null ? field.getType() : type);\n    }", "comment": "/**\n     * Constructor.\n     * \n     * @param field  the field being decorated\n     * @param type  the field type override\n     */"}}
{"code": {"body": "    public final DateTimeField getWrappedField() {\n        return iField;\n    }", "comment": "/**\n     * Gets the wrapped date time field.\n     * \n     * @return the wrapped DateTimeField\n     */"}}
{"code": {"body": "    public final DurationField getWrappedField() {\n        return iField;\n    }", "comment": "/**\n     * Gets the wrapped duration field.\n     * \n     * @return the wrapped DurationField\n     */"}}
{"code": {"body": "    public boolean isSupported() {\n        return iField.isSupported();\n    }", "comment": "/**\n     * Returns true if this field is supported.\n     */"}}
{"code": {"body": "public DividedDateTimeField(DateTimeField field,", "comment": "/**\n     * Constructor.\n     * \n     * @param field  the field to wrap, like \"year()\".\n     * @param type  the field type this field will actually use\n     * @param divisor  divisor, such as 100 years in a century\n     * @throws IllegalArgumentException if divisor is less than two\n     */"}}
{"code": {"body": "public DividedDateTimeField(RemainderDateTimeField remainderField, DateTimeFieldType type) {\n        super(remainderField.getWrappedField(), type);\n        int divisor = iDivisor = remainderField.iDivisor;\n        iDurationField = remainderField.iRangeField;\n\n        DateTimeField field = getWrappedField();\n        int i = field.getMinimumValue();\n        int min = (i >= 0) ? i / divisor : ((i + 1) / divisor - 1);\n\n        int j = field.getMaximumValue();\n        int max = (j >= 0) ? j / divisor : ((j + 1) / divisor - 1);\n\n        iMin = min;\n        iMax = max;\n    }", "comment": "/**\n     * Construct a DividedDateTimeField that compliments the given\n     * RemainderDateTimeField.\n     *\n     * @param remainderField  complimentary remainder field, like \"yearOfCentury()\".\n     * @param type  the field type this field will actually use\n     */"}}
{"code": {"body": "    public int get(long instant) {\n        int value = getWrappedField().get(instant);\n        if (value >= 0) {\n            return value / iDivisor;\n        } else {\n            return ((value + 1) / iDivisor) - 1;\n        }\n    }", "comment": "/**\n     * Get the amount of scaled units from the specified time instant.\n     * \n     * @param instant  the time instant in millis to query.\n     * @return the amount of scaled units extracted from the input.\n     */"}}
{"code": {"body": "    public long add(long instant, long amount) {\n        return getWrappedField().add(instant, amount * iDivisor);\n    }", "comment": "/**\n     * Add the specified amount of scaled units to the specified time\n     * instant. The amount added may be negative.\n     * \n     * @param instant  the time instant in millis to update.\n     * @param amount  the amount of scaled units to add (can be negative).\n     * @return the updated time instant.\n     */"}}
{"code": {"body": "    public long addWrapField(long instant, int amount) {\n        return set(instant, FieldUtils.getWrappedValue(get(instant), amount, iMin, iMax));\n    }", "comment": "/**\n     * Add to the scaled component of the specified time instant,\n     * wrapping around within that component if necessary.\n     * \n     * @param instant  the time instant in millis to update.\n     * @param amount  the amount of scaled units to add (can be negative).\n     * @return the updated time instant.\n     */"}}
{"code": {"body": "    public long set(long instant, int value) {\n        FieldUtils.verifyValueBounds(this, value, iMin, iMax);\n        int remainder = getRemainder(getWrappedField().get(instant));\n        return getWrappedField().set(instant, value * iDivisor + remainder);\n    }", "comment": "/**\n     * Set the specified amount of scaled units to the specified time instant.\n     * \n     * @param instant  the time instant in millis to update.\n     * @param value  value of scaled units to set.\n     * @return the updated time instant.\n     * @throws IllegalArgumentException if value is too large or too small.\n     */"}}
{"code": {"body": "    public DurationField getDurationField() {\n        return iDurationField;\n    }", "comment": "/**\n     * Returns a scaled version of the wrapped field's unit duration field.\n     */"}}
{"code": {"body": "    public int getMinimumValue() {\n        return iMin;\n    }", "comment": "/**\n     * Get the minimum value for the field.\n     * \n     * @return the minimum value\n     */"}}
{"code": {"body": "    public int getMaximumValue() {\n        return iMax;\n    }", "comment": "/**\n     * Get the maximum value for the field.\n     * \n     * @return the maximum value\n     */"}}
{"code": {"body": "    public int getDivisor() {\n        return iDivisor;\n    }", "comment": "/**\n     * Returns the divisor applied, in the field's units.\n     * \n     * @return the divisor\n     */"}}
{"code": {"body": "    public static int safeNegate(int value) {\n        if (value == Integer.MIN_VALUE) {\n            throw new ArithmeticException(\"\");\n        }\n        return -value;\n    }", "comment": "/**\n     * Negates the input throwing an exception if it can't negate it.\n     * \n     * @param value  the value to negate\n     * @return the negated value\n     * @throws ArithmeticException if the value is Integer.MIN_VALUE\n     * @since 1.1\n     */"}}
{"code": {"body": "    public static long safeAdd(long val1, long val2) {\n        long sum = val1 + val2;\n        \n        if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\n            throw new ArithmeticException\n                (\"\" + val1 + \"\" + val2);\n        }\n        return sum;\n    }", "comment": "/**\n     * Add two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */"}}
{"code": {"body": "    public static long safeSubtract(long val1, long val2) {\n        long diff = val1 - val2;\n        \n        if ((val1 ^ diff) < 0 && (val1 ^ val2) < 0) {\n            throw new ArithmeticException\n                (\"\" + val1 + \"\" + val2);\n        }\n        return diff;\n    }", "comment": "/**\n     * Subtracts two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value, to be taken away from\n     * @param val2  the second value, the amount to take away\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */"}}
{"code": {"body": "    public static long safeMultiply(long val1, long val2) {\n        if (val2 == 1) {\n            return val1;\n        }\n        if (val1 == 1) {\n            return val2;\n        }\n        if (val1 == 0 || val2 == 0) {\n            return 0;\n        }\n        long total = val1 * val2;\n        if (total / val2 != val1 || val1 == Long.MIN_VALUE && val2 == -1 || val2 == Long.MIN_VALUE && val1 == -1) {\n            throw new ArithmeticException(\"\" + val1 + \"\" + val2);\n        }\n        return total;\n    }", "comment": "/**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */"}}
{"code": {"body": "    public static int safeToInt(long value) {\n        if (Integer.MIN_VALUE <= value && value <= Integer.MAX_VALUE) {\n            return (int) value;\n        }\n        throw new ArithmeticException(\"\" + value);\n    }", "comment": "/**\n     * Casts to an int throwing an exception if overflow occurs.\n     * \n     * @param value  the value\n     * @return the value as an int\n     * @throws ArithmeticException if the value is too big or too small\n     */"}}
{"code": {"body": "    public static int safeMultiplyToInt(long val1, long val2) {\n        long val = FieldUtils.safeMultiply(val1, val2);\n        return FieldUtils.safeToInt(val);\n    }", "comment": "/**\n     * Multiply two values to return an int throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */"}}
{"code": {"body": "    public static void verifyValueBounds(String fieldName,\n                                         int value, int lowerBound, int upperBound) {\n        if ((value < lowerBound) || (value > upperBound)) {\n            throw new IllegalFieldValueException\n                (fieldName, Integer.valueOf(value),\n                 Integer.valueOf(lowerBound), Integer.valueOf(upperBound));\n        }\n    }", "comment": "/**\n     * Verify that input values are within specified bounds.\n     * \n     * @param value  the value to check\n     * @param lowerBound  the lower bound allowed for value\n     * @param upperBound  the upper bound allowed for value\n     * @throws IllegalFieldValueException if value is not in the specified bounds\n     */"}}
{"code": {"body": "    public static int getWrappedValue(int value, int minValue, int maxValue) {\n        if (minValue >= maxValue) {\n            throw new IllegalArgumentException(\"\");\n        }\n\n        int wrapRange = maxValue - minValue + 1;\n        value -= minValue;\n\n        if (value >= 0) {\n            return (value % wrapRange) + minValue;\n        }\n\n        int remByRange = (-value) % wrapRange;\n\n        if (remByRange == 0) {\n            return 0 + minValue;\n        }\n        return (wrapRange - remByRange) + minValue;\n    }", "comment": "/**\n     * Utility method that ensures the given value lies within the field's\n     * legal value range.\n     * \n     * @param value  the value to fit into the wrapped value range\n     * @param minValue the wrap range minimum value.\n     * @param maxValue the wrap range maximum value.  This must be\n     *  greater than minValue (checked by the method).\n     * @return the wrapped value\n     * @throws IllegalArgumentException if minValue is greater\n     *  than or equal to maxValue\n     */"}}
{"code": {"body": "    public static boolean equals(Object object1, Object object2) {\n        if (object1 == object2) {\n            return true;\n        }\n        if (object1 == null || object2 == null) {\n            return false;\n        }\n        return object1.equals(object2);\n    }", "comment": "/**\n     * Compares two objects as equals handling null.\n     * \n     * @param object1  the first object\n     * @param object2  the second object\n     * @return true if equal\n     * @since 1.4\n     */"}}
{"code": {"body": "public ImpreciseDateTimeField(DateTimeFieldType type, long unitMillis) {\n        super(type);\n        iUnitMillis = unitMillis;\n        iDurationField = new LinkedDurationField(type.getDurationType());\n    }", "comment": "/**\n     * Constructor.\n     * \n     * @param type  the field type\n     * @param unitMillis  the average duration unit milliseconds\n     */"}}
{"code": {"body": "    public static DateTimeField getInstance(DateTimeField field, Chronology base) {\n        if (field == null) {\n            return null;\n        }\n        if (field instanceof StrictDateTimeField) {\n            field = ((StrictDateTimeField)field).getWrappedField();\n        }\n        if (field.isLenient()) {\n            return field;\n        }\n        return new LenientDateTimeField(field, base);\n    }", "comment": "/**\n     * Returns a lenient version of the given field. If it is already lenient,\n     * then it is returned as-is. Otherwise, a new LenientDateTimeField is\n     * returned.\n     */"}}
{"code": {"body": "    public long set(long instant, int value) {\n        \n        \n        long localInstant = iBase.getZone().convertUTCToLocal(instant);\n        long difference = FieldUtils.safeSubtract(value, get(instant));\n        localInstant = getType().getField(iBase.withUTC()).add(localInstant, difference);\n        return iBase.getZone().convertLocalToUTC(localInstant, false, instant);\n    }", "comment": "/**\n     * Set values which may be out of bounds by adding the difference between\n     * the new value and the current value.\n     */"}}
{"code": {"body": "    public boolean isSupported() {\n        return true;\n    }", "comment": "/**\n     * Returns true as this field is supported.\n     * \n     * @return true always\n     */"}}
{"code": {"body": "    public final boolean isPrecise() {\n        return true;\n    }", "comment": "/**\n     * Returns true as this field is precise.\n     * \n     * @return true always\n     */"}}
{"code": {"body": "    public final long getUnitMillis() {\n        return 1;\n    }", "comment": "/**\n     * Returns the amount of milliseconds per unit value of this field.\n     *\n     * @return one always\n     */"}}
{"code": {"body": "    public String toString() {\n        return \"\";\n    }", "comment": "/**\n     * Get a suitable debug string.\n     * \n     * @return debug string\n     */"}}
{"code": {"body": "    private Object readResolve() {\n        return INSTANCE;\n    }", "comment": "/**\n     * Deserialize to the singleton.\n     */"}}
{"code": {"body": "public OffsetDateTimeField(DateTimeField field, int offset) {\n        this(field, (field == null ? null : field.getType()), offset, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    }", "comment": "/**\n     * Constructor.\n     * \n     * @param field  the field to wrap, like \"year()\".\n     * @param offset  offset to add to field values\n     * @throws IllegalArgumentException if offset is zero\n     */"}}
{"code": {"body": "public OffsetDateTimeField(DateTimeField field, DateTimeFieldType type, int offset) {\n        this(field, type, offset, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    }", "comment": "/**\n     * Constructor.\n     * \n     * @param field  the field to wrap, like \"year()\".\n     * @param type  the field type this field actually uses\n     * @param offset  offset to add to field values\n     * @throws IllegalArgumentException if offset is zero\n     */"}}
{"code": {"body": "public OffsetDateTimeField(DateTimeField field, DateTimeFieldType type, int offset)", "comment": "/**\n     * Constructor.\n     * \n     * @param field  the field to wrap, like \"year()\".\n     * @param type  the field type this field actually uses\n     * @param offset  offset to add to field values\n     * @throws IllegalArgumentException if offset is zero\n     */"}}
{"code": {"body": "    public int get(long instant) {\n        return super.get(instant) + iOffset;\n    }", "comment": "/**\n     * Get the amount of offset units from the specified time instant.\n     * \n     * @param instant  the time instant in millis to query.\n     * @return the amount of units extracted from the input.\n     */"}}
{"code": {"body": "    public long add(long instant, long amount) {\n        instant = super.add(instant, amount);\n        FieldUtils.verifyValueBounds(this, get(instant), iMin, iMax);\n        return instant;\n    }", "comment": "/**\n     * Add the specified amount of offset units to the specified time\n     * instant. The amount added may be negative.\n     * \n     * @param instant  the time instant in millis to update.\n     * @param amount  the amount of units to add (can be negative).\n     * @return the updated time instant.\n     */"}}
{"code": {"body": "    public long addWrapField(long instant, int amount) {\n        return set(instant, FieldUtils.getWrappedValue(get(instant), amount, iMin, iMax));\n    }", "comment": "/**\n     * Add to the offset component of the specified time instant,\n     * wrapping around within that component if necessary.\n     * \n     * @param instant  the time instant in millis to update.\n     * @param amount  the amount of units to add (can be negative).\n     * @return the updated time instant.\n     */"}}
{"code": {"body": "    public long set(long instant, int value) {\n        FieldUtils.verifyValueBounds(this, value, iMin, iMax);\n        return super.set(instant, value - iOffset);\n    }", "comment": "/**\n     * Set the specified amount of offset units to the specified time instant.\n     * \n     * @param instant  the time instant in millis to update.\n     * @param value  value of units to set.\n     * @return the updated time instant.\n     * @throws IllegalArgumentException if value is too large or too small.\n     */"}}
{"code": {"body": "    public int getMinimumValue() {\n        return iMin;\n    }", "comment": "/**\n     * Get the minimum value for the field.\n     * \n     * @return the minimum value\n     */"}}
{"code": {"body": "    public int getMaximumValue() {\n        return iMax;\n    }", "comment": "/**\n     * Get the maximum value for the field.\n     * \n     * @return the maximum value\n     */"}}
{"code": {"body": "    public int getOffset() {\n        return iOffset;\n    }", "comment": "/**\n     * Returns the offset added to the field values.\n     * \n     * @return the offset\n     */"}}
{"code": {"body": "public PreciseDateTimeField(DateTimeFieldType type,", "comment": "/**\n     * Constructor.\n     * \n     * @param type  the field type this field uses\n     * @param unit  precise unit duration, like \"seconds()\".\n     * @param range precise range duration, preferably a multiple of the unit,\n     * like \"minutes()\".\n     * @throws IllegalArgumentException if either duration field is imprecise\n     * @throws IllegalArgumentException if unit milliseconds is less than one\n     * or effective value range is less than two.\n     */"}}
{"code": {"body": "    public int get(long instant) {\n        if (instant >= 0) {\n            return (int) ((instant / getUnitMillis()) % iRange);\n        } else {\n            return iRange - 1 + (int) (((instant + 1) / getUnitMillis()) % iRange);\n        }\n    }", "comment": "/**\n     * Get the amount of fractional units from the specified time instant.\n     * \n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n     * @return the amount of fractional units extracted from the input.\n     */"}}
{"code": {"body": "    public long addWrapField(long instant, int amount) {\n        int thisValue = get(instant);\n        int wrappedValue = FieldUtils.getWrappedValue\n            (thisValue, amount, getMinimumValue(), getMaximumValue());\n        \n        return instant + (wrappedValue - thisValue) * getUnitMillis();\n    }", "comment": "/**\n     * Add to the component of the specified time instant, wrapping around\n     * within that component if necessary.\n     * \n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to\n     * @param amount  the amount of units to add (can be negative).\n     * @return the updated time instant.\n     */"}}
{"code": {"body": "    public long set(long instant, int value) {\n        FieldUtils.verifyValueBounds(this, value, getMinimumValue(), getMaximumValue());\n        return instant + (value - get(instant)) * iUnitMillis;\n    }", "comment": "/**\n     * Set the specified amount of units to the specified time instant.\n     * \n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in\n     * @param value  value of units to set.\n     * @return the updated time instant.\n     * @throws IllegalArgumentException if value is too large or too small.\n     */"}}
{"code": {"body": "    public DurationField getRangeDurationField() {\n        return iRangeField;\n    }", "comment": "/**\n     * Returns the range duration of this field. For example, if this field\n     * represents \"minute of hour\", then the range duration field is an hours.\n     *\n     * @return the range duration of this field, or null if field has no range\n     */"}}
{"code": {"body": "    public int getMaximumValue() {\n        return iRange - 1;\n    }", "comment": "/**\n     * Get the maximum value for the field.\n     * \n     * @return the maximum value\n     */"}}
{"code": {"body": "    public int getRange() {\n        return iRange;\n    }", "comment": "/**\n     * Returns the range of the field in the field's units.\n     * <p>\n     * For example, 60 for seconds per minute. The field is allowed values\n     * from 0 to range - 1.\n     * \n     * @return unit range\n     */"}}
{"code": {"body": "public PreciseDurationDateTimeField(DateTimeFieldType type, DurationField unit) {\n        super(type);\n\n        if (!unit.isPrecise()) {\n            throw new IllegalArgumentException(\"\");\n        }\n\n        iUnitMillis = unit.getUnitMillis();\n        if (iUnitMillis < 1) {\n            throw new IllegalArgumentException(\"\");\n        }\n\n        iUnitField = unit;\n    }", "comment": "/**\n     * Constructor.\n     * \n     * @param type  the field type\n     * @param unit  precise unit duration, like \"days()\".\n     * @throws IllegalArgumentException if duration field is imprecise\n     * @throws IllegalArgumentException if unit milliseconds is less than one\n     */"}}
{"code": {"body": "    public boolean isLenient() {\n        return false;\n    }", "comment": "/**\n     * Returns false by default.\n     */"}}
{"code": {"body": "    public long set(long instant, int value) {\n        FieldUtils.verifyValueBounds(this, value, getMinimumValue(),\n                                     getMaximumValueForSet(instant, value));\n        return instant + (value - get(instant)) * iUnitMillis;\n    }", "comment": "/**\n     * Set the specified amount of units to the specified time instant.\n     * \n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in\n     * @param value  value of units to set.\n     * @return the updated time instant.\n     * @throws IllegalArgumentException if value is too large or too small.\n     */"}}
{"code": {"body": "    public long roundFloor(long instant) {\n        if (instant >= 0) {\n            return instant - instant % iUnitMillis;\n        } else {\n            instant += 1;\n            return instant - instant % iUnitMillis - iUnitMillis;\n        }\n    }", "comment": "/**\n     * This method assumes that this field is properly rounded on\n     * 1970-01-01T00:00:00. If the rounding alignment differs, override this\n     * method as follows:\n     * <pre>\n     * return super.roundFloor(instant + ALIGNMENT_MILLIS) - ALIGNMENT_MILLIS;\n     * </pre>\n     */"}}
{"code": {"body": "    public long roundCeiling(long instant) {\n        if (instant > 0) {\n            instant -= 1;\n            return instant - instant % iUnitMillis + iUnitMillis;\n        } else {\n            return instant - instant % iUnitMillis;\n        }\n    }", "comment": "/**\n     * This method assumes that this field is properly rounded on\n     * 1970-01-01T00:00:00. If the rounding alignment differs, override this\n     * method as follows:\n     * <pre>\n     * return super.roundCeiling(instant + ALIGNMENT_MILLIS) - ALIGNMENT_MILLIS;\n     * </pre>\n     */"}}
{"code": {"body": "    public long remainder(long instant) {\n        if (instant >= 0) {\n            return instant % iUnitMillis;\n        } else {\n            return (instant + 1) % iUnitMillis + iUnitMillis - 1;\n        }\n    }", "comment": "/**\n     * This method assumes that this field is properly rounded on\n     * 1970-01-01T00:00:00. If the rounding alignment differs, override this\n     * method as follows:\n     * <pre>\n     * return super.remainder(instant + ALIGNMENT_MILLIS);\n     * </pre>\n     */"}}
{"code": {"body": "    public DurationField getDurationField() {\n        return iUnitField;\n    }", "comment": "/**\n     * Returns the duration per unit value of this field. For example, if this\n     * field represents \"minute of hour\", then the duration field is minutes.\n     *\n     * @return the duration of this field, or UnsupportedDurationField if field\n     * has no duration\n     */"}}
{"code": {"body": "    public int getMinimumValue() {\n        return 0;\n    }", "comment": "/**\n     * Get the minimum value for the field.\n     * \n     * @return the minimum value\n     */"}}
{"code": {"body": "    protected int getMaximumValueForSet(long instant, int value) {\n        return getMaximumValue(instant);\n    }", "comment": "/**\n     * Called by the set method to get the maximum allowed value. By default,\n     * returns getMaximumValue(instant). Override to provide a faster\n     * implementation.\n     */"}}
{"code": {"body": "public PreciseDurationField(DurationFieldType type, long unitMillis) {\n        super(type);\n        iUnitMillis = unitMillis;\n    }", "comment": "/**\n     * Constructor.\n     * \n     * @param type  the field type\n     * @param unitMillis  the unit milliseconds\n     */"}}
{"code": {"body": "    public final boolean isPrecise() {\n        return true;\n    }", "comment": "/**\n     * This field is precise.\n     * \n     * @return true always\n     */"}}
{"code": {"body": "    public final long getUnitMillis() {\n        return iUnitMillis;\n    }", "comment": "/**\n     * Returns the amount of milliseconds per unit value of this field.\n     *\n     * @return the unit size of this field, in milliseconds\n     */"}}
{"code": {"body": "    public long getValueAsLong(long duration, long instant) {\n        return duration / iUnitMillis;  \n    }", "comment": "/**\n     * Get the value of this field from the milliseconds.\n     * \n     * @param duration  the milliseconds to query, which may be negative\n     * @param instant  ignored\n     * @return the value of the field, in the units of the field, which may be\n     * negative\n     */"}}
{"code": {"body": "    public long getMillis(long value, long instant) {\n        return FieldUtils.safeMultiply(value, iUnitMillis);\n    }", "comment": "/**\n     * Get the millisecond duration of this field from its value.\n     * \n     * @param value  the value of the field, which may be negative\n     * @param instant  ignored\n     * @return the milliseconds that the field represents, which may be\n     * negative\n     */"}}
{"code": {"body": "    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        } else if (obj instanceof PreciseDurationField) {\n            PreciseDurationField other = (PreciseDurationField) obj;\n            return (getType() == other.getType()) && (iUnitMillis == other.iUnitMillis);\n        }\n        return false;\n    }", "comment": "/**\n     * Compares this duration field to another.\n     * Two fields are equal if of the same type and duration.\n     * \n     * @param obj  the object to compare to\n     * @return if equal\n     */"}}
{"code": {"body": "    public int hashCode() {\n        long millis = iUnitMillis;\n        int hash = (int) (millis ^ (millis >>> 32));\n        hash += getType().hashCode();\n        return hash;\n    }", "comment": "/**\n     * Gets a hash code for this instance.\n     * \n     * @return a suitable hashcode\n     */"}}
{"code": {"body": "public RemainderDateTimeField(DateTimeField field,", "comment": "/**\n     * Constructor.\n     * \n     * @param field  the field to wrap, like \"year()\".\n     * @param type  the field type this field actually uses\n     * @param divisor  divisor, such as 100 years in a century\n     * @throws IllegalArgumentException if divisor is less than two\n     */"}}
{"code": {"body": "public RemainderDateTimeField(DividedDateTimeField dividedField) {\n        this(dividedField, dividedField.getType());\n    }", "comment": "/**\n     * Construct a RemainderDateTimeField that compliments the given\n     * DividedDateTimeField.\n     *\n     * @param dividedField  complimentary divided field, like \"century()\".\n     */"}}
{"code": {"body": "public RemainderDateTimeField(DividedDateTimeField dividedField, DateTimeFieldType type) {\n        super(dividedField.getWrappedField(), type);\n        iDivisor = dividedField.iDivisor;\n        iRangeField = dividedField.iDurationField;\n    }", "comment": "/**\n     * Construct a RemainderDateTimeField that compliments the given\n     * DividedDateTimeField.\n     *\n     * @param dividedField  complimentary divided field, like \"century()\".\n     * @param type  the field type this field actually uses\n     */"}}
{"code": {"body": "    public int get(long instant) {\n        int value = getWrappedField().get(instant);\n        if (value >= 0) {\n            return value % iDivisor;\n        } else {\n            return (iDivisor - 1) + ((value + 1) % iDivisor);\n        }\n    }", "comment": "/**\n     * Get the remainder from the specified time instant.\n     * \n     * @param instant  the time instant in millis to query.\n     * @return the remainder extracted from the input.\n     */"}}
{"code": {"body": "    public long addWrapField(long instant, int amount) {\n        return set(instant, FieldUtils.getWrappedValue(get(instant), amount, 0, iDivisor - 1));\n    }", "comment": "/**\n     * Add the specified amount to the specified time instant, wrapping around\n     * within the remainder range if necessary. The amount added may be\n     * negative.\n     * \n     * @param instant  the time instant in millis to update.\n     * @param amount  the amount to add (can be negative).\n     * @return the updated time instant.\n     */"}}
{"code": {"body": "    public long set(long instant, int value) {\n        FieldUtils.verifyValueBounds(this, value, 0, iDivisor - 1);\n        int divided = getDivided(getWrappedField().get(instant));\n        return getWrappedField().set(instant, divided * iDivisor + value);\n    }", "comment": "/**\n     * Set the specified amount of remainder units to the specified time instant.\n     * \n     * @param instant  the time instant in millis to update.\n     * @param value  value of remainder units to set.\n     * @return the updated time instant.\n     * @throws IllegalArgumentException if value is too large or too small.\n     */"}}
{"code": {"body": "    public DurationField getRangeDurationField() {\n        return iRangeField;\n    }", "comment": "/**\n     * Returns a scaled version of the wrapped field's unit duration field.\n     */"}}
{"code": {"body": "    public int getMinimumValue() {\n        return 0;\n    }", "comment": "/**\n     * Get the minimum value for the field, which is always zero.\n     * \n     * @return the minimum value of zero.\n     */"}}
{"code": {"body": "    public int getMaximumValue() {\n        return iDivisor - 1;\n    }", "comment": "/**\n     * Get the maximum value for the field, which is always one less than the\n     * divisor.\n     * \n     * @return the maximum value\n     */"}}
{"code": {"body": "    public int getDivisor() {\n        return iDivisor;\n    }", "comment": "/**\n     * Returns the divisor applied, in the field's units.\n     * \n     * @return the divisor\n     */"}}
{"code": {"body": "public ScaledDurationField(DurationField field, DurationFieldType type, int scalar) {\n        super(field, type);\n        if (scalar == 0 || scalar == 1) {\n            throw new IllegalArgumentException(\"\");\n        }\n        iScalar = scalar;\n    }", "comment": "/**\n     * Constructor\n     * \n     * @param field  the field to wrap, like \"year()\".\n     * @param type  the type this field will actually use\n     * @param scalar  scalar, such as 100 years in a century\n     * @throws IllegalArgumentException if scalar is zero or one.\n     */"}}
{"code": {"body": "    public int getScalar() {\n        return iScalar;\n    }", "comment": "/**\n     * Returns the scalar applied, in the field's units.\n     * \n     * @return the scalar\n     */"}}
{"code": {"body": "    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        } else if (obj instanceof ScaledDurationField) {\n            ScaledDurationField other = (ScaledDurationField) obj;\n            return (getWrappedField().equals(other.getWrappedField())) &&\n                   (getType() == other.getType()) &&\n                   (iScalar == other.iScalar);\n        }\n        return false;\n    }", "comment": "/**\n     * Compares this duration field to another.\n     * Two fields are equal if of the same type and duration.\n     * \n     * @param obj  the object to compare to\n     * @return if equal\n     */"}}
{"code": {"body": "    public int hashCode() {\n        long scalar = iScalar;\n        int hash = (int) (scalar ^ (scalar >>> 32));\n        hash += getType().hashCode();\n        hash += getWrappedField().hashCode();\n        return hash;\n    }", "comment": "/**\n     * Gets a hash code for this instance.\n     * \n     * @return a suitable hashcode\n     */"}}
{"code": {"body": "public SkipDateTimeField(Chronology chronology, DateTimeField field) {\n        this(chronology, field, 0);\n    }", "comment": "/**\n     * Constructor that skips zero.\n     * \n     * @param chronology  the chronoogy to use\n     * @param field  the field to skip zero on\n     */"}}
{"code": {"body": "public SkipDateTimeField(Chronology chronology, DateTimeField field, int skip) {\n        super(field);\n        iChronology = chronology;\n        int min = super.getMinimumValue();\n        if (min < skip) {\n            iMinValue = min - 1;\n        } else if (min == skip) {\n            iMinValue = skip + 1;\n        } else {\n            iMinValue = min;\n        }\n        iSkip = skip;\n    }", "comment": "/**\n     * Constructor.\n     * \n     * @param chronology  the chronoogy to use\n     * @param field  the field to skip zero on\n     * @param skip  the value to skip\n     */"}}
{"code": {"body": "public SkipUndoDateTimeField(Chronology chronology, DateTimeField field) {\n        this(chronology, field, 0);\n    }", "comment": "/**\n     * Constructor that reinserts zero.\n     * \n     * @param chronology  the chronoogy to use\n     * @param field  the field to skip zero on\n     */"}}
{"code": {"body": "public SkipUndoDateTimeField(Chronology chronology, DateTimeField field, int skip) {\n        super(field);\n        iChronology = chronology;\n        int min = super.getMinimumValue();\n        if (min < skip) {\n            iMinValue = min + 1;\n        } else if (min == skip + 1) {\n            iMinValue = skip;\n        } else {\n            iMinValue = min;\n        }\n        iSkip = skip;\n    }", "comment": "/**\n     * Constructor.\n     * \n     * @param chronology  the chronoogy to use\n     * @param field  the field to skip zero on\n     * @param skip  the value to skip\n     */"}}
{"code": {"body": "    public static DateTimeField getInstance(DateTimeField field) {\n        if (field == null) {\n            return null;\n        }\n        if (field instanceof LenientDateTimeField) {\n            field = ((LenientDateTimeField)field).getWrappedField();\n        }\n        if (!field.isLenient()) {\n            return field;\n        }\n        return new StrictDateTimeField(field);\n    }", "comment": "/**\n     * Returns a strict version of the given field. If it is already strict,\n     * then it is returned as-is. Otherwise, a new StrictDateTimeField is\n     * returned.\n     */"}}
{"code": {"body": "    public long set(long instant, int value) {\n        FieldUtils.verifyValueBounds\n            (this, value, getMinimumValue(instant), getMaximumValue(instant));\n        return super.set(instant, value);\n    }", "comment": "/**\n     * Does a bounds check before setting the value.\n     *\n     * @throws IllegalArgumentException if the value is invalid\n     */"}}
{"code": {"body": "    public static synchronized UnsupportedDateTimeField getInstance(\n            DateTimeFieldType type, DurationField durationField) {\n\n        UnsupportedDateTimeField field;\n        if (cCache == null) {\n            cCache = new HashMap<DateTimeFieldType, UnsupportedDateTimeField>(7);\n            field = null;\n        } else {\n            field = cCache.get(type);\n            if (field != null && field.getDurationField() != durationField) {\n                field = null;\n            }\n        }\n        if (field == null) {\n            field = new UnsupportedDateTimeField(type, durationField);\n            cCache.put(type, field);\n        }\n        return field;\n    }", "comment": "/**\n     * Gets an instance of UnsupportedDateTimeField for a specific named field.\n     * Names should be of standard format, such as 'monthOfYear' or 'hourOfDay'.\n     * The returned instance is cached.\n     * \n     * @param type  the type to obtain\n     * @return the instance\n     * @throws IllegalArgumentException if durationField is null\n     */"}}
{"code": {"body": "    public boolean isSupported() {\n        return false;\n    }", "comment": "/**\n     * This field is not supported.\n     *\n     * @return false always\n     */"}}
{"code": {"body": "    public boolean isLenient() {\n        return false;\n    }", "comment": "/**\n     * This field is not lenient.\n     *\n     * @return false always\n     */"}}
{"code": {"body": "    public int get(long instant) {\n        throw unsupported();\n    }", "comment": "/**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */"}}
{"code": {"body": "    public String getAsText(int fieldValue, Locale locale) {\n        throw unsupported();\n    }", "comment": "/**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */"}}
{"code": {"body": "    public String getAsShortText(int fieldValue, Locale locale) {\n        throw unsupported();\n    }", "comment": "/**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */"}}
{"code": {"body": "    public int[] add(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {\n        throw unsupported();\n    }", "comment": "/**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */"}}
{"code": {"body": "    public int[] addWrapPartial(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {\n        throw unsupported();\n    }", "comment": "/**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */"}}
{"code": {"body": "    public int[] addWrapField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {\n        throw unsupported();\n    }", "comment": "/**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */"}}
{"code": {"body": "    public int getDifference(long minuendInstant, long subtrahendInstant) {\n        return getDurationField().getDifference(minuendInstant, subtrahendInstant);\n    }", "comment": "/**\n     * Delegates to the duration field.\n     *\n     * @throws UnsupportedOperationException if the duration is unsupported\n     */"}}
{"code": {"body": "    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n        return getDurationField().getDifferenceAsLong(minuendInstant, subtrahendInstant);\n    }", "comment": "/**\n     * Delegates to the duration field.\n     *\n     * @throws UnsupportedOperationException if the duration is unsupported\n     */"}}
{"code": {"body": "    public int[] set(ReadablePartial instant, int fieldIndex, int[] values, String text, Locale locale) {\n        throw unsupported();\n    }", "comment": "/**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */"}}
{"code": {"body": "    public DurationField getDurationField() {\n        return iDurationField;\n    }", "comment": "/**\n     * Even though this DateTimeField is unsupported, the duration field might\n     * be supported.\n     *\n     * @return a possibly supported DurationField\n     */"}}
{"code": {"body": "    public DurationField getRangeDurationField() {\n        return null;\n    }", "comment": "/**\n     * Always returns null.\n     *\n     * @return null always\n     */"}}
{"code": {"body": "    public boolean isLeap(long instant) {\n        throw unsupported();\n    }", "comment": "/**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */"}}
{"code": {"body": "    public int getLeapAmount(long instant) {\n        throw unsupported();\n    }", "comment": "/**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */"}}
{"code": {"body": "    public DurationField getLeapDurationField() {\n        return null;\n    }", "comment": "/**\n     * Always returns null.\n     *\n     * @return null always\n     */"}}
{"code": {"body": "    public int getMinimumValue(ReadablePartial instant, int[] values) {\n        throw unsupported();\n    }", "comment": "/**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */"}}
{"code": {"body": "    public int getMaximumValue(ReadablePartial instant, int[] values) {\n        throw unsupported();\n    }", "comment": "/**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */"}}
{"code": {"body": "    public int getMaximumTextLength(Locale locale) {\n        throw unsupported();\n    }", "comment": "/**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */"}}
{"code": {"body": "    public int getMaximumShortTextLength(Locale locale) {\n        throw unsupported();\n    }", "comment": "/**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */"}}
{"code": {"body": "    public long roundFloor(long instant) {\n        throw unsupported();\n    }", "comment": "/**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */"}}
{"code": {"body": "    public long roundCeiling(long instant) {\n        throw unsupported();\n    }", "comment": "/**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */"}}
{"code": {"body": "    public long roundHalfFloor(long instant) {\n        throw unsupported();\n    }", "comment": "/**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */"}}
{"code": {"body": "    public long roundHalfCeiling(long instant) {\n        throw unsupported();\n    }", "comment": "/**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */"}}
{"code": {"body": "    public long roundHalfEven(long instant) {\n        throw unsupported();\n    }", "comment": "/**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */"}}
{"code": {"body": "    public long remainder(long instant) {\n        throw unsupported();\n    }", "comment": "/**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */"}}
{"code": {"body": "    public String toString() {\n        return \"\";\n    }", "comment": "/**\n     * Get a suitable debug string.\n     * \n     * @return debug string\n     */"}}
{"code": {"body": "    private Object readResolve() {\n        return getInstance(iType, iDurationField);\n    }", "comment": "/**\n     * Ensure proper singleton serialization\n     */"}}
{"code": {"body": "    public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) {\n        UnsupportedDurationField field;\n        if (cCache == null) {\n            cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7);\n            field = null;\n        } else {\n            field = cCache.get(type);\n        }\n        if (field == null) {\n            field = new UnsupportedDurationField(type);\n            cCache.put(type, field);\n        }\n        return field;\n    }", "comment": "/**\n     * Gets an instance of UnsupportedDurationField for a specific named field.\n     * The returned instance is cached.\n     * \n     * @param type  the type to obtain\n     * @return the instance\n     */"}}
{"code": {"body": "    public boolean isSupported() {\n        return false;\n    }", "comment": "/**\n     * This field is not supported.\n     *\n     * @return false always\n     */"}}
{"code": {"body": "    public boolean isPrecise() {\n        return true;\n    }", "comment": "/**\n     * This field is precise.\n     * \n     * @return true always\n     */"}}
{"code": {"body": "    public int getValue(long duration, long instant) {\n        throw unsupported();\n    }", "comment": "/**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */"}}
{"code": {"body": "    public long getValueAsLong(long duration, long instant) {\n        throw unsupported();\n    }", "comment": "/**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */"}}
{"code": {"body": "    public long getMillis(long value, long instant) {\n        throw unsupported();\n    }", "comment": "/**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */"}}
{"code": {"body": "    public long add(long instant, long value) {\n        throw unsupported();\n    }", "comment": "/**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */"}}
{"code": {"body": "    public int getDifference(long minuendInstant, long subtrahendInstant) {\n        throw unsupported();\n    }", "comment": "/**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */"}}
{"code": {"body": "    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n        throw unsupported();\n    }", "comment": "/**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */"}}
{"code": {"body": "    public long getUnitMillis() {\n        return 0;\n    }", "comment": "/**\n     * Always returns zero.\n     *\n     * @return zero always\n     */"}}
{"code": {"body": "    public int compareTo(DurationField durationField) {\n        return 0;\n    }", "comment": "/**\n     * Always returns zero, indicating that sort order is not relevent.\n     *\n     * @return zero always\n     */"}}
{"code": {"body": "    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        } else if (obj instanceof UnsupportedDurationField) {\n            UnsupportedDurationField other = (UnsupportedDurationField) obj;\n            if (other.getName() == null) {\n                return (getName() == null);\n            }\n            return (other.getName().equals(getName()));\n        }\n        return false;\n    }", "comment": "/**\n     * Compares this duration field to another.\n     * \n     * @param obj  the object to compare to\n     * @return true if equal\n     */"}}
{"code": {"body": "    public int hashCode() {\n        return getName().hashCode();\n    }", "comment": "/**\n     * Gets a suitable hashcode.\n     * \n     * @return the hashcode\n     */"}}
{"code": {"body": "    public String toString() {\n        return \"\" + getName() + '';\n    }", "comment": "/**\n     * Get a suitable debug string.\n     * \n     * @return debug string\n     */"}}
{"code": {"body": "    private Object readResolve() {\n        return getInstance(iType);\n    }", "comment": "/**\n     * Ensure proper singleton serialization\n     */"}}
{"code": {"body": "public ZeroIsMaxDateTimeField(DateTimeField field, DateTimeFieldType type) {\n        super(field, type);\n        if (field.getMinimumValue() != 0) {\n            throw new IllegalArgumentException(\"\");\n        }\n    }", "comment": "/**\n     * Constructor.\n     * \n     * @param field  the base field\n     * @param type  the field type this field will actually use\n     * @throws IllegalArgumentException if wrapped field's minimum value is not zero\n     */"}}
{"code": {"body": "    public int getMinimumValue(ReadablePartial instant, int[] values) {\n        return 1;\n    }", "comment": "/**\n     * Always returns 1.\n     * \n     * @return the minimum value of 1\n     */"}}
{"code": {"body": "    public int getMaximumValue(ReadablePartial instant, int[] values) {\n        return getWrappedField().getMaximumValue(instant, values) + 1;\n    }", "comment": "/**\n     * Get the maximum value for the field, which is one more than the wrapped\n     * field's maximum value.\n     * \n     * @return the maximum value\n     */"}}
{"code": {"body": "    public static DateTimeFormatter forPattern(String pattern) {\n        return createFormatterForPattern(pattern);\n    }", "comment": "/**\n     * Factory to create a formatter from a pattern string.\n     * The pattern string is described above in the class level javadoc.\n     * It is very similar to SimpleDateFormat patterns.\n     * <p>\n     * The format may contain locale specific output, and this will change as\n     * you change the locale of the formatter.\n     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n     * For example:\n     * <pre>\n     * DateTimeFormat.forPattern(pattern).withLocale(Locale.FRANCE).print(dt);\n     * </pre>\n     *\n     * @param pattern  pattern specification\n     * @return the formatter\n     * @throws IllegalArgumentException if the pattern is invalid\n     */"}}
{"code": {"body": "    public static DateTimeFormatter forStyle(String style) {\n        return createFormatterForStyle(style);\n    }", "comment": "/**\n     * Factory to create a format from a two character style pattern.\n     * <p>\n     * The first character is the date style, and the second character is the\n     * time style. Specify a character of 'S' for short style, 'M' for medium,\n     * 'L' for long, and 'F' for full.\n     * A date or time may be ommitted by specifying a style character '-'.\n     * <p>\n     * The returned formatter will dynamically adjust to the locale that\n     * the print/parse takes place in. Thus you just call\n     * {@link DateTimeFormatter#withLocale(Locale)} and the Short/Medium/Long/Full\n     * style for that locale will be output. For example:\n     * <pre>\n     * DateTimeFormat.forStyle(style).withLocale(Locale.FRANCE).print(dt);\n     * </pre>\n     *\n     * @param style  two characters from the set {\"S\", \"M\", \"L\", \"F\", \"-\"}\n     * @return the formatter\n     * @throws IllegalArgumentException if the style is invalid\n     */"}}
{"code": {"body": "    public static String patternForStyle(String style, Locale locale) {\n        DateTimeFormatter formatter = createFormatterForStyle(style);\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        \n        return ((StyleFormatter) formatter.getPrinter()).getPattern(locale);\n    }", "comment": "/**\n     * Returns the pattern used by a particular style and locale.\n     * <p>\n     * The first character is the date style, and the second character is the\n     * time style. Specify a character of 'S' for short style, 'M' for medium,\n     * 'L' for long, and 'F' for full.\n     * A date or time may be ommitted by specifying a style character '-'.\n     *\n     * @param style  two characters from the set {\"S\", \"M\", \"L\", \"F\", \"-\"}\n     * @param locale  locale to use, null means default\n     * @return the formatter\n     * @throws IllegalArgumentException if the style is invalid\n     * @since 1.3\n     */"}}
{"code": {"body": "    public static DateTimeFormatter shortDate() {\n        return createFormatterForStyleIndex(SHORT, NONE);\n    }", "comment": "/**\n     * Creates a format that outputs a short date format.\n     * <p>\n     * The format will change as you change the locale of the formatter.\n     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n     * \n     * @return the formatter\n     */"}}
{"code": {"body": "    public static DateTimeFormatter shortTime() {\n        return createFormatterForStyleIndex(NONE, SHORT);\n    }", "comment": "/**\n     * Creates a format that outputs a short time format.\n     * <p>\n     * The format will change as you change the locale of the formatter.\n     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n     * \n     * @return the formatter\n     */"}}
{"code": {"body": "    public static DateTimeFormatter shortDateTime() {\n        return createFormatterForStyleIndex(SHORT, SHORT);\n    }", "comment": "/**\n     * Creates a format that outputs a short datetime format.\n     * <p>\n     * The format will change as you change the locale of the formatter.\n     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n     * \n     * @return the formatter\n     */"}}
{"code": {"body": "    public static DateTimeFormatter mediumDate() {\n        return createFormatterForStyleIndex(MEDIUM, NONE);\n    }", "comment": "/**\n     * Creates a format that outputs a medium date format.\n     * <p>\n     * The format will change as you change the locale of the formatter.\n     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n     * \n     * @return the formatter\n     */"}}
{"code": {"body": "    public static DateTimeFormatter mediumTime() {\n        return createFormatterForStyleIndex(NONE, MEDIUM);\n    }", "comment": "/**\n     * Creates a format that outputs a medium time format.\n     * <p>\n     * The format will change as you change the locale of the formatter.\n     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n     * \n     * @return the formatter\n     */"}}
{"code": {"body": "    public static DateTimeFormatter mediumDateTime() {\n        return createFormatterForStyleIndex(MEDIUM, MEDIUM);\n    }", "comment": "/**\n     * Creates a format that outputs a medium datetime format.\n     * <p>\n     * The format will change as you change the locale of the formatter.\n     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n     * \n     * @return the formatter\n     */"}}
{"code": {"body": "    public static DateTimeFormatter longDate() {\n        return createFormatterForStyleIndex(LONG, NONE);\n    }", "comment": "/**\n     * Creates a format that outputs a long date format.\n     * <p>\n     * The format will change as you change the locale of the formatter.\n     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n     * \n     * @return the formatter\n     */"}}
{"code": {"body": "    public static DateTimeFormatter longTime() {\n        return createFormatterForStyleIndex(NONE, LONG);\n    }", "comment": "/**\n     * Creates a format that outputs a long time format.\n     * <p>\n     * The format will change as you change the locale of the formatter.\n     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n     * \n     * @return the formatter\n     */"}}
{"code": {"body": "    public static DateTimeFormatter longDateTime() {\n        return createFormatterForStyleIndex(LONG, LONG);\n    }", "comment": "/**\n     * Creates a format that outputs a long datetime format.\n     * <p>\n     * The format will change as you change the locale of the formatter.\n     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n     * \n     * @return the formatter\n     */"}}
{"code": {"body": "    public static DateTimeFormatter fullDate() {\n        return createFormatterForStyleIndex(FULL, NONE);\n    }", "comment": "/**\n     * Creates a format that outputs a full date format.\n     * <p>\n     * The format will change as you change the locale of the formatter.\n     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n     * \n     * @return the formatter\n     */"}}
{"code": {"body": "    public static DateTimeFormatter fullTime() {\n        return createFormatterForStyleIndex(NONE, FULL);\n    }", "comment": "/**\n     * Creates a format that outputs a full time format.\n     * <p>\n     * The format will change as you change the locale of the formatter.\n     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n     * \n     * @return the formatter\n     */"}}
{"code": {"body": "    public static DateTimeFormatter fullDateTime() {\n        return createFormatterForStyleIndex(FULL, FULL);\n    }", "comment": "/**\n     * Creates a format that outputs a full datetime format.\n     * <p>\n     * The format will change as you change the locale of the formatter.\n     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n     * \n     * @return the formatter\n     */"}}
{"code": {"body": "    static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        parsePatternTo(builder, pattern);\n    }", "comment": "/**\n     * Parses the given pattern and appends the rules to the given\n     * DateTimeFormatterBuilder.\n     *\n     * @param pattern  pattern specification\n     * @throws IllegalArgumentException if the pattern is invalid\n     */"}}
{"code": {"body": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case '': \n                builder.appendEraText();\n                break;\n            case '': \n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case '': \n            case '': \n            case '': \n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    \n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            \n                            \n                            \n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    \n                    switch (c) {\n                    case '':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case '':\n                    case '':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    \n                    int maxDigits = 9;\n\n                    \n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            \n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case '':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case '':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case '':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case '': \n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case '': \n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case '': \n                builder.appendHalfdayOfDayText();\n                break;\n            case '': \n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case '': \n                builder.appendHourOfDay(tokenLen);\n                break;\n            case '': \n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case '': \n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case '': \n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case '': \n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case '': \n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case '': \n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case '': \n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case '': \n                builder.appendDayOfYear(tokenLen);\n                break;\n            case '': \n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case '': \n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case '': \n                if (tokenLen == 1) {\n                    builder.appendTimeZoneOffset(null, \"\", false, 2, 2);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '': \n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    \n                    \n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"\" + token);\n            }\n        }\n    }", "comment": "/**\n     * Parses the given pattern and appends the rules to the given\n     * DateTimeFormatterBuilder.\n     *\n     * @param pattern  pattern specification\n     * @throws IllegalArgumentException if the pattern is invalid\n     * @see #forPattern\n     */"}}
{"code": {"body": "    private static String parseToken(String pattern, int[] indexRef) {\n        StringBuilder buf = new StringBuilder();\n\n        int i = indexRef[0];\n        int length = pattern.length();\n\n        char c = pattern.charAt(i);\n        if (c >= '' && c <= '' || c >= '' && c <= '') {\n            \n            \n            buf.append(c);\n\n            while (i + 1 < length) {\n                char peek = pattern.charAt(i + 1);\n                if (peek == c) {\n                    buf.append(c);\n                    i++;\n                } else {\n                    break;\n                }\n            }\n        } else {\n            \n            buf.append('');\n\n            boolean inLiteral = false;\n\n            for (; i < length; i++) {\n                c = pattern.charAt(i);\n                \n                if (c == '') {\n                    if (i + 1 < length && pattern.charAt(i + 1) == '') {\n                        \n                        i++;\n                        buf.append(c);\n                    } else {\n                        inLiteral = !inLiteral;\n                    }\n                } else if (!inLiteral &&\n                           (c >= '' && c <= '' || c >= '' && c <= '')) {\n                    i--;\n                    break;\n                } else {\n                    buf.append(c);\n                }\n            }\n        }\n\n        indexRef[0] = i;\n        return buf.toString();\n    }", "comment": "/**\n     * Parses an individual token.\n     * \n     * @param pattern  the pattern string\n     * @param indexRef  a single element array, where the input is the start\n     *  location and the output is the location after parsing the token\n     * @return the parsed token\n     */"}}
{"code": {"body": "    private static boolean isNumericToken(String token) {\n        int tokenLen = token.length();\n        if (tokenLen > 0) {\n            char c = token.charAt(0);\n            switch (c) {\n            case '': \n            case '': \n            case '': \n            case '': \n            case '': \n            case '': \n            case '': \n            case '': \n            case '': \n            case '': \n            case '': \n            case '': \n            case '': \n            case '': \n            case '': \n            case '': \n            case '': \n            case '': \n                return true;\n            case '': \n                if (tokenLen <= 2) {\n                    return true;\n                }\n            }\n        }\n            \n        return false;\n    }", "comment": "/**\n     * Returns true if token should be parsed as a numeric field.\n     * \n     * @param token  the token to parse\n     * @return true if numeric field\n     */"}}
{"code": {"body": "    private static DateTimeFormatter createFormatterForPattern(String pattern) {\n        if (pattern == null || pattern.length() == 0) {\n            throw new IllegalArgumentException(\"\");\n        }\n        DateTimeFormatter formatter = null;\n        synchronized (PATTERN_CACHE) {\n            formatter = PATTERN_CACHE.get(pattern);\n            if (formatter == null) {\n                DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n                parsePatternTo(builder, pattern);\n                formatter = builder.toFormatter();\n\n                PATTERN_CACHE.put(pattern, formatter);\n            }\n        }\n        return formatter;\n    }", "comment": "/**\n     * Select a format from a custom pattern.\n     *\n     * @param pattern  pattern specification\n     * @throws IllegalArgumentException if the pattern is invalid\n     * @see #appendPatternTo\n     */"}}
{"code": {"body": "    private static DateTimeFormatter createFormatterForStyle(String style) {\n        if (style == null || style.length() != 2) {\n            throw new IllegalArgumentException(\"\" + style);\n        }\n        int dateStyle = selectStyle(style.charAt(0));\n        int timeStyle = selectStyle(style.charAt(1));\n        if (dateStyle == NONE && timeStyle == NONE) {\n            throw new IllegalArgumentException(\"\");\n        }\n        return createFormatterForStyleIndex(dateStyle, timeStyle);\n    }", "comment": "/**\n     * Select a format from a two character style pattern. The first character\n     * is the date style, and the second character is the time style. Specify a\n     * character of 'S' for short style, 'M' for medium, 'L' for long, and 'F'\n     * for full. A date or time may be ommitted by specifying a style character '-'.\n     *\n     * @param style  two characters from the set {\"S\", \"M\", \"L\", \"F\", \"-\"}\n     * @throws IllegalArgumentException if the style is invalid\n     */"}}
{"code": {"body": "    private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle) {\n        int index = ((dateStyle << 2) + dateStyle) + timeStyle;\n        \n        if (index >= STYLE_CACHE.length) {\n            return createDateTimeFormatter(dateStyle, timeStyle);\n        }\n        DateTimeFormatter f = null;\n        synchronized (STYLE_CACHE) {\n            f = STYLE_CACHE[index];\n            if (f == null) {\n                f = createDateTimeFormatter(dateStyle, timeStyle);\n                STYLE_CACHE[index] = f;\n            }\n        }\n        return f;\n    }", "comment": "/**\n     * Gets the formatter for the specified style.\n     * \n     * @param dateStyle  the date style\n     * @param timeStyle  the time style\n     * @return the formatter\n     */"}}
{"code": {"body": "    private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle){\n        int type = DATETIME;\n        if (dateStyle == NONE) {\n            type = TIME;\n        } else if (timeStyle == NONE) {\n            type = DATE;\n        }\n        StyleFormatter llf = new StyleFormatter(dateStyle, timeStyle, type);\n        return new DateTimeFormatter(llf, llf);\n    }", "comment": "/**\n     * Creates a formatter for the specified style.\n     * @param dateStyle  the date style\n     * @param timeStyle  the time style\n     * @return the formatter\n     */"}}
{"code": {"body": "    private static int selectStyle(char ch) {\n        switch (ch) {\n        case '':\n            return SHORT;\n        case '':\n            return MEDIUM;\n        case '':\n            return LONG;\n        case '':\n            return FULL;\n        case '':\n            return NONE;\n        default:\n            throw new IllegalArgumentException(\"\" + ch);\n        }\n    }", "comment": "/**\n     * Gets the JDK style code from the Joda code.\n     * \n     * @param ch  the Joda style code\n     * @return the JDK style code\n     */"}}
{"code": {"body": "public DateTimeFormatter(", "comment": "/**\n     * Creates a new formatter, however you will normally use the factory\n     * or the builder.\n     * \n     * @param printer  the internal printer, null if cannot print\n     * @param parser  the internal parser, null if cannot parse\n     */"}}
{"code": {"body": "public DateTimeFormatter withLocale(Locale locale) {\n        if (locale == getLocale() || (locale != null && locale.equals(getLocale()))) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, locale,\n                iOffsetParsed, iChrono, iZone, iPivotYear, iDefaultYear);\n    }", "comment": "/**\n     * Returns a new formatter with a different locale that will be used\n     * for printing and parsing.\n     * <p>\n     * A DateTimeFormatter is immutable, so a new instance is returned,\n     * and the original is unaltered and still usable.\n     * \n     * @param locale the locale to use; if null, formatter uses default locale\n     * at invocation time\n     * @return the new formatter\n     */"}}
{"code": {"body": "public DateTimeFormatter withOffsetParsed() {\n        if (iOffsetParsed == true) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                true, iChrono, null, iPivotYear, iDefaultYear);\n    }", "comment": "/**\n     * Returns a new formatter that will create a datetime with a time zone\n     * equal to that of the offset of the parsed string.\n     * <p>\n     * After calling this method, a string '2004-06-09T10:20:30-08:00' will\n     * create a datetime with a zone of -08:00 (a fixed zone, with no daylight\n     * savings rules). If the parsed string represents a local time (no zone\n     * offset) the parsed datetime will be in the default zone.\n     * <p>\n     * Calling this method sets the override zone to null.\n     * Calling the override zone method sets this flag off.\n     * \n     * @return the new formatter\n     */"}}
{"code": {"body": "public DateTimeFormatter withChronology(Chronology chrono) {\n        if (iChrono == chrono) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                iOffsetParsed, chrono, iZone, iPivotYear, iDefaultYear);\n    }", "comment": "/**\n     * Returns a new formatter that will use the specified chronology in\n     * preference to that of the printed object, or ISO on a parse.\n     * <p>\n     * When printing, this chronolgy will be used in preference to the chronology\n     * from the datetime that would otherwise be used.\n     * <p>\n     * When parsing, this chronology will be set on the parsed datetime.\n     * <p>\n     * A null chronology means no-override.\n     * If both an override chronology and an override zone are set, the\n     * override zone will take precedence over the zone in the chronology.\n     * \n     * @param chrono  the chronology to use as an override\n     * @return the new formatter\n     */"}}
{"code": {"body": "public DateTimeFormatter withZoneUTC() {\n        return withZone(DateTimeZone.UTC);\n    }", "comment": "/**\n     * Returns a new formatter that will use the UTC zone in preference\n     * to the zone of the printed object, or default zone on a parse.\n     * <p>\n     * When printing, UTC will be used in preference to the zone\n     * from the datetime that would otherwise be used.\n     * <p>\n     * When parsing, UTC will be set on the parsed datetime.\n     * <p>\n     * If both an override chronology and an override zone are set, the\n     * override zone will take precedence over the zone in the chronology.\n     * \n     * @return the new formatter, never null\n     * @since 2.0\n     */"}}
{"code": {"body": "public DateTimeFormatter withZone(DateTimeZone zone) {\n        if (iZone == zone) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                false, iChrono, zone, iPivotYear, iDefaultYear);\n    }", "comment": "/**\n     * Returns a new formatter that will use the specified zone in preference\n     * to the zone of the printed object, or default zone on a parse.\n     * <p>\n     * When printing, this zone will be used in preference to the zone\n     * from the datetime that would otherwise be used.\n     * <p>\n     * When parsing, this zone will be set on the parsed datetime.\n     * <p>\n     * A null zone means of no-override.\n     * If both an override chronology and an override zone are set, the\n     * override zone will take precedence over the zone in the chronology.\n     * \n     * @param zone  the zone to use as an override\n     * @return the new formatter\n     */"}}
{"code": {"body": "public DateTimeFormatter withPivotYear(Integer pivotYear) {\n        if (iPivotYear == pivotYear || (iPivotYear != null && iPivotYear.equals(pivotYear))) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                iOffsetParsed, iChrono, iZone, pivotYear, iDefaultYear);\n    }", "comment": "/**\n     * Returns a new formatter that will use the specified pivot year for two\n     * digit year parsing in preference to that stored in the parser.\n     * <p>\n     * This setting is useful for changing the pivot year of formats built\n     * using a pattern - {@link DateTimeFormat#forPattern(String)}.\n     * <p>\n     * When parsing, this pivot year is used. Null means no-override.\n     * There is no effect when printing.\n     * <p>\n     * The pivot year enables a two digit year to be converted to a four\n     * digit year. The pivot represents the year in the middle of the\n     * supported range of years. Thus the full range of years that will\n     * be built is <code>(pivot - 50) .. (pivot + 49)</code>.\n     *\n     * <pre>\n     * pivot   supported range   00 is   20 is   40 is   60 is   80 is\n     * ---------------------------------------------------------------\n     * 1950      1900..1999      1900    1920    1940    1960    1980\n     * 1975      1925..2024      2000    2020    1940    1960    1980\n     * 2000      1950..2049      2000    2020    2040    1960    1980\n     * 2025      1975..2074      2000    2020    2040    2060    1980\n     * 2050      2000..2099      2000    2020    2040    2060    2080\n     * </pre>\n     *\n     * @param pivotYear  the pivot year to use as an override when parsing\n     * @return the new formatter\n     * @since 1.1\n     */"}}
{"code": {"body": "public DateTimeFormatter withPivotYear(int pivotYear) {\n        return withPivotYear(Integer.valueOf(pivotYear));\n    }", "comment": "/**\n     * Returns a new formatter that will use the specified pivot year for two\n     * digit year parsing in preference to that stored in the parser.\n     * <p>\n     * This setting is useful for changing the pivot year of formats built\n     * using a pattern - {@link DateTimeFormat#forPattern(String)}.\n     * <p>\n     * When parsing, this pivot year is used.\n     * There is no effect when printing.\n     * <p>\n     * The pivot year enables a two digit year to be converted to a four\n     * digit year. The pivot represents the year in the middle of the\n     * supported range of years. Thus the full range of years that will\n     * be built is <code>(pivot - 50) .. (pivot + 49)</code>.\n     *\n     * <pre>\n     * pivot   supported range   00 is   20 is   40 is   60 is   80 is\n     * ---------------------------------------------------------------\n     * 1950      1900..1999      1900    1920    1940    1960    1980\n     * 1975      1925..2024      2000    2020    1940    1960    1980\n     * 2000      1950..2049      2000    2020    2040    1960    1980\n     * 2025      1975..2074      2000    2020    2040    2060    1980\n     * 2050      2000..2099      2000    2020    2040    2060    2080\n     * </pre>\n     *\n     * @param pivotYear  the pivot year to use as an override when parsing\n     * @return the new formatter\n     * @since 1.1\n     */"}}
{"code": {"body": "public DateTimeFormatter withDefaultYear(int defaultYear) {\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                iOffsetParsed, iChrono, iZone, iPivotYear, defaultYear);\n    }", "comment": "/**\n     * Returns a new formatter that will use the specified default year.\n     * <p>\n     * The default year is used when parsing in the case where there is a\n     * month or a day but not a year. Specifically, it is used if there is\n     * a field parsed with a duration between the length of a month and the\n     * length of a day inclusive.\n     * <p>\n     * This value is typically used to move the year from 1970 to a leap year\n     * to enable February 29th to be parsed.\n     * Unless customised, the year 2000 is used.\n     * <p>\n     * This setting has no effect when printing.\n     *\n     * @param defaultYear  the default year to use\n     * @return the new formatter, not null\n     * @since 2.0\n     */"}}
{"code": {"body": "    public boolean isPrinter() {\n        return (iPrinter != null);\n    }", "comment": "/**\n     * Is this formatter capable of printing.\n     * \n     * @return true if this is a printer\n     */"}}
{"code": {"body": "    public DateTimePrinter getPrinter() {\n        return iPrinter;\n    }", "comment": "/**\n     * Gets the internal printer object that performs the real printing work.\n     * \n     * @return the internal printer; is null if printing not supported\n     */"}}
{"code": {"body": "    public boolean isParser() {\n        return (iParser != null);\n    }", "comment": "/**\n     * Is this formatter capable of parsing.\n     * \n     * @return true if this is a parser\n     */"}}
{"code": {"body": "    public DateTimeParser getParser() {\n        return iParser;\n    }", "comment": "/**\n     * Gets the internal parser object that performs the real parsing work.\n     * \n     * @return the internal parser; is null if parsing not supported\n     */"}}
{"code": {"body": "    public DateTimeFormatter withLocale(Locale locale) {\n        if (locale == getLocale() || (locale != null && locale.equals(getLocale()))) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, locale,\n                iOffsetParsed, iChrono, iZone, iPivotYear, iDefaultYear);\n    }", "comment": "/**\n     * Returns a new formatter with a different locale that will be used\n     * for printing and parsing.\n     * <p>\n     * A DateTimeFormatter is immutable, so a new instance is returned,\n     * and the original is unaltered and still usable.\n     * \n     * @param locale the locale to use; if null, formatter uses default locale\n     * at invocation time\n     * @return the new formatter\n     */"}}
{"code": {"body": "    public Locale getLocale() {\n        return iLocale;\n    }", "comment": "/**\n     * Gets the locale that will be used for printing and parsing.\n     * \n     * @return the locale to use; if null, formatter uses default locale at\n     * invocation time\n     */"}}
{"code": {"body": "    public DateTimeFormatter withOffsetParsed() {\n        if (iOffsetParsed == true) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                true, iChrono, null, iPivotYear, iDefaultYear);\n    }", "comment": "/**\n     * Returns a new formatter that will create a datetime with a time zone\n     * equal to that of the offset of the parsed string.\n     * <p>\n     * After calling this method, a string '2004-06-09T10:20:30-08:00' will\n     * create a datetime with a zone of -08:00 (a fixed zone, with no daylight\n     * savings rules). If the parsed string represents a local time (no zone\n     * offset) the parsed datetime will be in the default zone.\n     * <p>\n     * Calling this method sets the override zone to null.\n     * Calling the override zone method sets this flag off.\n     * \n     * @return the new formatter\n     */"}}
{"code": {"body": "    public boolean isOffsetParsed() {\n        return iOffsetParsed;\n    }", "comment": "/**\n     * Checks whether the offset from the string is used as the zone of\n     * the parsed datetime.\n     * \n     * @return true if the offset from the string is used as the zone\n     */"}}
{"code": {"body": "    public DateTimeFormatter withChronology(Chronology chrono) {\n        if (iChrono == chrono) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                iOffsetParsed, chrono, iZone, iPivotYear, iDefaultYear);\n    }", "comment": "/**\n     * Returns a new formatter that will use the specified chronology in\n     * preference to that of the printed object, or ISO on a parse.\n     * <p>\n     * When printing, this chronolgy will be used in preference to the chronology\n     * from the datetime that would otherwise be used.\n     * <p>\n     * When parsing, this chronology will be set on the parsed datetime.\n     * <p>\n     * A null chronology means no-override.\n     * If both an override chronology and an override zone are set, the\n     * override zone will take precedence over the zone in the chronology.\n     * \n     * @param chrono  the chronology to use as an override\n     * @return the new formatter\n     */"}}
{"code": {"body": "    public Chronology getChronology() {\n        return iChrono;\n    }", "comment": "/**\n     * Gets the chronology to use as an override.\n     * \n     * @return the chronology to use as an override\n     */"}}
{"code": {"body": "    public DateTimeFormatter withZoneUTC() {\n        return withZone(DateTimeZone.UTC);\n    }", "comment": "/**\n     * Returns a new formatter that will use the UTC zone in preference\n     * to the zone of the printed object, or default zone on a parse.\n     * <p>\n     * When printing, UTC will be used in preference to the zone\n     * from the datetime that would otherwise be used.\n     * <p>\n     * When parsing, UTC will be set on the parsed datetime.\n     * <p>\n     * If both an override chronology and an override zone are set, the\n     * override zone will take precedence over the zone in the chronology.\n     * \n     * @return the new formatter, never null\n     * @since 2.0\n     */"}}
{"code": {"body": "    public DateTimeFormatter withZone(DateTimeZone zone) {\n        if (iZone == zone) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                false, iChrono, zone, iPivotYear, iDefaultYear);\n    }", "comment": "/**\n     * Returns a new formatter that will use the specified zone in preference\n     * to the zone of the printed object, or default zone on a parse.\n     * <p>\n     * When printing, this zone will be used in preference to the zone\n     * from the datetime that would otherwise be used.\n     * <p>\n     * When parsing, this zone will be set on the parsed datetime.\n     * <p>\n     * A null zone means of no-override.\n     * If both an override chronology and an override zone are set, the\n     * override zone will take precedence over the zone in the chronology.\n     * \n     * @param zone  the zone to use as an override\n     * @return the new formatter\n     */"}}
{"code": {"body": "    public DateTimeZone getZone() {\n        return iZone;\n    }", "comment": "/**\n     * Gets the zone to use as an override.\n     * \n     * @return the zone to use as an override\n     */"}}
{"code": {"body": "    public DateTimeFormatter withPivotYear(int pivotYear) {\n        return withPivotYear(Integer.valueOf(pivotYear));\n    }", "comment": "/**\n     * Returns a new formatter that will use the specified pivot year for two\n     * digit year parsing in preference to that stored in the parser.\n     * <p>\n     * This setting is useful for changing the pivot year of formats built\n     * using a pattern - {@link DateTimeFormat#forPattern(String)}.\n     * <p>\n     * When parsing, this pivot year is used.\n     * There is no effect when printing.\n     * <p>\n     * The pivot year enables a two digit year to be converted to a four\n     * digit year. The pivot represents the year in the middle of the\n     * supported range of years. Thus the full range of years that will\n     * be built is <code>(pivot - 50) .. (pivot + 49)</code>.\n     *\n     * <pre>\n     * pivot   supported range   00 is   20 is   40 is   60 is   80 is\n     * ---------------------------------------------------------------\n     * 1950      1900..1999      1900    1920    1940    1960    1980\n     * 1975      1925..2024      2000    2020    1940    1960    1980\n     * 2000      1950..2049      2000    2020    2040    1960    1980\n     * 2025      1975..2074      2000    2020    2040    2060    1980\n     * 2050      2000..2099      2000    2020    2040    2060    2080\n     * </pre>\n     *\n     * @param pivotYear  the pivot year to use as an override when parsing\n     * @return the new formatter\n     * @since 1.1\n     */"}}
{"code": {"body": "    public Integer getPivotYear() {\n      return iPivotYear;\n    }", "comment": "/**\n     * Gets the pivot year to use as an override.\n     *\n     * @return the pivot year to use as an override\n     * @since 1.1\n     */"}}
{"code": {"body": "    public DateTimeFormatter withDefaultYear(int defaultYear) {\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                iOffsetParsed, iChrono, iZone, iPivotYear, defaultYear);\n    }", "comment": "/**\n     * Returns a new formatter that will use the specified default year.\n     * <p>\n     * The default year is used when parsing in the case where there is a\n     * month or a day but not a year. Specifically, it is used if there is\n     * a field parsed with a duration between the length of a month and the\n     * length of a day inclusive.\n     * <p>\n     * This value is typically used to move the year from 1970 to a leap year\n     * to enable February 29th to be parsed.\n     * Unless customised, the year 2000 is used.\n     * <p>\n     * This setting has no effect when printing.\n     *\n     * @param defaultYear  the default year to use\n     * @return the new formatter, not null\n     * @since 2.0\n     */"}}
{"code": {"body": "    public int getDefaultYear() {\n      return iDefaultYear;\n    }", "comment": "/**\n     * Gets the default year for parsing months and days.\n     *\n     * @return the default year for parsing months and days\n     * @since 2.0\n     */"}}
{"code": {"body": "    public String print(ReadablePartial partial) {\n        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\n        printTo(buf, partial);\n        return buf.toString();\n    }", "comment": "/**\n     * Prints a ReadablePartial to a new String.\n     * <p>\n     * Neither the override chronology nor the override zone are used\n     * by this method.\n     *\n     * @param partial  partial to format\n     * @return the printed result\n     */"}}
{"code": {"body": "    private DateTimePrinter requirePrinter() {\n        DateTimePrinter printer = iPrinter;\n        if (printer == null) {\n            throw new UnsupportedOperationException(\"\");\n        }\n        return printer;\n    }", "comment": "/**\n     * Checks whether printing is supported.\n     * \n     * @throws UnsupportedOperationException if printing is not supported\n     */"}}
{"code": {"body": "    public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        \n        long instantMillis = instant.getMillis();\n        Chronology chrono = instant.getChronology();\n        int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);\n        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n        chrono = selectChronology(chrono);\n        \n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n        int newPos = parser.parseInto(bucket, text, position);\n        instant.setMillis(bucket.computeMillis(false, text));\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            int parsedOffset = bucket.getOffsetInteger();\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n            chrono = chrono.withZone(parsedZone);\n        } else if (bucket.getZone() != null) {\n            chrono = chrono.withZone(bucket.getZone());\n        }\n        instant.setChronology(chrono);\n        if (iZone != null) {\n            instant.setZone(iZone);\n        }\n        return newPos;\n    }", "comment": "/**\n     * Parses a datetime from the given text, at the given position, saving the\n     * result into the fields of the given ReadWritableInstant. If the parse\n     * succeeds, the return value is the new text position. Note that the parse\n     * may succeed without fully reading the text and in this case those fields\n     * that were read will be set.\n     * <p>\n     * Only those fields present in the string will be changed in the specified\n     * instant. All other fields will remain unaltered. Thus if the string only\n     * contains a year and a month, then the day and time will be retained from\n     * the input instant. If this is not the behaviour you want, then reset the\n     * fields before calling this method, or use {@link #parseDateTime(String)}\n     * or {@link #parseMutableDateTime(String)}.\n     * <p>\n     * If it fails, the return value is negative, but the instant may still be\n     * modified. To determine the position where the parse failed, apply the\n     * one's complement operator (~) on the return value.\n     * <p>\n     * This parse method ignores the {@link #getDefaultYear() default year} and\n     * parses using the year from the supplied instant based on the chronology\n     * and time-zone of the supplied instant.\n     * <p>\n     * The parse will use the chronology of the instant.\n     *\n     * @param instant  an instant that will be modified, not null\n     * @param text  the text to parse\n     * @param position  position to start parsing from\n     * @return new position, negative value means parse failed -\n     *  apply complement operator (~) to get position of failure\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the instant is null\n     * @throws IllegalArgumentException if any field is out of range\n     */"}}
{"code": {"body": "    public long parseMillis(String text) {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(iChrono);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                return bucket.computeMillis(true, text);\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }", "comment": "/**\n     * Parses a datetime from the given text, returning the number of\n     * milliseconds since the epoch, 1970-01-01T00:00:00Z.\n     * <p>\n     * The parse will use the ISO chronology, and the default time zone.\n     * If the text contains a time zone string then that will be taken into account.\n     *\n     * @param text  text to parse\n     * @return parsed value expressed in milliseconds since the epoch\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     */"}}
{"code": {"body": "    public LocalDate parseLocalDate(String text) {\n        return parseLocalDateTime(text).toLocalDate();\n    }", "comment": "/**\n     * Parses only the local date from the given text, returning a new LocalDate.\n     * <p>\n     * This will parse the text fully according to the formatter, using the UTC zone.\n     * Once parsed, only the local date will be used.\n     * This means that any parsed time, time-zone or offset field is completely ignored.\n     * It also means that the zone and offset-parsed settings are ignored.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed date, never null\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     * @since 2.0\n     */"}}
{"code": {"body": "    public LocalTime parseLocalTime(String text) {\n        return parseLocalDateTime(text).toLocalTime();\n    }", "comment": "/**\n     * Parses only the local time from the given text, returning a new LocalTime.\n     * <p>\n     * This will parse the text fully according to the formatter, using the UTC zone.\n     * Once parsed, only the local time will be used.\n     * This means that any parsed date, time-zone or offset field is completely ignored.\n     * It also means that the zone and offset-parsed settings are ignored.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed time, never null\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     * @since 2.0\n     */"}}
{"code": {"body": "    public LocalDateTime parseLocalDateTime(String text) {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(null).withUTC();  \n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (bucket.getOffsetInteger() != null) {  \n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                return new LocalDateTime(millis, chrono);\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }", "comment": "/**\n     * Parses only the local date-time from the given text, returning a new LocalDateTime.\n     * <p>\n     * This will parse the text fully according to the formatter, using the UTC zone.\n     * Once parsed, only the local date-time will be used.\n     * This means that any parsed time-zone or offset field is completely ignored.\n     * It also means that the zone and offset-parsed settings are ignored.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed date-time, never null\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     * @since 2.0\n     */"}}
{"code": {"body": "    public DateTime parseDateTime(String text) {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(null);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                DateTime dt = new DateTime(millis, chrono);\n                if (iZone != null) {\n                    dt = dt.withZone(iZone);\n                }\n                return dt;\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }", "comment": "/**\n     * Parses a date-time from the given text, returning a new DateTime.\n     * <p>\n     * The parse will use the zone and chronology specified on this formatter.\n     * <p>\n     * If the text contains a time zone string then that will be taken into\n     * account in adjusting the time of day as follows.\n     * If the {@link #withOffsetParsed()} has been called, then the resulting\n     * DateTime will have a fixed offset based on the parsed time zone.\n     * Otherwise the resulting DateTime will have the zone of this formatter,\n     * but the parsed zone may have caused the time to be adjusted.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed date-time, never null\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     */"}}
{"code": {"body": "    public MutableDateTime parseMutableDateTime(String text) {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(null);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                MutableDateTime dt = new MutableDateTime(millis, chrono);\n                if (iZone != null) {\n                    dt.setZone(iZone);\n                }\n                return dt;\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }", "comment": "/**\n     * Parses a date-time from the given text, returning a new MutableDateTime.\n     * <p>\n     * The parse will use the zone and chronology specified on this formatter.\n     * <p>\n     * If the text contains a time zone string then that will be taken into\n     * account in adjusting the time of day as follows.\n     * If the {@link #withOffsetParsed()} has been called, then the resulting\n     * DateTime will have a fixed offset based on the parsed time zone.\n     * Otherwise the resulting DateTime will have the zone of this formatter,\n     * but the parsed zone may have caused the time to be adjusted.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed date-time, never null\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     */"}}
{"code": {"body": "    private DateTimeParser requireParser() {\n        DateTimeParser parser = iParser;\n        if (parser == null) {\n            throw new UnsupportedOperationException(\"\");\n        }\n        return parser;\n    }", "comment": "/**\n     * Checks whether parsing is supported.\n     * \n     * @throws UnsupportedOperationException if parsing is not supported\n     */"}}
{"code": {"body": "    private Chronology selectChronology(Chronology chrono) {\n        chrono = DateTimeUtils.getChronology(chrono);\n        if (iChrono != null) {\n            chrono = iChrono;\n        }\n        if (iZone != null) {\n            chrono = chrono.withZone(iZone);\n        }\n        return chrono;\n    }", "comment": "/**\n     * Determines the correct chronology to use.\n     *\n     * @param chrono  the proposed chronology\n     * @return the actual chronology\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder() {\n        super();\n        iElementPairs = new ArrayList<Object>();\n    }", "comment": "/**\n     * Creates a DateTimeFormatterBuilder.\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder append(DateTimeFormatter formatter) {\n        if (formatter == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        return append0(formatter.getPrinter(), formatter.getParser());\n    }", "comment": "/**\n     * Appends another formatter.\n     * <p>\n     * This extracts the underlying printer and parser and appends them\n     * The printer and parser interfaces are the low-level part of the formatting API.\n     * Normally, instances are extracted from another formatter.\n     * Note however that any formatter specific information, such as the locale,\n     * time-zone, chronology, offset parsing or pivot/default year, will not be\n     * extracted by this method.\n     *\n     * @param formatter  the formatter to add\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if formatter is null or of an invalid type\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder append(DateTimePrinter printer) {\n        checkPrinter(printer);\n        return append0(printer, null);\n    }", "comment": "/**\n     * Appends just a printer. With no matching parser, a parser cannot be\n     * built from this DateTimeFormatterBuilder.\n     * <p>\n     * The printer interface is part of the low-level part of the formatting API.\n     * Normally, instances are extracted from another formatter.\n     * Note however that any formatter specific information, such as the locale,\n     * time-zone, chronology, offset parsing or pivot/default year, will not be\n     * extracted by this method.\n     *\n     * @param printer  the printer to add, not null\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if printer is null or of an invalid type\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder append(DateTimeParser parser) {\n        checkParser(parser);\n        return append0(null, parser);\n    }", "comment": "/**\n     * Appends just a parser. With no matching printer, a printer cannot be\n     * built from this builder.\n     * <p>\n     * The parser interface is part of the low-level part of the formatting API.\n     * Normally, instances are extracted from another formatter.\n     * Note however that any formatter specific information, such as the locale,\n     * time-zone, chronology, offset parsing or pivot/default year, will not be\n     * extracted by this method.\n     *\n     * @param parser  the parser to add, not null\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if parser is null or of an invalid type\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser parser) {\n        checkPrinter(printer);\n        checkParser(parser);\n        return append0(printer, parser);\n    }", "comment": "/**\n     * Appends a printer/parser pair.\n     * <p>\n     * The printer and parser interfaces are the low-level part of the formatting API.\n     * Normally, instances are extracted from another formatter.\n     * Note however that any formatter specific information, such as the locale,\n     * time-zone, chronology, offset parsing or pivot/default year, will not be\n     * extracted by this method.\n     *\n     * @param printer  the printer to add, not null\n     * @param parser  the parser to add, not null\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if printer or parser is null or of an invalid type\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser[] parsers) {\n        if (printer != null) {\n            checkPrinter(printer);\n        }\n        if (parsers == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        int length = parsers.length;\n        if (length == 1) {\n            if (parsers[0] == null) {\n                throw new IllegalArgumentException(\"\");\n            }\n            return append0(printer, parsers[0]);\n        }\n\n        DateTimeParser[] copyOfParsers = new DateTimeParser[length];\n        int i;\n        for (i = 0; i < length - 1; i++) {\n            if ((copyOfParsers[i] = parsers[i]) == null) {\n                throw new IllegalArgumentException(\"\");\n            }\n        }\n        copyOfParsers[i] = parsers[i];\n\n        return append0(printer, new MatchingParser(copyOfParsers));\n    }", "comment": "/**\n     * Appends a printer and a set of matching parsers. When parsing, the first\n     * parser in the list is selected for parsing. If it fails, the next is\n     * chosen, and so on. If none of these parsers succeeds, then the failed\n     * position of the parser that made the greatest progress is returned.\n     * <p>\n     * Only the printer is optional. In addition, it is illegal for any but the\n     * last of the parser array elements to be null. If the last element is\n     * null, this represents the empty parser. The presence of an empty parser\n     * indicates that the entire array of parse formats is optional.\n     * <p>\n     * The printer and parser interfaces are the low-level part of the formatting API.\n     * Normally, instances are extracted from another formatter.\n     * Note however that any formatter specific information, such as the locale,\n     * time-zone, chronology, offset parsing or pivot/default year, will not be\n     * extracted by this method.\n     *\n     * @param printer  the printer to add\n     * @param parsers  the parsers to add\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if any printer or parser is of an invalid type\n     * @throws IllegalArgumentException if any parser element but the last is null\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendOptional(DateTimeParser parser) {\n        checkParser(parser);\n        DateTimeParser[] parsers = new DateTimeParser[] {parser, null};\n        return append0(null, new MatchingParser(parsers));\n    }", "comment": "/**\n     * Appends just a parser element which is optional. With no matching\n     * printer, a printer cannot be built from this DateTimeFormatterBuilder.\n     * <p>\n     * The parser interface is part of the low-level part of the formatting API.\n     * Normally, instances are extracted from another formatter.\n     * Note however that any formatter specific information, such as the locale,\n     * time-zone, chronology, offset parsing or pivot/default year, will not be\n     * extracted by this method.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if parser is null or of an invalid type\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendLiteral(char c) {\n        return append0(new CharacterLiteral(c));\n    }", "comment": "/**\n     * Instructs the printer to emit a specific character, and the parser to\n     * expect it. The parser is case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendLiteral(String text) {\n        if (text == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        switch (text.length()) {\n            case 0:\n                return this;\n            case 1:\n                return append0(new CharacterLiteral(text.charAt(0)));\n            default:\n                return append0(new StringLiteral(text));\n        }\n    }", "comment": "/**\n     * Instructs the printer to emit specific text, and the parser to expect\n     * it. The parser is case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if text is null\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendDecimal(", "comment": "/**\n     * Instructs the printer to emit a field value as a decimal number, and the\n     * parser to expect an unsigned decimal number.\n     *\n     * @param fieldType  type of field to append\n     * @param minDigits  minimum number of digits to <i>print</i>\n     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n     * maximum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendFixedDecimal(", "comment": "/**\n     * Instructs the printer to emit a field value as a fixed-width decimal\n     * number (smaller numbers will be left-padded with zeros), and the parser\n     * to expect an unsigned decimal number with the same fixed width.\n     * \n     * @param fieldType  type of field to append\n     * @param numDigits  the exact number of digits to parse or print, except if\n     * printed value requires more digits\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null or if <code>numDigits <= 0</code>\n     * @since 1.5\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendSignedDecimal(", "comment": "/**\n     * Instructs the printer to emit a field value as a decimal number, and the\n     * parser to expect a signed decimal number.\n     *\n     * @param fieldType  type of field to append\n     * @param minDigits  minimum number of digits to <i>print</i>\n     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n     * maximum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendFixedSignedDecimal(", "comment": "/**\n     * Instructs the printer to emit a field value as a fixed-width decimal\n     * number (smaller numbers will be left-padded with zeros), and the parser\n     * to expect an signed decimal number with the same fixed width.\n     * \n     * @param fieldType  type of field to append\n     * @param numDigits  the exact number of digits to parse or print, except if\n     * printed value requires more digits\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null or if <code>numDigits <= 0</code>\n     * @since 1.5\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendText(DateTimeFieldType fieldType) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        return append0(new TextField(fieldType, false));\n    }", "comment": "/**\n     * Instructs the printer to emit a field value as text, and the\n     * parser to expect text.\n     *\n     * @param fieldType  type of field to append\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        return append0(new TextField(fieldType, true));\n    }", "comment": "/**\n     * Instructs the printer to emit a field value as short text, and the\n     * parser to expect text.\n     *\n     * @param fieldType  type of field to append\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendFraction(", "comment": "/**\n     * Instructs the printer to emit a remainder of time as a decimal fraction,\n     * without decimal point. For example, if the field is specified as\n     * minuteOfHour and the time is 12:30:45, the value printed is 75. A\n     * decimal point is implied, so the fraction is 0.75, or three-quarters of\n     * a minute.\n     *\n     * @param fieldType  type of field to append\n     * @param minDigits  minimum number of digits to print.\n     * @param maxDigits  maximum number of digits to print or parse.\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendFractionOfSecond(int minDigits, int maxDigits) {\n        return appendFraction(DateTimeFieldType.secondOfDay(), minDigits, maxDigits);\n    }", "comment": "/**\n     * Appends the print/parse of a fractional second.\n     * <p>\n     * This reliably handles the case where fractional digits are being handled\n     * beyond a visible decimal point. The digits parsed will always be treated\n     * as the most significant (numerically largest) digits.\n     * Thus '23' will be parsed as 230 milliseconds.\n     * Contrast this behaviour to {@link #appendMillisOfSecond}.\n     * This method does not print or parse the decimal point itself.\n     * \n     * @param minDigits  minimum number of digits to print\n     * @param maxDigits  maximum number of digits to print or parse\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendFractionOfMinute(int minDigits, int maxDigits) {\n        return appendFraction(DateTimeFieldType.minuteOfDay(), minDigits, maxDigits);\n    }", "comment": "/**\n     * Appends the print/parse of a fractional minute.\n     * <p>\n     * This reliably handles the case where fractional digits are being handled\n     * beyond a visible decimal point. The digits parsed will always be treated\n     * as the most significant (numerically largest) digits.\n     * Thus '23' will be parsed as 0.23 minutes (converted to milliseconds).\n     * This method does not print or parse the decimal point itself.\n     * \n     * @param minDigits  minimum number of digits to print\n     * @param maxDigits  maximum number of digits to print or parse\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendFractionOfHour(int minDigits, int maxDigits) {\n        return appendFraction(DateTimeFieldType.hourOfDay(), minDigits, maxDigits);\n    }", "comment": "/**\n     * Appends the print/parse of a fractional hour.\n     * <p>\n     * This reliably handles the case where fractional digits are being handled\n     * beyond a visible decimal point. The digits parsed will always be treated\n     * as the most significant (numerically largest) digits.\n     * Thus '23' will be parsed as 0.23 hours (converted to milliseconds).\n     * This method does not print or parse the decimal point itself.\n     * \n     * @param minDigits  minimum number of digits to print\n     * @param maxDigits  maximum number of digits to print or parse\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendFractionOfDay(int minDigits, int maxDigits) {\n        return appendFraction(DateTimeFieldType.dayOfYear(), minDigits, maxDigits);\n    }", "comment": "/**\n     * Appends the print/parse of a fractional day.\n     * <p>\n     * This reliably handles the case where fractional digits are being handled\n     * beyond a visible decimal point. The digits parsed will always be treated\n     * as the most significant (numerically largest) digits.\n     * Thus '23' will be parsed as 0.23 days (converted to milliseconds).\n     * This method does not print or parse the decimal point itself.\n     * \n     * @param minDigits  minimum number of digits to print\n     * @param maxDigits  maximum number of digits to print or parse\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendMillisOfSecond(int minDigits) {\n        return appendDecimal(DateTimeFieldType.millisOfSecond(), minDigits, 3);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric millisOfSecond field.\n     * <p>\n     * This method will append a field that prints a three digit value.\n     * During parsing the value that is parsed is assumed to be three digits.\n     * If less than three digits are present then they will be counted as the\n     * smallest parts of the millisecond. This is probably not what you want\n     * if you are using the field as a fraction. Instead, a fractional\n     * millisecond should be produced using {@link #appendFractionOfSecond}.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendMillisOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.millisOfDay(), minDigits, 8);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric millisOfDay field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {\n        return appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric secondOfMinute field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendSecondOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.secondOfDay(), minDigits, 5);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric secondOfDay field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {\n        return appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric minuteOfHour field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendMinuteOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.minuteOfDay(), minDigits, 4);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric minuteOfDay field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric hourOfDay field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendClockhourOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.clockhourOfDay(), minDigits, 2);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric clockhourOfDay field.\n     *\n     * @param minDigits minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendHourOfHalfday(int minDigits) {\n        return appendDecimal(DateTimeFieldType.hourOfHalfday(), minDigits, 2);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric hourOfHalfday field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendClockhourOfHalfday(int minDigits) {\n        return appendDecimal(DateTimeFieldType.clockhourOfHalfday(), minDigits, 2);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric clockhourOfHalfday field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendDayOfWeek(int minDigits) {\n        return appendDecimal(DateTimeFieldType.dayOfWeek(), minDigits, 1);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric dayOfWeek field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {\n        return appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric dayOfMonth field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendDayOfYear(int minDigits) {\n        return appendDecimal(DateTimeFieldType.dayOfYear(), minDigits, 3);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric dayOfYear field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendWeekOfWeekyear(int minDigits) {\n        return appendDecimal(DateTimeFieldType.weekOfWeekyear(), minDigits, 2);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric weekOfWeekyear field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendWeekyear(int minDigits, int maxDigits) {\n        return appendSignedDecimal(DateTimeFieldType.weekyear(), minDigits, maxDigits);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric weekyear field.\n     *\n     * @param minDigits  minimum number of digits to <i>print</i>\n     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n     * maximum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {\n        return appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric monthOfYear field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {\n        return appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric year field.\n     *\n     * @param minDigits  minimum number of digits to <i>print</i>\n     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n     * maximum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendTwoDigitYear(int pivot) {\n        return appendTwoDigitYear(pivot, false);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric year field which always prints\n     * and parses two digits. A pivot year is used during parsing to determine\n     * the range of supported years as <code>(pivot - 50) .. (pivot + 49)</code>.\n     *\n     * <pre>\n     * pivot   supported range   00 is   20 is   40 is   60 is   80 is\n     * ---------------------------------------------------------------\n     * 1950      1900..1999      1900    1920    1940    1960    1980\n     * 1975      1925..2024      2000    2020    1940    1960    1980\n     * 2000      1950..2049      2000    2020    2040    1960    1980\n     * 2025      1975..2074      2000    2020    2040    2060    1980\n     * 2050      2000..2099      2000    2020    2040    2060    2080\n     * </pre>\n     *\n     * @param pivot  pivot year to use when parsing\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendTwoDigitYear(int pivot, boolean lenientParse) {\n        return append0(new TwoDigitYear(DateTimeFieldType.year(), pivot, lenientParse));\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric year field which always prints\n     * two digits. A pivot year is used during parsing to determine the range\n     * of supported years as <code>(pivot - 50) .. (pivot + 49)</code>. If\n     * parse is instructed to be lenient and the digit count is not two, it is\n     * treated as an absolute year. With lenient parsing, specifying a positive\n     * or negative sign before the year also makes it absolute.\n     *\n     * @param pivot  pivot year to use when parsing\n     * @param lenientParse  when true, if digit count is not two, it is treated\n     * as an absolute year\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @since 1.1\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot) {\n        return appendTwoDigitWeekyear(pivot, false);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric weekyear field which always prints\n     * and parses two digits. A pivot year is used during parsing to determine\n     * the range of supported years as <code>(pivot - 50) .. (pivot + 49)</code>.\n     *\n     * <pre>\n     * pivot   supported range   00 is   20 is   40 is   60 is   80 is\n     * ---------------------------------------------------------------\n     * 1950      1900..1999      1900    1920    1940    1960    1980\n     * 1975      1925..2024      2000    2020    1940    1960    1980\n     * 2000      1950..2049      2000    2020    2040    1960    1980\n     * 2025      1975..2074      2000    2020    2040    2060    1980\n     * 2050      2000..2099      2000    2020    2040    2060    2080\n     * </pre>\n     *\n     * @param pivot  pivot weekyear to use when parsing\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot, boolean lenientParse) {\n        return append0(new TwoDigitYear(DateTimeFieldType.weekyear(), pivot, lenientParse));\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric weekyear field which always prints\n     * two digits. A pivot year is used during parsing to determine the range\n     * of supported years as <code>(pivot - 50) .. (pivot + 49)</code>. If\n     * parse is instructed to be lenient and the digit count is not two, it is\n     * treated as an absolute weekyear. With lenient parsing, specifying a positive\n     * or negative sign before the weekyear also makes it absolute.\n     *\n     * @param pivot  pivot weekyear to use when parsing\n     * @param lenientParse  when true, if digit count is not two, it is treated\n     * as an absolute weekyear\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @since 1.1\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendYearOfEra(int minDigits, int maxDigits) {\n        return appendDecimal(DateTimeFieldType.yearOfEra(), minDigits, maxDigits);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric yearOfEra field.\n     *\n     * @param minDigits  minimum number of digits to <i>print</i>\n     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n     * maximum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendYearOfCentury(int minDigits, int maxDigits) {\n        return appendDecimal(DateTimeFieldType.yearOfCentury(), minDigits, maxDigits);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric year of century field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n     * maximum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendCenturyOfEra(int minDigits, int maxDigits) {\n        return appendSignedDecimal(DateTimeFieldType.centuryOfEra(), minDigits, maxDigits);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric century of era field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n     * maximum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendHalfdayOfDayText() {\n        return appendText(DateTimeFieldType.halfdayOfDay());\n    }", "comment": "/**\n     * Instructs the printer to emit a locale-specific AM/PM text, and the\n     * parser to expect it. The parser is case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendDayOfWeekText() {\n        return appendText(DateTimeFieldType.dayOfWeek());\n    }", "comment": "/**\n     * Instructs the printer to emit a locale-specific dayOfWeek text. The\n     * parser will accept a long or short dayOfWeek text, case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendDayOfWeekShortText() {\n        return appendShortText(DateTimeFieldType.dayOfWeek());\n    }", "comment": "/**\n     * Instructs the printer to emit a short locale-specific dayOfWeek\n     * text. The parser will accept a long or short dayOfWeek text,\n     * case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendMonthOfYearText() { \n        return appendText(DateTimeFieldType.monthOfYear());\n    }", "comment": "/**\n     * Instructs the printer to emit a short locale-specific monthOfYear\n     * text. The parser will accept a long or short monthOfYear text,\n     * case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendMonthOfYearShortText() {\n        return appendShortText(DateTimeFieldType.monthOfYear());\n    }", "comment": "/**\n     * Instructs the printer to emit a locale-specific monthOfYear text. The\n     * parser will accept a long or short monthOfYear text, case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendEraText() {\n        return appendText(DateTimeFieldType.era());\n    }", "comment": "/**\n     * Instructs the printer to emit a locale-specific era text (BC/AD), and\n     * the parser to expect it. The parser is case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendTimeZoneName() {\n        return append0(new TimeZoneName(TimeZoneName.LONG_NAME, null), null);\n    }", "comment": "/**\n     * Instructs the printer to emit a locale-specific time zone name.\n     * Using this method prevents parsing, because time zone names are not unique.\n     * See {@link #appendTimeZoneName(Map)}.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendTimeZoneName(Map<String, DateTimeZone> parseLookup) {\n        TimeZoneName pp = new TimeZoneName(TimeZoneName.LONG_NAME, parseLookup);\n        return append0(pp, pp);\n    }", "comment": "/**\n     * Instructs the printer to emit a locale-specific time zone name, providing a lookup for parsing.\n     * Time zone names are not unique, thus the API forces you to supply the lookup.\n     * The names are searched in the order of the map, thus it is strongly recommended\n     * to use a {@code LinkedHashMap} or similar.\n     *\n     * @param parseLookup  the table of names, not null\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendTimeZoneShortName() {\n        return append0(new TimeZoneName(TimeZoneName.SHORT_NAME, null), null);\n    }", "comment": "/**\n     * Instructs the printer to emit a short locale-specific time zone name.\n     * Using this method prevents parsing, because time zone names are not unique.\n     * See {@link #appendTimeZoneShortName(Map)}.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendTimeZoneShortName(Map<String, DateTimeZone> parseLookup) {\n        TimeZoneName pp = new TimeZoneName(TimeZoneName.SHORT_NAME, parseLookup);\n        return append0(pp, pp);\n    }", "comment": "/**\n     * Instructs the printer to emit a short locale-specific time zone\n     * name, providing a lookup for parsing.\n     * Time zone names are not unique, thus the API forces you to supply the lookup.\n     * The names are searched in the order of the map, thus it is strongly recommended\n     * to use a {@code LinkedHashMap} or similar.\n     *\n     * @param parseLookup  the table of names, null to use the {@link DateTimeUtils#getDefaultTimeZoneNames() default names}\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendTimeZoneId() {\n        return append0(TimeZoneId.INSTANCE, TimeZoneId.INSTANCE);\n    }", "comment": "/**\n     * Instructs the printer to emit the identifier of the time zone.\n     * From version 2.0, this field can be parsed.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendTimeZoneOffset(", "comment": "/**\n     * Instructs the printer to emit text and numbers to display time zone\n     * offset from UTC. A parser will use the parsed time zone offset to adjust\n     * the datetime.\n     * <p>\n     * If zero offset text is supplied, then it will be printed when the zone is zero.\n     * During parsing, either the zero offset text, or the offset will be parsed.\n     *\n     * @param zeroOffsetText  the text to use if time zone offset is zero. If\n     * null, offset is always shown.\n     * @param showSeparators  if true, prints ':' separator before minute and\n     * second field and prints '.' separator before fraction field.\n     * @param minFields  minimum number of fields to print, stopping when no\n     * more precision is required. 1=hours, 2=minutes, 3=seconds, 4=fraction\n     * @param maxFields  maximum number of fields to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendTimeZoneOffset(", "comment": "/**\n     * Instructs the printer to emit text and numbers to display time zone\n     * offset from UTC. A parser will use the parsed time zone offset to adjust\n     * the datetime.\n     * <p>\n     * If zero offset text is supplied, then it will be printed when the zone is zero.\n     * During parsing, either the zero offset text, or the offset will be parsed.\n     *\n     * @param zeroOffsetText  the text to use if time zone offset is zero. If\n     * null, offset is always shown.\n     * @param showSeparators  if true, prints ':' separator before minute and\n     * second field and prints '.' separator before fraction field.\n     * @param minFields  minimum number of fields to print, stopping when no\n     * more precision is required. 1=hours, 2=minutes, 3=seconds, 4=fraction\n     * @param maxFields  maximum number of fields to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "public DateTimeFormatterBuilder appendPattern(String pattern) {\n        DateTimeFormat.appendPatternTo(this, pattern);\n        return this;\n    }", "comment": "/**\n     * Calls upon {@link DateTimeFormat} to parse the pattern and append the\n     * results into this builder.\n     *\n     * @param pattern  pattern specification\n     * @throws IllegalArgumentException if the pattern is invalid\n     * @see DateTimeFormat\n     */"}}
{"code": {"body": "    public DateTimeFormatter toFormatter() {\n        Object f = getFormatter();\n        DateTimePrinter printer = null;\n        if (isPrinter(f)) {\n            printer = (DateTimePrinter) f;\n        }\n        DateTimeParser parser = null;\n        if (isParser(f)) {\n            parser = (DateTimeParser) f;\n        }\n        if (printer != null || parser != null) {\n            return new DateTimeFormatter(printer, parser);\n        }\n        throw new UnsupportedOperationException(\"\");\n    }", "comment": "/**\n     * Constructs a DateTimeFormatter using all the appended elements.\n     * <p>\n     * This is the main method used by applications at the end of the build\n     * process to create a usable formatter.\n     * <p>\n     * Subsequent changes to this builder do not affect the returned formatter.\n     * <p>\n     * The returned formatter may not support both printing and parsing.\n     * The methods {@link DateTimeFormatter#isPrinter()} and\n     * {@link DateTimeFormatter#isParser()} will help you determine the state\n     * of the formatter.\n     *\n     * @throws UnsupportedOperationException if neither printing nor parsing is supported\n     */"}}
{"code": {"body": "    public DateTimePrinter toPrinter() {\n        Object f = getFormatter();\n        if (isPrinter(f)) {\n            return (DateTimePrinter) f;\n        }\n        throw new UnsupportedOperationException(\"\");\n    }", "comment": "/**\n     * Internal method to create a DateTimePrinter instance using all the\n     * appended elements.\n     * <p>\n     * Most applications will not use this method.\n     * If you want a printer in an application, call {@link #toFormatter()}\n     * and just use the printing API.\n     * <p>\n     * Subsequent changes to this builder do not affect the returned printer.\n     *\n     * @throws UnsupportedOperationException if printing is not supported\n     */"}}
{"code": {"body": "    public DateTimeParser toParser() {\n        Object f = getFormatter();\n        if (isParser(f)) {\n            return (DateTimeParser) f;\n        }\n        throw new UnsupportedOperationException(\"\");\n    }", "comment": "/**\n     * Internal method to create a DateTimeParser instance using all the\n     * appended elements.\n     * <p>\n     * Most applications will not use this method.\n     * If you want a parser in an application, call {@link #toFormatter()}\n     * and just use the parsing API.\n     * <p>\n     * Subsequent changes to this builder do not affect the returned parser.\n     *\n     * @throws UnsupportedOperationException if parsing is not supported\n     */"}}
{"code": {"body": "    public boolean canBuildFormatter() {\n        return isFormatter(getFormatter());\n    }", "comment": "/**\n     * Returns true if toFormatter can be called without throwing an\n     * UnsupportedOperationException.\n     * \n     * @return true if a formatter can be built\n     */"}}
{"code": {"body": "    public boolean canBuildPrinter() {\n        return isPrinter(getFormatter());\n    }", "comment": "/**\n     * Returns true if toPrinter can be called without throwing an\n     * UnsupportedOperationException.\n     * \n     * @return true if a printer can be built\n     */"}}
{"code": {"body": "    public boolean canBuildParser() {\n        return isParser(getFormatter());\n    }", "comment": "/**\n     * Returns true if toParser can be called without throwing an\n     * UnsupportedOperationException.\n     * \n     * @return true if a parser can be built\n     */"}}
{"code": {"body": "    public void clear() {\n        iFormatter = null;\n        iElementPairs.clear();\n    }", "comment": "/**\n     * Clears out all the appended elements, allowing this builder to be\n     * reused.\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser[] parsers) {\n        if (printer != null) {\n            checkPrinter(printer);\n        }\n        if (parsers == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        int length = parsers.length;\n        if (length == 1) {\n            if (parsers[0] == null) {\n                throw new IllegalArgumentException(\"\");\n            }\n            return append0(printer, parsers[0]);\n        }\n\n        DateTimeParser[] copyOfParsers = new DateTimeParser[length];\n        int i;\n        for (i = 0; i < length - 1; i++) {\n            if ((copyOfParsers[i] = parsers[i]) == null) {\n                throw new IllegalArgumentException(\"\");\n            }\n        }\n        copyOfParsers[i] = parsers[i];\n\n        return append0(printer, new MatchingParser(copyOfParsers));\n    }", "comment": "/**\n     * Appends a printer and a set of matching parsers. When parsing, the first\n     * parser in the list is selected for parsing. If it fails, the next is\n     * chosen, and so on. If none of these parsers succeeds, then the failed\n     * position of the parser that made the greatest progress is returned.\n     * <p>\n     * Only the printer is optional. In addition, it is illegal for any but the\n     * last of the parser array elements to be null. If the last element is\n     * null, this represents the empty parser. The presence of an empty parser\n     * indicates that the entire array of parse formats is optional.\n     * <p>\n     * The printer and parser interfaces are the low-level part of the formatting API.\n     * Normally, instances are extracted from another formatter.\n     * Note however that any formatter specific information, such as the locale,\n     * time-zone, chronology, offset parsing or pivot/default year, will not be\n     * extracted by this method.\n     *\n     * @param printer  the printer to add\n     * @param parsers  the parsers to add\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if any printer or parser is of an invalid type\n     * @throws IllegalArgumentException if any parser element but the last is null\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendOptional(DateTimeParser parser) {\n        checkParser(parser);\n        DateTimeParser[] parsers = new DateTimeParser[] {parser, null};\n        return append0(null, new MatchingParser(parsers));\n    }", "comment": "/**\n     * Appends just a parser element which is optional. With no matching\n     * printer, a printer cannot be built from this DateTimeFormatterBuilder.\n     * <p>\n     * The parser interface is part of the low-level part of the formatting API.\n     * Normally, instances are extracted from another formatter.\n     * Note however that any formatter specific information, such as the locale,\n     * time-zone, chronology, offset parsing or pivot/default year, will not be\n     * extracted by this method.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if parser is null or of an invalid type\n     */"}}
{"code": {"body": "    private void checkParser(DateTimeParser parser) {\n        if (parser == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n    }", "comment": "/**\n     * Checks if the parser is non null and a provider.\n     * \n     * @param parser  the parser to check\n     */"}}
{"code": {"body": "    private void checkPrinter(DateTimePrinter printer) {\n        if (printer == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n    }", "comment": "/**\n     * Checks if the printer is non null and a provider.\n     * \n     * @param printer  the printer to check\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendLiteral(String text) {\n        if (text == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        switch (text.length()) {\n            case 0:\n                return this;\n            case 1:\n                return append0(new CharacterLiteral(text.charAt(0)));\n            default:\n                return append0(new StringLiteral(text));\n        }\n    }", "comment": "/**\n     * Instructs the printer to emit specific text, and the parser to expect\n     * it. The parser is case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if text is null\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendDecimal(\n            DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (maxDigits < minDigits) {\n            maxDigits = minDigits;\n        }\n        if (minDigits < 0 || maxDigits <= 0) {\n            throw new IllegalArgumentException();\n        }\n        if (minDigits <= 1) {\n            return append0(new UnpaddedNumber(fieldType, maxDigits, false));\n        } else {\n            return append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));\n        }\n    }", "comment": "/**\n     * Instructs the printer to emit a field value as a decimal number, and the\n     * parser to expect an unsigned decimal number.\n     *\n     * @param fieldType  type of field to append\n     * @param minDigits  minimum number of digits to <i>print</i>\n     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n     * maximum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendFixedDecimal(\n            DateTimeFieldType fieldType, int numDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (numDigits <= 0) {\n            throw new IllegalArgumentException(\"\" + numDigits);\n        }\n        return append0(new FixedNumber(fieldType, numDigits, false));\n    }", "comment": "/**\n     * Instructs the printer to emit a field value as a fixed-width decimal\n     * number (smaller numbers will be left-padded with zeros), and the parser\n     * to expect an unsigned decimal number with the same fixed width.\n     * \n     * @param fieldType  type of field to append\n     * @param numDigits  the exact number of digits to parse or print, except if\n     * printed value requires more digits\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null or if <code>numDigits <= 0</code>\n     * @since 1.5\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendSignedDecimal(\n            DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (maxDigits < minDigits) {\n            maxDigits = minDigits;\n        }\n        if (minDigits < 0 || maxDigits <= 0) {\n            throw new IllegalArgumentException();\n        }\n        if (minDigits <= 1) {\n            return append0(new UnpaddedNumber(fieldType, maxDigits, true));\n        } else {\n            return append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));\n        }\n    }", "comment": "/**\n     * Instructs the printer to emit a field value as a decimal number, and the\n     * parser to expect a signed decimal number.\n     *\n     * @param fieldType  type of field to append\n     * @param minDigits  minimum number of digits to <i>print</i>\n     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n     * maximum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendFixedSignedDecimal(\n            DateTimeFieldType fieldType, int numDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (numDigits <= 0) {\n            throw new IllegalArgumentException(\"\" + numDigits);\n        }\n        return append0(new FixedNumber(fieldType, numDigits, true));\n    }", "comment": "/**\n     * Instructs the printer to emit a field value as a fixed-width decimal\n     * number (smaller numbers will be left-padded with zeros), and the parser\n     * to expect an signed decimal number with the same fixed width.\n     * \n     * @param fieldType  type of field to append\n     * @param numDigits  the exact number of digits to parse or print, except if\n     * printed value requires more digits\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null or if <code>numDigits <= 0</code>\n     * @since 1.5\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendText(DateTimeFieldType fieldType) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        return append0(new TextField(fieldType, false));\n    }", "comment": "/**\n     * Instructs the printer to emit a field value as text, and the\n     * parser to expect text.\n     *\n     * @param fieldType  type of field to append\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        return append0(new TextField(fieldType, true));\n    }", "comment": "/**\n     * Instructs the printer to emit a field value as short text, and the\n     * parser to expect text.\n     *\n     * @param fieldType  type of field to append\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendFraction(\n            DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (maxDigits < minDigits) {\n            maxDigits = minDigits;\n        }\n        if (minDigits < 0 || maxDigits <= 0) {\n            throw new IllegalArgumentException();\n        }\n        return append0(new Fraction(fieldType, minDigits, maxDigits));\n    }", "comment": "/**\n     * Instructs the printer to emit a remainder of time as a decimal fraction,\n     * without decimal point. For example, if the field is specified as\n     * minuteOfHour and the time is 12:30:45, the value printed is 75. A\n     * decimal point is implied, so the fraction is 0.75, or three-quarters of\n     * a minute.\n     *\n     * @param fieldType  type of field to append\n     * @param minDigits  minimum number of digits to print.\n     * @param maxDigits  maximum number of digits to print or parse.\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendFractionOfSecond(int minDigits, int maxDigits) {\n        return appendFraction(DateTimeFieldType.secondOfDay(), minDigits, maxDigits);\n    }", "comment": "/**\n     * Appends the print/parse of a fractional second.\n     * <p>\n     * This reliably handles the case where fractional digits are being handled\n     * beyond a visible decimal point. The digits parsed will always be treated\n     * as the most significant (numerically largest) digits.\n     * Thus '23' will be parsed as 230 milliseconds.\n     * Contrast this behaviour to {@link #appendMillisOfSecond}.\n     * This method does not print or parse the decimal point itself.\n     * \n     * @param minDigits  minimum number of digits to print\n     * @param maxDigits  maximum number of digits to print or parse\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendFractionOfMinute(int minDigits, int maxDigits) {\n        return appendFraction(DateTimeFieldType.minuteOfDay(), minDigits, maxDigits);\n    }", "comment": "/**\n     * Appends the print/parse of a fractional minute.\n     * <p>\n     * This reliably handles the case where fractional digits are being handled\n     * beyond a visible decimal point. The digits parsed will always be treated\n     * as the most significant (numerically largest) digits.\n     * Thus '23' will be parsed as 0.23 minutes (converted to milliseconds).\n     * This method does not print or parse the decimal point itself.\n     * \n     * @param minDigits  minimum number of digits to print\n     * @param maxDigits  maximum number of digits to print or parse\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendFractionOfHour(int minDigits, int maxDigits) {\n        return appendFraction(DateTimeFieldType.hourOfDay(), minDigits, maxDigits);\n    }", "comment": "/**\n     * Appends the print/parse of a fractional hour.\n     * <p>\n     * This reliably handles the case where fractional digits are being handled\n     * beyond a visible decimal point. The digits parsed will always be treated\n     * as the most significant (numerically largest) digits.\n     * Thus '23' will be parsed as 0.23 hours (converted to milliseconds).\n     * This method does not print or parse the decimal point itself.\n     * \n     * @param minDigits  minimum number of digits to print\n     * @param maxDigits  maximum number of digits to print or parse\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendFractionOfDay(int minDigits, int maxDigits) {\n        return appendFraction(DateTimeFieldType.dayOfYear(), minDigits, maxDigits);\n    }", "comment": "/**\n     * Appends the print/parse of a fractional day.\n     * <p>\n     * This reliably handles the case where fractional digits are being handled\n     * beyond a visible decimal point. The digits parsed will always be treated\n     * as the most significant (numerically largest) digits.\n     * Thus '23' will be parsed as 0.23 days (converted to milliseconds).\n     * This method does not print or parse the decimal point itself.\n     * \n     * @param minDigits  minimum number of digits to print\n     * @param maxDigits  maximum number of digits to print or parse\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendMillisOfSecond(int minDigits) {\n        return appendDecimal(DateTimeFieldType.millisOfSecond(), minDigits, 3);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric millisOfSecond field.\n     * <p>\n     * This method will append a field that prints a three digit value.\n     * During parsing the value that is parsed is assumed to be three digits.\n     * If less than three digits are present then they will be counted as the\n     * smallest parts of the millisecond. This is probably not what you want\n     * if you are using the field as a fraction. Instead, a fractional\n     * millisecond should be produced using {@link #appendFractionOfSecond}.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendMillisOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.millisOfDay(), minDigits, 8);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric millisOfDay field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {\n        return appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric secondOfMinute field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendSecondOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.secondOfDay(), minDigits, 5);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric secondOfDay field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {\n        return appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric minuteOfHour field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendMinuteOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.minuteOfDay(), minDigits, 4);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric minuteOfDay field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric hourOfDay field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendClockhourOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.clockhourOfDay(), minDigits, 2);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric clockhourOfDay field.\n     *\n     * @param minDigits minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendHourOfHalfday(int minDigits) {\n        return appendDecimal(DateTimeFieldType.hourOfHalfday(), minDigits, 2);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric hourOfHalfday field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendClockhourOfHalfday(int minDigits) {\n        return appendDecimal(DateTimeFieldType.clockhourOfHalfday(), minDigits, 2);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric clockhourOfHalfday field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendDayOfWeek(int minDigits) {\n        return appendDecimal(DateTimeFieldType.dayOfWeek(), minDigits, 1);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric dayOfWeek field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {\n        return appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric dayOfMonth field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendDayOfYear(int minDigits) {\n        return appendDecimal(DateTimeFieldType.dayOfYear(), minDigits, 3);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric dayOfYear field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendWeekOfWeekyear(int minDigits) {\n        return appendDecimal(DateTimeFieldType.weekOfWeekyear(), minDigits, 2);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric weekOfWeekyear field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendWeekyear(int minDigits, int maxDigits) {\n        return appendSignedDecimal(DateTimeFieldType.weekyear(), minDigits, maxDigits);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric weekyear field.\n     *\n     * @param minDigits  minimum number of digits to <i>print</i>\n     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n     * maximum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {\n        return appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric monthOfYear field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {\n        return appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric year field.\n     *\n     * @param minDigits  minimum number of digits to <i>print</i>\n     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n     * maximum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendTwoDigitYear(int pivot, boolean lenientParse) {\n        return append0(new TwoDigitYear(DateTimeFieldType.year(), pivot, lenientParse));\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric year field which always prints\n     * two digits. A pivot year is used during parsing to determine the range\n     * of supported years as <code>(pivot - 50) .. (pivot + 49)</code>. If\n     * parse is instructed to be lenient and the digit count is not two, it is\n     * treated as an absolute year. With lenient parsing, specifying a positive\n     * or negative sign before the year also makes it absolute.\n     *\n     * @param pivot  pivot year to use when parsing\n     * @param lenientParse  when true, if digit count is not two, it is treated\n     * as an absolute year\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @since 1.1\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot, boolean lenientParse) {\n        return append0(new TwoDigitYear(DateTimeFieldType.weekyear(), pivot, lenientParse));\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric weekyear field which always prints\n     * two digits. A pivot year is used during parsing to determine the range\n     * of supported years as <code>(pivot - 50) .. (pivot + 49)</code>. If\n     * parse is instructed to be lenient and the digit count is not two, it is\n     * treated as an absolute weekyear. With lenient parsing, specifying a positive\n     * or negative sign before the weekyear also makes it absolute.\n     *\n     * @param pivot  pivot weekyear to use when parsing\n     * @param lenientParse  when true, if digit count is not two, it is treated\n     * as an absolute weekyear\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @since 1.1\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendYearOfEra(int minDigits, int maxDigits) {\n        return appendDecimal(DateTimeFieldType.yearOfEra(), minDigits, maxDigits);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric yearOfEra field.\n     *\n     * @param minDigits  minimum number of digits to <i>print</i>\n     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n     * maximum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendYearOfCentury(int minDigits, int maxDigits) {\n        return appendDecimal(DateTimeFieldType.yearOfCentury(), minDigits, maxDigits);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric year of century field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n     * maximum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendCenturyOfEra(int minDigits, int maxDigits) {\n        return appendSignedDecimal(DateTimeFieldType.centuryOfEra(), minDigits, maxDigits);\n    }", "comment": "/**\n     * Instructs the printer to emit a numeric century of era field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n     * maximum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendHalfdayOfDayText() {\n        return appendText(DateTimeFieldType.halfdayOfDay());\n    }", "comment": "/**\n     * Instructs the printer to emit a locale-specific AM/PM text, and the\n     * parser to expect it. The parser is case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendDayOfWeekText() {\n        return appendText(DateTimeFieldType.dayOfWeek());\n    }", "comment": "/**\n     * Instructs the printer to emit a locale-specific dayOfWeek text. The\n     * parser will accept a long or short dayOfWeek text, case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendDayOfWeekShortText() {\n        return appendShortText(DateTimeFieldType.dayOfWeek());\n    }", "comment": "/**\n     * Instructs the printer to emit a short locale-specific dayOfWeek\n     * text. The parser will accept a long or short dayOfWeek text,\n     * case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendMonthOfYearText() { \n        return appendText(DateTimeFieldType.monthOfYear());\n    }", "comment": "/**\n     * Instructs the printer to emit a short locale-specific monthOfYear\n     * text. The parser will accept a long or short monthOfYear text,\n     * case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendMonthOfYearShortText() {\n        return appendShortText(DateTimeFieldType.monthOfYear());\n    }", "comment": "/**\n     * Instructs the printer to emit a locale-specific monthOfYear text. The\n     * parser will accept a long or short monthOfYear text, case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendEraText() {\n        return appendText(DateTimeFieldType.era());\n    }", "comment": "/**\n     * Instructs the printer to emit a locale-specific era text (BC/AD), and\n     * the parser to expect it. The parser is case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendTimeZoneName(Map<String, DateTimeZone> parseLookup) {\n        TimeZoneName pp = new TimeZoneName(TimeZoneName.LONG_NAME, parseLookup);\n        return append0(pp, pp);\n    }", "comment": "/**\n     * Instructs the printer to emit a locale-specific time zone name, providing a lookup for parsing.\n     * Time zone names are not unique, thus the API forces you to supply the lookup.\n     * The names are searched in the order of the map, thus it is strongly recommended\n     * to use a {@code LinkedHashMap} or similar.\n     *\n     * @param parseLookup  the table of names, not null\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendTimeZoneShortName(Map<String, DateTimeZone> parseLookup) {\n        TimeZoneName pp = new TimeZoneName(TimeZoneName.SHORT_NAME, parseLookup);\n        return append0(pp, pp);\n    }", "comment": "/**\n     * Instructs the printer to emit a short locale-specific time zone\n     * name, providing a lookup for parsing.\n     * Time zone names are not unique, thus the API forces you to supply the lookup.\n     * The names are searched in the order of the map, thus it is strongly recommended\n     * to use a {@code LinkedHashMap} or similar.\n     *\n     * @param parseLookup  the table of names, null to use the {@link DateTimeUtils#getDefaultTimeZoneNames() default names}\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendTimeZoneId() {\n        return append0(TimeZoneId.INSTANCE, TimeZoneId.INSTANCE);\n    }", "comment": "/**\n     * Instructs the printer to emit the identifier of the time zone.\n     * From version 2.0, this field can be parsed.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendTimeZoneOffset(\n            String zeroOffsetPrintText, String zeroOffsetParseText, boolean showSeparators,\n            int minFields, int maxFields) {\n        return append0(new TimeZoneOffset\n                       (zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields));\n    }", "comment": "/**\n     * Instructs the printer to emit text and numbers to display time zone\n     * offset from UTC. A parser will use the parsed time zone offset to adjust\n     * the datetime.\n     * <p>\n     * If zero offset print text is supplied, then it will be printed when the zone is zero.\n     * If zero offset parse text is supplied, then either it or the offset will be parsed.\n     *\n     * @param zeroOffsetPrintText  the text to print if time zone offset is zero. If\n     * null, offset is always shown.\n     * @param zeroOffsetParseText  the text to optionally parse to indicate that the time\n     * zone offset is zero. If null, then always use the offset.\n     * @param showSeparators  if true, prints ':' separator before minute and\n     * second field and prints '.' separator before fraction field.\n     * @param minFields  minimum number of fields to print, stopping when no\n     * more precision is required. 1=hours, 2=minutes, 3=seconds, 4=fraction\n     * @param maxFields  maximum number of fields to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @since 2.0\n     */"}}
{"code": {"body": "    public DateTimeFormatterBuilder appendPattern(String pattern) {\n        DateTimeFormat.appendPatternTo(this, pattern);\n        return this;\n    }", "comment": "/**\n     * Calls upon {@link DateTimeFormat} to parse the pattern and append the\n     * results into this builder.\n     *\n     * @param pattern  pattern specification\n     * @throws IllegalArgumentException if the pattern is invalid\n     * @see DateTimeFormat\n     */"}}
{"code": {"body": "        private int digitCount(String text, int position, int amount) {\n            int limit = Math.min(text.length() - position, amount);\n            amount = 0;\n            for (; limit > 0; limit--) {\n                char c = text.charAt(position + amount);\n                if (c < '' || c > '') {\n                    break;\n                }\n                amount++;\n            }\n            return amount;\n        }", "comment": "/**\n         * Returns actual amount of digits to parse, but no more than original\n         * 'amount' parameter.\n         */"}}
{"code": {"body": "        private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) {\n            int size = elementPairs.size();\n            for (int i=0; i<size; i+=2) {\n                Object element = elementPairs.get(i);\n                if (element instanceof Composite) {\n                    addArrayToList(printerList, ((Composite)element).iPrinters);\n                } else {\n                    printerList.add(element);\n                }\n\n                element = elementPairs.get(i + 1);\n                if (element instanceof Composite) {\n                    addArrayToList(parserList, ((Composite)element).iParsers);\n                } else {\n                    parserList.add(element);\n                }\n            }\n        }", "comment": "/**\n         * Processes the element pairs, putting results into the given printer\n         * and parser lists.\n         */"}}
{"code": {"body": "    public Chronology getChronology() {\n        return iChrono;\n    }", "comment": "/**\n     * Gets the chronology of the bucket, which will be a local (UTC) chronology.\n     */"}}
{"code": {"body": "    public Locale getLocale() {\n        return iLocale;\n    }", "comment": "/**\n     * Returns the locale to be used during parsing.\n     * \n     * @return the locale to use\n     */"}}
{"code": {"body": "    public DateTimeZone getZone() {\n        return iZone;\n    }", "comment": "/**\n     * Returns the time zone used by computeMillis.\n     */"}}
{"code": {"body": "    public void setZone(DateTimeZone zone) {\n        iSavedState = null;\n        iZone = zone;\n    }", "comment": "/**\n     * Set a time zone to be used when computeMillis is called.\n     */"}}
{"code": {"body": "    public Integer getOffsetInteger() {\n        return iOffset;\n    }", "comment": "/**\n     * Returns the time zone offset in milliseconds used by computeMillis.\n     */"}}
{"code": {"body": "    public void setOffset(Integer offset) {\n        iSavedState = null;\n        iOffset = offset;\n    }", "comment": "/**\n     * Set a time zone offset to be used when computeMillis is called.\n     */"}}
{"code": {"body": "    public Integer getPivotYear() {\n        return iPivotYear;\n    }", "comment": "/**\n     * Returns the default year used when information is incomplete.\n     * <p>\n     * This is used for two-digit years and when the largest parsed field is\n     * months or days.\n     * <p>\n     * A null value for two-digit years means to use the value from DateTimeFormatterBuilder.\n     * A null value for month/day only parsing will cause the default of 2000 to be used.\n     *\n     * @return Integer value of the pivot year, null if not set\n     * @since 1.1\n     */"}}
{"code": {"body": "    public void setPivotYear(Integer pivotYear) {\n        iPivotYear = pivotYear;\n    }", "comment": "/**\n     * Sets the pivot year to use when parsing two digit years.\n     * <p>\n     * If the value is set to null, this will indicate that default\n     * behaviour should be used.\n     *\n     * @param pivotYear  the pivot year to use\n     * @since 1.1\n     */"}}
{"code": {"body": "    public Object saveState() {\n        if (iSavedState == null) {\n            iSavedState = new SavedState();\n        }\n        return iSavedState;\n    }", "comment": "/**\n     * Saves the state of this bucket, returning it in an opaque object. Call\n     * restoreState to undo any changes that were made since the state was\n     * saved. Calls to saveState may be nested.\n     *\n     * @return opaque saved state, which may be passed to restoreState\n     */"}}
{"code": {"body": "    public long computeMillis(boolean resetFields, String text) {\n        SavedField[] savedFields = iSavedFields;\n        int count = iSavedFieldsCount;\n        if (iSavedFieldsShared) {\n            iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n            iSavedFieldsShared = false;\n        }\n        sort(savedFields, count);\n        if (count > 0) {\n            \n            DurationField months = DurationFieldType.months().getField(iChrono);\n            DurationField days = DurationFieldType.days().getField(iChrono);\n            DurationField first = savedFields[0].iField.getDurationField();\n            if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n                saveField(DateTimeFieldType.year(), iDefaultYear);\n                return computeMillis(resetFields, text);\n            }\n        }\n\n        long millis = iMillis;\n        try {\n            for (int i = 0; i < count; i++) {\n                millis = savedFields[i].set(millis, resetFields);\n            }\n            if (resetFields) {\n                for (int i = 0; i < count; i++) {\n                    millis = savedFields[i].set(millis, i == (count - 1));\n                }\n            }\n        } catch (IllegalFieldValueException e) {\n            if (text != null) {\n                e.prependMessage(\"\" + text + '');\n            }\n            throw e;\n        }\n        \n        if (iOffset != null) {\n            millis -= iOffset;\n        } else if (iZone != null) {\n            int offset = iZone.getOffsetFromLocal(millis);\n            millis -= offset;\n            if (offset != iZone.getOffset(millis)) {\n                String message = \"\" + iZone + '';\n                if (text != null) {\n                    message = \"\" + text + \"\" + message;\n                }\n                throw new IllegalInstantException(message);\n            }\n        }\n        \n        return millis;\n    }", "comment": "/**\n     * Computes the parsed datetime by setting the saved fields.\n     * This method is idempotent, but it is not thread-safe.\n     *\n     * @param resetFields false by default, but when true, unsaved field values are cleared\n     * @param text optional text being parsed, to be included in any error message\n     * @return milliseconds since 1970-01-01T00:00:00Z\n     * @throws IllegalArgumentException if any field is out of range\n     * @since 1.3\n     */"}}
{"code": {"body": "    private static void sort(SavedField[] array, int high) {\n        if (high > 10) {\n            Arrays.sort(array, 0, high);\n        } else {\n            for (int i=0; i<high; i++) {\n                for (int j=i; j>0 && (array[j-1]).compareTo(array[j])>0; j--) {\n                    SavedField t = array[j];\n                    array[j] = array[j-1];\n                    array[j-1] = t;\n                }\n            }\n        }\n    }", "comment": "/**\n     * Sorts elements [0,high). Calling java.util.Arrays isn't always the right\n     * choice since it always creates an internal copy of the array, even if it\n     * doesn't need to. If the array slice is small enough, an insertion sort\n     * is chosen instead, but it doesn't need a copy!\n     * <p>\n     * This method has a modified version of that insertion sort, except it\n     * doesn't create an unnecessary array copy. If high is over 10, then\n     * java.util.Arrays is called, which will perform a merge sort, which is\n     * faster than insertion sort on large lists.\n     * <p>\n     * The end result is much greater performance when computeMillis is called.\n     * Since the amount of saved fields is small, the insertion sort is a\n     * better choice. Additional performance is gained since there is no extra\n     * array allocation and copying. Also, the insertion sort here does not\n     * perform any casting operations. The version in java.util.Arrays performs\n     * casts within the insertion sort loop.\n     */"}}
{"code": {"body": "        public int compareTo(SavedField obj) {\n            DateTimeField other = obj.iField;\n            int result = compareReverse\n                (iField.getRangeDurationField(), other.getRangeDurationField());\n            if (result != 0) {\n                return result;\n            }\n            return compareReverse\n                (iField.getDurationField(), other.getDurationField());\n        }", "comment": "/**\n         * The field with the longer range duration is ordered first, where\n         * null is considered infinite. If the ranges match, then the field\n         * with the longer duration is ordered first.\n         */"}}
{"code": {"body": "    public static void appendPaddedInteger(StringBuffer buf, long value, int size) {\n        int intValue = (int)value;\n        if (intValue == value) {\n            appendPaddedInteger(buf, intValue, size);\n        } else if (size <= 19) {\n            buf.append(Long.toString(value));\n        } else {\n            if (value < 0) {\n                buf.append('');\n                if (value != Long.MIN_VALUE) {\n                    value = -value;\n                } else {\n                    for (; size > 19; size--) {\n                        buf.append('');\n                    }\n                    buf.append(\"\");\n                    return;\n                }\n            }\n            int digits = (int)(Math.log(value) / LOG_10) + 1;\n            for (; size > digits; size--) {\n                buf.append('');\n            }\n            buf.append(Long.toString(value));\n        }\n    }", "comment": "/**\n     * Converts an integer to a string, prepended with a variable amount of '0'\n     * pad characters, and appends it to the given buffer.\n     *\n     * <p>This method is optimized for converting small values to strings.\n     *\n     * @param buf receives integer converted to a string\n     * @param value value to convert to a string\n     * @param size minumum amount of digits to append\n     */"}}
{"code": {"body": "    public static void writePaddedInteger(Writer out, long value, int size)\n        throws IOException\n    {\n        int intValue = (int)value;\n        if (intValue == value) {\n            writePaddedInteger(out, intValue, size);\n        } else if (size <= 19) {\n            out.write(Long.toString(value));\n        } else {\n            if (value < 0) {\n                out.write('');\n                if (value != Long.MIN_VALUE) {\n                    value = -value;\n                } else {\n                    for (; size > 19; size--) {\n                        out.write('');\n                    }\n                    out.write(\"\");\n                    return;\n                }\n            }\n            int digits = (int)(Math.log(value) / LOG_10) + 1;\n            for (; size > digits; size--) {\n                out.write('');\n            }\n            out.write(Long.toString(value));\n        }\n    }", "comment": "/**\n     * Converts an integer to a string, prepended with a variable amount of '0'\n     * pad characters, and writes it to the given writer.\n     *\n     * <p>This method is optimized for converting small values to strings.\n     *\n     * @param out receives integer converted to a string\n     * @param value value to convert to a string\n     * @param size minumum amount of digits to append\n     */"}}
{"code": {"body": "    public static void appendUnpaddedInteger(StringBuffer buf, long value) {\n        int intValue = (int)value;\n        if (intValue == value) {\n            appendUnpaddedInteger(buf, intValue);\n        } else {\n            buf.append(Long.toString(value));\n        }\n    }", "comment": "/**\n     * Converts an integer to a string, and appends it to the given buffer.\n     *\n     * <p>This method is optimized for converting small values to strings.\n     *\n     * @param buf receives integer converted to a string\n     * @param value value to convert to a string\n     */"}}
{"code": {"body": "    public static void writeUnpaddedInteger(Writer out, long value)\n        throws IOException\n    {\n        int intValue = (int)value;\n        if (intValue == value) {\n            writeUnpaddedInteger(out, intValue);\n        } else {\n            out.write(Long.toString(value));\n        }\n    }", "comment": "/**\n     * Converts an integer to a string, and writes it to the given writer.\n     *\n     * <p>This method is optimized for converting small values to strings.\n     *\n     * @param out receives integer converted to a string\n     * @param value value to convert to a string\n     */"}}
{"code": {"body": "    public static int calculateDigitCount(long value) {\n        if (value < 0) {\n            if (value != Long.MIN_VALUE) {\n                return calculateDigitCount(-value) + 1;\n            } else {\n                return 20;\n            }\n        }\n        return \n            (value < 10 ? 1 :\n             (value < 100 ? 2 :\n              (value < 1000 ? 3 :\n               (value < 10000 ? 4 :\n                ((int)(Math.log(value) / LOG_10) + 1)))));\n    }", "comment": "/**\n     * Calculates the number of decimal digits for the given value,\n     * including the sign.\n     */"}}
{"code": {"body": "    public static DateTimeFormatter forFields(\n        Collection<DateTimeFieldType> fields,\n        boolean extended,\n        boolean strictISO) {\n        \n        if (fields == null || fields.size() == 0) {\n            throw new IllegalArgumentException(\"\");\n        }\n        Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields);\n        int inputSize = workingFields.size();\n        boolean reducedPrec = false;\n        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n        \n        if (workingFields.contains(DateTimeFieldType.monthOfYear())) {\n            reducedPrec = dateByMonth(bld, workingFields, extended, strictISO);\n        } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) {\n            reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO);\n        } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) {\n            reducedPrec = dateByWeek(bld, workingFields, extended, strictISO);\n        } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) {\n            reducedPrec = dateByMonth(bld, workingFields, extended, strictISO);\n        } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) {\n            reducedPrec = dateByWeek(bld, workingFields, extended, strictISO);\n        } else if (workingFields.remove(DateTimeFieldType.year())) {\n            bld.append(Constants.ye);\n            reducedPrec = true;\n        } else if (workingFields.remove(DateTimeFieldType.weekyear())) {\n            bld.append(Constants.we);\n            reducedPrec = true;\n        }\n        boolean datePresent = (workingFields.size() < inputSize);\n        \n        \n        time(bld, workingFields, extended, strictISO, reducedPrec, datePresent);\n        \n        \n        if (bld.canBuildFormatter() == false) {\n            throw new IllegalArgumentException(\"\" + fields);\n        }\n        \n        \n        \n        try {\n            fields.retainAll(workingFields);\n        } catch (UnsupportedOperationException ex) {\n            \n        }\n        return bld.toFormatter();\n    }", "comment": "/**\n     * Returns a formatter that outputs only those fields specified.\n     * <p>\n     * This method examines the fields provided and returns an ISO-style\n     * formatter that best fits. This can be useful for outputting\n     * less-common ISO styles, such as YearMonth (YYYY-MM) or MonthDay (--MM-DD).\n     * <p>\n     * The list provided may have overlapping fields, such as dayOfWeek and\n     * dayOfMonth. In this case, the style is chosen based on the following\n     * list, thus in the example, the calendar style is chosen as dayOfMonth\n     * is higher in priority than dayOfWeek:\n     * <ul>\n     * <li>monthOfYear - calendar date style\n     * <li>dayOfYear - ordinal date style\n     * <li>weekOfWeekYear - week date style\n     * <li>dayOfMonth - calendar date style\n     * <li>dayOfWeek - week date style\n     * <li>year\n     * <li>weekyear\n     * </ul>\n     * The supported formats are:\n     * <pre>\n     * Extended      Basic       Fields\n     * 2005-03-25    20050325    year/monthOfYear/dayOfMonth\n     * 2005-03       2005-03     year/monthOfYear\n     * 2005--25      2005--25    year/dayOfMonth *\n     * 2005          2005        year\n     * --03-25       --0325      monthOfYear/dayOfMonth\n     * --03          --03        monthOfYear\n     * ---03         ---03       dayOfMonth\n     * 2005-084      2005084     year/dayOfYear\n     * -084          -084        dayOfYear\n     * 2005-W12-5    2005W125    weekyear/weekOfWeekyear/dayOfWeek\n     * 2005-W-5      2005W-5     weekyear/dayOfWeek *\n     * 2005-W12      2005W12     weekyear/weekOfWeekyear\n     * -W12-5        -W125       weekOfWeekyear/dayOfWeek\n     * -W12          -W12        weekOfWeekyear\n     * -W-5          -W-5        dayOfWeek\n     * 10:20:30.040  102030.040  hour/minute/second/milli\n     * 10:20:30      102030      hour/minute/second\n     * 10:20         1020        hour/minute\n     * 10            10          hour\n     * -20:30.040    -2030.040   minute/second/milli\n     * -20:30        -2030       minute/second\n     * -20           -20         minute\n     * --30.040      --30.040    second/milli\n     * --30          --30        second\n     * ---.040       ---.040     milli *\n     * 10-30.040     10-30.040   hour/second/milli *\n     * 10:20-.040    1020-.040   hour/minute/milli *\n     * 10-30         10-30       hour/second *\n     * 10--.040      10--.040    hour/milli *\n     * -20-.040      -20-.040    minute/milli *\n     *   plus datetime formats like {date}T{time}\n     * </pre>\n     * * indiates that this is not an official ISO format and can be excluded\n     * by passing in <code>strictISO</code> as <code>true</code>.\n     * <p>\n     * This method can side effect the input collection of fields.\n     * If the input collection is modifiable, then each field that was added to\n     * the formatter will be removed from the collection, including any duplicates.\n     * If the input collection is unmodifiable then no side effect occurs.\n     * <p>\n     * This side effect processing is useful if you need to know whether all\n     * the fields were converted into the formatter or not. To achieve this,\n     * pass in a modifiable list, and check that it is empty on exit.\n     *\n     * @param fields  the fields to get a formatter for, not null,\n     *  updated by the method call unless unmodifiable,\n     *  removing those fields built in the formatter\n     * @param extended  true to use the extended format (with separators)\n     * @param strictISO  true to stick exactly to ISO8601, false to include additional formats\n     * @return a suitable formatter\n     * @throws IllegalArgumentException if there is no format for the fields\n     * @since 1.1\n     */"}}
{"code": {"body": "    private static boolean dateByMonth(\n        DateTimeFormatterBuilder bld,\n        Collection<DateTimeFieldType> fields,\n        boolean extended,\n        boolean strictISO) {\n        \n        boolean reducedPrec = false;\n        if (fields.remove(DateTimeFieldType.year())) {\n            bld.append(Constants.ye);\n            if (fields.remove(DateTimeFieldType.monthOfYear())) {\n                if (fields.remove(DateTimeFieldType.dayOfMonth())) {\n                    \n                    appendSeparator(bld, extended);\n                    bld.appendMonthOfYear(2);\n                    appendSeparator(bld, extended);\n                    bld.appendDayOfMonth(2);\n                } else {\n                    \n                    bld.appendLiteral('');\n                    bld.appendMonthOfYear(2);\n                    reducedPrec = true;\n                }\n            } else {\n                if (fields.remove(DateTimeFieldType.dayOfMonth())) {\n                    \n                    checkNotStrictISO(fields, strictISO);\n                    bld.appendLiteral('');\n                    bld.appendLiteral('');\n                    bld.appendDayOfMonth(2);\n                } else {\n                    \n                    reducedPrec = true;\n                }\n            }\n            \n        } else if (fields.remove(DateTimeFieldType.monthOfYear())) {\n            bld.appendLiteral('');\n            bld.appendLiteral('');\n            bld.appendMonthOfYear(2);\n            if (fields.remove(DateTimeFieldType.dayOfMonth())) {\n                \n                appendSeparator(bld, extended);\n                bld.appendDayOfMonth(2);\n            } else {\n                \n                reducedPrec = true;\n            }\n        } else if (fields.remove(DateTimeFieldType.dayOfMonth())) {\n            \n            bld.appendLiteral('');\n            bld.appendLiteral('');\n            bld.appendLiteral('');\n            bld.appendDayOfMonth(2);\n        }\n        return reducedPrec;\n    }", "comment": "/**\n     * Creates a date using the calendar date format.\n     * Specification reference: 5.2.1.\n     *\n     * @param bld  the builder\n     * @param fields  the fields\n     * @param extended  true to use extended format\n     * @param strictISO  true to only allow ISO formats\n     * @return true if reduced precision\n     * @since 1.1\n     */"}}
{"code": {"body": "    private static boolean dateByOrdinal(\n        DateTimeFormatterBuilder bld,\n        Collection<DateTimeFieldType> fields,\n        boolean extended,\n        boolean strictISO) {\n        \n        boolean reducedPrec = false;\n        if (fields.remove(DateTimeFieldType.year())) {\n            bld.append(Constants.ye);\n            if (fields.remove(DateTimeFieldType.dayOfYear())) {\n                \n                appendSeparator(bld, extended);\n                bld.appendDayOfYear(3);\n            } else {\n                \n                reducedPrec = true;\n            }\n            \n        } else if (fields.remove(DateTimeFieldType.dayOfYear())) {\n            \n            bld.appendLiteral('');\n            bld.appendDayOfYear(3);\n        }\n        return reducedPrec;\n    }", "comment": "/**\n     * Creates a date using the ordinal date format.\n     * Specification reference: 5.2.2.\n     *\n     * @param bld  the builder\n     * @param fields  the fields\n     * @param extended  true to use extended format\n     * @param strictISO  true to only allow ISO formats\n     * @since 1.1\n     */"}}
{"code": {"body": "    private static boolean dateByWeek(\n        DateTimeFormatterBuilder bld,\n        Collection<DateTimeFieldType> fields,\n        boolean extended,\n        boolean strictISO) {\n        \n        boolean reducedPrec = false;\n        if (fields.remove(DateTimeFieldType.weekyear())) {\n            bld.append(Constants.we);\n            if (fields.remove(DateTimeFieldType.weekOfWeekyear())) {\n                appendSeparator(bld, extended);\n                bld.appendLiteral('');\n                bld.appendWeekOfWeekyear(2);\n                if (fields.remove(DateTimeFieldType.dayOfWeek())) {\n                    \n                    appendSeparator(bld, extended);\n                    bld.appendDayOfWeek(1);\n                } else {\n                    \n                    reducedPrec = true;\n                }\n            } else {\n                if (fields.remove(DateTimeFieldType.dayOfWeek())) {\n                    \n                    checkNotStrictISO(fields, strictISO);\n                    appendSeparator(bld, extended);\n                    bld.appendLiteral('');\n                    bld.appendLiteral('');\n                    bld.appendDayOfWeek(1);\n                } else {\n                    \n                    reducedPrec = true;\n                }\n            }\n            \n        } else if (fields.remove(DateTimeFieldType.weekOfWeekyear())) {\n            bld.appendLiteral('');\n            bld.appendLiteral('');\n            bld.appendWeekOfWeekyear(2);\n            if (fields.remove(DateTimeFieldType.dayOfWeek())) {\n                \n                appendSeparator(bld, extended);\n                bld.appendDayOfWeek(1);\n            } else {\n                \n                reducedPrec = true;\n            }\n        } else if (fields.remove(DateTimeFieldType.dayOfWeek())) {\n            \n            bld.appendLiteral('');\n            bld.appendLiteral('');\n            bld.appendLiteral('');\n            bld.appendDayOfWeek(1);\n        }\n        return reducedPrec;\n    }", "comment": "/**\n     * Creates a date using the calendar date format.\n     * Specification reference: 5.2.3.\n     *\n     * @param bld  the builder\n     * @param fields  the fields\n     * @param extended  true to use extended format\n     * @param strictISO  true to only allow ISO formats\n     * @since 1.1\n     */"}}
{"code": {"body": "    private static void checkNotStrictISO(Collection<DateTimeFieldType> fields, boolean strictISO) {\n        if (strictISO) {\n            throw new IllegalArgumentException(\"\" + fields);\n        }\n    }", "comment": "/**\n     * Checks that the iso only flag is not set, throwing an exception if it is.\n     * \n     * @param fields  the fields\n     * @param strictISO  true if only ISO formats allowed\n     * @since 1.1\n     */"}}
{"code": {"body": "    private static void appendSeparator(DateTimeFormatterBuilder bld, boolean extended) {\n        if (extended) {\n            bld.appendLiteral('');\n        }\n    }", "comment": "/**\n     * Appends the separator if necessary.\n     *\n     * @param bld  the builder\n     * @param extended  whether to append the separator\n     * @param sep  the separator\n     * @since 1.1\n     */"}}
{"code": {"body": "    public static DateTimeFormatter date() {\n        return yearMonthDay();\n    }", "comment": "/**\n     * Returns a formatter for a full date as four digit year, two digit month\n     * of year, and two digit day of month (yyyy-MM-dd).\n     * \n     * @return a formatter for yyyy-MM-dd\n     */"}}
{"code": {"body": "    public static DateTimeFormatter weekDate() {\n        return Constants.wwd;\n    }", "comment": "/**\n     * Returns a formatter for a full date as four digit weekyear, two digit\n     * week of weekyear, and one digit day of week (xxxx-'W'ww-e).\n     * \n     * @return a formatter for xxxx-'W'ww-e\n     */"}}
{"code": {"body": "    public static DateTimeFormatter year() {\n        return Constants.ye;\n    }", "comment": "/**\n     * Returns a formatter for a four digit year. (yyyy)\n     * \n     * @return a formatter for yyyy\n     */"}}
{"code": {"body": "    public static DateTimeFormatter weekyear() {\n        return Constants.we;\n    }", "comment": "/**\n     * Returns a formatter for a four digit weekyear. (xxxx)\n     * \n     * @return a formatter for xxxx\n     */"}}
{"code": {"body": "    public static DateTimeFormatter hour() {\n        return Constants.hde;\n    }", "comment": "/**\n     * Returns a formatter for a two digit hour of day. (HH)\n     * \n     * @return a formatter for HH\n     */"}}
{"code": {"body": "    public static PeriodFormatter standard() {\n        if (cStandard == null) {\n            cStandard = new PeriodFormatterBuilder()\n                .appendLiteral(\"\")\n                .appendYears()\n                .appendSuffix(\"\")\n                .appendMonths()\n                .appendSuffix(\"\")\n                .appendWeeks()\n                .appendSuffix(\"\")\n                .appendDays()\n                .appendSuffix(\"\")\n                .appendSeparatorIfFieldsAfter(\"\")\n                .appendHours()\n                .appendSuffix(\"\")\n                .appendMinutes()\n                .appendSuffix(\"\")\n                .appendSecondsWithOptionalMillis()\n                .appendSuffix(\"\")\n                .toFormatter();\n        }\n        return cStandard;\n    }", "comment": "/**\n     * The standard ISO format - PyYmMwWdDThHmMsS.\n     * Milliseconds are not output.\n     * Note that the ISO8601 standard actually indicates weeks should not\n     * be shown if any other field is present and vice versa.\n     * \n     * @return the formatter\n     */"}}
{"code": {"body": "    public static PeriodFormatter alternate() {\n        if (cAlternate == null) {\n            cAlternate = new PeriodFormatterBuilder()\n                .appendLiteral(\"\")\n                .printZeroAlways()\n                .minimumPrintedDigits(4)\n                .appendYears()\n                .minimumPrintedDigits(2)\n                .appendMonths()\n                .appendDays()\n                .appendSeparatorIfFieldsAfter(\"\")\n                .appendHours()\n                .appendMinutes()\n                .appendSecondsWithOptionalMillis()\n                .toFormatter();\n        }\n        return cAlternate;\n    }", "comment": "/**\n     * The alternate ISO format, PyyyymmddThhmmss, which excludes weeks.\n     * <p>\n     * Even if weeks are present in the period, they are not output.\n     * Fractional seconds (milliseconds) will appear if required.\n     * \n     * @return the formatter\n     */"}}
{"code": {"body": "    public static PeriodFormatter alternateExtended() {\n        if (cAlternateExtended == null) {\n            cAlternateExtended = new PeriodFormatterBuilder()\n                .appendLiteral(\"\")\n                .printZeroAlways()\n                .minimumPrintedDigits(4)\n                .appendYears()\n                .appendSeparator(\"\")\n                .minimumPrintedDigits(2)\n                .appendMonths()\n                .appendSeparator(\"\")\n                .appendDays()\n                .appendSeparatorIfFieldsAfter(\"\")\n                .appendHours()\n                .appendSeparator(\"\")\n                .appendMinutes()\n                .appendSeparator(\"\")\n                .appendSecondsWithOptionalMillis()\n                .toFormatter();\n        }\n        return cAlternateExtended;\n    }", "comment": "/**\n     * The alternate ISO format, Pyyyy-mm-ddThh:mm:ss, which excludes weeks.\n     * <p>\n     * Even if weeks are present in the period, they are not output.\n     * Fractional seconds (milliseconds) will appear if required.\n     * \n     * @return the formatter\n     */"}}
{"code": {"body": "    public static PeriodFormatter alternateWithWeeks() {\n        if (cAlternateWithWeeks == null) {\n            cAlternateWithWeeks = new PeriodFormatterBuilder()\n                .appendLiteral(\"\")\n                .printZeroAlways()\n                .minimumPrintedDigits(4)\n                .appendYears()\n                .minimumPrintedDigits(2)\n                .appendPrefix(\"\")\n                .appendWeeks()\n                .appendDays()\n                .appendSeparatorIfFieldsAfter(\"\")\n                .appendHours()\n                .appendMinutes()\n                .appendSecondsWithOptionalMillis()\n                .toFormatter();\n        }\n        return cAlternateWithWeeks;\n    }", "comment": "/**\n     * The alternate ISO format, PyyyyWwwddThhmmss, which excludes months.\n     * <p>\n     * Even if months are present in the period, they are not output.\n     * Fractional seconds (milliseconds) will appear if required.\n     * \n     * @return the formatter\n     */"}}
{"code": {"body": "    public static PeriodFormatter alternateExtendedWithWeeks() {\n        if (cAlternateExtendedWihWeeks == null) {\n            cAlternateExtendedWihWeeks = new PeriodFormatterBuilder()\n                .appendLiteral(\"\")\n                .printZeroAlways()\n                .minimumPrintedDigits(4)\n                .appendYears()\n                .appendSeparator(\"\")\n                .minimumPrintedDigits(2)\n                .appendPrefix(\"\")\n                .appendWeeks()\n                .appendSeparator(\"\")\n                .appendDays()\n                .appendSeparatorIfFieldsAfter(\"\")\n                .appendHours()\n                .appendSeparator(\"\")\n                .appendMinutes()\n                .appendSeparator(\"\")\n                .appendSecondsWithOptionalMillis()\n                .toFormatter();\n        }\n        return cAlternateExtendedWihWeeks;\n    }", "comment": "/**\n     * The alternate ISO format, Pyyyy-Www-ddThh:mm:ss, which excludes months.\n     * <p>\n     * Even if months are present in the period, they are not output.\n     * Fractional seconds (milliseconds) will appear if required.\n     * \n     * @return the formatter\n     */"}}
{"code": {"body": "    public static PeriodFormatter getDefault() {\n        return wordBased(Locale.ENGLISH);\n    }", "comment": "/**\n     * Gets the default formatter that outputs words in English.\n     * <p>\n     * This calls {@link #wordBased(Locale)} using a locale of {@code ENGLISH}.\n     * \n     * @return the formatter, not null\n     */"}}
{"code": {"body": "    public static PeriodFormatter wordBased(Locale locale) {\n        PeriodFormatter pf = FORMATTERS.get(locale);\n        if (pf == null) {\n            ResourceBundle b = ResourceBundle.getBundle(BUNDLE_NAME, locale);\n            String[] variants = {\n                    b.getString(\"\"), b.getString(\"\"),\n                    b.getString(\"\"), b.getString(\"\")};\n            pf = new PeriodFormatterBuilder()\n                .appendYears()\n                .appendSuffix(b.getString(\"\"), b.getString(\"\"))\n                .appendSeparator(b.getString(\"\"), b.getString(\"\"), variants)\n                .appendMonths()\n                .appendSuffix(b.getString(\"\"), b.getString(\"\"))\n                .appendSeparator(b.getString(\"\"), b.getString(\"\"), variants)\n                .appendWeeks()\n                .appendSuffix(b.getString(\"\"), b.getString(\"\"))\n                .appendSeparator(b.getString(\"\"), b.getString(\"\"), variants)\n                .appendDays()\n                .appendSuffix(b.getString(\"\"), b.getString(\"\"))\n                .appendSeparator(b.getString(\"\"), b.getString(\"\"), variants)\n                .appendHours()\n                .appendSuffix(b.getString(\"\"), b.getString(\"\"))\n                .appendSeparator(b.getString(\"\"), b.getString(\"\"), variants)\n                .appendMinutes()\n                .appendSuffix(b.getString(\"\"), b.getString(\"\"))\n                .appendSeparator(b.getString(\"\"), b.getString(\"\"), variants)\n                .appendSeconds()\n                .appendSuffix(b.getString(\"\"), b.getString(\"\"))\n                .appendSeparator(b.getString(\"\"), b.getString(\"\"), variants)\n                .appendMillis()\n                .appendSuffix(b.getString(\"\"), b.getString(\"\"))\n                .toFormatter();\n            FORMATTERS.putIfAbsent(locale, pf);\n        }\n        return pf;\n    }", "comment": "/**\n     * Returns a word based formatter for the specified locale.\n     * <p>\n     * The words are configured in a resource bundle text file -\n     * {@code org.joda.time.format.messages}.\n     * This can be added to via the normal classpath resource bundle mechanisms.\n     * <p>\n     * Available languages are English, Danish, Dutch, French, German, Japanese, Portuguese, and Spanish.\n     * \n     * @return the formatter, not null\n     * @since 2.0\n     */"}}
{"code": {"body": "public PeriodFormatter withLocale(Locale locale) {\n        if (locale == getLocale() || (locale != null && locale.equals(getLocale()))) {\n            return this;\n        }\n        return new PeriodFormatter(iPrinter, iParser, locale, iParseType);\n    }", "comment": "/**\n     * Returns a new formatter with a different locale that will be used\n     * for printing and parsing.\n     * <p>\n     * A PeriodFormatter is immutable, so a new instance is returned,\n     * and the original is unaltered and still usable.\n     * \n     * @param locale  the locale to use\n     * @return the new formatter\n     */"}}
{"code": {"body": "public PeriodFormatter withParseType(PeriodType type) {\n        if (type == iParseType) {\n            return this;\n        }\n        return new PeriodFormatter(iPrinter, iParser, iLocale, type);\n    }", "comment": "/**\n     * Returns a new formatter with a different PeriodType for parsing.\n     * <p>\n     * A PeriodFormatter is immutable, so a new instance is returned,\n     * and the original is unaltered and still usable.\n     * \n     * @param type  the type to use in parsing\n     * @return the new formatter\n     */"}}
{"code": {"body": "    public boolean isPrinter() {\n        return (iPrinter != null);\n    }", "comment": "/**\n     * Is this formatter capable of printing.\n     * \n     * @return true if this is a printer\n     */"}}
{"code": {"body": "    public PeriodPrinter getPrinter() {\n        return iPrinter;\n    }", "comment": "/**\n     * Gets the internal printer object that performs the real printing work.\n     * \n     * @return the internal printer\n     */"}}
{"code": {"body": "    public boolean isParser() {\n        return (iParser != null);\n    }", "comment": "/**\n     * Is this formatter capable of parsing.\n     * \n     * @return true if this is a parser\n     */"}}
{"code": {"body": "    public PeriodParser getParser() {\n        return iParser;\n    }", "comment": "/**\n     * Gets the internal parser object that performs the real parsing work.\n     * \n     * @return the internal parser\n     */"}}
{"code": {"body": "    public PeriodFormatter withLocale(Locale locale) {\n        if (locale == getLocale() || (locale != null && locale.equals(getLocale()))) {\n            return this;\n        }\n        return new PeriodFormatter(iPrinter, iParser, locale, iParseType);\n    }", "comment": "/**\n     * Returns a new formatter with a different locale that will be used\n     * for printing and parsing.\n     * <p>\n     * A PeriodFormatter is immutable, so a new instance is returned,\n     * and the original is unaltered and still usable.\n     * \n     * @param locale  the locale to use\n     * @return the new formatter\n     */"}}
{"code": {"body": "    public Locale getLocale() {\n        return iLocale;\n    }", "comment": "/**\n     * Gets the locale that will be used for printing and parsing.\n     * \n     * @return the locale to use\n     */"}}
{"code": {"body": "    public PeriodFormatter withParseType(PeriodType type) {\n        if (type == iParseType) {\n            return this;\n        }\n        return new PeriodFormatter(iPrinter, iParser, iLocale, type);\n    }", "comment": "/**\n     * Returns a new formatter with a different PeriodType for parsing.\n     * <p>\n     * A PeriodFormatter is immutable, so a new instance is returned,\n     * and the original is unaltered and still usable.\n     * \n     * @param type  the type to use in parsing\n     * @return the new formatter\n     */"}}
{"code": {"body": "    public PeriodType getParseType() {\n        return iParseType;\n    }", "comment": "/**\n     * Gets the PeriodType that will be used for parsing.\n     * \n     * @return the parse type to use\n     */"}}
{"code": {"body": "    public void printTo(Writer out, ReadablePeriod period) throws IOException {\n        checkPrinter();\n        checkPeriod(period);\n        \n        getPrinter().printTo(out, period, iLocale);\n    }", "comment": "/**\n     * Prints a ReadablePeriod to a Writer.\n     *\n     * @param out  the formatted period is written out\n     * @param period  the period to format, not null\n     */"}}
{"code": {"body": "    public String print(ReadablePeriod period) {\n        checkPrinter();\n        checkPeriod(period);\n        \n        PeriodPrinter printer = getPrinter();\n        StringBuffer buf = new StringBuffer(printer.calculatePrintedLength(period, iLocale));\n        printer.printTo(buf, period, iLocale);\n        return buf.toString();\n    }", "comment": "/**\n     * Prints a ReadablePeriod to a new String.\n     *\n     * @param period  the period to format, not null\n     * @return the printed result\n     */"}}
{"code": {"body": "    private void checkPrinter() {\n        if (iPrinter == null) {\n            throw new UnsupportedOperationException(\"\");\n        }\n    }", "comment": "/**\n     * Checks whether printing is supported.\n     * \n     * @throws UnsupportedOperationException if printing is not supported\n     */"}}
{"code": {"body": "    private void checkPeriod(ReadablePeriod period) {\n        if (period == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n    }", "comment": "/**\n     * Checks whether the period is non-null.\n     * \n     * @throws IllegalArgumentException if the period is null\n     */"}}
{"code": {"body": "    public int parseInto(ReadWritablePeriod period, String text, int position) {\n        checkParser();\n        checkPeriod(period);\n        \n        return getParser().parseInto(period, text, position, iLocale);\n    }", "comment": "/**\n     * Parses a period from the given text, at the given position, saving the\n     * result into the fields of the given ReadWritablePeriod. If the parse\n     * succeeds, the return value is the new text position. Note that the parse\n     * may succeed without fully reading the text.\n     * <p>\n     * The parse type of the formatter is not used by this method.\n     * <p>\n     * If it fails, the return value is negative, but the period may still be\n     * modified. To determine the position where the parse failed, apply the\n     * one's complement operator (~) on the return value.\n     *\n     * @param period  a period that will be modified\n     * @param text  text to parse\n     * @param position position to start parsing from\n     * @return new position, if negative, parse failed. Apply complement\n     * operator (~) to get position of failure\n     * @throws IllegalArgumentException if any field is out of range\n     */"}}
{"code": {"body": "    public Period parsePeriod(String text) {\n        checkParser();\n        \n        return parseMutablePeriod(text).toPeriod();\n    }", "comment": "/**\n     * Parses a period from the given text, returning a new Period.\n     *\n     * @param text  text to parse\n     * @return parsed value in a Period object\n     * @throws IllegalArgumentException if any field is out of range\n     */"}}
{"code": {"body": "    public MutablePeriod parseMutablePeriod(String text) {\n        checkParser();\n        \n        MutablePeriod period = new MutablePeriod(0, iParseType);\n        int newPos = getParser().parseInto(period, text, 0, iLocale);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                return period;\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }", "comment": "/**\n     * Parses a period from the given text, returning a new MutablePeriod.\n     *\n     * @param text  text to parse\n     * @return parsed value in a MutablePeriod object\n     * @throws IllegalArgumentException if any field is out of range\n     */"}}
{"code": {"body": "    private void checkParser() {\n        if (iParser == null) {\n            throw new UnsupportedOperationException(\"\");\n        }\n    }", "comment": "/**\n     * Checks whether parsing is supported.\n     * \n     * @throws UnsupportedOperationException if parsing is not supported\n     */"}}
{"code": {"body": "public PeriodFormatterBuilder append(PeriodFormatter formatter) {\n        if (formatter == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        clearPrefix();\n        append0(formatter.getPrinter(), formatter.getParser());\n        return this;\n    }", "comment": "/**\n     * Appends another formatter.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "public PeriodFormatterBuilder append(PeriodPrinter printer, PeriodParser parser) {\n        if (printer == null && parser == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        clearPrefix();\n        append0(printer, parser);\n        return this;\n    }", "comment": "/**\n     * Appends a printer parser pair.\n     * <p>\n     * Either the printer or the parser may be null, in which case the builder will\n     * be unable to produce a parser or printer repectively.\n     *\n     * @param printer  appends a printer to the builder, null if printing is not supported\n     * @param parser  appends a parser to the builder, null if parsing is not supported\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalArgumentException if both the printer and parser are null\n     */"}}
{"code": {"body": "public PeriodFormatterBuilder appendLiteral(String text) {\n        if (text == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        clearPrefix();\n        Literal literal = new Literal(text);\n        append0(literal, literal);\n        return this;\n    }", "comment": "/**\n     * Instructs the printer to emit specific text, and the parser to expect it.\n     * The parser is case-insensitive.\n     *\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalArgumentException if text is null\n     */"}}
{"code": {"body": "public PeriodFormatterBuilder minimumPrintedDigits(int minDigits) {\n        iMinPrintedDigits = minDigits;\n        return this;\n    }", "comment": "/**\n     * Set the minimum digits printed for the next and following appended\n     * fields. By default, the minimum digits printed is one. If the field value\n     * is zero, it is not printed unless a printZero rule is applied.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "public PeriodFormatterBuilder maximumParsedDigits(int maxDigits) {\n        iMaxParsedDigits = maxDigits;\n        return this;\n    }", "comment": "/**\n     * Set the maximum digits parsed for the next and following appended\n     * fields. By default, the maximum digits parsed is ten.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "public PeriodFormatterBuilder rejectSignedValues(boolean v) {\n        iRejectSignedValues = v;\n        return this;\n    }", "comment": "/**\n     * Reject signed values when parsing the next and following appended fields.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "public PeriodFormatterBuilder printZeroRarelyLast() {\n        iPrintZeroSetting = PRINT_ZERO_RARELY_LAST;\n        return this;\n    }", "comment": "/**\n     * Never print zero values for the next and following appended fields,\n     * unless no fields would be printed. If no fields are printed, the printer\n     * forces the last \"printZeroRarely\" field to print a zero.\n     * <p>\n     * This field setting is the default.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "public PeriodFormatterBuilder printZeroRarelyFirst() {\n        iPrintZeroSetting = PRINT_ZERO_RARELY_FIRST;\n        return this;\n    }", "comment": "/**\n     * Never print zero values for the next and following appended fields,\n     * unless no fields would be printed. If no fields are printed, the printer\n     * forces the first \"printZeroRarely\" field to print a zero.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "public PeriodFormatterBuilder printZeroIfSupported() {\n        iPrintZeroSetting = PRINT_ZERO_IF_SUPPORTED;\n        return this;\n    }", "comment": "/**\n     * Print zero values for the next and following appened fields only if the\n     * period supports it.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "public PeriodFormatterBuilder printZeroAlways() {\n        iPrintZeroSetting = PRINT_ZERO_ALWAYS;\n        return this;\n    }", "comment": "/**\n     * Always print zero values for the next and following appended fields,\n     * even if the period doesn't support it. The parser requires values for\n     * fields that always print zero.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "public PeriodFormatterBuilder printZeroNever() {\n        iPrintZeroSetting = PRINT_ZERO_NEVER;\n        return this;\n    }", "comment": "/**\n     * Never print zero values for the next and following appended fields,\n     * unless no fields would be printed. If no fields are printed, the printer\n     * forces the last \"printZeroRarely\" field to print a zero.\n     * <p>\n     * This field setting is the default.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "public PeriodFormatterBuilder appendPrefix(String text) {\n        if (text == null) {\n            throw new IllegalArgumentException();\n        }\n        return appendPrefix(new SimpleAffix(text));\n    }", "comment": "/**\n     * Append a field prefix which applies only to the next appended field. If\n     * the field is not printed, neither is the prefix.\n     *\n     * @param text text to print before field only if field is printed\n     * @return this PeriodFormatterBuilder\n     * @see #appendSuffix\n     */"}}
{"code": {"body": "public PeriodFormatterBuilder appendPrefix(String singularText,", "comment": "/**\n     * Append a field prefix which applies only to the next appended field. If\n     * the field is not printed, neither is the prefix.\n     * <p>\n     * During parsing, the singular and plural versions are accepted whether\n     * or not the actual value matches plurality.\n     *\n     * @param singularText text to print if field value is one\n     * @param pluralText text to print if field value is not one\n     * @return this PeriodFormatterBuilder\n     * @see #appendSuffix\n     */"}}
{"code": {"body": "public PeriodFormatterBuilder appendYears() {\n        appendField(YEARS);\n        return this;\n    }", "comment": "/**\n     * Instruct the printer to emit an integer years field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "public PeriodFormatterBuilder appendMonths() {\n        appendField(MONTHS);\n        return this;\n    }", "comment": "/**\n     * Instruct the printer to emit an integer months field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "public PeriodFormatterBuilder appendWeeks() {\n        appendField(WEEKS);\n        return this;\n    }", "comment": "/**\n     * Instruct the printer to emit an integer weeks field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "public PeriodFormatterBuilder appendDays() {\n        appendField(DAYS);\n        return this;\n    }", "comment": "/**\n     * Instruct the printer to emit an integer days field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "public PeriodFormatterBuilder appendHours() {\n        appendField(HOURS);\n        return this;\n    }", "comment": "/**\n     * Instruct the printer to emit an integer hours field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "public PeriodFormatterBuilder appendMinutes() {\n        appendField(MINUTES);\n        return this;\n    }", "comment": "/**\n     * Instruct the printer to emit an integer minutes field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "public PeriodFormatterBuilder appendSeconds() {\n        appendField(SECONDS);\n        return this;\n    }", "comment": "/**\n     * Instruct the printer to emit an integer seconds field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "public PeriodFormatterBuilder appendSecondsWithMillis() {\n        appendField(SECONDS_MILLIS);\n        return this;\n    }", "comment": "/**\n     * Instruct the printer to emit a combined seconds and millis field, if supported.\n     * The millis will overflow into the seconds if necessary.\n     * The millis are always output.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "public PeriodFormatterBuilder appendSecondsWithOptionalMillis() {\n        appendField(SECONDS_OPTIONAL_MILLIS);\n        return this;\n    }", "comment": "/**\n     * Instruct the printer to emit a combined seconds and millis field, if supported.\n     * The millis will overflow into the seconds if necessary.\n     * The millis are only output if non-zero.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "public PeriodFormatterBuilder appendMillis() {\n        appendField(MILLIS);\n        return this;\n    }", "comment": "/**\n     * Instruct the printer to emit an integer millis field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "public PeriodFormatterBuilder appendMillis3Digit() {\n        appendField(7, 3);\n        return this;\n    }", "comment": "/**\n     * Instruct the printer to emit an integer millis field, if supported.\n     * <p>\n     * The number of arsed digits can be controlled using {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "public PeriodFormatterBuilder appendSuffix(String text) {\n        if (text == null) {\n            throw new IllegalArgumentException();\n        }\n        return appendSuffix(new SimpleAffix(text));\n    }", "comment": "/**\n     * Append a field suffix which applies only to the last appended field. If\n     * the field is not printed, neither is the suffix.\n     *\n     * @param text text to print after field only if field is printed\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if no field exists to append to\n     * @see #appendPrefix\n     */"}}
{"code": {"body": "public PeriodFormatterBuilder appendSuffix(String singularText,", "comment": "/**\n     * Append a field suffix which applies only to the last appended field. If\n     * the field is not printed, neither is the suffix.\n     * <p>\n     * During parsing, the singular and plural versions are accepted whether or\n     * not the actual value matches plurality.\n     *\n     * @param singularText text to print if field value is one\n     * @param pluralText text to print if field value is not one\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if no field exists to append to\n     * @see #appendPrefix\n     */"}}
{"code": {"body": "public PeriodFormatterBuilder appendSeparator(String text) {\n        return appendSeparator(text, text, null, true, true);\n    }", "comment": "/**\n     * Append a separator, which is output if fields are printed both before\n     * and after the separator.\n     * <p>\n     * For example, <code>builder.appendDays().appendSeparator(\",\").appendHours()</code>\n     * will only output the comma if both the days and hours fields are output.\n     * <p>\n     * The text will be parsed case-insensitively.\n     * <p>\n     * Note: appending a separator discontinues any further work on the latest\n     * appended field.\n     *\n     * @param text  the text to use as a separator\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if this separator follows a previous one\n     */"}}
{"code": {"body": "public PeriodFormatterBuilder appendSeparatorIfFieldsAfter(String text) {\n        return appendSeparator(text, text, null, false, true);\n    }", "comment": "/**\n     * Append a separator, which is output only if fields are printed after the separator.\n     * <p>\n     * For example,\n     * <code>builder.appendDays().appendSeparatorIfFieldsAfter(\",\").appendHours()</code>\n     * will only output the comma if the hours fields is output.\n     * <p>\n     * The text will be parsed case-insensitively.\n     * <p>\n     * Note: appending a separator discontinues any further work on the latest\n     * appended field.\n     *\n     * @param text  the text to use as a separator\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if this separator follows a previous one\n     */"}}
{"code": {"body": "public PeriodFormatterBuilder appendSeparatorIfFieldsBefore(String text) {\n        return appendSeparator(text, text, null, true, false);\n    }", "comment": "/**\n     * Append a separator, which is output only if fields are printed before the separator.\n     * <p>\n     * For example,\n     * <code>builder.appendDays().appendSeparatorIfFieldsBefore(\",\").appendHours()</code>\n     * will only output the comma if the days fields is output.\n     * <p>\n     * The text will be parsed case-insensitively.\n     * <p>\n     * Note: appending a separator discontinues any further work on the latest\n     * appended field.\n     *\n     * @param text  the text to use as a separator\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if this separator follows a previous one\n     */"}}
{"code": {"body": "public PeriodFormatterBuilder appendSeparator(String text, String finalText) {\n        return appendSeparator(text, finalText, null, true, true);\n    }", "comment": "/**\n     * Append a separator, which is output if fields are printed both before\n     * and after the separator.\n     * <p>\n     * This method changes the separator depending on whether it is the last separator\n     * to be output.\n     * <p>\n     * For example, <code>builder.appendDays().appendSeparator(\",\", \"&\").appendHours().appendSeparator(\",\", \"&\").appendMinutes()</code>\n     * will output '1,2&3' if all three fields are output, '1&2' if two fields are output\n     * and '1' if just one field is output.\n     * <p>\n     * The text will be parsed case-insensitively.\n     * <p>\n     * Note: appending a separator discontinues any further work on the latest\n     * appended field.\n     *\n     * @param text  the text to use as a separator\n     * @param finalText  the text used used if this is the final separator to be printed\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if this separator follows a previous one\n     */"}}
{"code": {"body": "public PeriodFormatterBuilder appendSeparator(String text, String finalText)", "comment": "/**\n     * Append a separator, which is output if fields are printed both before\n     * and after the separator.\n     * <p>\n     * This method changes the separator depending on whether it is the last separator\n     * to be output.\n     * <p>\n     * For example, <code>builder.appendDays().appendSeparator(\",\", \"&\").appendHours().appendSeparator(\",\", \"&\").appendMinutes()</code>\n     * will output '1,2&3' if all three fields are output, '1&2' if two fields are output\n     * and '1' if just one field is output.\n     * <p>\n     * The text will be parsed case-insensitively.\n     * <p>\n     * Note: appending a separator discontinues any further work on the latest\n     * appended field.\n     *\n     * @param text  the text to use as a separator\n     * @param finalText  the text used used if this is the final separator to be printed\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if this separator follows a previous one\n     */"}}
{"code": {"body": "    public PeriodPrinter toPrinter() {\n        if (iNotPrinter) {\n            return null;\n        }\n        return toFormatter().getPrinter();\n    }", "comment": "/**\n     * Internal method to create a PeriodPrinter instance using all the\n     * appended elements.\n     * <p>\n     * Most applications will not use this method.\n     * If you want a printer in an application, call {@link #toFormatter()}\n     * and just use the printing API.\n     * <p>\n     * Subsequent changes to this builder do not affect the returned printer.\n     * \n     * @return the newly created printer, null if builder cannot create a printer\n     */"}}
{"code": {"body": "    public PeriodParser toParser() {\n        if (iNotParser) {\n            return null;\n        }\n        return toFormatter().getParser();\n    }", "comment": "/**\n     * Internal method to create a PeriodParser instance using all the\n     * appended elements.\n     * <p>\n     * Most applications will not use this method.\n     * If you want a printer in an application, call {@link #toFormatter()}\n     * and just use the printing API.\n     * <p>\n     * Subsequent changes to this builder do not affect the returned parser.\n     * \n     * @return the newly created parser, null if builder cannot create a parser\n     */"}}
{"code": {"body": "    public void clear() {\n        iMinPrintedDigits = 1;\n        iPrintZeroSetting = PRINT_ZERO_RARELY_LAST;\n        iMaxParsedDigits = 10;\n        iRejectSignedValues = false;\n        iPrefix = null;\n        if (iElementPairs == null) {\n            iElementPairs = new ArrayList<Object>();\n        } else {\n            iElementPairs.clear();\n        }\n        iNotPrinter = false;\n        iNotParser = false;\n        iFieldFormatters = new FieldFormatter[10];\n    }", "comment": "/**\n     * Clears out all the appended elements, allowing this builder to be reused.\n     */"}}
{"code": {"body": "    public PeriodFormatterBuilder append(PeriodPrinter printer, PeriodParser parser) {\n        if (printer == null && parser == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        clearPrefix();\n        append0(printer, parser);\n        return this;\n    }", "comment": "/**\n     * Appends a printer parser pair.\n     * <p>\n     * Either the printer or the parser may be null, in which case the builder will\n     * be unable to produce a parser or printer repectively.\n     *\n     * @param printer  appends a printer to the builder, null if printing is not supported\n     * @param parser  appends a parser to the builder, null if parsing is not supported\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalArgumentException if both the printer and parser are null\n     */"}}
{"code": {"body": "    public PeriodFormatterBuilder appendLiteral(String text) {\n        if (text == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        clearPrefix();\n        Literal literal = new Literal(text);\n        append0(literal, literal);\n        return this;\n    }", "comment": "/**\n     * Instructs the printer to emit specific text, and the parser to expect it.\n     * The parser is case-insensitive.\n     *\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalArgumentException if text is null\n     */"}}
{"code": {"body": "    public PeriodFormatterBuilder minimumPrintedDigits(int minDigits) {\n        iMinPrintedDigits = minDigits;\n        return this;\n    }", "comment": "/**\n     * Set the minimum digits printed for the next and following appended\n     * fields. By default, the minimum digits printed is one. If the field value\n     * is zero, it is not printed unless a printZero rule is applied.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "    public PeriodFormatterBuilder maximumParsedDigits(int maxDigits) {\n        iMaxParsedDigits = maxDigits;\n        return this;\n    }", "comment": "/**\n     * Set the maximum digits parsed for the next and following appended\n     * fields. By default, the maximum digits parsed is ten.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "    public PeriodFormatterBuilder rejectSignedValues(boolean v) {\n        iRejectSignedValues = v;\n        return this;\n    }", "comment": "/**\n     * Reject signed values when parsing the next and following appended fields.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "    public PeriodFormatterBuilder printZeroRarelyLast() {\n        iPrintZeroSetting = PRINT_ZERO_RARELY_LAST;\n        return this;\n    }", "comment": "/**\n     * Never print zero values for the next and following appended fields,\n     * unless no fields would be printed. If no fields are printed, the printer\n     * forces the last \"printZeroRarely\" field to print a zero.\n     * <p>\n     * This field setting is the default.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "    public PeriodFormatterBuilder printZeroRarelyFirst() {\n        iPrintZeroSetting = PRINT_ZERO_RARELY_FIRST;\n        return this;\n    }", "comment": "/**\n     * Never print zero values for the next and following appended fields,\n     * unless no fields would be printed. If no fields are printed, the printer\n     * forces the first \"printZeroRarely\" field to print a zero.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "    public PeriodFormatterBuilder printZeroIfSupported() {\n        iPrintZeroSetting = PRINT_ZERO_IF_SUPPORTED;\n        return this;\n    }", "comment": "/**\n     * Print zero values for the next and following appened fields only if the\n     * period supports it.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "    public PeriodFormatterBuilder printZeroAlways() {\n        iPrintZeroSetting = PRINT_ZERO_ALWAYS;\n        return this;\n    }", "comment": "/**\n     * Always print zero values for the next and following appended fields,\n     * even if the period doesn't support it. The parser requires values for\n     * fields that always print zero.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "    public PeriodFormatterBuilder printZeroNever() {\n        iPrintZeroSetting = PRINT_ZERO_NEVER;\n        return this;\n    }", "comment": "/**\n     * Never print zero values for the next and following appended fields,\n     * unless no fields would be printed. If no fields are printed, the printer\n     * forces the last \"printZeroRarely\" field to print a zero.\n     * <p>\n     * This field setting is the default.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "    private PeriodFormatterBuilder appendPrefix(PeriodFieldAffix prefix) {\n        if (prefix == null) {\n            throw new IllegalArgumentException();\n        }\n        if (iPrefix != null) {\n            prefix = new CompositeAffix(iPrefix, prefix);\n        }\n        iPrefix = prefix;\n        return this;\n    }", "comment": "/**\n     * Append a field prefix which applies only to the next appended field. If\n     * the field is not printed, neither is the prefix.\n     *\n     * @param prefix custom prefix\n     * @return this PeriodFormatterBuilder\n     * @see #appendSuffix\n     */"}}
{"code": {"body": "    public PeriodFormatterBuilder appendYears() {\n        appendField(YEARS);\n        return this;\n    }", "comment": "/**\n     * Instruct the printer to emit an integer years field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "    public PeriodFormatterBuilder appendMonths() {\n        appendField(MONTHS);\n        return this;\n    }", "comment": "/**\n     * Instruct the printer to emit an integer months field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "    public PeriodFormatterBuilder appendWeeks() {\n        appendField(WEEKS);\n        return this;\n    }", "comment": "/**\n     * Instruct the printer to emit an integer weeks field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "    public PeriodFormatterBuilder appendDays() {\n        appendField(DAYS);\n        return this;\n    }", "comment": "/**\n     * Instruct the printer to emit an integer days field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "    public PeriodFormatterBuilder appendHours() {\n        appendField(HOURS);\n        return this;\n    }", "comment": "/**\n     * Instruct the printer to emit an integer hours field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "    public PeriodFormatterBuilder appendMinutes() {\n        appendField(MINUTES);\n        return this;\n    }", "comment": "/**\n     * Instruct the printer to emit an integer minutes field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "    public PeriodFormatterBuilder appendSeconds() {\n        appendField(SECONDS);\n        return this;\n    }", "comment": "/**\n     * Instruct the printer to emit an integer seconds field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "    public PeriodFormatterBuilder appendSecondsWithMillis() {\n        appendField(SECONDS_MILLIS);\n        return this;\n    }", "comment": "/**\n     * Instruct the printer to emit a combined seconds and millis field, if supported.\n     * The millis will overflow into the seconds if necessary.\n     * The millis are always output.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "    public PeriodFormatterBuilder appendSecondsWithOptionalMillis() {\n        appendField(SECONDS_OPTIONAL_MILLIS);\n        return this;\n    }", "comment": "/**\n     * Instruct the printer to emit a combined seconds and millis field, if supported.\n     * The millis will overflow into the seconds if necessary.\n     * The millis are only output if non-zero.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "    public PeriodFormatterBuilder appendMillis() {\n        appendField(MILLIS);\n        return this;\n    }", "comment": "/**\n     * Instruct the printer to emit an integer millis field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "    public PeriodFormatterBuilder appendMillis3Digit() {\n        appendField(7, 3);\n        return this;\n    }", "comment": "/**\n     * Instruct the printer to emit an integer millis field, if supported.\n     * <p>\n     * The number of arsed digits can be controlled using {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */"}}
{"code": {"body": "    private PeriodFormatterBuilder appendSuffix(PeriodFieldAffix suffix) {\n        final Object originalPrinter;\n        final Object originalParser;\n        if (iElementPairs.size() > 0) {\n            originalPrinter = iElementPairs.get(iElementPairs.size() - 2);\n            originalParser = iElementPairs.get(iElementPairs.size() - 1);\n        } else {\n            originalPrinter = null;\n            originalParser = null;\n        }\n\n        if (originalPrinter == null || originalParser == null ||\n                originalPrinter != originalParser ||\n                !(originalPrinter instanceof FieldFormatter)) {\n            throw new IllegalStateException(\"\");\n        }\n\n        clearPrefix();\n        FieldFormatter newField = new FieldFormatter((FieldFormatter) originalPrinter, suffix);\n        iElementPairs.set(iElementPairs.size() - 2, newField);\n        iElementPairs.set(iElementPairs.size() - 1, newField);\n        iFieldFormatters[newField.getFieldType()] = newField;\n        \n        return this;\n    }", "comment": "/**\n     * Append a field suffix which applies only to the last appended field. If\n     * the field is not printed, neither is the suffix.\n     *\n     * @param suffix custom suffix\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if no field exists to append to\n     * @see #appendPrefix\n     */"}}
{"code": {"body": "    public PeriodFormatterBuilder appendSeparatorIfFieldsAfter(String text) {\n        return appendSeparator(text, text, null, false, true);\n    }", "comment": "/**\n     * Append a separator, which is output only if fields are printed after the separator.\n     * <p>\n     * For example,\n     * <code>builder.appendDays().appendSeparatorIfFieldsAfter(\",\").appendHours()</code>\n     * will only output the comma if the hours fields is output.\n     * <p>\n     * The text will be parsed case-insensitively.\n     * <p>\n     * Note: appending a separator discontinues any further work on the latest\n     * appended field.\n     *\n     * @param text  the text to use as a separator\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if this separator follows a previous one\n     */"}}
{"code": {"body": "    public PeriodFormatterBuilder appendSeparatorIfFieldsBefore(String text) {\n        return appendSeparator(text, text, null, true, false);\n    }", "comment": "/**\n     * Append a separator, which is output only if fields are printed before the separator.\n     * <p>\n     * For example,\n     * <code>builder.appendDays().appendSeparatorIfFieldsBefore(\",\").appendHours()</code>\n     * will only output the comma if the days fields is output.\n     * <p>\n     * The text will be parsed case-insensitively.\n     * <p>\n     * Note: appending a separator discontinues any further work on the latest\n     * appended field.\n     *\n     * @param text  the text to use as a separator\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if this separator follows a previous one\n     */"}}
{"code": {"body": "        private int parseInt(String text, int position, int length) {\n            if (length >= 10) {\n                \n                return Integer.parseInt(text.substring(position, position + length));\n            }\n            if (length <= 0) {\n                return 0;\n            }\n            int value = text.charAt(position++);\n            length--;\n            boolean negative;\n            if (value == '') {\n                if (--length < 0) {\n                    return 0;\n                }\n                negative = true;\n                value = text.charAt(position++);\n            } else {\n                negative = false;\n            }\n            value -= '';\n            while (length-- > 0) {\n                value = ((value << 3) + (value << 1)) + text.charAt(position++) - '';\n            }\n            return negative ? -value : value;\n        }", "comment": "/**\n         * @param text text to parse\n         * @param position position in text\n         * @param length exact count of characters to parse\n         * @return parsed int value\n         */"}}
{"code": {"body": "        long getFieldValue(ReadablePeriod period) {\n            PeriodType type;\n            if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) {\n                type = null; \n            } else {\n                type = period.getPeriodType();\n            }\n            if (type != null && isSupported(type, iFieldType) == false) {\n                return Long.MAX_VALUE;\n            }\n\n            long value;\n\n            switch (iFieldType) {\n            default:\n                return Long.MAX_VALUE;\n            case YEARS:\n                value = period.get(DurationFieldType.years());\n                break;\n            case MONTHS:\n                value = period.get(DurationFieldType.months());\n                break;\n            case WEEKS:\n                value = period.get(DurationFieldType.weeks());\n                break;\n            case DAYS:\n                value = period.get(DurationFieldType.days());\n                break;\n            case HOURS:\n                value = period.get(DurationFieldType.hours());\n                break;\n            case MINUTES:\n                value = period.get(DurationFieldType.minutes());\n                break;\n            case SECONDS:\n                value = period.get(DurationFieldType.seconds());\n                break;\n            case MILLIS:\n                value = period.get(DurationFieldType.millis());\n                break;\n            case SECONDS_MILLIS: \n            case SECONDS_OPTIONAL_MILLIS:\n                int seconds = period.get(DurationFieldType.seconds());\n                int millis = period.get(DurationFieldType.millis());\n                value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis;\n                break;\n            }\n\n            \n            if (value == 0) {\n                switch (iPrintZeroSetting) {\n                case PRINT_ZERO_NEVER:\n                    return Long.MAX_VALUE;\n                case PRINT_ZERO_RARELY_LAST:\n                    if (isZero(period) && iFieldFormatters[iFieldType] == this) {\n                        for (int i = iFieldType + 1; i <= MAX_FIELD; i++) {\n                            if (isSupported(type, i) && iFieldFormatters[i] != null) {\n                                return Long.MAX_VALUE;\n                            }\n                        }\n                    } else {\n                        return Long.MAX_VALUE;\n                    }\n                    break;\n                case PRINT_ZERO_RARELY_FIRST:\n                    if (isZero(period) && iFieldFormatters[iFieldType] == this) {\n                        int i = Math.min(iFieldType, 8);  \n                        i--;                              \n                        for (; i >= 0 && i <= MAX_FIELD; i--) {\n                            if (isSupported(type, i) && iFieldFormatters[i] != null) {\n                                return Long.MAX_VALUE;\n                            }\n                        }\n                    } else {\n                        return Long.MAX_VALUE;\n                    }\n                    break;\n                }\n            }\n\n            return value;\n        }", "comment": "/**\n         * @return Long.MAX_VALUE if nothing to print, otherwise value\n         */"}}
{"code": {"body": "    public static CachedDateTimeZone forZone(DateTimeZone zone) {\n        if (zone instanceof CachedDateTimeZone) {\n            return (CachedDateTimeZone)zone;\n        }\n        return new CachedDateTimeZone(zone);\n    }", "comment": "/**\n     * Returns a new CachedDateTimeZone unless given zone is already cached.\n     */"}}
{"code": {"body": "    public DateTimeZone getUncachedZone() {\n        return iZone;\n    }", "comment": "/**\n     * Returns the DateTimeZone being wrapped.\n     */"}}
{"code": {"body": "public DateTimeZoneBuilder addCutover(int year,", "comment": "/**\n     * Adds a cutover for added rules. The standard offset at the cutover\n     * defaults to 0. Call setStandardOffset afterwards to change it.\n     *\n     * @param year  the year of cutover\n     * @param mode 'u' - cutover is measured against UTC, 'w' - against wall\n     *  offset, 's' - against standard offset\n     * @param monthOfYear  the month from 1 (January) to 12 (December)\n     * @param dayOfMonth  if negative, set to ((last day of month) - ~dayOfMonth).\n     *  For example, if -1, set to last day of month\n     * @param dayOfWeek  from 1 (Monday) to 7 (Sunday), if 0 then ignore\n     * @param advanceDayOfWeek  if dayOfMonth does not fall on dayOfWeek, advance to\n     *  dayOfWeek when true, retreat when false.\n     * @param millisOfDay  additional precision for specifying time of day of cutover\n     */"}}
{"code": {"body": "public DateTimeZoneBuilder setStandardOffset(int standardOffset) {\n        getLastRuleSet().setStandardOffset(standardOffset);\n        return this;\n    }", "comment": "/**\n     * Sets the standard offset to use for newly added rules until the next\n     * cutover is added.\n     * @param standardOffset  the standard offset in millis\n     */"}}
{"code": {"body": "public DateTimeZoneBuilder setFixedSavings(String nameKey, int saveMillis) {\n        getLastRuleSet().setFixedSavings(nameKey, saveMillis);\n        return this;\n    }", "comment": "/**\n     * Set a fixed savings rule at the cutover.\n     */"}}
{"code": {"body": "public DateTimeZoneBuilder addRecurringSavings(String nameKey, int saveMillis,", "comment": "/**\n     * Add a recurring daylight saving time rule.\n     *\n     * @param nameKey  the name key of new rule\n     * @param saveMillis  the milliseconds to add to standard offset\n     * @param fromYear  the first year that rule is in effect, MIN_VALUE indicates\n     * beginning of time\n     * @param toYear  the last year (inclusive) that rule is in effect, MAX_VALUE\n     *  indicates end of time\n     * @param mode  'u' - transitions are calculated against UTC, 'w' -\n     *  transitions are calculated against wall offset, 's' - transitions are\n     *  calculated against standard offset\n     * @param monthOfYear  the month from 1 (January) to 12 (December)\n     * @param dayOfMonth  if negative, set to ((last day of month) - ~dayOfMonth).\n     *  For example, if -1, set to last day of month\n     * @param dayOfWeek  from 1 (Monday) to 7 (Sunday), if 0 then ignore\n     * @param advanceDayOfWeek  if dayOfMonth does not fall on dayOfWeek, advance to\n     *  dayOfWeek when true, retreat when false.\n     * @param millisOfDay  additional precision for specifying time of day of transitions\n     */"}}
{"code": {"body": "    static void writeMillis(DataOutput out, long millis) throws IOException {\n        if (millis % (30 * 60000L) == 0) {\n            \n            long units = millis / (30 * 60000L);\n            if (((units << (64 - 6)) >> (64 - 6)) == units) {\n                \n                out.writeByte((int)(units & 0x3f));\n                return;\n            }\n        }\n\n        if (millis % 60000L == 0) {\n            \n            long minutes = millis / 60000L;\n            if (((minutes << (64 - 30)) >> (64 - 30)) == minutes) {\n                \n                out.writeInt(0x40000000 | (int)(minutes & 0x3fffffff));\n                return;\n            }\n        }\n        \n        if (millis % 1000L == 0) {\n            \n            long seconds = millis / 1000L;\n            if (((seconds << (64 - 38)) >> (64 - 38)) == seconds) {\n                \n                out.writeByte(0x80 | (int)((seconds >> 32) & 0x3f));\n                out.writeInt((int)(seconds & 0xffffffff));\n                return;\n            }\n        }\n\n        \n        \n        \n        \n        out.writeByte(millis < 0 ? 0xff : 0xc0);\n        out.writeLong(millis);\n    }", "comment": "/**\n     * Millisecond encoding formats:\n     *\n     * upper two bits  units       field length  approximate range\n     * ---------------------------------------------------------------\n     * 00              30 minutes  1 byte        +/- 16 hours\n     * 01              minutes     4 bytes       +/- 1020 years\n     * 10              seconds     5 bytes       +/- 4355 years\n     * 11              millis      9 bytes       +/- 292,000,000 years\n     *\n     * Remaining bits in field form signed offset from 1970-01-01T00:00:00Z.\n     */"}}
{"code": {"body": "    static long readMillis(DataInput in) throws IOException {\n        int v = in.readUnsignedByte();\n        switch (v >> 6) {\n        case 0: default:\n            \n            v = (v << (32 - 6)) >> (32 - 6);\n            return v * (30 * 60000L);\n\n        case 1:\n            \n            v = (v << (32 - 6)) >> (32 - 30);\n            v |= (in.readUnsignedByte()) << 16;\n            v |= (in.readUnsignedByte()) << 8;\n            v |= (in.readUnsignedByte());\n            return v * 60000L;\n\n        case 2:\n            \n            long w = (((long)v) << (64 - 6)) >> (64 - 38);\n            w |= (in.readUnsignedByte()) << 24;\n            w |= (in.readUnsignedByte()) << 16;\n            w |= (in.readUnsignedByte()) << 8;\n            w |= (in.readUnsignedByte());\n            return w * 1000L;\n\n        case 3:\n            \n            return in.readLong();\n        }\n    }", "comment": "/**\n     * Reads encoding generated by writeMillis.\n     */"}}
{"code": {"body": "    public DateTimeZoneBuilder addCutover(int year,\n                                          char mode,\n                                          int monthOfYear,\n                                          int dayOfMonth,\n                                          int dayOfWeek,\n                                          boolean advanceDayOfWeek,\n                                          int millisOfDay)\n    {\n        if (iRuleSets.size() > 0) {\n            OfYear ofYear = new OfYear\n                (mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay);\n            RuleSet lastRuleSet = iRuleSets.get(iRuleSets.size() - 1);\n            lastRuleSet.setUpperLimit(year, ofYear);\n        }\n        iRuleSets.add(new RuleSet());\n        return this;\n    }", "comment": "/**\n     * Adds a cutover for added rules. The standard offset at the cutover\n     * defaults to 0. Call setStandardOffset afterwards to change it.\n     *\n     * @param year  the year of cutover\n     * @param mode 'u' - cutover is measured against UTC, 'w' - against wall\n     *  offset, 's' - against standard offset\n     * @param monthOfYear  the month from 1 (January) to 12 (December)\n     * @param dayOfMonth  if negative, set to ((last day of month) - ~dayOfMonth).\n     *  For example, if -1, set to last day of month\n     * @param dayOfWeek  from 1 (Monday) to 7 (Sunday), if 0 then ignore\n     * @param advanceDayOfWeek  if dayOfMonth does not fall on dayOfWeek, advance to\n     *  dayOfWeek when true, retreat when false.\n     * @param millisOfDay  additional precision for specifying time of day of cutover\n     */"}}
{"code": {"body": "    public DateTimeZoneBuilder addRecurringSavings(String nameKey, int saveMillis,\n                                                   int fromYear, int toYear,\n                                                   char mode,\n                                                   int monthOfYear,\n                                                   int dayOfMonth,\n                                                   int dayOfWeek,\n                                                   boolean advanceDayOfWeek,\n                                                   int millisOfDay)\n    {\n        if (fromYear <= toYear) {\n            OfYear ofYear = new OfYear\n                (mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay);\n            Recurrence recurrence = new Recurrence(ofYear, nameKey, saveMillis);\n            Rule rule = new Rule(recurrence, fromYear, toYear);\n            getLastRuleSet().addRule(rule);\n        }\n        return this;\n    }", "comment": "/**\n     * Add a recurring daylight saving time rule.\n     *\n     * @param nameKey  the name key of new rule\n     * @param saveMillis  the milliseconds to add to standard offset\n     * @param fromYear  the first year that rule is in effect, MIN_VALUE indicates\n     * beginning of time\n     * @param toYear  the last year (inclusive) that rule is in effect, MAX_VALUE\n     *  indicates end of time\n     * @param mode  'u' - transitions are calculated against UTC, 'w' -\n     *  transitions are calculated against wall offset, 's' - transitions are\n     *  calculated against standard offset\n     * @param monthOfYear  the month from 1 (January) to 12 (December)\n     * @param dayOfMonth  if negative, set to ((last day of month) - ~dayOfMonth).\n     *  For example, if -1, set to last day of month\n     * @param dayOfWeek  from 1 (Monday) to 7 (Sunday), if 0 then ignore\n     * @param advanceDayOfWeek  if dayOfMonth does not fall on dayOfWeek, advance to\n     *  dayOfWeek when true, retreat when false.\n     * @param millisOfDay  additional precision for specifying time of day of transitions\n     */"}}
{"code": {"body": "    public DateTimeZone toDateTimeZone(String id, boolean outputID) {\n        if (id == null) {\n            throw new IllegalArgumentException();\n        }\n\n        \n        \n        ArrayList<Transition> transitions = new ArrayList<Transition>();\n\n        \n        \n        DSTZone tailZone = null;\n\n        long millis = Long.MIN_VALUE;\n        int saveMillis = 0;\n            \n        int ruleSetCount = iRuleSets.size();\n        for (int i=0; i<ruleSetCount; i++) {\n            RuleSet rs = iRuleSets.get(i);\n            Transition next = rs.firstTransition(millis);\n            if (next == null) {\n                continue;\n            }\n            addTransition(transitions, next);\n            millis = next.getMillis();\n            saveMillis = next.getSaveMillis();\n\n            \n            rs = new RuleSet(rs);\n\n            while ((next = rs.nextTransition(millis, saveMillis)) != null) {\n                if (addTransition(transitions, next)) {\n                    if (tailZone != null) {\n                        \n                        break;\n                    }\n                }\n                millis = next.getMillis();\n                saveMillis = next.getSaveMillis();\n                if (tailZone == null && i == ruleSetCount - 1) {\n                    tailZone = rs.buildTailZone(id);\n                    \n                    \n                    \n                }\n            }\n\n            millis = rs.getUpperLimit(saveMillis);\n        }\n\n        \n        if (transitions.size() == 0) {\n            if (tailZone != null) {\n                \n                return tailZone;\n            }\n            return buildFixedZone(id, \"\", 0, 0);\n        }\n        if (transitions.size() == 1 && tailZone == null) {\n            Transition tr = transitions.get(0);\n            return buildFixedZone(id, tr.getNameKey(),\n                                  tr.getWallOffset(), tr.getStandardOffset());\n        }\n\n        PrecalculatedZone zone = PrecalculatedZone.create(id, outputID, transitions, tailZone);\n        if (zone.isCachable()) {\n            return CachedDateTimeZone.forZone(zone);\n        }\n        return zone;\n    }", "comment": "/**\n     * Processes all the rules and builds a DateTimeZone.\n     *\n     * @param id  time zone id to assign\n     * @param outputID  true if the zone id should be output\n     */"}}
{"code": {"body": "        public void writeTo(DataOutput out) throws IOException {\n            out.writeByte(iMode);\n            out.writeByte(iMonthOfYear);\n            out.writeByte(iDayOfMonth);\n            out.writeByte(iDayOfWeek);\n            out.writeBoolean(iAdvance);\n            writeMillis(out, iMillisOfDay);\n        }", "comment": "/*\n        public String toString() {\n            return\n                \"[OfYear]\\n\" + \n                \"Mode: \" + iMode + '\\n' +\n                \"MonthOfYear: \" + iMonthOfYear + '\\n' +\n                \"DayOfMonth: \" + iDayOfMonth + '\\n' +\n                \"DayOfWeek: \" + iDayOfWeek + '\\n' +\n                \"AdvanceDayOfWeek: \" + iAdvance + '\\n' +\n                \"MillisOfDay: \" + iMillisOfDay + '\\n';\n        }\n        */"}}
{"code": {"body": "        public long setInstant(int year, int standardOffset, int saveMillis) {\n            int offset;\n            if (iMode == '') {\n                offset = standardOffset + saveMillis;\n            } else if (iMode == '') {\n                offset = standardOffset;\n            } else {\n                offset = 0;\n            }\n\n            Chronology chrono = ISOChronology.getInstanceUTC();\n            long millis = chrono.year().set(0, year);\n            millis = chrono.monthOfYear().set(millis, iMonthOfYear);\n            millis = chrono.millisOfDay().set(millis, iMillisOfDay);\n            millis = setDayOfMonth(chrono, millis);\n\n            if (iDayOfWeek != 0) {\n                millis = setDayOfWeek(chrono, millis);\n            }\n\n            \n            return millis - offset;\n        }", "comment": "/**\n         * @param standardOffset standard offset just before instant\n         */"}}
{"code": {"body": "        public long previous(long instant, int standardOffset, int saveMillis) {\n            int offset;\n            if (iMode == '') {\n                offset = standardOffset + saveMillis;\n            } else if (iMode == '') {\n                offset = standardOffset;\n            } else {\n                offset = 0;\n            }\n\n            \n            instant += offset;\n\n            Chronology chrono = ISOChronology.getInstanceUTC();\n            long prev = chrono.monthOfYear().set(instant, iMonthOfYear);\n            \n            prev = chrono.millisOfDay().set(prev, 0);\n            prev = chrono.millisOfDay().add(prev, iMillisOfDay);\n            prev = setDayOfMonthPrevious(chrono, prev);\n\n            if (iDayOfWeek == 0) {\n                if (prev >= instant) {\n                    prev = chrono.year().add(prev, -1);\n                    prev = setDayOfMonthPrevious(chrono, prev);\n                }\n            } else {\n                prev = setDayOfWeek(chrono, prev);\n                if (prev >= instant) {\n                    prev = chrono.year().add(prev, -1);\n                    prev = chrono.monthOfYear().set(prev, iMonthOfYear);\n                    prev = setDayOfMonthPrevious(chrono, prev);\n                    prev = setDayOfWeek(chrono, prev);\n                }\n            }\n\n            \n            return prev - offset;\n        }", "comment": "/**\n         * @param standardOffset standard offset just before previous recurrence\n         */"}}
{"code": {"body": "        private long setDayOfMonthNext(Chronology chrono, long next) {\n            try {\n                next = setDayOfMonth(chrono, next);\n            } catch (IllegalArgumentException e) {\n                if (iMonthOfYear == 2 && iDayOfMonth == 29) {\n                    while (chrono.year().isLeap(next) == false) {\n                        next = chrono.year().add(next, 1);\n                    }\n                    next = setDayOfMonth(chrono, next);\n                } else {\n                    throw e;\n                }\n            }\n            return next;\n        }", "comment": "/**\n         * If month-day is 02-29 and year isn't leap, advances to next leap year.\n         */"}}
{"code": {"body": "        private long setDayOfMonthPrevious(Chronology chrono, long prev) {\n            try {\n                prev = setDayOfMonth(chrono, prev);\n            } catch (IllegalArgumentException e) {\n                if (iMonthOfYear == 2 && iDayOfMonth == 29) {\n                    while (chrono.year().isLeap(prev) == false) {\n                        prev = chrono.year().add(prev, -1);\n                    }\n                    prev = setDayOfMonth(chrono, prev);\n                } else {\n                    throw e;\n                }\n            }\n            return prev;\n        }", "comment": "/**\n         * If month-day is 02-29 and year isn't leap, retreats to previous leap year.\n         */"}}
{"code": {"body": "        public boolean isTransitionFrom(Transition other) {\n            if (other == null) {\n                return true;\n            }\n            return iMillis > other.iMillis &&\n                (iWallOffset != other.iWallOffset ||\n                 \n                 !(iNameKey.equals(other.iNameKey)));\n        }", "comment": "/**\n         * There must be a change in the millis, wall offsets or name keys.\n         */"}}
{"code": {"body": "        public Transition firstTransition(final long firstMillis) {\n            if (iInitialNameKey != null) {\n                \n                return new Transition(firstMillis, iInitialNameKey,\n                                      iStandardOffset + iInitialSaveMillis, iStandardOffset);\n            }\n\n            \n            ArrayList<Rule> copy = new ArrayList<Rule>(iRules);\n\n            \n            \n            \n\n            long millis = Long.MIN_VALUE;\n            int saveMillis = 0;\n            Transition first = null;\n\n            Transition next;\n            while ((next = nextTransition(millis, saveMillis)) != null) {\n                millis = next.getMillis();\n\n                if (millis == firstMillis) {\n                    first = new Transition(firstMillis, next);\n                    break;\n                }\n\n                if (millis > firstMillis) {\n                    if (first == null) {\n                        \n                        \n                        \n                        for (Rule rule : copy) {\n                            if (rule.getSaveMillis() == 0) {\n                                first = new Transition(firstMillis, rule, iStandardOffset);\n                                break;\n                            }\n                        }\n                    }\n                    if (first == null) {\n                        \n                        \n                        \n                        first = new Transition(firstMillis, next.getNameKey(),\n                                               iStandardOffset, iStandardOffset);\n                    }\n                    break;\n                }\n                \n                \n                \n                first = new Transition(firstMillis, next);\n\n                saveMillis = next.getSaveMillis();\n            }\n\n            iRules = copy;\n            return first;\n        }", "comment": "/**\n         * Returns a transition at firstMillis with the first name key and\n         * offsets for this rule set. This method may return null.\n         *\n         * @param firstMillis millis of first transition\n         */"}}
{"code": {"body": "        public long getUpperLimit(int saveMillis) {\n            if (iUpperYear == Integer.MAX_VALUE) {\n                return Long.MAX_VALUE;\n            }\n            return iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis);\n        }", "comment": "/**\n         * @param saveMillis savings before upper limit\n         */"}}
{"code": {"body": "        public DSTZone buildTailZone(String id) {\n            if (iRules.size() == 2) {\n                Rule startRule = iRules.get(0);\n                Rule endRule = iRules.get(1);\n                if (startRule.getToYear() == Integer.MAX_VALUE &&\n                    endRule.getToYear() == Integer.MAX_VALUE) {\n\n                    \n                    \n\n                    \n                    \n                    \n                    \n                    return new DSTZone(id, iStandardOffset,\n                                       startRule.iRecurrence, endRule.iRecurrence);\n                }\n            }\n            return null;\n        }", "comment": "/**\n         * Returns null if none can be built.\n         */"}}
{"code": {"body": "        static PrecalculatedZone create(String id, boolean outputID, ArrayList<Transition> transitions,\n                                        DSTZone tailZone) {\n            int size = transitions.size();\n            if (size == 0) {\n                throw new IllegalArgumentException();\n            }\n\n            long[] trans = new long[size];\n            int[] wallOffsets = new int[size];\n            int[] standardOffsets = new int[size];\n            String[] nameKeys = new String[size];\n\n            Transition last = null;\n            for (int i=0; i<size; i++) {\n                Transition tr = transitions.get(i);\n\n                if (!tr.isTransitionFrom(last)) {\n                    throw new IllegalArgumentException(id);\n                }\n\n                trans[i] = tr.getMillis();\n                wallOffsets[i] = tr.getWallOffset();\n                standardOffsets[i] = tr.getStandardOffset();\n                nameKeys[i] = tr.getNameKey();\n\n                last = tr;\n            }\n\n            \n            \n            String[] zoneNameData = new String[5];\n            String[][] zoneStrings = new DateFormatSymbols(Locale.ENGLISH).getZoneStrings();\n            for (int j = 0; j < zoneStrings.length; j++) {\n                String[] set = zoneStrings[j];\n                if (set != null && set.length == 5 && id.equals(set[0])) {\n                    zoneNameData = set;\n                }\n            }\n\n            Chronology chrono = ISOChronology.getInstanceUTC();\n\n            for (int i = 0; i < nameKeys.length - 1; i++) {\n                String curNameKey = nameKeys[i];\n                String nextNameKey = nameKeys[i + 1];\n                long curOffset = wallOffsets[i];\n                long nextOffset = wallOffsets[i + 1];\n                long curStdOffset = standardOffsets[i];\n                long nextStdOffset = standardOffsets[i + 1];\n                Period p = new Period(trans[i], trans[i + 1], PeriodType.yearMonthDay(), chrono);\n                if (curOffset != nextOffset &&\n                        curStdOffset == nextStdOffset &&\n                        curNameKey.equals(nextNameKey) &&\n                        p.getYears() == 0 && p.getMonths() > 4 && p.getMonths() < 8 &&\n                        curNameKey.equals(zoneNameData[2]) &&\n                        curNameKey.equals(zoneNameData[4])) {\n                    \n                    if (ZoneInfoCompiler.verbose()) {\n                        System.out.println(\"\" + nextNameKey);\n                        System.out.println(\"\" + new DateTime(trans[i], chrono) +\n                                           \"\" + new DateTime(trans[i + 1], chrono));\n                    }\n                    if (curOffset > nextOffset) {\n                        nameKeys[i] = (curNameKey + \"\").intern();\n                    } else if (curOffset < nextOffset) {\n                        nameKeys[i + 1] = (nextNameKey + \"\").intern();\n                        i++;\n                    }\n                }\n            }\n\n            if (tailZone != null) {\n                if (tailZone.iStartRecurrence.getNameKey()\n                    .equals(tailZone.iEndRecurrence.getNameKey())) {\n                    if (ZoneInfoCompiler.verbose()) {\n                        System.out.println(\"\" +\n                                           tailZone.iStartRecurrence.getNameKey());\n                    }\n                    if (tailZone.iStartRecurrence.getSaveMillis() > 0) {\n                        tailZone = new DSTZone(\n                            tailZone.getID(),\n                            tailZone.iStandardOffset,\n                            tailZone.iStartRecurrence.renameAppend(\"\"),\n                            tailZone.iEndRecurrence);\n                    } else {\n                        tailZone = new DSTZone(\n                            tailZone.getID(),\n                            tailZone.iStandardOffset,\n                            tailZone.iStartRecurrence,\n                            tailZone.iEndRecurrence.renameAppend(\"\"));\n                    }\n                }\n            }\n            \n            return new PrecalculatedZone\n                ((outputID ? id : \"\"), trans, wallOffsets, standardOffsets, nameKeys, tailZone);\n        }", "comment": "/**\n         * Factory to create instance from builder.\n         * \n         * @param id  the zone id\n         * @param outputID  true if the zone id should be output\n         * @param transitions  the list of Transition objects\n         * @param tailZone  optional zone for getting info beyond precalculated tables\n         */"}}
{"code": {"body": "    public java.util.TimeZone toTimeZone() {\n        String id = getID();\n        if (id.length() == 6 && (id.startsWith(\"\") || id.startsWith(\"\"))) {\n            \n            \n            return java.util.TimeZone.getTimeZone(\"\" + getID());\n        }\n        \n        return new java.util.SimpleTimeZone(iWallOffset, getID());\n    }", "comment": "/**\n     * Override to return the correct timzone instance.\n     * @since 1.5\n     */"}}
{"code": {"body": "public UTCProvider() {\n        super();\n    }", "comment": "/**\n     * Constructor.\n     */"}}
{"code": {"body": "    public DateTimeZone getZone(String id) {\n        if (\"\".equalsIgnoreCase(id)) {\n            return DateTimeZone.UTC;\n        }\n        return null;\n    }", "comment": "/**\n     * Returns {@link DateTimeZone#UTC UTC} for <code>\"UTC\"</code>, null\n     * otherwise.\n     */"}}
{"code": {"body": "    public Set<String> getAvailableIDs() {\n        return Collections.singleton(\"\");\n    }", "comment": "/**\n     * Returns a singleton collection containing only <code>\"UTC\"</code>.\n     */"}}
{"code": {"body": "    public static boolean verbose() {\n        return cVerbose.get();\n    }", "comment": "/**\n     * Gets a flag indicating that verbose logging is required.\n     * @return true to log verbosely\n     */"}}
{"code": {"body": "    public static void main(String[] args) throws Exception {\n        if (args.length == 0) {\n            printUsage();\n            return;\n        }\n\n        File inputDir = null;\n        File outputDir = null;\n        boolean verbose = false;\n\n        int i;\n        for (i=0; i<args.length; i++) {\n            try {\n                if (\"\".equals(args[i])) {\n                    inputDir = new File(args[++i]);\n                } else if (\"\".equals(args[i])) {\n                    outputDir = new File(args[++i]);\n                } else if (\"\".equals(args[i])) {\n                    verbose = true;\n                } else if (\"\".equals(args[i])) {\n                    printUsage();\n                    return;\n                } else {\n                    break;\n                }\n            } catch (IndexOutOfBoundsException e) {\n                printUsage();\n                return;\n            }\n        }\n\n        if (i >= args.length) {\n            printUsage();\n            return;\n        }\n\n        File[] sources = new File[args.length - i];\n        for (int j=0; i<args.length; i++,j++) {\n            sources[j] = inputDir == null ? new File(args[i]) : new File(inputDir, args[i]);\n        }\n\n        cVerbose.set(verbose);\n        ZoneInfoCompiler zic = new ZoneInfoCompiler();\n        zic.compile(outputDir, sources);\n    }", "comment": "/**\n     * Launches the ZoneInfoCompiler tool.\n     *\n     * <pre>\n     * Usage: java org.joda.time.tz.ZoneInfoCompiler &lt;options&gt; &lt;source files&gt;\n     * where possible options include:\n     *   -src &lt;directory&gt;    Specify where to read source files\n     *   -dst &lt;directory&gt;    Specify where to write generated files\n     *   -verbose            Output verbosely (default false)\n     * </pre>\n     */"}}
{"code": {"body": "    static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException {\n        \n        Map<String, Short> idToIndex = new HashMap<String, Short>(zimap.size());\n        TreeMap<Short, String> indexToId = new TreeMap<Short, String>();\n\n        short count = 0;\n        for (Entry<String, DateTimeZone> entry : zimap.entrySet()) {\n            String id = (String)entry.getKey();\n            if (!idToIndex.containsKey(id)) {\n                Short index = Short.valueOf(count);\n                idToIndex.put(id, index);\n                indexToId.put(index, id);\n                if (++count == 0) {\n                    throw new InternalError(\"\");\n                }\n            }\n            id = ((DateTimeZone)entry.getValue()).getID();\n            if (!idToIndex.containsKey(id)) {\n                Short index = Short.valueOf(count);\n                idToIndex.put(id, index);\n                indexToId.put(index, id);\n                if (++count == 0) {\n                    throw new InternalError(\"\");\n                }\n            }\n        }\n\n        \n        dout.writeShort(indexToId.size());\n        for (String id : indexToId.values()) {\n            dout.writeUTF(id);\n        }\n\n        \n        dout.writeShort(zimap.size());\n        for (Entry<String, DateTimeZone> entry : zimap.entrySet()) {\n            String id = entry.getKey();\n            dout.writeShort(idToIndex.get(id).shortValue());\n            id = entry.getValue().getID();\n            dout.writeShort(idToIndex.get(id).shortValue());\n        }\n    }", "comment": "/**\n     * @param zimap maps string ids to DateTimeZone objects.\n     */"}}
{"code": {"body": "    static boolean test(String id, DateTimeZone tz) {\n        if (!id.equals(tz.getID())) {\n            return true;\n        }\n\n        \n\n        long millis = ISOChronology.getInstanceUTC().year().set(0, 1850);\n        long end = ISOChronology.getInstanceUTC().year().set(0, 2050);\n\n        int offset = tz.getOffset(millis);\n        String key = tz.getNameKey(millis);\n\n        List<Long> transitions = new ArrayList<Long>();\n\n        while (true) {\n            long next = tz.nextTransition(millis);\n            if (next == millis || next > end) {\n                break;\n            }\n\n            millis = next;\n\n            int nextOffset = tz.getOffset(millis);\n            String nextKey = tz.getNameKey(millis);\n\n            if (offset == nextOffset\n                && key.equals(nextKey)) {\n                System.out.println(\"\" + tz.getID() + \"\"\n                                   + new DateTime(millis,\n                                                  ISOChronology.getInstanceUTC()));\n                return false;\n            }\n\n            if (nextKey == null || (nextKey.length() < 3 && !\"\".equals(nextKey))) {\n                System.out.println(\"\" + tz.getID() + \"\"\n                                   + new DateTime(millis,\n                                                  ISOChronology.getInstanceUTC())\n                                   + \"\" + nextKey);\n                return false;\n            }\n\n            transitions.add(Long.valueOf(millis));\n\n            offset = nextOffset;\n            key = nextKey;\n        }\n\n        \n\n        millis = ISOChronology.getInstanceUTC().year().set(0, 2050);\n        end = ISOChronology.getInstanceUTC().year().set(0, 1850);\n\n        for (int i=transitions.size(); --i>= 0; ) {\n            long prev = tz.previousTransition(millis);\n            if (prev == millis || prev < end) {\n                break;\n            }\n\n            millis = prev;\n\n            long trans = transitions.get(i).longValue();\n            \n            if (trans - 1 != millis) {\n                System.out.println(\"\" + tz.getID() + \"\"\n                                   + new DateTime(millis,\n                                                  ISOChronology.getInstanceUTC()) + \"\"\n                                   + new DateTime(trans - 1,\n                                                  ISOChronology.getInstanceUTC()));\n                                   \n                return false;\n            }\n        }\n\n        return true;\n    }", "comment": "/**\n     * @return false if error.\n     */"}}
{"code": {"body": "    public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException {\n        if (sources != null) {\n            for (int i=0; i<sources.length; i++) {\n                BufferedReader in = new BufferedReader(new FileReader(sources[i]));\n                parseDataFile(in);\n                in.close();\n            }\n        }\n\n        if (outputDir != null) {\n            if (!outputDir.exists()) {\n                if (!outputDir.mkdirs()) {\n                    throw new IOException(\"\" + outputDir);\n                }\n            }\n            if (!outputDir.isDirectory()) {\n                throw new IOException(\"\" + outputDir);\n            }\n        }\n\n        Map<String, DateTimeZone> map = new TreeMap<String, DateTimeZone>();\n\n        System.out.println(\"\");\n        for (int i=0; i<iZones.size(); i++) {\n            Zone zone = iZones.get(i);\n            DateTimeZoneBuilder builder = new DateTimeZoneBuilder();\n            zone.addToBuilder(builder, iRuleSets);\n            final DateTimeZone original = builder.toDateTimeZone(zone.iName, true);\n            DateTimeZone tz = original;\n            if (test(tz.getID(), tz)) {\n                map.put(tz.getID(), tz);\n                if (outputDir != null) {\n                    if (ZoneInfoCompiler.verbose()) {\n                        System.out.println(\"\" + tz.getID());\n                    }\n                    File file = new File(outputDir, tz.getID());\n                    if (!file.getParentFile().exists()) {\n                        file.getParentFile().mkdirs();\n                    }\n                    OutputStream out = new FileOutputStream(file);\n                    try {\n                        builder.writeTo(zone.iName, out);\n                    } finally {\n                        out.close();\n                    }\n\n                    \n                    InputStream in = new FileInputStream(file);\n                    DateTimeZone tz2 = DateTimeZoneBuilder.readFrom(in, tz.getID());\n                    in.close();\n\n                    if (!original.equals(tz2)) {\n                        System.out.println(\"\" + tz.getID() +\n                                           \"\");\n                    }\n                }\n            }\n        }\n\n        for (int pass=0; pass<2; pass++) {\n            for (int i=0; i<iLinks.size(); i += 2) {\n                String id = iLinks.get(i);\n                String alias = iLinks.get(i + 1);\n                DateTimeZone tz = map.get(id);\n                if (tz == null) {\n                    if (pass > 0) {\n                        System.out.println(\"\" + id +\n                                           \"\" + alias + \"\");\n                    }\n                } else {\n                    map.put(alias, tz);\n                }\n            }\n        }\n\n        if (outputDir != null) {\n            System.out.println(\"\");\n            File file = new File(outputDir, \"\");\n            if (!file.getParentFile().exists()) {\n                file.getParentFile().mkdirs();\n            }\n\n            OutputStream out = new FileOutputStream(file);\n            DataOutputStream dout = new DataOutputStream(out);\n            try {\n                \n                Map<String, DateTimeZone> zimap = new TreeMap<String, DateTimeZone>(String.CASE_INSENSITIVE_ORDER);\n                zimap.putAll(map);\n                writeZoneInfoMap(dout, zimap);\n            } finally {\n                dout.close();\n            }\n        }\n\n        return map;\n    }", "comment": "/**\n     * Returns a map of ids to DateTimeZones.\n     *\n     * @param outputDir optional directory to write compiled data files to\n     * @param sources optional list of source files to parse\n     */"}}
{"code": {"body": "        public void addRecurring(DateTimeZoneBuilder builder, String nameFormat) {\n            String nameKey = formatName(nameFormat);\n            iDateTimeOfYear.addRecurring\n                (builder, nameKey, iSaveMillis, iFromYear, iToYear);\n        }", "comment": "/**\n         * Adds a recurring savings rule to the builder.\n         */"}}
{"code": {"body": "        public void addCutover(DateTimeZoneBuilder builder, int year) {\n            builder.addCutover(year,\n                               iZoneChar,\n                               iMonthOfYear,\n                               iDayOfMonth,\n                               iDayOfWeek,\n                               iAdvanceDayOfWeek,\n                               iMillisOfDay);\n        }", "comment": "/**\n         * Adds a cutover to the builder.\n         */"}}
{"code": {"body": "public ZoneInfoProvider(File fileDir) throws IOException {\n        if (fileDir == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (!fileDir.exists()) {\n            throw new IOException(\"\" + fileDir);\n        }\n        if (!fileDir.isDirectory()) {\n            throw new IOException(\"\" + fileDir);\n        }\n\n        iFileDir = fileDir;\n        iResourcePath = null;\n        iLoader = null;\n\n        iZoneInfoMap = loadZoneInfoMap(openResource(\"\"));\n    }", "comment": "/**\n     * ZoneInfoProvider searches the given directory for compiled data files.\n     *\n     * @throws IOException if directory or map file cannot be read\n     */"}}
{"code": {"body": "public ZoneInfoProvider(String resourcePath) throws IOException {\n        this(resourcePath, null, false);\n    }", "comment": "/**\n     * ZoneInfoProvider searches the given ClassLoader resource path for\n     * compiled data files. Resources are loaded from the ClassLoader that\n     * loaded this class.\n     *\n     * @throws IOException if directory or map file cannot be read\n     */"}}
{"code": {"body": "public ZoneInfoProvider(String resourcePath, ClassLoader loader)", "comment": "/**\n     * ZoneInfoProvider searches the given ClassLoader resource path for\n     * compiled data files.\n     *\n     * @param loader ClassLoader to load compiled data files from. If null,\n     * use system ClassLoader.\n     * @throws IOException if directory or map file cannot be read\n     */"}}
{"code": {"body": "    public DateTimeZone getZone(String id) {\n        if (id == null) {\n            return null;\n        }\n\n        Object obj = iZoneInfoMap.get(id);\n        if (obj == null) {\n            return null;\n        }\n\n        if (id.equals(obj)) {\n            \n            return loadZoneData(id);\n        }\n\n        if (obj instanceof SoftReference<?>) {\n            @SuppressWarnings(\"\")\n            SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj;\n            DateTimeZone tz = ref.get();\n            if (tz != null) {\n                return tz;\n            }\n            \n            return loadZoneData(id);\n        }\n\n        \n        return getZone((String)obj);\n    }", "comment": "/**\n     * If an error is thrown while loading zone data, uncaughtException is\n     * called to log the error and null is returned for this and all future\n     * requests.\n     * \n     * @param id  the id to load\n     * @return the loaded zone\n     */"}}
{"code": {"body": "    public Set<String> getAvailableIDs() {\n        \n        \n        \n        return new TreeSet<String>(iZoneInfoMap.keySet());\n    }", "comment": "/**\n     * Gets a list of all the available zone ids.\n     * \n     * @return the zone ids\n     */"}}
{"code": {"body": "    protected void uncaughtException(Exception ex) {\n        Thread t = Thread.currentThread();\n        t.getThreadGroup().uncaughtException(t, ex);\n    }", "comment": "/**\n     * Called if an exception is thrown from getZone while loading zone data.\n     * \n     * @param ex  the exception\n     */"}}
{"code": {"body": "    private DateTimeZone loadZoneData(String id) {\n        InputStream in = null;\n        try {\n            in = openResource(id);\n            DateTimeZone tz = DateTimeZoneBuilder.readFrom(in, id);\n            iZoneInfoMap.put(id, new SoftReference<DateTimeZone>(tz));\n            return tz;\n        } catch (IOException ex) {\n            uncaughtException(ex);\n            iZoneInfoMap.remove(id);\n            return null;\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n            } catch (IOException ex) {\n            }\n        }\n    }", "comment": "/**\n     * Loads the time zone data for one id.\n     * \n     * @param id  the id to load\n     * @return the zone\n     */"}}
{"code": {"body": "    private static Map<String, Object> loadZoneInfoMap(InputStream in) throws IOException {\n        Map<String, Object> map = new ConcurrentHashMap<String, Object>();\n        DataInputStream din = new DataInputStream(in);\n        try {\n            readZoneInfoMap(din, map);\n        } finally {\n            try {\n                din.close();\n            } catch (IOException ex) {\n            }\n        }\n        map.put(\"\", new SoftReference<DateTimeZone>(DateTimeZone.UTC));\n        return map;\n    }", "comment": "/**\n     * Loads the zone info map.\n     * \n     * @param in  the input stream\n     * @return the map\n     */"}}
{"code": {"body": "    private static void readZoneInfoMap(DataInputStream din, Map<String, Object> zimap) throws IOException {\n        \n        int size = din.readUnsignedShort();\n        String[] pool = new String[size];\n        for (int i=0; i<size; i++) {\n            pool[i] = din.readUTF().intern();\n        }\n\n        \n        size = din.readUnsignedShort();\n        for (int i=0; i<size; i++) {\n            try {\n                zimap.put(pool[din.readUnsignedShort()], pool[din.readUnsignedShort()]);\n            } catch (ArrayIndexOutOfBoundsException ex) {\n                throw new IOException(\"\");\n            }\n        }\n    }", "comment": "/**\n     * Reads the zone info map from file.\n     * \n     * @param din  the input stream\n     * @param zimap  gets filled with string id to string id mappings\n     */"}}
{"code": {"body": "    public void test_now() throws Throwable {\n        DateMidnight test = DateMidnight.now();\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n        assertEquals(2002, test.getYear());\n        assertEquals(6, test.getMonthOfYear());\n        assertEquals(9, test.getDayOfMonth());\n    }", "comment": "/**\n     * Test now ()\n     */"}}
{"code": {"body": "    public void test_now_DateTimeZone() throws Throwable {\n        DateMidnight test = DateMidnight.now(PARIS);\n        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n        assertEquals(TEST_TIME_NOW_PARIS, test.getMillis());\n    }", "comment": "/**\n     * Test now (DateTimeZone)\n     */"}}
{"code": {"body": "    public void test_now_nullDateTimeZone() throws Throwable {\n        try {\n            DateMidnight.now((DateTimeZone) null);\n            fail();\n        } catch (NullPointerException ex) {}\n    }", "comment": "/**\n     * Test now (DateTimeZone=null)\n     */"}}
{"code": {"body": "    public void test_now_Chronology() throws Throwable {\n        DateMidnight test = DateMidnight.now(GregorianChronology.getInstance());\n        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n    }", "comment": "/**\n     * Test now (Chronology)\n     */"}}
{"code": {"body": "    public void test_now_nullChronology() throws Throwable {\n        try {\n            DateMidnight.now((Chronology) null);\n            fail();\n        } catch (NullPointerException ex) {}\n    }", "comment": "/**\n     * Test now (Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor() throws Throwable {\n        DateMidnight test = new DateMidnight();\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n        assertEquals(2002, test.getYear());\n        assertEquals(6, test.getMonthOfYear());\n        assertEquals(9, test.getDayOfMonth());\n    }", "comment": "/**\n     * Test constructor ()\n     */"}}
{"code": {"body": "    public void testConstructor_DateTimeZone() throws Throwable {\n        DateMidnight test = new DateMidnight(PARIS);\n        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n        assertEquals(TEST_TIME_NOW_PARIS, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (DateTimeZone)\n     */"}}
{"code": {"body": "    public void testConstructor_nullDateTimeZone() throws Throwable {\n        DateMidnight test = new DateMidnight((DateTimeZone) null);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (DateTimeZone=null)\n     */"}}
{"code": {"body": "    public void testConstructor_Chronology() throws Throwable {\n        DateMidnight test = new DateMidnight(GregorianChronology.getInstance());\n        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_nullChronology() throws Throwable {\n        DateMidnight test = new DateMidnight((Chronology) null);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor_long1() throws Throwable {\n        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME1_LONDON, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (long)\n     */"}}
{"code": {"body": "    public void testConstructor_long2() throws Throwable {\n        DateMidnight test = new DateMidnight(TEST_TIME2_UTC);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME2_LONDON, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (long)\n     */"}}
{"code": {"body": "    public void testConstructor_long1_DateTimeZone() throws Throwable {\n        DateMidnight test = new DateMidnight(TEST_TIME1_UTC, PARIS);\n        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n        assertEquals(TEST_TIME1_PARIS, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (long, DateTimeZone)\n     */"}}
{"code": {"body": "    public void testConstructor_long2_DateTimeZone() throws Throwable {\n        DateMidnight test = new DateMidnight(TEST_TIME2_UTC, PARIS);\n        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n        assertEquals(TEST_TIME2_PARIS, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (long, DateTimeZone)\n     */"}}
{"code": {"body": "    public void testConstructor_long_nullDateTimeZone() throws Throwable {\n        DateMidnight test = new DateMidnight(TEST_TIME1_UTC, (DateTimeZone) null);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME1_LONDON, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (long, DateTimeZone=null)\n     */"}}
{"code": {"body": "    public void testConstructor_long1_Chronology() throws Throwable {\n        DateMidnight test = new DateMidnight(TEST_TIME1_UTC, GregorianChronology.getInstance());\n        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME1_LONDON, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (long, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_long2_Chronology() throws Throwable {\n        DateMidnight test = new DateMidnight(TEST_TIME2_UTC, GregorianChronology.getInstance());\n        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME2_LONDON, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (long, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_long_nullChronology() throws Throwable {\n        DateMidnight test = new DateMidnight(TEST_TIME1_UTC, (Chronology) null);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME1_LONDON, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (long, Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor_Object() throws Throwable {\n        Date date = new Date(TEST_TIME1_UTC);\n        DateMidnight test = new DateMidnight(date);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME1_LONDON, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Object)\n     */"}}
{"code": {"body": "    public void testConstructor_invalidObject() throws Throwable {\n        try {\n            new DateMidnight(new Object());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n    }", "comment": "/**\n     * Test constructor (Object)\n     */"}}
{"code": {"body": "    public void testConstructor_nullObject() throws Throwable {\n        DateMidnight test = new DateMidnight((Object) null);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Object=null)\n     */"}}
{"code": {"body": "    public void testConstructor_badconverterObject() throws Throwable {\n        try {\n            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n            DateMidnight test = new DateMidnight(new Integer(0));\n            assertEquals(ISOChronology.getInstance(), test.getChronology());\n            assertEquals(0L - DateTimeConstants.MILLIS_PER_HOUR, test.getMillis());\n        } finally {\n            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n        }\n    }", "comment": "/**\n     * Test constructor (Object=null)\n     */"}}
{"code": {"body": "    public void testConstructor_Object_DateTimeZone() throws Throwable {\n        Date date = new Date(TEST_TIME1_UTC);\n        DateMidnight test = new DateMidnight(date, PARIS);\n        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n        assertEquals(TEST_TIME1_PARIS, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Object, DateTimeZone)\n     */"}}
{"code": {"body": "    public void testConstructor_invalidObject_DateTimeZone() throws Throwable {\n        try {\n            new DateMidnight(new Object(), PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n    }", "comment": "/**\n     * Test constructor (Object, DateTimeZone)\n     */"}}
{"code": {"body": "    public void testConstructor_nullObject_DateTimeZone() throws Throwable {\n        DateMidnight test = new DateMidnight((Object) null, PARIS);\n        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n        assertEquals(TEST_TIME_NOW_PARIS, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Object=null, DateTimeZone)\n     */"}}
{"code": {"body": "    public void testConstructor_Object_nullDateTimeZone() throws Throwable {\n        Date date = new Date(TEST_TIME1_UTC);\n        DateMidnight test = new DateMidnight(date, (DateTimeZone) null);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME1_LONDON, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Object, DateTimeZone=null)\n     */"}}
{"code": {"body": "    public void testConstructor_nullObject_nullDateTimeZone() throws Throwable {\n        DateMidnight test = new DateMidnight((Object) null, (DateTimeZone) null);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Object=null, DateTimeZone=null)\n     */"}}
{"code": {"body": "    public void testConstructor_badconverterObject_DateTimeZone() throws Throwable {\n        try {\n            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n            DateMidnight test = new DateMidnight(new Integer(0), GregorianChronology.getInstance());\n            assertEquals(ISOChronology.getInstance(), test.getChronology());\n            assertEquals(0L - DateTimeConstants.MILLIS_PER_HOUR, test.getMillis());\n        } finally {\n            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n        }\n    }", "comment": "/**\n     * Test constructor (Object, DateTimeZone)\n     */"}}
{"code": {"body": "    public void testConstructor_Object_Chronology() throws Throwable {\n        Date date = new Date(TEST_TIME1_UTC);\n        DateMidnight test = new DateMidnight(date, GregorianChronology.getInstance());\n        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME1_LONDON, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Object, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_invalidObject_Chronology() throws Throwable {\n        try {\n            new DateMidnight(new Object(), GregorianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n    }", "comment": "/**\n     * Test constructor (Object, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_nullObject_Chronology() throws Throwable {\n        DateMidnight test = new DateMidnight((Object) null, GregorianChronology.getInstance());\n        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Object=null, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_Object_nullChronology() throws Throwable {\n        Date date = new Date(TEST_TIME1_UTC);\n        DateMidnight test = new DateMidnight(date, (Chronology) null);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME1_LONDON, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Object, Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor_nullObject_nullChronology() throws Throwable {\n        DateMidnight test = new DateMidnight((Object) null, (Chronology) null);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Object=null, Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor_badconverterObject_Chronology() throws Throwable {\n        try {\n            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n            DateMidnight test = new DateMidnight(new Integer(0), GregorianChronology.getInstance());\n            assertEquals(ISOChronology.getInstance(), test.getChronology());\n            assertEquals(0L - DateTimeConstants.MILLIS_PER_HOUR, test.getMillis());\n        } finally {\n            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n        }\n    }", "comment": "/**\n     * Test constructor (Object, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_int() throws Throwable {\n        DateMidnight test = new DateMidnight(2002, 6, 9);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(LONDON, test.getZone());\n        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n        assertEquals(2002, test.getYear());\n        assertEquals(6, test.getMonthOfYear());\n        assertEquals(9, test.getDayOfMonth());\n        try {\n            new DateMidnight(Integer.MIN_VALUE, 6, 9);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new DateMidnight(Integer.MAX_VALUE, 6, 9);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new DateMidnight(2002, 0, 9);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new DateMidnight(2002, 13, 9);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new DateMidnight(2002, 6, 0);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new DateMidnight(2002, 6, 31);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        new DateMidnight(2002, 7, 31);\n        try {\n            new DateMidnight(2002, 7, 32);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n    }", "comment": "/**\n     * Test constructor (int, int, int)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_int_DateTimeZone() throws Throwable {\n        DateMidnight test = new DateMidnight(2002, 6, 9, PARIS);\n        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n        assertEquals(TEST_TIME_NOW_PARIS, test.getMillis());\n        assertEquals(2002, test.getYear());\n        assertEquals(6, test.getMonthOfYear());\n        assertEquals(9, test.getDayOfMonth());\n        try {\n            new DateMidnight(Integer.MIN_VALUE, 6, 9, PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new DateMidnight(Integer.MAX_VALUE, 6, 9, PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new DateMidnight(2002, 0, 9, PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new DateMidnight(2002, 13, 9, PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new DateMidnight(2002, 6, 0, PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new DateMidnight(2002, 6, 31, PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        new DateMidnight(2002, 7, 31, PARIS);\n        try {\n            new DateMidnight(2002, 7, 32, PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n    }", "comment": "/**\n     * Test constructor (int, int, int, DateTimeZone)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_int_nullDateTimeZone() throws Throwable {\n        DateMidnight test = new DateMidnight(2002, 6, 9, (DateTimeZone) null);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n        assertEquals(2002, test.getYear());\n        assertEquals(6, test.getMonthOfYear());\n        assertEquals(9, test.getDayOfMonth());\n    }", "comment": "/**\n     * Test constructor (int, int, int, DateTimeZone=null)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_int_Chronology() throws Throwable {\n        DateMidnight test = new DateMidnight(2002, 6, 9, GregorianChronology.getInstance());\n        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n        assertEquals(2002, test.getYear());\n        assertEquals(6, test.getMonthOfYear());\n        assertEquals(9, test.getDayOfMonth());\n        try {\n            new DateMidnight(Integer.MIN_VALUE, 6, 9, GregorianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new DateMidnight(Integer.MAX_VALUE, 6, 9, GregorianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new DateMidnight(2002, 0, 9, GregorianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new DateMidnight(2002, 13, 9, GregorianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new DateMidnight(2002, 6, 0, GregorianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new DateMidnight(2002, 6, 31, GregorianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        new DateMidnight(2002, 7, 31, GregorianChronology.getInstance());\n        try {\n            new DateMidnight(2002, 7, 32, GregorianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n    }", "comment": "/**\n     * Test constructor (int, int, int, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_int_nullChronology() throws Throwable {\n        DateMidnight test = new DateMidnight(2002, 6, 9, (Chronology) null);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n        assertEquals(2002, test.getYear());\n        assertEquals(6, test.getMonthOfYear());\n        assertEquals(9, test.getDayOfMonth());\n    }", "comment": "/**\n     * Test constructor (int, int, int, Chronology=null)\n     */"}}
{"code": {"body": "    public void testBasicComps1() {\n        aDateTime = new DateTime( System.currentTimeMillis(), DateTimeZone.UTC );\n        bDateTime = new DateTime( aDateTime.getMillis(), DateTimeZone.UTC );\n        assertEquals( \"\", aDateTime.getMillis(),\n            bDateTime.getMillis() );\n        assertEquals( \"\", 0, cMillis.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cSecond.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cMinute.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cHour.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cDayOfWeek.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cDayOfMonth.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cDayOfYear.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cWeekyear.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cMonth.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cYear.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cDate.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cTime.compare( aDateTime, bDateTime ) );\n    }", "comment": "/**\n     * Test all basic comparator operation with DateTime objects.\n     */"}}
{"code": {"body": "    public void testBasicComps2() {\n        ReadableInstant aDateTime = new DateTime( System.currentTimeMillis(), DateTimeZone.UTC );\n        ReadableInstant bDateTime = new DateTime( aDateTime.getMillis(), DateTimeZone.UTC );\n        assertEquals( \"\", aDateTime.getMillis(),\n            bDateTime.getMillis() );\n        assertEquals( \"\", 0, cMillis.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cSecond.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cMinute.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cHour.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cDayOfWeek.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cDayOfMonth.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cDayOfYear.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cWeekyear.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cMonth.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cYear.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cDate.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cTime.compare( aDateTime, bDateTime ) );\n    }", "comment": "/**\n     * Test all basic comparator operation with ReadableInstant objects.\n     */"}}
{"code": {"body": "    public void testBasicComps3() {\n        Date aDateTime\n            = new Date( System.currentTimeMillis() );\n        Date bDateTime\n            = new Date( aDateTime.getTime() );\n        assertEquals( \"\", 0, cMillis.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cSecond.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cMinute.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cHour.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cDayOfWeek.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cDayOfMonth.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cDayOfYear.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cWeekyear.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cMonth.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cYear.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cDate.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cTime.compare( aDateTime, bDateTime ) );\n    }", "comment": "/**\n     * Test all basic comparator operation with java Date objects.\n     */"}}
{"code": {"body": "    public void testBasicComps4() {\n        Long aDateTime\n            = new Long( System.currentTimeMillis() );\n        Long bDateTime\n            = new Long( aDateTime.longValue() );\n        assertEquals( \"\", 0, cMillis.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cSecond.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cMinute.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cHour.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cDayOfWeek.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cDayOfMonth.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cDayOfYear.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cWeekyear.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cMonth.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cYear.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cDate.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cTime.compare( aDateTime, bDateTime ) );\n    }", "comment": "/**\n     * Test all basic comparator operation with Long objects.\n     */"}}
{"code": {"body": "    public void testBasicComps5() {\n        Calendar aDateTime\n            = Calendar.getInstance();   \n        Calendar bDateTime = aDateTime;\n        assertEquals( \"\", 0, cMillis.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cSecond.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cMinute.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cHour.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cDayOfWeek.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cDayOfMonth.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cDayOfYear.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cWeekyear.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cMonth.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cYear.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cDate.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 0, cTime.compare( aDateTime, bDateTime ) );\n    }", "comment": "/**\n     * Test all basic comparator operation with Calendar objects.\n     */"}}
{"code": {"body": "    public void testMillis() {\n        aDateTime = new DateTime( System.currentTimeMillis(), DateTimeZone.UTC );\n        bDateTime = new DateTime( aDateTime.getMillis() + 1, DateTimeZone.UTC );\n        assertEquals( \"\", -1, cMillis.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 1, cMillis.compare( bDateTime, aDateTime ) );\n    }", "comment": "/**\n     * Test unequal comparisons with millis of second comparators.\n     */"}}
{"code": {"body": "    public void testSecond() {\n        aDateTime = getADate( \"\" );\n        bDateTime = getADate( \"\" );\n        assertEquals( \"\", -1, cSecond.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 1, cSecond.compare( bDateTime, aDateTime ) );\n        aDateTime = getADate( \"\" );\n        bDateTime = getADate( \"\" );\n        assertEquals( \"\", -1, cSecond.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 1, cSecond.compare( bDateTime, aDateTime ) );\n    }", "comment": "/**\n     * Test unequal comparisons with second comparators.\n     */"}}
{"code": {"body": "    public void testMinute() {\n        aDateTime = getADate( \"\" );\n        bDateTime = getADate( \"\" );\n        assertEquals( \"\", -1, cMinute.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 1, cMinute.compare( bDateTime, aDateTime ) );\n        aDateTime = getADate( \"\" );\n        bDateTime = getADate( \"\" );\n        assertEquals( \"\", -1, cMinute.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 1, cMinute.compare( bDateTime, aDateTime ) );\n    }", "comment": "/**\n     * Test unequal comparisons with minute comparators.\n     */"}}
{"code": {"body": "    public void testHour() {\n        aDateTime = getADate( \"\" );\n        bDateTime = getADate( \"\" );\n        assertEquals( \"\", -1, cHour.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 1, cHour.compare( bDateTime, aDateTime ) );\n        aDateTime = getADate( \"\" );\n        bDateTime = getADate( \"\" );\n        assertEquals( \"\", -1, cHour.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 1, cHour.compare( bDateTime, aDateTime ) );\n        aDateTime = getADate( \"\" );\n        bDateTime = getADate( \"\" );\n        assertEquals( \"\", 1, cHour.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", -1, cHour.compare( bDateTime, aDateTime ) );\n    }", "comment": "/**\n     * Test unequal comparisons with hour comparators.\n     */"}}
{"code": {"body": "    public void testDOW() {\n        \n        aDateTime = getADate( \"\" );\n        bDateTime = getADate( \"\" );\n        assertEquals( \"\", -1, cDayOfWeek.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 1, cDayOfWeek.compare( bDateTime, aDateTime ) );\n    }", "comment": "/**\n     * Test unequal comparisons with day of week comparators.\n     */"}}
{"code": {"body": "    public void testDOM() {\n        aDateTime = getADate( \"\" );\n        bDateTime = getADate( \"\" );\n        assertEquals( \"\", -1, cDayOfMonth.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 1, cDayOfMonth.compare( bDateTime, aDateTime ) );\n        aDateTime = getADate( \"\" );\n        bDateTime = getADate( \"\" );\n        assertEquals( \"\", -1, cDayOfMonth.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 1, cDayOfMonth.compare( bDateTime, aDateTime ) );\n    }", "comment": "/**\n     * Test unequal comparisons with day of month comparators.\n     */"}}
{"code": {"body": "    public void testDOY() {\n        aDateTime = getADate( \"\" );\n        bDateTime = getADate( \"\" );\n        assertEquals( \"\", -1, cDayOfYear.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 1, cDayOfYear.compare( bDateTime, aDateTime ) );\n        aDateTime = getADate( \"\" );\n        bDateTime = getADate( \"\" );\n        assertEquals( \"\", -1, cDayOfYear.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 1, cDayOfYear.compare( bDateTime, aDateTime ) );\n    }", "comment": "/**\n     * Test unequal comparisons with day of year comparators.\n     */"}}
{"code": {"body": "    public void testWOW() {\n        \n        aDateTime = getADate( \"\" );\n        bDateTime = getADate( \"\" );\n        assertEquals( \"\", -1,\n            cWeekOfWeekyear.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 1,\n            cWeekOfWeekyear.compare( bDateTime, aDateTime ) );\n        aDateTime = getADate( \"\" );\n        bDateTime = getADate( \"\" );\n        assertEquals( \"\", -1,\n            cWeekOfWeekyear.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 1,\n            cWeekOfWeekyear.compare( bDateTime, aDateTime ) );\n    }", "comment": "/**\n     * Test unequal comparisons with week of weekyear comparators.\n     */"}}
{"code": {"body": "    public void testWOYY() {\n        \n        \n        aDateTime = getADate( \"\" );\n        bDateTime = getADate( \"\" );\n        assertEquals( \"\", 0, cWeekyear.compare( aDateTime, bDateTime ) );\n        bDateTime = getADate( \"\" );\n        assertEquals( \"\", -1, cWeekyear.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 1, cWeekyear.compare( bDateTime, aDateTime ) );\n    }", "comment": "/**\n     * Test unequal comparisons with year given the week comparators.\n     */"}}
{"code": {"body": "    public void testMonth() {\n        aDateTime = getADate( \"\" );\n        bDateTime = getADate( \"\" );\n        assertEquals( \"\", -1, cMonth.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 1, cMonth.compare( bDateTime, aDateTime ) );\n        aDateTime = getADate( \"\" );\n        bDateTime = getADate( \"\" );\n        assertEquals( \"\", -1, cMonth.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 1, cMonth.compare( bDateTime, aDateTime ) );\n    }", "comment": "/**\n     * Test unequal comparisons with month comparators.\n     */"}}
{"code": {"body": "    public void testYear() {\n        aDateTime = getADate( \"\" );\n        bDateTime = getADate( \"\" );\n        assertEquals( \"\", -1, cYear.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 1, cYear.compare( bDateTime, aDateTime ) );\n        aDateTime = getADate( \"\" );\n        bDateTime = getADate( \"\" );\n        assertEquals( \"\", -1, cYear.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 1, cYear.compare( bDateTime, aDateTime ) );\n        aDateTime = getADate( \"\" );\n        bDateTime = getADate( \"\" );\n        assertEquals( \"\", -1, cYear.compare( aDateTime, bDateTime ) );\n        assertEquals( \"\", 1, cYear.compare( bDateTime, aDateTime ) );\n    }", "comment": "/**\n     * Test unequal comparisons with year comparators.\n     */"}}
{"code": {"body": "     public void testListBasic() {\n        String[] dtStrs = {\n            \"\",\n            \"\"\n        };\n        \n        List sl = loadAList( dtStrs );\n        boolean isSorted1 = isListSorted( sl );\n        Collections.sort( sl );\n        boolean isSorted2 = isListSorted( sl );\n        assertEquals(\"\", !isSorted1, isSorted2);\n     }", "comment": "/**\n      * Test sorting with full default comparator.\n      */"}}
{"code": {"body": "    public void testListMillis() {\n        \n        List sl = new ArrayList();\n        long base = 12345L * 1000L;\n        sl.add( new DateTime( base + 999L, DateTimeZone.UTC ) );\n        sl.add( new DateTime( base + 222L, DateTimeZone.UTC ) );\n        sl.add( new DateTime( base + 456L, DateTimeZone.UTC ) );\n        sl.add( new DateTime( base + 888L, DateTimeZone.UTC ) );\n        sl.add( new DateTime( base + 123L, DateTimeZone.UTC ) );\n        sl.add( new DateTime( base + 000L, DateTimeZone.UTC ) );\n        \n        boolean isSorted1 = isListSorted( sl );\n        Collections.sort( sl, cMillis );\n        boolean isSorted2 = isListSorted( sl );\n        assertEquals(\"\", !isSorted1, isSorted2);\n    }", "comment": "/**\n      * Test sorting with millis of second comparator.\n      */"}}
{"code": {"body": "    public void testListSecond() {\n        String[] dtStrs = {\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\"\n        };\n        \n        List sl = loadAList( dtStrs );\n        boolean isSorted1 = isListSorted( sl );\n        Collections.sort( sl, cSecond );\n        boolean isSorted2 = isListSorted( sl );\n        assertEquals(\"\", !isSorted1, isSorted2);\n    }", "comment": "/**\n      * Test sorting with second comparator.\n      */"}}
{"code": {"body": "    public void testListMinute() {\n        String[] dtStrs = {\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\"\n        };\n        \n        List sl = loadAList( dtStrs );\n        boolean isSorted1 = isListSorted( sl );\n        Collections.sort( sl, cMinute );\n        boolean isSorted2 = isListSorted( sl );\n        assertEquals(\"\", !isSorted1, isSorted2);\n    }", "comment": "/**\n      * Test sorting with minute comparator.\n      */"}}
{"code": {"body": "    public void testListHour() {\n        String[] dtStrs = {\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\"\n        };\n        \n        List sl = loadAList( dtStrs );\n        boolean isSorted1 = isListSorted( sl );\n        Collections.sort( sl, cHour );\n        boolean isSorted2 = isListSorted( sl );\n        assertEquals(\"\", !isSorted1, isSorted2);\n    }", "comment": "/**\n      * Test sorting with hour comparator.\n      */"}}
{"code": {"body": "    public void testListDOW() {\n        String[] dtStrs = {\n            \n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\"\n        };\n        \n        List sl = loadAList( dtStrs );\n        boolean isSorted1 = isListSorted( sl );\n        Collections.sort( sl, cDayOfWeek );\n        boolean isSorted2 = isListSorted( sl );\n        assertEquals(\"\", !isSorted1, isSorted2);\n    }", "comment": "/**\n      * Test sorting with day of week comparator.\n      */"}}
{"code": {"body": "    public void testListDOM() {\n        String[] dtStrs = {\n            \n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\"\n        };\n        \n        List sl = loadAList( dtStrs );\n        boolean isSorted1 = isListSorted( sl );\n        Collections.sort( sl, cDayOfMonth );\n        boolean isSorted2 = isListSorted( sl );\n        assertEquals(\"\", !isSorted1, isSorted2);\n    }", "comment": "/**\n      * Test sorting with day of month comparator.\n      */"}}
{"code": {"body": "    public void testListDOY() {\n        String[] dtStrs = {\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\"\n        };\n        \n        List sl = loadAList( dtStrs );\n        boolean isSorted1 = isListSorted( sl );\n        Collections.sort( sl, cDayOfYear );\n        boolean isSorted2 = isListSorted( sl );\n        assertEquals(\"\", !isSorted1, isSorted2);\n    }", "comment": "/**\n      * Test sorting with day of year comparator.\n      */"}}
{"code": {"body": "    public void testListWOW() {\n        String[] dtStrs = {\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\"\n        };\n        \n        List sl = loadAList( dtStrs );\n        boolean isSorted1 = isListSorted( sl );\n        Collections.sort( sl, cWeekOfWeekyear );\n        boolean isSorted2 = isListSorted( sl );\n        assertEquals(\"\", !isSorted1, isSorted2);\n    }", "comment": "/**\n      * Test sorting with week of weekyear comparator.\n      */"}}
{"code": {"body": "    public void testListYOYY() {\n        \n        String[] dtStrs = {\n            \"\",\n            \"\"\n        };\n        \n        List sl = loadAList( dtStrs );\n        boolean isSorted1 = isListSorted( sl );\n        Collections.sort( sl, cWeekyear );\n        boolean isSorted2 = isListSorted( sl );\n        assertEquals(\"\", !isSorted1, isSorted2);\n    }", "comment": "/**\n      * Test sorting with year (given week) comparator.\n      */"}}
{"code": {"body": "    public void testListMonth() {\n        String[] dtStrs = {\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\"\n        };\n        \n        List sl = loadAList( dtStrs );\n        boolean isSorted1 = isListSorted( sl );\n        Collections.sort( sl, cMonth );\n        boolean isSorted2 = isListSorted( sl );\n        assertEquals(\"\", !isSorted1, isSorted2);\n    }", "comment": "/**\n      * Test sorting with month comparator.\n      */"}}
{"code": {"body": "     public void testListYear() {\n        String[] dtStrs = {\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\"\n        };\n        \n        List sl = loadAList( dtStrs );\n        boolean isSorted1 = isListSorted( sl );\n        Collections.sort( sl, cYear );\n        boolean isSorted2 = isListSorted( sl );\n        assertEquals(\"\", !isSorted1, isSorted2);\n     }", "comment": "/**\n      * Test sorting with year comparator.\n      */"}}
{"code": {"body": "    public void testListDate() {\n        String[] dtStrs = {\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\"\n        };\n        \n        List sl = loadAList( dtStrs );\n        boolean isSorted1 = isListSorted( sl );\n        Collections.sort( sl, cDate );\n        boolean isSorted2 = isListSorted( sl );\n        assertEquals(\"\", !isSorted1, isSorted2);\n    }", "comment": "/**\n      * Test sorting with date only comparator.\n      */"}}
{"code": {"body": "    public void testListTime() {\n        String[] dtStrs = {\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\"\n        };\n        \n        List sl = loadAList( dtStrs );\n        boolean isSorted1 = isListSorted( sl );\n        Collections.sort( sl, cTime );\n        boolean isSorted2 = isListSorted( sl );\n        assertEquals(\"\", !isSorted1, isSorted2);\n    }", "comment": "/**\n      * Test sorting with time only comparator.\n      */"}}
{"code": {"body": "    public void testNullDT() {\n        \n        aDateTime = getADate(\"\");\n        assertTrue(cYear.compare(null, aDateTime) > 0);\n        assertTrue(cYear.compare(aDateTime, null) < 0);\n    }", "comment": "/**\n     * Test comparator operation with null object(s).\n     */"}}
{"code": {"body": "    public void testInvalidObj() {\n        aDateTime = getADate(\"\");\n        try {\n            cYear.compare(\"\", aDateTime);\n            fail(\"\");\n        } catch (IllegalArgumentException cce) {}\n    }", "comment": "/**\n     * Test comparator operation with an invalid object type.\n     */"}}
{"code": {"body": "    private DateTime getADate(String s) {\n        DateTime retDT = null;\n        try {\n            retDT = new DateTime(s, DateTimeZone.UTC);\n        } catch (IllegalArgumentException pe) {\n            pe.printStackTrace();\n        }\n        return retDT;\n    }", "comment": "/**\n     * Creates a date to test with.\n     */"}}
{"code": {"body": "    private List loadAList(String[] someStrs) {\n        List newList = new ArrayList();\n        try {\n            for (int i = 0; i < someStrs.length; ++i) {\n                newList.add(new DateTime(someStrs[i], DateTimeZone.UTC));\n            } \n        } catch (IllegalArgumentException pe) {\n            pe.printStackTrace();\n        }\n        return newList;\n    }", "comment": "/**\n     * Load a string array.\n     */"}}
{"code": {"body": "    private boolean isListSorted(List tl) {\n        \n        DateTime lhDT = (DateTime)tl.get(0);\n        DateTime rhDT = null;\n        Long lhVal = new Long( lhDT.getMillis() );\n        Long rhVal = null;\n        for (int i = 1; i < tl.size(); ++i) {\n            rhDT = (DateTime)tl.get(i);\n            rhVal = new Long( rhDT.getMillis() );\n            if ( lhVal.compareTo( rhVal) > 0 ) return false;\n            \n            lhVal = rhVal;  \n            lhDT = rhDT;    \n        }\n        return true;\n    }", "comment": "/**\n     * Check if the list is sorted.\n     */"}}
{"code": {"body": "public TestDateTimeConstants(String name) {\n        super(name);\n    }", "comment": "/**\n     * TestDateTimeComparator constructor.\n     * @param name\n     */"}}
{"code": {"body": "    public static void main(String[] args) {\n        junit.textui.TestRunner.run(suite());\n    }", "comment": "/**\n     * The main method for this test program.\n     * @param args command line arguments.\n     */"}}
{"code": {"body": "    public static TestSuite suite() {\n        return new TestSuite(TestDateTimeConstants.class);\n    }", "comment": "/**\n     * TestSuite is a junit required method.\n     */"}}
{"code": {"body": "    public void test_now() throws Throwable {\n        DateTime test = DateTime.now();\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test now ()\n     */"}}
{"code": {"body": "    public void test_now_DateTimeZone() throws Throwable {\n        DateTime test = DateTime.now(PARIS);\n        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test now (DateTimeZone)\n     */"}}
{"code": {"body": "    public void test_now_nullDateTimeZone() throws Throwable {\n        try {\n            DateTime.now((DateTimeZone) null);\n            fail();\n        } catch (NullPointerException ex) {}\n    }", "comment": "/**\n     * Test now (DateTimeZone=null)\n     */"}}
{"code": {"body": "    public void test_now_Chronology() throws Throwable {\n        DateTime test = DateTime.now(GregorianChronology.getInstance());\n        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test now (Chronology)\n     */"}}
{"code": {"body": "    public void test_now_nullChronology() throws Throwable {\n        try {\n            DateTime.now((Chronology) null);\n            fail();\n        } catch (NullPointerException ex) {}\n    }", "comment": "/**\n     * Test now (Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor() throws Throwable {\n        DateTime test = new DateTime();\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test constructor ()\n     */"}}
{"code": {"body": "    public void testConstructor_DateTimeZone() throws Throwable {\n        DateTime test = new DateTime(PARIS);\n        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (DateTimeZone)\n     */"}}
{"code": {"body": "    public void testConstructor_nullDateTimeZone() throws Throwable {\n        DateTime test = new DateTime((DateTimeZone) null);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (DateTimeZone=null)\n     */"}}
{"code": {"body": "    public void testConstructor_Chronology() throws Throwable {\n        DateTime test = new DateTime(GregorianChronology.getInstance());\n        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_nullChronology() throws Throwable {\n        DateTime test = new DateTime((Chronology) null);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor_long1() throws Throwable {\n        DateTime test = new DateTime(TEST_TIME1);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME1, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (long)\n     */"}}
{"code": {"body": "    public void testConstructor_long2() throws Throwable {\n        DateTime test = new DateTime(TEST_TIME2);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME2, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (long)\n     */"}}
{"code": {"body": "    public void testConstructor_long1_DateTimeZone() throws Throwable {\n        DateTime test = new DateTime(TEST_TIME1, PARIS);\n        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n        assertEquals(TEST_TIME1, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (long, DateTimeZone)\n     */"}}
{"code": {"body": "    public void testConstructor_long2_DateTimeZone() throws Throwable {\n        DateTime test = new DateTime(TEST_TIME2, PARIS);\n        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n        assertEquals(TEST_TIME2, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (long, DateTimeZone)\n     */"}}
{"code": {"body": "    public void testConstructor_long_nullDateTimeZone() throws Throwable {\n        DateTime test = new DateTime(TEST_TIME1, (DateTimeZone) null);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME1, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (long, DateTimeZone=null)\n     */"}}
{"code": {"body": "    public void testConstructor_long1_Chronology() throws Throwable {\n        DateTime test = new DateTime(TEST_TIME1, GregorianChronology.getInstance());\n        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME1, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (long, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_long2_Chronology() throws Throwable {\n        DateTime test = new DateTime(TEST_TIME2, GregorianChronology.getInstance());\n        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME2, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (long, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_long_nullChronology() throws Throwable {\n        DateTime test = new DateTime(TEST_TIME1, (Chronology) null);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME1, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (long, Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor_Object() throws Throwable {\n        Date date = new Date(TEST_TIME1);\n        DateTime test = new DateTime(date);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME1, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Object)\n     */"}}
{"code": {"body": "    public void testConstructor_invalidObject() throws Throwable {\n        try {\n            new DateTime(new Object());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n    }", "comment": "/**\n     * Test constructor (Object)\n     */"}}
{"code": {"body": "    public void testConstructor_nullObject() throws Throwable {\n        DateTime test = new DateTime((Object) null);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Object=null)\n     */"}}
{"code": {"body": "    public void testConstructor_badconverterObject() throws Throwable {\n        try {\n            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n            DateTime test = new DateTime(new Integer(0));\n            assertEquals(ISOChronology.getInstance(), test.getChronology());\n            assertEquals(0L, test.getMillis());\n        } finally {\n            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n        }\n    }", "comment": "/**\n     * Test constructor (Object=null)\n     */"}}
{"code": {"body": "    public void testConstructor_Object_DateTimeZone() throws Throwable {\n        Date date = new Date(TEST_TIME1);\n        DateTime test = new DateTime(date, PARIS);\n        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n        assertEquals(TEST_TIME1, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Object, DateTimeZone)\n     */"}}
{"code": {"body": "    public void testConstructor_invalidObject_DateTimeZone() throws Throwable {\n        try {\n            new DateTime(new Object(), PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n    }", "comment": "/**\n     * Test constructor (Object, DateTimeZone)\n     */"}}
{"code": {"body": "    public void testConstructor_nullObject_DateTimeZone() throws Throwable {\n        DateTime test = new DateTime((Object) null, PARIS);\n        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Object=null, DateTimeZone)\n     */"}}
{"code": {"body": "    public void testConstructor_Object_nullDateTimeZone() throws Throwable {\n        Date date = new Date(TEST_TIME1);\n        DateTime test = new DateTime(date, (DateTimeZone) null);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME1, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Object, DateTimeZone=null)\n     */"}}
{"code": {"body": "    public void testConstructor_nullObject_nullDateTimeZone() throws Throwable {\n        DateTime test = new DateTime((Object) null, (DateTimeZone) null);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Object=null, DateTimeZone=null)\n     */"}}
{"code": {"body": "    public void testConstructor_badconverterObject_DateTimeZone() throws Throwable {\n        try {\n            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n            DateTime test = new DateTime(new Integer(0), GregorianChronology.getInstance());\n            assertEquals(ISOChronology.getInstance(), test.getChronology());\n            assertEquals(0L, test.getMillis());\n        } finally {\n            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n        }\n    }", "comment": "/**\n     * Test constructor (Object, DateTimeZone)\n     */"}}
{"code": {"body": "    public void testConstructor_Object_Chronology() throws Throwable {\n        Date date = new Date(TEST_TIME1);\n        DateTime test = new DateTime(date, GregorianChronology.getInstance());\n        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME1, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Object, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_invalidObject_Chronology() throws Throwable {\n        try {\n            new DateTime(new Object(), GregorianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n    }", "comment": "/**\n     * Test constructor (Object, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_nullObject_Chronology() throws Throwable {\n        DateTime test = new DateTime((Object) null, GregorianChronology.getInstance());\n        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Object=null, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_Object_nullChronology() throws Throwable {\n        Date date = new Date(TEST_TIME1);\n        DateTime test = new DateTime(date, (Chronology) null);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME1, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Object, Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor_nullObject_nullChronology() throws Throwable {\n        DateTime test = new DateTime((Object) null, (Chronology) null);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Object=null, Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor_badconverterObject_Chronology() throws Throwable {\n        try {\n            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n            DateTime test = new DateTime(new Integer(0), GregorianChronology.getInstance());\n            assertEquals(ISOChronology.getInstance(), test.getChronology());\n            assertEquals(0L, test.getMillis());\n        } finally {\n            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n        }\n    }", "comment": "/**\n     * Test constructor (Object, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_int_int_int() throws Throwable {\n        DateTime test = new DateTime(2002, 6, 9, 1, 0);  \n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(LONDON, test.getZone());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (int, int, int, int, int)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_int_int_int_DateTimeZone() throws Throwable {\n        DateTime test = new DateTime(2002, 6, 9, 2, 0, PARIS);  \n        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (int, int, int, int, int, DateTimeZone)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_int_int_int_nullDateTimeZone() throws Throwable {\n        DateTime test = new DateTime(2002, 6, 9, 1, 0, (DateTimeZone) null);  \n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (int, int, int, int, int, DateTimeZone=null)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_int_int_int_Chronology() throws Throwable {\n        DateTime test = new DateTime(2002, 6, 9, 1, 0, GregorianChronology.getInstance());  \n        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (int, int, int, int, int, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_int_int_int_nullChronology() throws Throwable {\n        DateTime test = new DateTime(2002, 6, 9, 1, 0, (Chronology) null);  \n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (int, int, int, int, int, Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_int_int_int_int() throws Throwable {\n        DateTime test = new DateTime(2002, 6, 9, 1, 0, 0);  \n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(LONDON, test.getZone());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (int, int, int, int, int, int)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_int_int_int_int_DateTimeZone() throws Throwable {\n        DateTime test = new DateTime(2002, 6, 9, 2, 0, 0, PARIS);  \n        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (int, int, int, int, int, int, DateTimeZone)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_int_int_int_int_nullDateTimeZone() throws Throwable {\n        DateTime test = new DateTime(2002, 6, 9, 1, 0, 0, (DateTimeZone) null);  \n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (int, int, int, int, int, int, DateTimeZone=null)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_int_int_int_int_Chronology() throws Throwable {\n        DateTime test = new DateTime(2002, 6, 9, 1, 0, 0, GregorianChronology.getInstance());  \n        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (int, int, int, int, int, int, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_int_int_int_int_nullChronology() throws Throwable {\n        DateTime test = new DateTime(2002, 6, 9, 1, 0, 0, (Chronology) null);  \n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (int, int, int, int, int, int, Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_int_int_int_int_int() throws Throwable {\n        DateTime test = new DateTime(2002, 6, 9, 1, 0, 0, 0);  \n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(LONDON, test.getZone());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n        try {\n            new DateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new DateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new DateTime(2002, 0, 9, 0, 0, 0, 0);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new DateTime(2002, 13, 9, 0, 0, 0, 0);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new DateTime(2002, 6, 0, 0, 0, 0, 0);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new DateTime(2002, 6, 31, 0, 0, 0, 0);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        new DateTime(2002, 7, 31, 0, 0, 0, 0);\n        try {\n            new DateTime(2002, 7, 32, 0, 0, 0, 0);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n    }", "comment": "/**\n     * Test constructor (int, int, int)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_int_int_int_int_int_DateTimeZone() throws Throwable {\n        DateTime test = new DateTime(2002, 6, 9, 2, 0, 0, 0, PARIS);  \n        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n        try {\n            new DateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0, PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new DateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0, PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new DateTime(2002, 0, 9, 0, 0, 0, 0, PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new DateTime(2002, 13, 9, 0, 0, 0, 0, PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new DateTime(2002, 6, 0, 0, 0, 0, 0, PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new DateTime(2002, 6, 31, 0, 0, 0, 0, PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        new DateTime(2002, 7, 31, 0, 0, 0, 0, PARIS);\n        try {\n            new DateTime(2002, 7, 32, 0, 0, 0, 0, PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n    }", "comment": "/**\n     * Test constructor (int, int, int, DateTimeZone)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_int_int_int_int_int_nullDateTimeZone() throws Throwable {\n        DateTime test = new DateTime(2002, 6, 9, 1, 0, 0, 0, (DateTimeZone) null);  \n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (int, int, int, DateTimeZone=null)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_int_int_int_int_int_Chronology() throws Throwable {\n        DateTime test = new DateTime(2002, 6, 9, 1, 0, 0, 0, GregorianChronology.getInstance());  \n        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n        try {\n            new DateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0, GregorianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new DateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0, GregorianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new DateTime(2002, 0, 9, 0, 0, 0, 0, GregorianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new DateTime(2002, 13, 9, 0, 0, 0, 0, GregorianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new DateTime(2002, 6, 0, 0, 0, 0, 0, GregorianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new DateTime(2002, 6, 31, 0, 0, 0, 0, GregorianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        new DateTime(2002, 7, 31, 0, 0, 0, 0, GregorianChronology.getInstance());\n        try {\n            new DateTime(2002, 7, 32, 0, 0, 0, 0, GregorianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n    }", "comment": "/**\n     * Test constructor (int, int, int, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_int_int_int_int_int_nullChronology() throws Throwable {\n        DateTime test = new DateTime(2002, 6, 9, 1, 0, 0, 0, (Chronology) null);  \n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (int, int, int, Chronology=null)\n     */"}}
{"code": {"body": "    public void testZERO() throws Throwable {\n        Duration test = Duration.ZERO;\n        assertEquals(0, test.getMillis());\n    }", "comment": "/**\n     * Test constructor ()\n     */"}}
{"code": {"body": "    public void testConstructor_Object1() throws Throwable {\n        Duration test = new Duration(\"\");\n        assertEquals(72345, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Object)\n     */"}}
{"code": {"body": "    public void test_now() throws Throwable {\n        Instant test = Instant.now();\n        assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test now ()\n     */"}}
{"code": {"body": "    public void testConstructor() throws Throwable {\n        Instant test = new Instant();\n        assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test constructor ()\n     */"}}
{"code": {"body": "    public void testConstructor_long1() throws Throwable {\n        Instant test = new Instant(TEST_TIME1);\n        assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());\n        assertEquals(TEST_TIME1, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (long)\n     */"}}
{"code": {"body": "    public void testConstructor_long2() throws Throwable {\n        Instant test = new Instant(TEST_TIME2);\n        assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());\n        assertEquals(TEST_TIME2, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (long)\n     */"}}
{"code": {"body": "    public void testConstructor_Object() throws Throwable {\n        Date date = new Date(TEST_TIME1);\n        Instant test = new Instant(date);\n        assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());\n        assertEquals(TEST_TIME1, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Object)\n     */"}}
{"code": {"body": "    public void testConstructor_invalidObject() throws Throwable {\n        try {\n            new Instant(new Object());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n    }", "comment": "/**\n     * Test constructor (Object)\n     */"}}
{"code": {"body": "    public void testConstructor_nullObject() throws Throwable {\n        Instant test = new Instant((Object) null);\n        assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Object=null)\n     */"}}
{"code": {"body": "    public void testConstructor_badconverterObject() throws Throwable {\n        try {\n            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n            Instant test = new Instant(new Integer(0));\n            assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());\n            assertEquals(0L, test.getMillis());\n        } finally {\n            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n        }\n    }", "comment": "/**\n     * Test constructor (Object=null)\n     */"}}
{"code": {"body": "    public void testConstantMidnight() throws Throwable {\n        LocalTime test = LocalTime.MIDNIGHT;\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(0, test.getHourOfDay());\n        assertEquals(0, test.getMinuteOfHour());\n        assertEquals(0, test.getSecondOfMinute());\n        assertEquals(0, test.getMillisOfSecond());\n    }", "comment": "/**\n     * Test constructor ()\n     */"}}
{"code": {"body": "    public void testConstructor() throws Throwable {\n        MonthDay test = new MonthDay();\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(6, test.getMonthOfYear());\n        assertEquals(9, test.getDayOfMonth());\n        assertEquals(test, MonthDay.now());\n    }", "comment": "/**\n     * Test constructor ()\n     */"}}
{"code": {"body": "    public void testConstructor_DateTimeZone() throws Throwable {\n        DateTime dt = new DateTime(2005, 6, 30, 23, 59, 0, 0, LONDON);\n        DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n        \n        \n        MonthDay test = new MonthDay(LONDON);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(6, test.getMonthOfYear());\n        assertEquals(30, test.getDayOfMonth());\n        assertEquals(test, MonthDay.now(LONDON));\n        \n        test = new MonthDay(PARIS);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(7, test.getMonthOfYear());\n        assertEquals(1, test.getDayOfMonth());\n        assertEquals(test, MonthDay.now(PARIS));\n    }", "comment": "/**\n     * Test constructor (DateTimeZone)\n     */"}}
{"code": {"body": "    public void testConstructor_nullDateTimeZone() throws Throwable {\n        DateTime dt = new DateTime(2005, 6, 30, 23, 59, 0, 0, LONDON);\n        DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n        \n        \n        MonthDay test = new MonthDay((DateTimeZone) null);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(6, test.getMonthOfYear());\n        assertEquals(30, test.getDayOfMonth());\n    }", "comment": "/**\n     * Test constructor (DateTimeZone=null)\n     */"}}
{"code": {"body": "    public void testConstructor_Chronology() throws Throwable {\n        MonthDay test = new MonthDay(GREGORIAN_PARIS);\n        assertEquals(GREGORIAN_UTC, test.getChronology());\n        assertEquals(6, test.getMonthOfYear());\n        assertEquals(9, test.getDayOfMonth());\n        assertEquals(test, MonthDay.now(GREGORIAN_PARIS));\n    }", "comment": "/**\n     * Test constructor (Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_nullChronology() throws Throwable {\n        MonthDay test = new MonthDay((Chronology) null);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(6, test.getMonthOfYear());\n        assertEquals(9, test.getDayOfMonth());\n    }", "comment": "/**\n     * Test constructor (Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor_long1() throws Throwable {\n        MonthDay test = new MonthDay(TEST_TIME1);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(4, test.getMonthOfYear());\n        assertEquals(6, test.getDayOfMonth());\n    }", "comment": "/**\n     * Test constructor (long)\n     */"}}
{"code": {"body": "    public void testConstructor_long2() throws Throwable {\n        MonthDay test = new MonthDay(TEST_TIME2);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(5, test.getMonthOfYear());\n        assertEquals(7, test.getDayOfMonth());\n    }", "comment": "/**\n     * Test constructor (long)\n     */"}}
{"code": {"body": "    public void testConstructor_long1_Chronology() throws Throwable {\n        MonthDay test = new MonthDay(TEST_TIME1, GREGORIAN_PARIS);\n        assertEquals(GREGORIAN_UTC, test.getChronology());\n        assertEquals(4, test.getMonthOfYear());\n        assertEquals(6, test.getDayOfMonth());\n    }", "comment": "/**\n     * Test constructor (long, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_long2_Chronology() throws Throwable {\n        MonthDay test = new MonthDay(TEST_TIME2, GREGORIAN_PARIS);\n        assertEquals(GREGORIAN_UTC, test.getChronology());\n        assertEquals(5, test.getMonthOfYear());\n        assertEquals(7, test.getDayOfMonth());\n    }", "comment": "/**\n     * Test constructor (long, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_long_nullChronology() throws Throwable {\n        MonthDay test = new MonthDay(TEST_TIME1, null);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(4, test.getMonthOfYear());\n        assertEquals(6, test.getDayOfMonth());\n    }", "comment": "/**\n     * Test constructor (long, Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor_Object_Chronology() throws Throwable {\n        Date date = new Date(TEST_TIME1);\n        MonthDay test = new MonthDay(date, GREGORIAN_PARIS);\n        assertEquals(GREGORIAN_UTC, test.getChronology());\n        assertEquals(4, test.getMonthOfYear());\n        assertEquals(6, test.getDayOfMonth());\n    }", "comment": "/**\n     * Test constructor (Object, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_nullObject_Chronology() throws Throwable {\n        MonthDay test = new MonthDay((Object) null, GREGORIAN_PARIS);\n        assertEquals(GREGORIAN_UTC, test.getChronology());\n        assertEquals(6, test.getMonthOfYear());\n        assertEquals(9, test.getDayOfMonth());\n    }", "comment": "/**\n     * Test constructor (Object=null, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_Object_nullChronology() throws Throwable {\n        Date date = new Date(TEST_TIME1);\n        MonthDay test = new MonthDay(date, null);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(4, test.getMonthOfYear());\n        assertEquals(6, test.getDayOfMonth());\n    }", "comment": "/**\n     * Test constructor (Object, Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor_nullObject_nullChronology() throws Throwable {\n        MonthDay test = new MonthDay((Object) null, null);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(6, test.getMonthOfYear());\n        assertEquals(9, test.getDayOfMonth());\n    }", "comment": "/**\n     * Test constructor (Object=null, Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int() throws Throwable {\n        MonthDay test = new MonthDay(6, 30);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(6, test.getMonthOfYear());\n        assertEquals(30, test.getDayOfMonth());\n        try {\n            new MonthDay(Integer.MIN_VALUE, 6);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new MonthDay(Integer.MAX_VALUE, 6);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new MonthDay(1970, 0);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new MonthDay(1970, 13);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n    }", "comment": "/**\n     * Test constructor (int, int)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_Chronology() throws Throwable {\n        MonthDay test = new MonthDay(6, 30, GREGORIAN_PARIS);\n        assertEquals(GREGORIAN_UTC, test.getChronology());\n        assertEquals(6, test.getMonthOfYear());\n        assertEquals(30, test.getDayOfMonth());\n        try {\n            new MonthDay(Integer.MIN_VALUE, 6, GREGORIAN_PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new MonthDay(Integer.MAX_VALUE, 6, GREGORIAN_PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new MonthDay(1970, 0, GREGORIAN_PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new MonthDay(1970, 13, GREGORIAN_PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n    }", "comment": "/**\n     * Test constructor (int, int, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_nullChronology() throws Throwable {\n        MonthDay test = new MonthDay(6, 30, null);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(6, test.getMonthOfYear());\n        assertEquals(30, test.getDayOfMonth());\n    }", "comment": "/**\n     * Test constructor (int, int, Chronology=null)\n     */"}}
{"code": {"body": "    public void test_now() throws Throwable {\n        MutableDateTime test = MutableDateTime.now();\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test now ()\n     */"}}
{"code": {"body": "    public void test_now_DateTimeZone() throws Throwable {\n        MutableDateTime test = MutableDateTime.now(PARIS);\n        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test now (DateTimeZone)\n     */"}}
{"code": {"body": "    public void test_now_nullDateTimeZone() throws Throwable {\n        try {\n            MutableDateTime.now((DateTimeZone) null);\n            fail();\n        } catch (NullPointerException ex) {}\n    }", "comment": "/**\n     * Test now (DateTimeZone=null)\n     */"}}
{"code": {"body": "    public void test_now_Chronology() throws Throwable {\n        MutableDateTime test = MutableDateTime.now(GregorianChronology.getInstance());\n        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test now (Chronology)\n     */"}}
{"code": {"body": "    public void test_now_nullChronology() throws Throwable {\n        try {\n            MutableDateTime.now((Chronology) null);\n            fail();\n        } catch (NullPointerException ex) {}\n    }", "comment": "/**\n     * Test now (Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor() throws Throwable {\n        MutableDateTime test = new MutableDateTime();\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test constructor ()\n     */"}}
{"code": {"body": "    public void testConstructor_DateTimeZone() throws Throwable {\n        MutableDateTime test = new MutableDateTime(PARIS);\n        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (DateTimeZone)\n     */"}}
{"code": {"body": "    public void testConstructor_nullDateTimeZone() throws Throwable {\n        MutableDateTime test = new MutableDateTime((DateTimeZone) null);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (DateTimeZone=null)\n     */"}}
{"code": {"body": "    public void testConstructor_Chronology() throws Throwable {\n        MutableDateTime test = new MutableDateTime(GregorianChronology.getInstance());\n        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_nullChronology() throws Throwable {\n        MutableDateTime test = new MutableDateTime((Chronology) null);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor_long1() throws Throwable {\n        MutableDateTime test = new MutableDateTime(TEST_TIME1);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME1, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (long)\n     */"}}
{"code": {"body": "    public void testConstructor_long2() throws Throwable {\n        MutableDateTime test = new MutableDateTime(TEST_TIME2);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME2, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (long)\n     */"}}
{"code": {"body": "    public void testConstructor_long1_DateTimeZone() throws Throwable {\n        MutableDateTime test = new MutableDateTime(TEST_TIME1, PARIS);\n        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n        assertEquals(TEST_TIME1, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (long, DateTimeZone)\n     */"}}
{"code": {"body": "    public void testConstructor_long2_DateTimeZone() throws Throwable {\n        MutableDateTime test = new MutableDateTime(TEST_TIME2, PARIS);\n        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n        assertEquals(TEST_TIME2, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (long, DateTimeZone)\n     */"}}
{"code": {"body": "    public void testConstructor_long_nullDateTimeZone() throws Throwable {\n        MutableDateTime test = new MutableDateTime(TEST_TIME1, (DateTimeZone) null);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME1, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (long, DateTimeZone=null)\n     */"}}
{"code": {"body": "    public void testConstructor_long1_Chronology() throws Throwable {\n        MutableDateTime test = new MutableDateTime(TEST_TIME1, GregorianChronology.getInstance());\n        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME1, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (long, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_long2_Chronology() throws Throwable {\n        MutableDateTime test = new MutableDateTime(TEST_TIME2, GregorianChronology.getInstance());\n        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME2, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (long, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_long_nullChronology() throws Throwable {\n        MutableDateTime test = new MutableDateTime(TEST_TIME1, (Chronology) null);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME1, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (long, Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor_Object() throws Throwable {\n        Date date = new Date(TEST_TIME1);\n        MutableDateTime test = new MutableDateTime(date);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME1, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Object)\n     */"}}
{"code": {"body": "    public void testConstructor_invalidObject() throws Throwable {\n        try {\n            new MutableDateTime(new Object());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n    }", "comment": "/**\n     * Test constructor (Object)\n     */"}}
{"code": {"body": "    public void testConstructor_nullObject() throws Throwable {\n        MutableDateTime test = new MutableDateTime((Object) null);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Object=null)\n     */"}}
{"code": {"body": "    public void testConstructor_badconverterObject() throws Throwable {\n        try {\n            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n            MutableDateTime test = new MutableDateTime(new Integer(0));\n            assertEquals(ISOChronology.getInstance(), test.getChronology());\n            assertEquals(0L, test.getMillis());\n        } finally {\n            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n        }\n    }", "comment": "/**\n     * Test constructor (Object=null)\n     */"}}
{"code": {"body": "    public void testConstructor_Object_DateTimeZone() throws Throwable {\n        Date date = new Date(TEST_TIME1);\n        MutableDateTime test = new MutableDateTime(date, PARIS);\n        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n        assertEquals(TEST_TIME1, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Object, DateTimeZone)\n     */"}}
{"code": {"body": "    public void testConstructor_invalidObject_DateTimeZone() throws Throwable {\n        try {\n            new MutableDateTime(new Object(), PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n    }", "comment": "/**\n     * Test constructor (Object, DateTimeZone)\n     */"}}
{"code": {"body": "    public void testConstructor_nullObject_DateTimeZone() throws Throwable {\n        MutableDateTime test = new MutableDateTime((Object) null, PARIS);\n        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Object=null, DateTimeZone)\n     */"}}
{"code": {"body": "    public void testConstructor_Object_nullDateTimeZone() throws Throwable {\n        Date date = new Date(TEST_TIME1);\n        MutableDateTime test = new MutableDateTime(date, (DateTimeZone) null);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME1, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Object, DateTimeZone=null)\n     */"}}
{"code": {"body": "    public void testConstructor_nullObject_nullDateTimeZone() throws Throwable {\n        MutableDateTime test = new MutableDateTime((Object) null, (DateTimeZone) null);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Object=null, DateTimeZone=null)\n     */"}}
{"code": {"body": "    public void testConstructor_badconverterObject_DateTimeZone() throws Throwable {\n        try {\n            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n            MutableDateTime test = new MutableDateTime(new Integer(0), GregorianChronology.getInstance());\n            assertEquals(ISOChronology.getInstance(), test.getChronology());\n            assertEquals(0L, test.getMillis());\n        } finally {\n            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n        }\n    }", "comment": "/**\n     * Test constructor (Object, DateTimeZone)\n     */"}}
{"code": {"body": "    public void testConstructor_Object_Chronology() throws Throwable {\n        Date date = new Date(TEST_TIME1);\n        MutableDateTime test = new MutableDateTime(date, GregorianChronology.getInstance());\n        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME1, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Object, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_invalidObject_Chronology() throws Throwable {\n        try {\n            new MutableDateTime(new Object(), GregorianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n    }", "comment": "/**\n     * Test constructor (Object, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_nullObject_Chronology() throws Throwable {\n        MutableDateTime test = new MutableDateTime((Object) null, GregorianChronology.getInstance());\n        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Object=null, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_Object_nullChronology() throws Throwable {\n        Date date = new Date(TEST_TIME1);\n        MutableDateTime test = new MutableDateTime(date, (Chronology) null);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME1, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Object, Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor_nullObject_nullChronology() throws Throwable {\n        MutableDateTime test = new MutableDateTime((Object) null, (Chronology) null);\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Object=null, Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor_badconverterObject_Chronology() throws Throwable {\n        try {\n            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n            MutableDateTime test = new MutableDateTime(new Integer(0), GregorianChronology.getInstance());\n            assertEquals(ISOChronology.getInstance(), test.getChronology());\n            assertEquals(0L, test.getMillis());\n        } finally {\n            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n        }\n    }", "comment": "/**\n     * Test constructor (Object, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_int_int_int_int_int() throws Throwable {\n        MutableDateTime test = new MutableDateTime(2002, 6, 9, 1, 0, 0, 0);  \n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(LONDON, test.getZone());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n        try {\n            new MutableDateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new MutableDateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new MutableDateTime(2002, 0, 9, 0, 0, 0, 0);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new MutableDateTime(2002, 13, 9, 0, 0, 0, 0);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new MutableDateTime(2002, 6, 0, 0, 0, 0, 0);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new MutableDateTime(2002, 6, 31, 0, 0, 0, 0);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        new MutableDateTime(2002, 7, 31, 0, 0, 0, 0);\n        try {\n            new MutableDateTime(2002, 7, 32, 0, 0, 0, 0);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n    }", "comment": "/**\n     * Test constructor (int, int, int)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_int_int_int_int_int_DateTimeZone() throws Throwable {\n        MutableDateTime test = new MutableDateTime(2002, 6, 9, 2, 0, 0, 0, PARIS);  \n        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n        try {\n            new MutableDateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0, PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new MutableDateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0, PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new MutableDateTime(2002, 0, 9, 0, 0, 0, 0, PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new MutableDateTime(2002, 13, 9, 0, 0, 0, 0, PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new MutableDateTime(2002, 6, 0, 0, 0, 0, 0, PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new MutableDateTime(2002, 6, 31, 0, 0, 0, 0, PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        new MutableDateTime(2002, 7, 31, 0, 0, 0, 0, PARIS);\n        try {\n            new MutableDateTime(2002, 7, 32, 0, 0, 0, 0, PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n    }", "comment": "/**\n     * Test constructor (int, int, int, DateTimeZone)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_int_int_int_int_int_nullDateTimeZone() throws Throwable {\n        MutableDateTime test = new MutableDateTime(2002, 6, 9, 1, 0, 0, 0, (DateTimeZone) null);  \n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (int, int, int, DateTimeZone=null)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_int_int_int_int_int_Chronology() throws Throwable {\n        MutableDateTime test = new MutableDateTime(2002, 6, 9, 1, 0, 0, 0, GregorianChronology.getInstance());  \n        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n        try {\n            new MutableDateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0, GregorianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new MutableDateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0, GregorianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new MutableDateTime(2002, 0, 9, 0, 0, 0, 0, GregorianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new MutableDateTime(2002, 13, 9, 0, 0, 0, 0, GregorianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new MutableDateTime(2002, 6, 0, 0, 0, 0, 0, GregorianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new MutableDateTime(2002, 6, 31, 0, 0, 0, 0, GregorianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        new MutableDateTime(2002, 7, 31, 0, 0, 0, 0, GregorianChronology.getInstance());\n        try {\n            new MutableDateTime(2002, 7, 32, 0, 0, 0, 0, GregorianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n    }", "comment": "/**\n     * Test constructor (int, int, int, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_int_int_int_int_int_nullChronology() throws Throwable {\n        MutableDateTime test = new MutableDateTime(2002, 6, 9, 1, 0, 0, 0, (Chronology) null);  \n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(TEST_TIME_NOW, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (int, int, int, Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor1() throws Throwable {\n        MutablePeriod test = new MutablePeriod();\n        assertEquals(PeriodType.standard(), test.getPeriodType());\n        assertEquals(0, test.getYears());\n        assertEquals(0, test.getMonths());\n        assertEquals(0, test.getWeeks());\n        assertEquals(0, test.getDays());\n        assertEquals(0, test.getHours());\n        assertEquals(0, test.getMinutes());\n        assertEquals(0, test.getSeconds());\n        assertEquals(0, test.getMillis());\n    }", "comment": "/**\n     * Test constructor ()\n     */"}}
{"code": {"body": "    public void testConstructor_PeriodType1() throws Throwable {\n        MutablePeriod test = new MutablePeriod(PeriodType.yearMonthDayTime());\n        assertEquals(PeriodType.yearMonthDayTime(), test.getPeriodType());\n        assertEquals(0, test.getYears());\n        assertEquals(0, test.getMonths());\n        assertEquals(0, test.getWeeks());\n        assertEquals(0, test.getDays());\n        assertEquals(0, test.getHours());\n        assertEquals(0, test.getMinutes());\n        assertEquals(0, test.getSeconds());\n        assertEquals(0, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (PeriodType)\n     */"}}
{"code": {"body": "    public void testConstructor_4int1() throws Throwable {\n        MutablePeriod test = new MutablePeriod(5, 6, 7, 8);\n        assertEquals(PeriodType.standard(), test.getPeriodType());\n        assertEquals(0, test.getYears());\n        assertEquals(0, test.getMonths());\n        assertEquals(0, test.getWeeks());\n        assertEquals(0, test.getDays());\n        assertEquals(5, test.getHours());\n        assertEquals(6, test.getMinutes());\n        assertEquals(7, test.getSeconds());\n        assertEquals(8, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (4ints)\n     */"}}
{"code": {"body": "    public void testConstructor_8int1() throws Throwable {\n        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n        assertEquals(PeriodType.standard(), test.getPeriodType());\n        assertEquals(1, test.getYears());\n        assertEquals(2, test.getMonths());\n        assertEquals(3, test.getWeeks());\n        assertEquals(4, test.getDays());\n        assertEquals(5, test.getHours());\n        assertEquals(6, test.getMinutes());\n        assertEquals(7, test.getSeconds());\n        assertEquals(8, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (8ints)\n     */"}}
{"code": {"body": "    public void testConstructor_8int__PeriodType1() throws Throwable {\n        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, null);\n        assertEquals(PeriodType.standard(), test.getPeriodType());\n        assertEquals(1, test.getYears());\n        assertEquals(2, test.getMonths());\n        assertEquals(3, test.getWeeks());\n        assertEquals(4, test.getDays());\n        assertEquals(5, test.getHours());\n        assertEquals(6, test.getMinutes());\n        assertEquals(7, test.getSeconds());\n        assertEquals(8, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (8ints)\n     */"}}
{"code": {"body": "    public void testConstructor_Object1() throws Throwable {\n        MutablePeriod test = new MutablePeriod(\"\");\n        assertEquals(PeriodType.standard(), test.getPeriodType());\n        assertEquals(1, test.getYears());\n        assertEquals(2, test.getMonths());\n        assertEquals(0, test.getWeeks());\n        assertEquals(3, test.getDays());\n        assertEquals(0, test.getHours());\n        assertEquals(0, test.getMinutes());\n        assertEquals(0, test.getSeconds());\n        assertEquals(0, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Object)\n     */"}}
{"code": {"body": "    public void testConstructor_Object_PeriodType1() throws Throwable {\n        MutablePeriod test = new MutablePeriod(\"\", PeriodType.yearMonthDayTime());\n        assertEquals(PeriodType.yearMonthDayTime(), test.getPeriodType());\n        assertEquals(1, test.getYears());\n        assertEquals(2, test.getMonths());\n        assertEquals(0, test.getWeeks());\n        assertEquals(3, test.getDays());\n        assertEquals(0, test.getHours());\n        assertEquals(0, test.getMinutes());\n        assertEquals(0, test.getSeconds());\n        assertEquals(0, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Object,PeriodType)\n     */"}}
{"code": {"body": "    public void testConstructor() throws Throwable {\n        Partial test = new Partial();\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(0, test.size());\n    }", "comment": "/**\n     * Test constructor\n     */"}}
{"code": {"body": "    public void testConstructor_Chrono() throws Throwable {\n        Partial test = new Partial((Chronology) null);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(0, test.size());\n        \n        test = new Partial(GREGORIAN_PARIS);\n        assertEquals(GREGORIAN_UTC, test.getChronology());\n        assertEquals(0, test.size());\n    }", "comment": "/**\n     * Test constructor\n     */"}}
{"code": {"body": "    public void testConstructor_Type_int() throws Throwable {\n        Partial test = new Partial(DateTimeFieldType.dayOfYear(), 4);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(1, test.size());\n        assertEquals(4, test.getValue(0));\n        assertEquals(4, test.get(DateTimeFieldType.dayOfYear()));\n        assertEquals(true, test.isSupported(DateTimeFieldType.dayOfYear()));\n    }", "comment": "/**\n     * Test constructor\n     */"}}
{"code": {"body": "    public void testConstructorEx1_Type_int() throws Throwable {\n        try {\n            new Partial(null, 4);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            assertMessageContains(ex, \"\");\n        }\n    }", "comment": "/**\n     * Test constructor\n     */"}}
{"code": {"body": "    public void testConstructorEx2_Type_int() throws Throwable {\n        try {\n            new Partial(DateTimeFieldType.dayOfYear(), 0);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            \n        }\n    }", "comment": "/**\n     * Test constructor\n     */"}}
{"code": {"body": "    public void testConstructor_Type_int_Chrono() throws Throwable {\n        Partial test = new Partial(DateTimeFieldType.dayOfYear(), 4, GREGORIAN_PARIS);\n        assertEquals(GREGORIAN_UTC, test.getChronology());\n        assertEquals(1, test.size());\n        assertEquals(4, test.getValue(0));\n        assertEquals(4, test.get(DateTimeFieldType.dayOfYear()));\n        assertEquals(true, test.isSupported(DateTimeFieldType.dayOfYear()));\n    }", "comment": "/**\n     * Test constructor\n     */"}}
{"code": {"body": "    public void testConstructorEx_Type_int_Chrono() throws Throwable {\n        try {\n            new Partial(null, 4, ISO_UTC);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            assertMessageContains(ex, \"\");\n        }\n    }", "comment": "/**\n     * Test constructor\n     */"}}
{"code": {"body": "    public void testConstructorEx2_Type_int_Chrono() throws Throwable {\n        try {\n            new Partial(DateTimeFieldType.dayOfYear(), 0, ISO_UTC);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            \n        }\n    }", "comment": "/**\n     * Test constructor\n     */"}}
{"code": {"body": "    public void testConstructor_TypeArray_intArray() throws Throwable {\n        DateTimeFieldType[] types = new DateTimeFieldType[] {\n            DateTimeFieldType.year(),\n            DateTimeFieldType.dayOfYear()\n        };\n        int[] values = new int[] {2005, 33};\n        Partial test = new Partial(types, values);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(2, test.size());\n        assertEquals(2005, test.getValue(0));\n        assertEquals(2005, test.get(DateTimeFieldType.year()));\n        assertEquals(true, test.isSupported(DateTimeFieldType.year()));\n        assertEquals(33, test.getValue(1));\n        assertEquals(33, test.get(DateTimeFieldType.dayOfYear()));\n        assertEquals(true, test.isSupported(DateTimeFieldType.dayOfYear()));\n        assertEquals(true, Arrays.equals(test.getFieldTypes(), types));\n        assertEquals(true, Arrays.equals(test.getValues(), values));\n    }", "comment": "/**\n     * Test constructor\n     */"}}
{"code": {"body": "    public void testConstructor2_TypeArray_intArray() throws Throwable {\n        DateTimeFieldType[] types = new DateTimeFieldType[0];\n        int[] values = new int[0];\n        Partial test = new Partial(types, values);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(0, test.size());\n    }", "comment": "/**\n     * Test constructor\n     */"}}
{"code": {"body": "    public void testConstructorEx1_TypeArray_intArray() throws Throwable {\n        try {\n            new Partial((DateTimeFieldType[]) null, new int[] {1});\n            fail();\n        } catch (IllegalArgumentException ex) {\n            assertMessageContains(ex, \"\");\n        }\n    }", "comment": "/**\n     * Test constructor\n     */"}}
{"code": {"body": "    public void testConstructorEx3_TypeArray_intArray() throws Throwable {\n        try {\n            new Partial(new DateTimeFieldType[] {DateTimeFieldType.dayOfYear()}, null);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            assertMessageContains(ex, \"\");\n        }\n    }", "comment": "/**\n     * Test constructor\n     */"}}
{"code": {"body": "    public void testConstructorEx5_TypeArray_intArray() throws Throwable {\n        try {\n            new Partial(new DateTimeFieldType[] {DateTimeFieldType.dayOfYear()}, new int[2]);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            assertMessageContains(ex, \"\");\n        }\n    }", "comment": "/**\n     * Test constructor\n     */"}}
{"code": {"body": "    public void testConstructorEx6_TypeArray_intArray() throws Throwable {\n        try {\n            new Partial(new DateTimeFieldType[] {null, DateTimeFieldType.dayOfYear()}, new int[2]);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            assertMessageContains(ex, \"\");\n        }\n        try {\n            new Partial(new DateTimeFieldType[] {DateTimeFieldType.dayOfYear(), null}, new int[2]);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            assertMessageContains(ex, \"\");\n        }\n    }", "comment": "/**\n     * Test constructor\n     */"}}
{"code": {"body": "    public void testConstructorEx7_TypeArray_intArray() throws Throwable {\n        int[] values = new int[] {1, 1, 1};\n        DateTimeFieldType[] types = new DateTimeFieldType[] {\n            DateTimeFieldType.dayOfMonth(), DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() };\n        try {\n            new Partial(types, values);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            assertMessageContains(ex, \"\", \"\");\n        }\n        \n        types = new DateTimeFieldType[] {\n            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.monthOfYear() };\n        try {\n            new Partial(types, values);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            assertMessageContains(ex, \"\", \"\");\n        }\n        \n        types = new DateTimeFieldType[] {\n            DateTimeFieldType.year(), DateTimeFieldType.era(), DateTimeFieldType.monthOfYear() };\n        try {\n            new Partial(types, values);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            assertMessageContains(ex, \"\", \"\");\n        }\n        \n        types = new DateTimeFieldType[] {\n            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.era() };\n        try {\n            new Partial(types, values);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            assertMessageContains(ex, \"\", \"\");\n        }\n        \n        types = new DateTimeFieldType[] {\n            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.dayOfYear() };\n        try {\n            new Partial(types, values);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            assertMessageContains(ex, \"\", \"\");\n        }\n        \n        types = new DateTimeFieldType[] {\n            DateTimeFieldType.yearOfEra(), DateTimeFieldType.year(), DateTimeFieldType.dayOfYear() };\n        try {\n            new Partial(types, values);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            assertMessageContains(ex, \"\", \"\");\n        }\n    }", "comment": "/**\n     * Test constructor\n     */"}}
{"code": {"body": "    public void testConstructorEx8_TypeArray_intArray() throws Throwable {\n        int[] values = new int[] {1, 1, 1};\n        DateTimeFieldType[] types = new DateTimeFieldType[] {\n            DateTimeFieldType.era(), DateTimeFieldType.year(), DateTimeFieldType.year() };\n        try {\n            new Partial(types, values);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            assertMessageContains(ex, \"\", \"\");\n        }\n        \n        types = new DateTimeFieldType[] {\n            DateTimeFieldType.era(), DateTimeFieldType.era(), DateTimeFieldType.monthOfYear() };\n        try {\n            new Partial(types, values);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            assertMessageContains(ex, \"\", \"\");\n        }\n        \n        types = new DateTimeFieldType[] {\n            DateTimeFieldType.dayOfYear(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.dayOfMonth() };\n        try {\n            new Partial(types, values);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            assertMessageContains(ex, \"\", \"\");\n        }\n    }", "comment": "/**\n     * Test constructor\n     */"}}
{"code": {"body": "    public void testConstructorEx9_TypeArray_intArray() throws Throwable {\n        int[] values = new int[] {3, 0};\n        DateTimeFieldType[] types = new DateTimeFieldType[] {\n            DateTimeFieldType.dayOfMonth(), DateTimeFieldType.dayOfWeek()};\n        try {\n            new Partial(types, values);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            \n        }\n    }", "comment": "/**\n     * Test constructor\n     */"}}
{"code": {"body": "    public void testConstructor_TypeArray_intArray_Chrono() throws Throwable {\n        DateTimeFieldType[] types = new DateTimeFieldType[] {\n            DateTimeFieldType.year(),\n            DateTimeFieldType.dayOfYear()\n        };\n        int[] values = new int[] {2005, 33};\n        Partial test = new Partial(types, values, GREGORIAN_PARIS);\n        assertEquals(GREGORIAN_UTC, test.getChronology());\n        assertEquals(2, test.size());\n        assertEquals(2005, test.getValue(0));\n        assertEquals(2005, test.get(DateTimeFieldType.year()));\n        assertEquals(true, test.isSupported(DateTimeFieldType.year()));\n        assertEquals(33, test.getValue(1));\n        assertEquals(33, test.get(DateTimeFieldType.dayOfYear()));\n        assertEquals(true, test.isSupported(DateTimeFieldType.dayOfYear()));\n        assertEquals(true, Arrays.equals(test.getFieldTypes(), types));\n        assertEquals(true, Arrays.equals(test.getValues(), values));\n    }", "comment": "/**\n     * Test constructor\n     */"}}
{"code": {"body": "    public void testConstructorEx_Partial() throws Throwable {\n        try {\n            new Partial((ReadablePartial) null);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            assertMessageContains(ex, \"\");\n        }\n    }", "comment": "/**\n     * Test constructor\n     */"}}
{"code": {"body": "    private void assertMessageContains(Exception ex, String str1, String str2) {\n        assertEquals(ex.getMessage() + \"\" + str1 + \"\" + str2, true,\n            ex.getMessage().indexOf(str1) >= 0 &&\n            ex.getMessage().indexOf(str2) >= 0 &&\n            ex.getMessage().indexOf(str1) < ex.getMessage().indexOf(str2));\n    }", "comment": "/**\n     * Checks if the exception message is valid.\n     * \n     * @param ex  the exception to check\n     * @param str1  the string to check\n     * @param str2  the string to check\n     */"}}
{"code": {"body": "    public void testConstructor_4int1() throws Throwable {\n        Period test = new Period(5, 6, 7, 8);\n        assertEquals(PeriodType.standard(), test.getPeriodType());\n        assertEquals(0, test.getYears());\n        assertEquals(0, test.getMonths());\n        assertEquals(0, test.getWeeks());\n        assertEquals(0, test.getDays());\n        assertEquals(5, test.getHours());\n        assertEquals(6, test.getMinutes());\n        assertEquals(7, test.getSeconds());\n        assertEquals(8, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (4ints)\n     */"}}
{"code": {"body": "    public void testConstructor_8int1() throws Throwable {\n        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n        assertEquals(PeriodType.standard(), test.getPeriodType());\n        assertEquals(1, test.getYears());\n        assertEquals(2, test.getMonths());\n        assertEquals(3, test.getWeeks());\n        assertEquals(4, test.getDays());\n        assertEquals(5, test.getHours());\n        assertEquals(6, test.getMinutes());\n        assertEquals(7, test.getSeconds());\n        assertEquals(8, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (8ints)\n     */"}}
{"code": {"body": "    public void testConstructor_8int__PeriodType1() throws Throwable {\n        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, null);\n        assertEquals(PeriodType.standard(), test.getPeriodType());\n        assertEquals(1, test.getYears());\n        assertEquals(2, test.getMonths());\n        assertEquals(3, test.getWeeks());\n        assertEquals(4, test.getDays());\n        assertEquals(5, test.getHours());\n        assertEquals(6, test.getMinutes());\n        assertEquals(7, test.getSeconds());\n        assertEquals(8, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (8ints)\n     */"}}
{"code": {"body": "    public void testConstructor_Object1() throws Throwable {\n        Period test = new Period(\"\");\n        assertEquals(PeriodType.standard(), test.getPeriodType());\n        assertEquals(1, test.getYears());\n        assertEquals(2, test.getMonths());\n        assertEquals(0, test.getWeeks());\n        assertEquals(3, test.getDays());\n        assertEquals(0, test.getHours());\n        assertEquals(0, test.getMinutes());\n        assertEquals(0, test.getSeconds());\n        assertEquals(0, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Object)\n     */"}}
{"code": {"body": "    public void testConstructor_Object_PeriodType1() throws Throwable {\n        Period test = new Period(\"\", PeriodType.yearMonthDayTime());\n        assertEquals(PeriodType.yearMonthDayTime(), test.getPeriodType());\n        assertEquals(1, test.getYears());\n        assertEquals(2, test.getMonths());\n        assertEquals(0, test.getWeeks());\n        assertEquals(3, test.getDays());\n        assertEquals(0, test.getHours());\n        assertEquals(0, test.getMinutes());\n        assertEquals(0, test.getSeconds());\n        assertEquals(0, test.getMillis());\n    }", "comment": "/**\n     * Test constructor (Object)\n     */"}}
{"code": {"body": "    public void testConstantMidnight() throws Throwable {\n        TimeOfDay test = TimeOfDay.MIDNIGHT;\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(0, test.getHourOfDay());\n        assertEquals(0, test.getMinuteOfHour());\n        assertEquals(0, test.getSecondOfMinute());\n        assertEquals(0, test.getMillisOfSecond());\n    }", "comment": "/**\n     * Test constructor ()\n     */"}}
{"code": {"body": "    public void testFactoryMillisOfDay_long1() throws Throwable {\n        TimeOfDay test = TimeOfDay.fromMillisOfDay(TEST_TIME1);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(1, test.getHourOfDay());\n        assertEquals(2, test.getMinuteOfHour());\n        assertEquals(3, test.getSecondOfMinute());\n        assertEquals(4, test.getMillisOfSecond());\n    }", "comment": "/**\n     * Test factory (long)\n     */"}}
{"code": {"body": "    public void testFactoryMillisOfDay_long1_Chronology() throws Throwable {\n        TimeOfDay test = TimeOfDay.fromMillisOfDay(TEST_TIME1, JulianChronology.getInstance());\n        assertEquals(JulianChronology.getInstanceUTC(), test.getChronology());\n        assertEquals(1, test.getHourOfDay());\n        assertEquals(2, test.getMinuteOfHour());\n        assertEquals(3, test.getSecondOfMinute());\n        assertEquals(4, test.getMillisOfSecond());\n    }", "comment": "/**\n     * Test factory (long, Chronology)\n     */"}}
{"code": {"body": "    public void testFactoryMillisOfDay_long_nullChronology() throws Throwable {\n        TimeOfDay test = TimeOfDay.fromMillisOfDay(TEST_TIME1, null);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(1, test.getHourOfDay());\n        assertEquals(2, test.getMinuteOfHour());\n        assertEquals(3, test.getSecondOfMinute());\n        assertEquals(4, test.getMillisOfSecond());\n    }", "comment": "/**\n     * Test factory (long, Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor() throws Throwable {\n        TimeOfDay test = new TimeOfDay();\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(10 + OFFSET, test.getHourOfDay());\n        assertEquals(20, test.getMinuteOfHour());\n        assertEquals(30, test.getSecondOfMinute());\n        assertEquals(40, test.getMillisOfSecond());\n    }", "comment": "/**\n     * Test constructor ()\n     */"}}
{"code": {"body": "    public void testConstructor_DateTimeZone() throws Throwable {\n        DateTime dt = new DateTime(2005, 6, 8, 23, 59, 30, 40, LONDON);\n        DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n        \n        \n        TimeOfDay test = new TimeOfDay(LONDON);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(23, test.getHourOfDay());\n        assertEquals(59, test.getMinuteOfHour());\n        assertEquals(30, test.getSecondOfMinute());\n        assertEquals(40, test.getMillisOfSecond());\n        \n        test = new TimeOfDay(PARIS);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(0, test.getHourOfDay());\n        assertEquals(59, test.getMinuteOfHour());\n        assertEquals(30, test.getSecondOfMinute());\n        assertEquals(40, test.getMillisOfSecond());\n    }", "comment": "/**\n     * Test constructor (DateTimeZone)\n     */"}}
{"code": {"body": "    public void testConstructor_nullDateTimeZone() throws Throwable {\n        DateTime dt = new DateTime(2005, 6, 8, 23, 59, 30, 40, LONDON);\n        DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n        \n        \n        TimeOfDay test = new TimeOfDay((DateTimeZone) null);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(23, test.getHourOfDay());\n        assertEquals(59, test.getMinuteOfHour());\n        assertEquals(30, test.getSecondOfMinute());\n        assertEquals(40, test.getMillisOfSecond());\n    }", "comment": "/**\n     * Test constructor (DateTimeZone=null)\n     */"}}
{"code": {"body": "    public void testConstructor_Chronology() throws Throwable {\n        TimeOfDay test = new TimeOfDay(JulianChronology.getInstance());\n        assertEquals(JulianChronology.getInstanceUTC(), test.getChronology());\n        assertEquals(10 + OFFSET, test.getHourOfDay());\n        assertEquals(20, test.getMinuteOfHour());\n        assertEquals(30, test.getSecondOfMinute());\n        assertEquals(40, test.getMillisOfSecond());\n    }", "comment": "/**\n     * Test constructor (Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_nullChronology() throws Throwable {\n        TimeOfDay test = new TimeOfDay((Chronology) null);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(10 + OFFSET, test.getHourOfDay());\n        assertEquals(20, test.getMinuteOfHour());\n        assertEquals(30, test.getSecondOfMinute());\n        assertEquals(40, test.getMillisOfSecond());\n    }", "comment": "/**\n     * Test constructor (Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor_long1() throws Throwable {\n        TimeOfDay test = new TimeOfDay(TEST_TIME1);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(1 + OFFSET, test.getHourOfDay());\n        assertEquals(2, test.getMinuteOfHour());\n        assertEquals(3, test.getSecondOfMinute());\n        assertEquals(4, test.getMillisOfSecond());\n    }", "comment": "/**\n     * Test constructor (long)\n     */"}}
{"code": {"body": "    public void testConstructor_long2() throws Throwable {\n        TimeOfDay test = new TimeOfDay(TEST_TIME2);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(5 + OFFSET, test.getHourOfDay());\n        assertEquals(6, test.getMinuteOfHour());\n        assertEquals(7, test.getSecondOfMinute());\n        assertEquals(8, test.getMillisOfSecond());\n    }", "comment": "/**\n     * Test constructor (long)\n     */"}}
{"code": {"body": "    public void testConstructor_long1_Chronology() throws Throwable {\n        TimeOfDay test = new TimeOfDay(TEST_TIME1, JulianChronology.getInstance());\n        assertEquals(JulianChronology.getInstanceUTC(), test.getChronology());\n        assertEquals(1 + OFFSET, test.getHourOfDay());\n        assertEquals(2, test.getMinuteOfHour());\n        assertEquals(3, test.getSecondOfMinute());\n        assertEquals(4, test.getMillisOfSecond());\n    }", "comment": "/**\n     * Test constructor (long, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_long2_Chronology() throws Throwable {\n        TimeOfDay test = new TimeOfDay(TEST_TIME2, JulianChronology.getInstance());\n        assertEquals(JulianChronology.getInstanceUTC(), test.getChronology());\n        assertEquals(5 + OFFSET, test.getHourOfDay());\n        assertEquals(6, test.getMinuteOfHour());\n        assertEquals(7, test.getSecondOfMinute());\n        assertEquals(8, test.getMillisOfSecond());\n    }", "comment": "/**\n     * Test constructor (long, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_long_nullChronology() throws Throwable {\n        TimeOfDay test = new TimeOfDay(TEST_TIME1, null);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(1 + OFFSET, test.getHourOfDay());\n        assertEquals(2, test.getMinuteOfHour());\n        assertEquals(3, test.getSecondOfMinute());\n        assertEquals(4, test.getMillisOfSecond());\n    }", "comment": "/**\n     * Test constructor (long, Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor_Object1() throws Throwable {\n        Date date = new Date(TEST_TIME1);\n        TimeOfDay test = new TimeOfDay(date);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(1 + OFFSET, test.getHourOfDay());\n        assertEquals(2, test.getMinuteOfHour());\n        assertEquals(3, test.getSecondOfMinute());\n        assertEquals(4, test.getMillisOfSecond());\n    }", "comment": "/**\n     * Test constructor (Object)\n     */"}}
{"code": {"body": "    public void testConstructor_Object2() throws Throwable {\n        Calendar cal = new GregorianCalendar();\n        cal.setTime(new Date(TEST_TIME1));\n        TimeOfDay test = new TimeOfDay(cal);\n        assertEquals(GJChronology.getInstanceUTC(), test.getChronology());\n        assertEquals(1 + OFFSET, test.getHourOfDay());\n        assertEquals(2, test.getMinuteOfHour());\n        assertEquals(3, test.getSecondOfMinute());\n        assertEquals(4, test.getMillisOfSecond());\n    }", "comment": "/**\n     * Test constructor (Object)\n     */"}}
{"code": {"body": "    public void testConstructor_nullObject() throws Throwable {\n        TimeOfDay test = new TimeOfDay((Object) null);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(10 + OFFSET, test.getHourOfDay());\n        assertEquals(20, test.getMinuteOfHour());\n        assertEquals(30, test.getSecondOfMinute());\n        assertEquals(40, test.getMillisOfSecond());\n    }", "comment": "/**\n     * Test constructor (Object=null)\n     */"}}
{"code": {"body": "    public void testConstructor_todObject() throws Throwable {\n        TimeOfDay base = new TimeOfDay(10, 20, 30, 40, CopticChronology.getInstance(PARIS));\n        TimeOfDay test = new TimeOfDay(base);\n        assertEquals(CopticChronology.getInstanceUTC(), test.getChronology());\n        assertEquals(10, test.getHourOfDay());\n        assertEquals(20, test.getMinuteOfHour());\n        assertEquals(30, test.getSecondOfMinute());\n        assertEquals(40, test.getMillisOfSecond());\n    }", "comment": "/**\n     * Test constructor (Object)\n     */"}}
{"code": {"body": "    public void testConstructor_Object_Chronology() throws Throwable {\n        Date date = new Date(TEST_TIME1);\n        TimeOfDay test = new TimeOfDay(date, JulianChronology.getInstance());\n        assertEquals(JulianChronology.getInstanceUTC(), test.getChronology());\n        assertEquals(1 + OFFSET, test.getHourOfDay());\n        assertEquals(2, test.getMinuteOfHour());\n        assertEquals(3, test.getSecondOfMinute());\n        assertEquals(4, test.getMillisOfSecond());\n    }", "comment": "/**\n     * Test constructor (Object, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor2_Object_Chronology() throws Throwable {\n        TimeOfDay test = new TimeOfDay(\"\");\n        assertEquals(10, test.getHourOfDay());\n        assertEquals(20, test.getMinuteOfHour());\n        assertEquals(0, test.getSecondOfMinute());\n        assertEquals(0, test.getMillisOfSecond());\n        \n        try {\n            new TimeOfDay(\"\");\n            fail();\n        } catch (IllegalArgumentException ex) {}\n    }", "comment": "/**\n     * Test constructor (Object, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_nullObject_Chronology() throws Throwable {\n        TimeOfDay test = new TimeOfDay((Object) null, JulianChronology.getInstance());\n        assertEquals(JulianChronology.getInstanceUTC(), test.getChronology());\n        assertEquals(10 + OFFSET, test.getHourOfDay());\n        assertEquals(20, test.getMinuteOfHour());\n        assertEquals(30, test.getSecondOfMinute());\n        assertEquals(40, test.getMillisOfSecond());\n    }", "comment": "/**\n     * Test constructor (Object=null, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_Object_nullChronology() throws Throwable {\n        Date date = new Date(TEST_TIME1);\n        TimeOfDay test = new TimeOfDay(date, null);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(1 + OFFSET, test.getHourOfDay());\n        assertEquals(2, test.getMinuteOfHour());\n        assertEquals(3, test.getSecondOfMinute());\n        assertEquals(4, test.getMillisOfSecond());\n    }", "comment": "/**\n     * Test constructor (Object, Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor_nullObject_nullChronology() throws Throwable {\n        TimeOfDay test = new TimeOfDay((Object) null, null);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(10 + OFFSET, test.getHourOfDay());\n        assertEquals(20, test.getMinuteOfHour());\n        assertEquals(30, test.getSecondOfMinute());\n        assertEquals(40, test.getMillisOfSecond());\n    }", "comment": "/**\n     * Test constructor (Object=null, Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int() throws Throwable {\n        TimeOfDay test = new TimeOfDay(10, 20);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(10, test.getHourOfDay());\n        assertEquals(20, test.getMinuteOfHour());\n        assertEquals(0, test.getSecondOfMinute());\n        assertEquals(0, test.getMillisOfSecond());\n        try {\n            new TimeOfDay(-1, 20);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new TimeOfDay(24, 20);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new TimeOfDay(10, -1);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new TimeOfDay(10, 60);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n    }", "comment": "/**\n     * Test constructor (int, int)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_Chronology() throws Throwable {\n        TimeOfDay test = new TimeOfDay(10, 20, JulianChronology.getInstance());\n        assertEquals(JulianChronology.getInstanceUTC(), test.getChronology());\n        assertEquals(10, test.getHourOfDay());\n        assertEquals(20, test.getMinuteOfHour());\n        assertEquals(0, test.getSecondOfMinute());\n        assertEquals(0, test.getMillisOfSecond());\n        try {\n            new TimeOfDay(-1, 20, JulianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new TimeOfDay(24, 20, JulianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new TimeOfDay(10, -1, JulianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new TimeOfDay(10, 60, JulianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n    }", "comment": "/**\n     * Test constructor (int, int, int, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_nullChronology() throws Throwable {\n        TimeOfDay test = new TimeOfDay(10, 20, null);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(10, test.getHourOfDay());\n        assertEquals(20, test.getMinuteOfHour());\n        assertEquals(0, test.getSecondOfMinute());\n        assertEquals(0, test.getMillisOfSecond());\n    }", "comment": "/**\n     * Test constructor (int, int, int, Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_int() throws Throwable {\n        TimeOfDay test = new TimeOfDay(10, 20, 30);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(10, test.getHourOfDay());\n        assertEquals(20, test.getMinuteOfHour());\n        assertEquals(30, test.getSecondOfMinute());\n        assertEquals(0, test.getMillisOfSecond());\n        try {\n            new TimeOfDay(-1, 20, 30);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new TimeOfDay(24, 20, 30);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new TimeOfDay(10, -1, 30);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new TimeOfDay(10, 60, 30);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new TimeOfDay(10, 20, -1);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new TimeOfDay(10, 20, 60);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n    }", "comment": "/**\n     * Test constructor (int, int, int)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_int_Chronology() throws Throwable {\n        TimeOfDay test = new TimeOfDay(10, 20, 30, JulianChronology.getInstance());\n        assertEquals(JulianChronology.getInstanceUTC(), test.getChronology());\n        assertEquals(10, test.getHourOfDay());\n        assertEquals(20, test.getMinuteOfHour());\n        assertEquals(30, test.getSecondOfMinute());\n        assertEquals(0, test.getMillisOfSecond());\n        try {\n            new TimeOfDay(-1, 20, 30, JulianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new TimeOfDay(24, 20, 30, JulianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new TimeOfDay(10, -1, 30, JulianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new TimeOfDay(10, 60, 30, JulianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new TimeOfDay(10, 20, -1, JulianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new TimeOfDay(10, 20, 60, JulianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n    }", "comment": "/**\n     * Test constructor (int, int, int, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_int_nullChronology() throws Throwable {\n        TimeOfDay test = new TimeOfDay(10, 20, 30, null);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(10, test.getHourOfDay());\n        assertEquals(20, test.getMinuteOfHour());\n        assertEquals(30, test.getSecondOfMinute());\n        assertEquals(0, test.getMillisOfSecond());\n    }", "comment": "/**\n     * Test constructor (int, int, int, Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_int_int() throws Throwable {\n        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(10, test.getHourOfDay());\n        assertEquals(20, test.getMinuteOfHour());\n        assertEquals(30, test.getSecondOfMinute());\n        assertEquals(40, test.getMillisOfSecond());\n        try {\n            new TimeOfDay(-1, 20, 30, 40);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new TimeOfDay(24, 20, 30, 40);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new TimeOfDay(10, -1, 30, 40);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new TimeOfDay(10, 60, 30, 40);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new TimeOfDay(10, 20, -1, 40);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new TimeOfDay(10, 20, 60, 40);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new TimeOfDay(10, 20, 30, -1);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new TimeOfDay(10, 20, 30, 1000);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n    }", "comment": "/**\n     * Test constructor (int, int, int, int)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_int_int_Chronology() throws Throwable {\n        TimeOfDay test = new TimeOfDay(10, 20, 30, 40, JulianChronology.getInstance());\n        assertEquals(JulianChronology.getInstanceUTC(), test.getChronology());\n        assertEquals(10, test.getHourOfDay());\n        assertEquals(20, test.getMinuteOfHour());\n        assertEquals(30, test.getSecondOfMinute());\n        assertEquals(40, test.getMillisOfSecond());\n        try {\n            new TimeOfDay(-1, 20, 30, 40, JulianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new TimeOfDay(24, 20, 30, 40, JulianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new TimeOfDay(10, -1, 30, 40, JulianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new TimeOfDay(10, 60, 30, 40, JulianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new TimeOfDay(10, 20, -1, 40, JulianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new TimeOfDay(10, 20, 60, 40, JulianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new TimeOfDay(10, 20, 30, -1, JulianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new TimeOfDay(10, 20, 30, 1000, JulianChronology.getInstance());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n    }", "comment": "/**\n     * Test constructor (int, int, int, int, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_int_int_nullChronology() throws Throwable {\n        TimeOfDay test = new TimeOfDay(10, 20, 30, 40, null);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(10, test.getHourOfDay());\n        assertEquals(20, test.getMinuteOfHour());\n        assertEquals(30, test.getSecondOfMinute());\n        assertEquals(40, test.getMillisOfSecond());\n    }", "comment": "/**\n     * Test constructor (int, int, int, int, Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor() throws Throwable {\n        YearMonthDay test = new YearMonthDay();\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(1970, test.getYear());\n        assertEquals(6, test.getMonthOfYear());\n        assertEquals(9, test.getDayOfMonth());\n    }", "comment": "/**\n     * Test constructor ()\n     */"}}
{"code": {"body": "    public void testConstructor_DateTimeZone() throws Throwable {\n        DateTime dt = new DateTime(2005, 6, 8, 23, 59, 0, 0, LONDON);\n        DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n        \n        \n        YearMonthDay test = new YearMonthDay(LONDON);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(2005, test.getYear());\n        assertEquals(6, test.getMonthOfYear());\n        assertEquals(8, test.getDayOfMonth());\n        \n        test = new YearMonthDay(PARIS);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(2005, test.getYear());\n        assertEquals(6, test.getMonthOfYear());\n        assertEquals(9, test.getDayOfMonth());\n    }", "comment": "/**\n     * Test constructor (DateTimeZone)\n     */"}}
{"code": {"body": "    public void testConstructor_nullDateTimeZone() throws Throwable {\n        DateTime dt = new DateTime(2005, 6, 8, 23, 59, 0, 0, LONDON);\n        DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n        \n        \n        YearMonthDay test = new YearMonthDay((DateTimeZone) null);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(2005, test.getYear());\n        assertEquals(6, test.getMonthOfYear());\n        assertEquals(8, test.getDayOfMonth());\n    }", "comment": "/**\n     * Test constructor (DateTimeZone=null)\n     */"}}
{"code": {"body": "    public void testConstructor_Chronology() throws Throwable {\n        YearMonthDay test = new YearMonthDay(GREGORIAN_PARIS);\n        assertEquals(GREGORIAN_UTC, test.getChronology());\n        assertEquals(1970, test.getYear());\n        assertEquals(6, test.getMonthOfYear());\n        assertEquals(9, test.getDayOfMonth());\n    }", "comment": "/**\n     * Test constructor (Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_nullChronology() throws Throwable {\n        YearMonthDay test = new YearMonthDay((Chronology) null);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(1970, test.getYear());\n        assertEquals(6, test.getMonthOfYear());\n        assertEquals(9, test.getDayOfMonth());\n    }", "comment": "/**\n     * Test constructor (Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor_long1() throws Throwable {\n        YearMonthDay test = new YearMonthDay(TEST_TIME1);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(1970, test.getYear());\n        assertEquals(4, test.getMonthOfYear());\n        assertEquals(6, test.getDayOfMonth());\n    }", "comment": "/**\n     * Test constructor (long)\n     */"}}
{"code": {"body": "    public void testConstructor_long2() throws Throwable {\n        YearMonthDay test = new YearMonthDay(TEST_TIME2);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(1971, test.getYear());\n        assertEquals(5, test.getMonthOfYear());\n        assertEquals(7, test.getDayOfMonth());\n    }", "comment": "/**\n     * Test constructor (long)\n     */"}}
{"code": {"body": "    public void testConstructor_long1_Chronology() throws Throwable {\n        YearMonthDay test = new YearMonthDay(TEST_TIME1, GREGORIAN_PARIS);\n        assertEquals(GREGORIAN_UTC, test.getChronology());\n        assertEquals(1970, test.getYear());\n        assertEquals(4, test.getMonthOfYear());\n        assertEquals(6, test.getDayOfMonth());\n    }", "comment": "/**\n     * Test constructor (long, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_long2_Chronology() throws Throwable {\n        YearMonthDay test = new YearMonthDay(TEST_TIME2, GREGORIAN_PARIS);\n        assertEquals(GREGORIAN_UTC, test.getChronology());\n        assertEquals(1971, test.getYear());\n        assertEquals(5, test.getMonthOfYear());\n        assertEquals(7, test.getDayOfMonth());\n    }", "comment": "/**\n     * Test constructor (long, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_long_nullChronology() throws Throwable {\n        YearMonthDay test = new YearMonthDay(TEST_TIME1, null);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(1970, test.getYear());\n        assertEquals(4, test.getMonthOfYear());\n        assertEquals(6, test.getDayOfMonth());\n    }", "comment": "/**\n     * Test constructor (long, Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor_Object_Chronology() throws Throwable {\n        Date date = new Date(TEST_TIME1);\n        YearMonthDay test = new YearMonthDay(date, GREGORIAN_PARIS);\n        assertEquals(GREGORIAN_UTC, test.getChronology());\n        assertEquals(1970, test.getYear());\n        assertEquals(4, test.getMonthOfYear());\n        assertEquals(6, test.getDayOfMonth());\n    }", "comment": "/**\n     * Test constructor (Object, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_nullObject_Chronology() throws Throwable {\n        YearMonthDay test = new YearMonthDay((Object) null, GREGORIAN_PARIS);\n        assertEquals(GREGORIAN_UTC, test.getChronology());\n        assertEquals(1970, test.getYear());\n        assertEquals(6, test.getMonthOfYear());\n        assertEquals(9, test.getDayOfMonth());\n    }", "comment": "/**\n     * Test constructor (Object=null, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_Object_nullChronology() throws Throwable {\n        Date date = new Date(TEST_TIME1);\n        YearMonthDay test = new YearMonthDay(date, null);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(1970, test.getYear());\n        assertEquals(4, test.getMonthOfYear());\n        assertEquals(6, test.getDayOfMonth());\n    }", "comment": "/**\n     * Test constructor (Object, Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor_nullObject_nullChronology() throws Throwable {\n        YearMonthDay test = new YearMonthDay((Object) null, null);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(1970, test.getYear());\n        assertEquals(6, test.getMonthOfYear());\n        assertEquals(9, test.getDayOfMonth());\n    }", "comment": "/**\n     * Test constructor (Object=null, Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_int() throws Throwable {\n        YearMonthDay test = new YearMonthDay(1970, 6, 9);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(1970, test.getYear());\n        assertEquals(6, test.getMonthOfYear());\n        assertEquals(9, test.getDayOfMonth());\n        try {\n            new YearMonthDay(Integer.MIN_VALUE, 6, 9);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new YearMonthDay(Integer.MAX_VALUE, 6, 9);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new YearMonthDay(1970, 0, 9);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new YearMonthDay(1970, 13, 9);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new YearMonthDay(1970, 6, 0);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new YearMonthDay(1970, 6, 31);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        new YearMonthDay(1970, 7, 31);\n        try {\n            new YearMonthDay(1970, 7, 32);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n    }", "comment": "/**\n     * Test constructor (int, int, int)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_int_Chronology() throws Throwable {\n        YearMonthDay test = new YearMonthDay(1970, 6, 9, GREGORIAN_PARIS);\n        assertEquals(GREGORIAN_UTC, test.getChronology());\n        assertEquals(1970, test.getYear());\n        assertEquals(6, test.getMonthOfYear());\n        assertEquals(9, test.getDayOfMonth());\n        try {\n            new YearMonthDay(Integer.MIN_VALUE, 6, 9, GREGORIAN_PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new YearMonthDay(Integer.MAX_VALUE, 6, 9, GREGORIAN_PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new YearMonthDay(1970, 0, 9, GREGORIAN_PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new YearMonthDay(1970, 13, 9, GREGORIAN_PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new YearMonthDay(1970, 6, 0, GREGORIAN_PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new YearMonthDay(1970, 6, 31, GREGORIAN_PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        new YearMonthDay(1970, 7, 31, GREGORIAN_PARIS);\n        try {\n            new YearMonthDay(1970, 7, 32, GREGORIAN_PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n    }", "comment": "/**\n     * Test constructor (int, int, int, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_int_nullChronology() throws Throwable {\n        YearMonthDay test = new YearMonthDay(1970, 6, 9, null);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(1970, test.getYear());\n        assertEquals(6, test.getMonthOfYear());\n        assertEquals(9, test.getDayOfMonth());\n    }", "comment": "/**\n     * Test constructor (int, int, int, Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor() throws Throwable {\n        YearMonth test = new YearMonth();\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(1970, test.getYear());\n        assertEquals(6, test.getMonthOfYear());\n        assertEquals(test, YearMonth.now());\n    }", "comment": "/**\n     * Test constructor ()\n     */"}}
{"code": {"body": "    public void testConstructor_DateTimeZone() throws Throwable {\n        DateTime dt = new DateTime(2005, 6, 30, 23, 59, 0, 0, LONDON);\n        DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n        \n        \n        YearMonth test = new YearMonth(LONDON);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(2005, test.getYear());\n        assertEquals(6, test.getMonthOfYear());\n        assertEquals(test, YearMonth.now(LONDON));\n        \n        test = new YearMonth(PARIS);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(2005, test.getYear());\n        assertEquals(7, test.getMonthOfYear());\n        assertEquals(test, YearMonth.now(PARIS));\n    }", "comment": "/**\n     * Test constructor (DateTimeZone)\n     */"}}
{"code": {"body": "    public void testConstructor_nullDateTimeZone() throws Throwable {\n        DateTime dt = new DateTime(2005, 6, 30, 23, 59, 0, 0, LONDON);\n        DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n        \n        \n        YearMonth test = new YearMonth((DateTimeZone) null);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(2005, test.getYear());\n        assertEquals(6, test.getMonthOfYear());\n    }", "comment": "/**\n     * Test constructor (DateTimeZone=null)\n     */"}}
{"code": {"body": "    public void testConstructor_Chronology() throws Throwable {\n        YearMonth test = new YearMonth(GREGORIAN_PARIS);\n        assertEquals(GREGORIAN_UTC, test.getChronology());\n        assertEquals(1970, test.getYear());\n        assertEquals(6, test.getMonthOfYear());\n        assertEquals(test, YearMonth.now(GREGORIAN_PARIS));\n    }", "comment": "/**\n     * Test constructor (Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_nullChronology() throws Throwable {\n        YearMonth test = new YearMonth((Chronology) null);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(1970, test.getYear());\n        assertEquals(6, test.getMonthOfYear());\n    }", "comment": "/**\n     * Test constructor (Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor_long1() throws Throwable {\n        YearMonth test = new YearMonth(TEST_TIME1);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(1970, test.getYear());\n        assertEquals(4, test.getMonthOfYear());\n    }", "comment": "/**\n     * Test constructor (long)\n     */"}}
{"code": {"body": "    public void testConstructor_long2() throws Throwable {\n        YearMonth test = new YearMonth(TEST_TIME2);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(1971, test.getYear());\n        assertEquals(5, test.getMonthOfYear());\n    }", "comment": "/**\n     * Test constructor (long)\n     */"}}
{"code": {"body": "    public void testConstructor_long1_Chronology() throws Throwable {\n        YearMonth test = new YearMonth(TEST_TIME1, GREGORIAN_PARIS);\n        assertEquals(GREGORIAN_UTC, test.getChronology());\n        assertEquals(1970, test.getYear());\n        assertEquals(4, test.getMonthOfYear());\n    }", "comment": "/**\n     * Test constructor (long, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_long2_Chronology() throws Throwable {\n        YearMonth test = new YearMonth(TEST_TIME2, GREGORIAN_PARIS);\n        assertEquals(GREGORIAN_UTC, test.getChronology());\n        assertEquals(1971, test.getYear());\n        assertEquals(5, test.getMonthOfYear());\n    }", "comment": "/**\n     * Test constructor (long, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_long_nullChronology() throws Throwable {\n        YearMonth test = new YearMonth(TEST_TIME1, null);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(1970, test.getYear());\n        assertEquals(4, test.getMonthOfYear());\n    }", "comment": "/**\n     * Test constructor (long, Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor_Object_Chronology() throws Throwable {\n        Date date = new Date(TEST_TIME1);\n        YearMonth test = new YearMonth(date, GREGORIAN_PARIS);\n        assertEquals(GREGORIAN_UTC, test.getChronology());\n        assertEquals(1970, test.getYear());\n        assertEquals(4, test.getMonthOfYear());\n    }", "comment": "/**\n     * Test constructor (Object, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_nullObject_Chronology() throws Throwable {\n        YearMonth test = new YearMonth((Object) null, GREGORIAN_PARIS);\n        assertEquals(GREGORIAN_UTC, test.getChronology());\n        assertEquals(1970, test.getYear());\n        assertEquals(6, test.getMonthOfYear());\n    }", "comment": "/**\n     * Test constructor (Object=null, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_Object_nullChronology() throws Throwable {\n        Date date = new Date(TEST_TIME1);\n        YearMonth test = new YearMonth(date, null);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(1970, test.getYear());\n        assertEquals(4, test.getMonthOfYear());\n    }", "comment": "/**\n     * Test constructor (Object, Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor_nullObject_nullChronology() throws Throwable {\n        YearMonth test = new YearMonth((Object) null, null);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(1970, test.getYear());\n        assertEquals(6, test.getMonthOfYear());\n    }", "comment": "/**\n     * Test constructor (Object=null, Chronology=null)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int() throws Throwable {\n        YearMonth test = new YearMonth(1970, 6);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(1970, test.getYear());\n        assertEquals(6, test.getMonthOfYear());\n        try {\n            new YearMonth(Integer.MIN_VALUE, 6);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new YearMonth(Integer.MAX_VALUE, 6);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new YearMonth(1970, 0);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new YearMonth(1970, 13);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n    }", "comment": "/**\n     * Test constructor (int, int)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_Chronology() throws Throwable {\n        YearMonth test = new YearMonth(1970, 6, GREGORIAN_PARIS);\n        assertEquals(GREGORIAN_UTC, test.getChronology());\n        assertEquals(1970, test.getYear());\n        assertEquals(6, test.getMonthOfYear());\n        try {\n            new YearMonth(Integer.MIN_VALUE, 6, GREGORIAN_PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new YearMonth(Integer.MAX_VALUE, 6, GREGORIAN_PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new YearMonth(1970, 0, GREGORIAN_PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            new YearMonth(1970, 13, GREGORIAN_PARIS);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n    }", "comment": "/**\n     * Test constructor (int, int, Chronology)\n     */"}}
{"code": {"body": "    public void testConstructor_int_int_nullChronology() throws Throwable {\n        YearMonth test = new YearMonth(1970, 6, null);\n        assertEquals(ISO_UTC, test.getChronology());\n        assertEquals(1970, test.getYear());\n        assertEquals(6, test.getMonthOfYear());\n    }", "comment": "/**\n     * Test constructor (int, int, Chronology=null)\n     */"}}
{"code": {"body": "    public void testCalendar() {\n        if (TestAll.FAST) {\n            return;\n        }\n        System.out.println(\"\");\n        DateTime epoch = new DateTime(1, 1, 1, 0, 0, 0, 0, COPTIC_UTC);\n        long millis = epoch.getMillis();\n        long end = new DateTime(3000, 1, 1, 0, 0, 0, 0, ISO_UTC).getMillis();\n        DateTimeField dayOfWeek = COPTIC_UTC.dayOfWeek();\n        DateTimeField dayOfYear = COPTIC_UTC.dayOfYear();\n        DateTimeField dayOfMonth = COPTIC_UTC.dayOfMonth();\n        DateTimeField monthOfYear = COPTIC_UTC.monthOfYear();\n        DateTimeField year = COPTIC_UTC.year();\n        DateTimeField yearOfEra = COPTIC_UTC.yearOfEra();\n        DateTimeField era = COPTIC_UTC.era();\n        int expectedDOW = new DateTime(284, 8, 29, 0, 0, 0, 0, JULIAN_UTC).getDayOfWeek();\n        int expectedDOY = 1;\n        int expectedDay = 1;\n        int expectedMonth = 1;\n        int expectedYear = 1;\n        while (millis < end) {\n            int dowValue = dayOfWeek.get(millis);\n            int doyValue = dayOfYear.get(millis);\n            int dayValue = dayOfMonth.get(millis);\n            int monthValue = monthOfYear.get(millis);\n            int yearValue = year.get(millis);\n            int yearOfEraValue = yearOfEra.get(millis);\n            int monthLen = dayOfMonth.getMaximumValue(millis);\n            if (monthValue < 1 || monthValue > 13) {\n                fail(\"\" + millis);\n            }\n            \n            \n            assertEquals(1, era.get(millis));\n            assertEquals(\"\", era.getAsText(millis));\n            assertEquals(\"\", era.getAsShortText(millis));\n            \n            \n            assertEquals(expectedYear, yearValue);\n            assertEquals(expectedYear, yearOfEraValue);\n            assertEquals(expectedMonth, monthValue);\n            assertEquals(expectedDay, dayValue);\n            assertEquals(expectedDOW, dowValue);\n            assertEquals(expectedDOY, doyValue);\n            \n            \n            assertEquals(yearValue % 4 == 3, year.isLeap(millis));\n            \n            \n            if (monthValue == 13) {\n                assertEquals(yearValue % 4 == 3, monthOfYear.isLeap(millis));\n                if (yearValue % 4 == 3) {\n                    assertEquals(6, monthLen);\n                } else {\n                    assertEquals(5, monthLen);\n                }\n            } else {\n                assertEquals(30, monthLen);\n            }\n            \n            \n            expectedDOW = (((expectedDOW + 1) - 1) % 7) + 1;\n            expectedDay++;\n            expectedDOY++;\n            if (expectedDay == 31 && expectedMonth < 13) {\n                expectedDay = 1;\n                expectedMonth++;\n            } else if (expectedMonth == 13) {\n                if (expectedYear % 4 == 3 && expectedDay == 7) {\n                    expectedDay = 1;\n                    expectedMonth = 1;\n                    expectedYear++;\n                    expectedDOY = 1;\n                } else if (expectedYear % 4 != 3 && expectedDay == 6) {\n                    expectedDay = 1;\n                    expectedMonth = 1;\n                    expectedYear++;\n                    expectedDOY = 1;\n                }\n            }\n            millis += SKIP;\n        }\n    }", "comment": "/**\n     * Tests era, year, monthOfYear, dayOfMonth and dayOfWeek.\n     */"}}
{"code": {"body": "    public void testCalendar() {\n        if (TestAll.FAST) {\n            return;\n        }\n        System.out.println(\"\");\n        DateTime epoch = new DateTime(1, 1, 1, 0, 0, 0, 0, ETHIOPIC_UTC);\n        long millis = epoch.getMillis();\n        long end = new DateTime(3000, 1, 1, 0, 0, 0, 0, ISO_UTC).getMillis();\n        DateTimeField dayOfWeek = ETHIOPIC_UTC.dayOfWeek();\n        DateTimeField dayOfYear = ETHIOPIC_UTC.dayOfYear();\n        DateTimeField dayOfMonth = ETHIOPIC_UTC.dayOfMonth();\n        DateTimeField monthOfYear = ETHIOPIC_UTC.monthOfYear();\n        DateTimeField year = ETHIOPIC_UTC.year();\n        DateTimeField yearOfEra = ETHIOPIC_UTC.yearOfEra();\n        DateTimeField era = ETHIOPIC_UTC.era();\n        int expectedDOW = new DateTime(8, 8, 29, 0, 0, 0, 0, JULIAN_UTC).getDayOfWeek();\n        int expectedDOY = 1;\n        int expectedDay = 1;\n        int expectedMonth = 1;\n        int expectedYear = 1;\n        while (millis < end) {\n            int dowValue = dayOfWeek.get(millis);\n            int doyValue = dayOfYear.get(millis);\n            int dayValue = dayOfMonth.get(millis);\n            int monthValue = monthOfYear.get(millis);\n            int yearValue = year.get(millis);\n            int yearOfEraValue = yearOfEra.get(millis);\n            int monthLen = dayOfMonth.getMaximumValue(millis);\n            if (monthValue < 1 || monthValue > 13) {\n                fail(\"\" + millis);\n            }\n            \n            \n            assertEquals(1, era.get(millis));\n            assertEquals(\"\", era.getAsText(millis));\n            assertEquals(\"\", era.getAsShortText(millis));\n            \n            \n            assertEquals(expectedYear, yearValue);\n            assertEquals(expectedYear, yearOfEraValue);\n            assertEquals(expectedMonth, monthValue);\n            assertEquals(expectedDay, dayValue);\n            assertEquals(expectedDOW, dowValue);\n            assertEquals(expectedDOY, doyValue);\n            \n            \n            assertEquals(yearValue % 4 == 3, year.isLeap(millis));\n            \n            \n            if (monthValue == 13) {\n                assertEquals(yearValue % 4 == 3, monthOfYear.isLeap(millis));\n                if (yearValue % 4 == 3) {\n                    assertEquals(6, monthLen);\n                } else {\n                    assertEquals(5, monthLen);\n                }\n            } else {\n                assertEquals(30, monthLen);\n            }\n            \n            \n            expectedDOW = (((expectedDOW + 1) - 1) % 7) + 1;\n            expectedDay++;\n            expectedDOY++;\n            if (expectedDay == 31 && expectedMonth < 13) {\n                expectedDay = 1;\n                expectedMonth++;\n            } else if (expectedMonth == 13) {\n                if (expectedYear % 4 == 3 && expectedDay == 7) {\n                    expectedDay = 1;\n                    expectedMonth = 1;\n                    expectedYear++;\n                    expectedDOY = 1;\n                } else if (expectedYear % 4 != 3 && expectedDay == 6) {\n                    expectedDay = 1;\n                    expectedMonth = 1;\n                    expectedYear++;\n                    expectedDOY = 1;\n                }\n            }\n            millis += SKIP;\n        }\n    }", "comment": "/**\n     * Tests era, year, monthOfYear, dayOfMonth and dayOfWeek.\n     */"}}
{"code": {"body": "    public void testCalendar() {\n        if (TestAll.FAST) {\n            return;\n        }\n        System.out.println(\"\");\n        DateTime epoch = new DateTime(1, 1, 1, 0, 0, 0, 0, ISLAMIC_UTC);\n        long millis = epoch.getMillis();\n        long end = new DateTime(3000, 1, 1, 0, 0, 0, 0, ISO_UTC).getMillis();\n        DateTimeField dayOfWeek = ISLAMIC_UTC.dayOfWeek();\n        DateTimeField dayOfYear = ISLAMIC_UTC.dayOfYear();\n        DateTimeField dayOfMonth = ISLAMIC_UTC.dayOfMonth();\n        DateTimeField monthOfYear = ISLAMIC_UTC.monthOfYear();\n        DateTimeField year = ISLAMIC_UTC.year();\n        DateTimeField yearOfEra = ISLAMIC_UTC.yearOfEra();\n        DateTimeField era = ISLAMIC_UTC.era();\n        int expectedDOW = new DateTime(622, 7, 16, 0, 0, 0, 0, JULIAN_UTC).getDayOfWeek();\n        int expectedDOY = 1;\n        int expectedDay = 1;\n        int expectedMonth = 1;\n        int expectedYear = 1;\n        while (millis < end) {\n            int dowValue = dayOfWeek.get(millis);\n            int doyValue = dayOfYear.get(millis);\n            int dayValue = dayOfMonth.get(millis);\n            int monthValue = monthOfYear.get(millis);\n            int yearValue = year.get(millis);\n            int yearOfEraValue = yearOfEra.get(millis);\n            int dayOfYearLen = dayOfYear.getMaximumValue(millis);\n            int monthLen = dayOfMonth.getMaximumValue(millis);\n            if (monthValue < 1 || monthValue > 12) {\n                fail(\"\" + millis);\n            }\n            \n            \n            assertEquals(1, era.get(millis));\n            assertEquals(\"\", era.getAsText(millis));\n            assertEquals(\"\", era.getAsShortText(millis));\n            \n            \n            assertEquals(expectedDOY, doyValue);\n            assertEquals(expectedMonth, monthValue);\n            assertEquals(expectedDay, dayValue);\n            assertEquals(expectedDOW, dowValue);\n            assertEquals(expectedYear, yearValue);\n            assertEquals(expectedYear, yearOfEraValue);\n            \n            \n            boolean leap = ((11 * yearValue + 14) % 30) < 11;\n            assertEquals(leap, year.isLeap(millis));\n            \n            \n            switch (monthValue) {\n                case 1:\n                case 3:\n                case 5:\n                case 7:\n                case 9:\n                case 11:\n                    assertEquals(30, monthLen);\n                    break;\n                case 2:\n                case 4:\n                case 6:\n                case 8:\n                case 10:\n                    assertEquals(29, monthLen);\n                    break;\n                case 12:\n                    assertEquals((leap ? 30 : 29), monthLen);\n                    break;\n            }\n            \n            \n            assertEquals((leap ? 355 : 354), dayOfYearLen);\n            \n            \n            expectedDOW = (((expectedDOW + 1) - 1) % 7) + 1;\n            expectedDay++;\n            expectedDOY++;\n            if (expectedDay > monthLen) {\n                expectedDay = 1;\n                expectedMonth++;\n                if (expectedMonth == 13) {\n                    expectedMonth = 1;\n                    expectedDOY = 1;\n                    expectedYear++;\n                }\n            }\n            millis += SKIP;\n        }\n    }", "comment": "/**\n     * Tests era, year, monthOfYear, dayOfMonth and dayOfWeek.\n     */"}}
{"code": {"body": "public MainTest(int iterations, int mode, long seed) {\n        super(\"\");\n        iIterations = iterations;\n        iMode = mode;\n        iSeed = seed;\n        if (mode == GREGORIAN_MODE) {\n            iTest = new TestGregorianChronology();\n            iActual = GregorianChronology.getInstanceUTC();\n        } else {\n            iTest = new TestJulianChronology();\n            iActual = JulianChronology.getInstanceUTC();\n        }\n    }", "comment": "/**\n     * @param iterations number of test iterations to perform\n     * @param mode GREGORIAN_MODE or JULIAN_MODE,0=Gregorian, 1=Julian\n     * @param seed seed for random number generator\n     */"}}
{"code": {"body": "    public static void main(String[] args) throws Exception {\n        int iterations = 1000000;\n        int mode = GREGORIAN_MODE;\n        long seed = 1345435247779935L;\n\n        if (args.length > 0) {\n            iterations = Integer.parseInt(args[0]);\n            if (args.length > 1) {\n                if (args[1].startsWith(\"\")) {\n                    mode = GREGORIAN_MODE;\n                } else if (args[1].startsWith(\"\")) {\n                    mode = JULIAN_MODE;\n                } else {\n                    throw new IllegalArgumentException\n                        (\"\" + args[1]);\n                }\n                if (args.length > 2) {\n                    seed = Long.parseLong(args[2]);\n                }\n            }\n        }\n\n        new MainTest(iterations, mode, seed).testChronology();\n    }", "comment": "/**\n     * Arguments: iterations [mode [seed]]\n     */"}}
{"code": {"body": "    public void testChronology() {\n        int iterations = iIterations;\n        long seed = iSeed;\n        String modeStr;\n        if (iMode == GREGORIAN_MODE) {\n            modeStr = \"\";\n        } else {\n            modeStr = \"\";\n        }\n\n        System.out.println(\"\" + modeStr + \"\" + iterations + \"\");\n\n        Random rnd = new Random(seed);\n        long updateMillis = System.currentTimeMillis() + UPDATE_INTERVAL;\n\n        for (int i=0; i<iterations; i++) {\n            long now = System.currentTimeMillis();\n            if (now >= updateMillis) {\n                updateMillis = now + UPDATE_INTERVAL;\n                double complete = ((int)((double)i / iterations * 1000.0)) / 10d;\n                if (complete < 100) {\n                    System.out.println(\"\" + complete + \"\" + i + \"\");\n                }\n            }\n\n            long millis = randomMillis(rnd);\n            int value = rnd.nextInt(200) - 100;\n            \n            long millis2 = millis + rnd.nextLong() % _1000_YEARS - _500_YEARS;\n\n            try {\n                testFields(millis, value, millis2);\n            } catch (RuntimeException e) {\n                System.out.println(\"\" + i);\n                System.out.println(\"\" + millis);\n                System.out.println(\"\" + value);\n                System.out.println(\"\" + millis2);\n                fail(e.getMessage());\n            }\n        }\n\n        System.out.println(\"\" + iterations + \"\");\n    }", "comment": "/**\n     * Main junit test\n     */"}}
{"code": {"body": "    static long div(long dividend, long divisor) {\n        if (divisor < 0) {\n            throw new IllegalArgumentException(\"\" + divisor);\n        }\n        if (dividend >= 0) {\n            return dividend / divisor;\n        } else {\n            return (dividend + 1) / divisor - 1;\n        }\n    }", "comment": "/**\n     * Divide with round-negative behavior.\n     *\n     * @param divisor must be positive\n     */"}}
{"code": {"body": "    static long mod(long dividend, long divisor) {\n        if (divisor < 0) {\n            throw new IllegalArgumentException(\"\" + divisor);\n        }\n        if (dividend >= 0) {\n            return dividend % divisor;\n        } else {\n            return (dividend + 1) % divisor - 1 + divisor;\n        }\n    }", "comment": "/**\n     * Modulus with round-negative behavior, result is always positive.\n     *\n     * @param divisor must be positive\n     */"}}
{"code": {"body": "    public Chronology withZone(DateTimeZone zone) {\n        throw new UnsupportedOperationException();\n    }", "comment": "/**\n     * Unsupported.\n     */"}}
{"code": {"body": "    abstract int[] gjFromFixed(long date);\n\n ", "comment": "/**\n     * @param date days from 0001-01-01\n     * @return gj year, monthOfYear, dayOfMonth\n     */"}}
{"code": {"body": "    long fixedFromMillis(long millis) {\n        return div(millis + iEpochMillis, MILLIS_PER_DAY);\n    }", "comment": "/**\n     * @param millis milliseconds from epoch\n     * @return days from 0001-01-01\n     */"}}
{"code": {"body": "    long millisFromFixed(long fixed) {\n        return fixed * MILLIS_PER_DAY - iEpochMillis;\n    }", "comment": "/**\n     * @param fixed days from 0001-01-01\n     * @return milliseconds from epoch\n     */"}}
{"code": {"body": "    long millisFromGJ(int year, int monthOfYear, int dayOfMonth) {\n        return millisFromFixed(fixedFromGJ(year, monthOfYear, dayOfMonth));\n    }", "comment": "/**\n     * @return milliseconds from epoch\n     */"}}
{"code": {"body": "    int gjYearFromMillis(long millis) {\n        return gjYearFromFixed(fixedFromMillis(millis));\n    }", "comment": "/**\n     * @param millis milliseconds from epoch\n     * @return gj year\n     */"}}
{"code": {"body": "    int[] gjFromMillis(long millis) {\n        return gjFromFixed(fixedFromMillis(millis));\n    }", "comment": "/**\n     * @param millis milliseconds from epoch\n     * @return gj year, monthOfYear, dayOfMonth\n     */"}}
{"code": {"body": "    long millisFromISO(int weekyear, int weekOfWeekyear, int dayOfWeek) {\n        return millisFromFixed(fixedFromISO(weekyear, weekOfWeekyear, dayOfWeek));\n    }", "comment": "/**\n     * @return milliseconds from epoch\n     */"}}
{"code": {"body": "    int[] isoFromMillis(long millis) {\n        return isoFromFixed(fixedFromMillis(millis));\n    }", "comment": "/**\n     * @param millis milliseconds from epoch\n     * @return iso weekyear, weekOfWeekyear, dayOfWeek (1=Monday to 7)\n     */"}}
{"code": {"body": "    long weekdayOnOrBefore(long date, int weekday) {\n        return date - mod(date - mod(weekday, 7), 7);\n    }", "comment": "/**\n     * @param date days from 0001-01-01\n     * @param weekday 0=Sunday, 1=Monday, 2=Tuesday ... 6=Saturday, 7=Sunday\n     * @param date days from 0001-01-01, on or before weekday\n     */"}}
{"code": {"body": "public TestGregorianChronology() {\n        super(1970, 1, 1);\n    }", "comment": "/**\n     * Constructs with an epoch of 1970-01-01.\n     */"}}
{"code": {"body": "    long fixedFromGJ(int year, int monthOfYear, int dayOfMonth) {\n        long year_m1 = year - 1;\n        long f = 365 * year_m1 + div(year_m1, 4) - div(year_m1, 100)\n            + div(year_m1, 400) + div(367 * monthOfYear - 362, 12) + dayOfMonth;\n        if (monthOfYear > 2) {\n            f += isLeapYear(year) ? -1 : -2;\n        }\n        return f;\n    }", "comment": "/**\n     * @return days from 0001-01-01\n     */"}}
{"code": {"body": "    int gjYearFromFixed(long date) {\n        long d0 = date - 1;\n        long n400 = div(d0, 146097);\n        long d1 = mod(d0, 146097);\n        long n100 = div(d1, 36524);\n        long d2 = mod(d1, 36524);\n        long n4 = div(d2, 1461);\n        long d3 = mod(d2, 1461);\n        long n1 = div(d3, 365);\n        long year = 400 * n400 + 100 * n100 + 4 * n4 + n1;\n        if (!(n100 == 4 || n1 == 4)) {\n            year += 1;\n        }\n\n        int year_i = (int)year;\n        if (year_i == year) {\n            return year_i;\n        } else {\n            throw new RuntimeException(\"\" + year);\n        }\n    }", "comment": "/**\n     * @param date days from 0001-01-01\n     * @return gj year\n     */"}}
{"code": {"body": "    int[] gjFromFixed(long date) {\n        int year = gjYearFromFixed(date);\n        long priorDays = date - fixedFromGJ(year, 1, 1);\n        long correction;\n        if (date < fixedFromGJ(year, 3, 1)) {\n            correction = 0;\n        } else if (isLeapYear(year)) {\n            correction = 1;\n        } else {\n            correction = 2;\n        }\n        int monthOfYear = (int)div(12 * (priorDays + correction) + 373, 367);\n        int day = (int)(date - fixedFromGJ(year, monthOfYear, 1) + 1);\n\n        return new int[]{year, monthOfYear, day};\n    }", "comment": "/**\n     * @param date days from 0001-01-01\n     * @return gj year, monthOfYear, dayOfMonth\n     */"}}
{"code": {"body": "    int[] isoFromFixed(long date) {\n        int weekyear = gjYearFromFixed(date - 3);\n        if (date >= fixedFromISO(weekyear + 1, 1, 1)) {\n            weekyear += 1;\n        }\n        int weekOfWeekyear = (int)(div(date - fixedFromISO(weekyear, 1, 1), 7) + 1);\n        int dayOfWeek = (int)amod(date, 7);\n        return new int[]{weekyear, weekOfWeekyear, dayOfWeek};\n    }", "comment": "/**\n     * @param date days from 0001-01-01\n     * @return iso weekyear, weekOfWeekyear, dayOfWeek (1=Monday to 7)\n     */"}}
{"code": {"body": "public TestJulianChronology() {\n        super(1969, 12, 19);\n    }", "comment": "/**\n     * Constructs with an epoch of 1969-12-19.\n     */"}}
{"code": {"body": "    long fixedFromGJ(int year, int monthOfYear, int dayOfMonth) {\n        if (year == 0) {\n            throw new IllegalArgumentException(\"\" + year);\n        }\n        int y = (year < 0) ? year + 1 : year;\n        long y_m1 = y - 1;\n        long f = JULIAN_EPOCH - 1 + 365 * y_m1 + div(y_m1, 4)\n            + div(367 * monthOfYear - 362, 12) + dayOfMonth;\n        if (monthOfYear > 2) {\n            f += isLeapYear(year) ? -1 : -2;\n        }\n        return f;\n    }", "comment": "/**\n     * @return days from 0001-01-01\n     */"}}
{"code": {"body": "    int gjYearFromFixed(long date) {\n        return gjFromFixed(date)[0];\n    }", "comment": "/**\n     * @param date days from 0001-01-01\n     * @return gj year\n     */"}}
{"code": {"body": "    int[] gjFromFixed(long date) {\n        long approx = div(4 * (date - JULIAN_EPOCH) + 1464, 1461);\n        long year = (approx <= 0) ? approx - 1 : approx;\n        int year_i = (int)year;\n        if (year_i != year) {\n            throw new RuntimeException(\"\" + year);\n        }\n        long priorDays = date - fixedFromGJ(year_i, 1, 1);\n        long correction;\n        if (date < fixedFromGJ(year_i, 3, 1)) {\n            correction = 0;\n        } else if (isLeapYear(year_i)) {\n            correction = 1;\n        } else {\n            correction = 2;\n        }\n        int monthOfYear = (int)div(12 * (priorDays + correction) + 373, 367);\n        int day = (int)(date - fixedFromGJ(year_i, monthOfYear, 1) + 1);\n\n        return new int[]{year_i, monthOfYear, day};\n    }", "comment": "/**\n     * @param date days from 0001-01-01\n     * @return gj year, monthOfYear, dayOfMonth\n     */"}}
{"code": {"body": "    int[] isoFromFixed(long date) {\n        int weekyear = gjYearFromFixed(date - 3);\n        int nextWeekyear;\n        if (weekyear == -1) {\n            nextWeekyear = 1;\n        } else {\n            nextWeekyear = weekyear + 1;\n        }\n        if (date >= fixedFromISO(nextWeekyear, 1, 1)) {\n            weekyear = nextWeekyear;\n        }\n        int weekOfWeekyear = (int)(div(date - fixedFromISO(weekyear, 1, 1), 7) + 1);\n        int dayOfWeek = (int)amod(date, 7);\n        return new int[]{weekyear, weekOfWeekyear, dayOfWeek};\n    }", "comment": "/**\n     * @param date days from 0001-01-01\n     * @return iso weekyear, weekOfWeekyear, dayOfWeek (1=Monday to 7)\n     */"}}
{"code": {"body": "    public void testNullValuesToGetInstanceThrowsException() {\n\n        try {\n            UnsupportedDateTimeField.getInstance(null, null);\n            assertTrue(false);\n        } catch (IllegalArgumentException e) {\n            assertTrue(true);\n        }\n    }", "comment": "/**\n     * Passing null values into UnsupportedDateTimeField.getInstance() should\n     * throw an IllegalArguementsException\n     */"}}
{"code": {"body": "    public void testDifferentDurationReturnDifferentObjects() {\n\n        \n        DateTimeField fieldOne = UnsupportedDateTimeField.getInstance(\n                dateTimeFieldTypeOne, UnsupportedDurationField\n                        .getInstance(weeks));\n        DateTimeField fieldTwo = UnsupportedDateTimeField.getInstance(\n                dateTimeFieldTypeOne, UnsupportedDurationField\n                        .getInstance(weeks));\n        assertSame(fieldOne, fieldTwo);\n\n        \n        DateTimeField fieldThree = UnsupportedDateTimeField.getInstance(\n                dateTimeFieldTypeOne, UnsupportedDurationField\n                        .getInstance(months));\n        assertNotSame(fieldOne, fieldThree);\n    }", "comment": "/**\n     * \n     * This test exercises the logic in UnsupportedDateTimeField.getInstance. If\n     * getInstance() is invoked twice with: - the same DateTimeFieldType -\n     * different duration fields\n     * \n     * Then the field returned in the first invocation should not be equal to\n     * the field returned by the second invocation. In otherwords, the generated\n     * instance should be the same for a unique pairing of\n     * DateTimeFieldType/DurationField\n     */"}}
{"code": {"body": "    public void testPublicGetNameMethod() {\n        DateTimeField fieldOne = UnsupportedDateTimeField.getInstance(\n                dateTimeFieldTypeOne, UnsupportedDurationField\n                        .getInstance(weeks));\n\n        assertSame(fieldOne.getName(), dateTimeFieldTypeOne.getName());\n    }", "comment": "/**\n     * The getName() method should return the same value as the getName() method\n     * of the DateTimeFieldType that was used to create the instance.\n     * \n     */"}}
{"code": {"body": "    public void testAlwaysFalseReturnTypes() {\n        DateTimeField fieldOne = UnsupportedDateTimeField.getInstance(\n                dateTimeFieldTypeOne, UnsupportedDurationField\n                        .getInstance(weeks));\n        assertFalse(fieldOne.isLenient());\n        assertFalse(fieldOne.isSupported());\n    }", "comment": "/**\n     * As this is an unsupported date/time field, some normal methods will\n     * always return false, as they are not supported. Verify that each method\n     * correctly returns null.\n     */"}}
{"code": {"body": "    public void testMethodsThatShouldAlwaysReturnNull() {\n        DateTimeField fieldOne = UnsupportedDateTimeField.getInstance(\n                dateTimeFieldTypeOne, UnsupportedDurationField\n                        .getInstance(weeks));\n\n        assertNull(fieldOne.getLeapDurationField());\n        assertNull(fieldOne.getRangeDurationField());\n    }", "comment": "/**\n     * According to the JavaDocs, there are two methods that should always\n     * return null. * getRangeDurationField() * getLeapDurationField()\n     * \n     * Ensure that these are in fact null.\n     */"}}
{"code": {"body": "    public void testUnsupportedMethods() {\n        DateTimeField fieldOne = UnsupportedDateTimeField.getInstance(\n                dateTimeFieldTypeOne, UnsupportedDurationField\n                        .getInstance(weeks));\n\n        \n        \n        try {\n            fieldOne.add(localTime, 0, new int[] { 0, 100 }, 100);\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n        \n        try {\n            fieldOne.addWrapField(100000L, 250);\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n        \n        \n        try {\n            fieldOne.addWrapField(localTime, 0, new int[] { 0, 100 }, 100);\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n        \n        \n        try {\n            fieldOne.addWrapPartial(localTime, 0, new int[] { 0, 100 }, 100);\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n        \n        try {\n            fieldOne.get(1000L);\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n\n        \n        \n        try {\n            fieldOne.getAsShortText(0, Locale.getDefault());\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n\n        \n        try {\n            fieldOne.getAsShortText(100000L);\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n\n        \n        try {\n            fieldOne.getAsShortText(100000L, Locale.getDefault());\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n\n        \n        \n        \n        try {\n            fieldOne.getAsShortText(localTime, 0, Locale.getDefault());\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n\n        \n        \n        try {\n            fieldOne.getAsShortText(localTime, Locale.getDefault());\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n\n        \n        \n        try {\n            fieldOne.getAsText(0, Locale.getDefault());\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n\n        \n        try {\n            fieldOne.getAsText(1000L);\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n\n        \n        try {\n            fieldOne.getAsText(1000L, Locale.getDefault());\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n\n        \n        \n        \n        try {\n            fieldOne.getAsText(localTime, 0, Locale.getDefault());\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n\n        \n        \n        try {\n            fieldOne.getAsText(localTime, Locale.getDefault());\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n\n        \n        \n        try {\n            fieldOne.getLeapAmount(System.currentTimeMillis());\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n\n        \n        \n        \n        try {\n            fieldOne.getMaximumShortTextLength(Locale.getDefault());\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n\n        \n        \n        \n        try {\n            fieldOne.getMaximumTextLength(Locale.getDefault());\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n\n        \n        \n        try {\n            fieldOne.getMaximumValue();\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n\n        \n        \n        \n        try {\n            fieldOne.getMaximumValue(1000000L);\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n\n        \n        \n        \n        try {\n            fieldOne.getMaximumValue(localTime);\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n\n        \n        \n        \n        \n        try {\n            fieldOne.getMaximumValue(localTime, new int[] { 0 });\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n\n        \n        \n        try {\n            fieldOne.getMinimumValue();\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n\n        \n        \n        try {\n            fieldOne.getMinimumValue(10000000L);\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n\n        \n        \n        \n        try {\n            fieldOne.getMinimumValue(localTime);\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n\n        \n        \n        \n        try {\n            fieldOne.getMinimumValue(localTime, new int[] { 0 });\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n\n        \n        \n        try {\n            fieldOne.isLeap(System.currentTimeMillis());\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n\n        \n        \n        try {\n            fieldOne.remainder(1000000L);\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n\n        \n        \n        \n        try {\n            fieldOne.roundCeiling(1000000L);\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n\n        \n        \n        try {\n            fieldOne.roundFloor(1000000L);\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n\n        \n        \n        \n        try {\n            fieldOne.roundHalfCeiling(1000000L);\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n\n        \n        \n        \n        try {\n            fieldOne.roundHalfEven(1000000L);\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n\n        \n        \n        \n        try {\n            fieldOne.roundHalfFloor(1000000L);\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n\n        \n        \n        \n        try {\n            fieldOne.set(1000000L, 1000);\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n\n        \n        \n        \n        try {\n            fieldOne.set(1000000L, \"\");\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n\n        \n        \n        \n        \n        try {\n            fieldOne\n                    .set(1000000L, \"\", Locale.getDefault());\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n\n        \n        \n        \n        \n        \n        try {\n            fieldOne.set(localTime, 0, new int[] { 0 }, 10000);\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n\n        \n        \n        \n        \n        \n        \n        try {\n            fieldOne.set(localTime, 0, new int[] { 0 },\n                    \"\", Locale.getDefault());\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n    }", "comment": "/**\n     * As this is an unsupported date/time field, many normal methods are\n     * unsupported and throw an UnsupportedOperationException. Verify that each\n     * method correctly throws this exception. * add(ReadablePartial instant,\n     * int fieldIndex, int[] values, int valueToAdd) * addWrapField(long\n     * instant, int value) * addWrapField(ReadablePartial instant, int\n     * fieldIndex, int[] values, int valueToAdd) *\n     * addWrapPartial(ReadablePartial instant, int fieldIndex, int[] values, int\n     * valueToAdd) * get(long instant) * getAsShortText(int fieldValue, Locale\n     * locale) * getAsShortText(long instant) * getAsShortText(long instant,\n     * Locale locale) * getAsShortText(ReadablePartial partial, int fieldValue,\n     * Locale locale) * getAsShortText(ReadablePartial partial, Locale locale) *\n     * getAsText(int fieldValue, Locale locale) * getAsText(long instant) *\n     * getAsText(long instant, Locale locale) * getAsText(ReadablePartial\n     * partial, int fieldValue, Locale locale) * getAsText(ReadablePartial\n     * partial, Locale locale) * getLeapAmount(long instant) *\n     * getMaximumShortTextLength(Locale locale) * getMaximumTextLength(Locale\n     * locale) * getMaximumValue() * getMaximumValue(long instant) *\n     * getMaximumValue(ReadablePartial instant) *\n     * getMaximumValue(ReadablePartial instant, int[] values) *\n     * getMinimumValue() * getMinimumValue(long instant) *\n     * getMinimumValue(ReadablePartial instant) *\n     * getMinimumValue(ReadablePartial instant, int[] values) * isLeap(long\n     * instant) * remainder(long instant) * roundCeiling(long instant) *\n     * roundFloor(long instant) * roundHalfCeiling(long instant) *\n     * roundHalfEven(long instant) * roundHalfFloor(long instant) * set(long\n     * instant, int value) * set(long instant, String text) * set(long instant,\n     * String text, Locale locale) * set(ReadablePartial instant, int\n     * fieldIndex, int[] values, int newValue) * set(ReadablePartial instant,\n     * int fieldIndex, int[] values, String text, Locale locale)\n     */"}}
{"code": {"body": "    public void testDelegatedMethods() {\n        DateTimeField fieldOne = UnsupportedDateTimeField.getInstance(\n                dateTimeFieldTypeOne, UnsupportedDurationField\n                        .getInstance(weeks));\n        PreciseDurationField hoursDuration = new PreciseDurationField(\n                DurationFieldType.hours(), 10L);\n        DateTimeField fieldTwo = UnsupportedDateTimeField.getInstance(\n                dateTimeFieldTypeOne, hoursDuration);\n\n        \n        \n        \n        \n        \n        try {\n            fieldOne.add(System.currentTimeMillis(), 100);\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n        try {\n            long currentTime = System.currentTimeMillis();\n            long firstComputation = hoursDuration.add(currentTime, 100);\n            long secondComputation = fieldTwo.add(currentTime,\n                    100);\n            assertEquals(firstComputation,secondComputation);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(false);\n        }\n\n        \n        \n        \n        \n        \n        try {\n            fieldOne.add(System.currentTimeMillis(), 1000L);\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n\n        try {\n            long currentTime = System.currentTimeMillis();\n            long firstComputation = hoursDuration.add(currentTime, 1000L);\n            long secondComputation = fieldTwo.add(currentTime,\n                    1000L);\n            assertTrue(firstComputation == secondComputation);\n            assertEquals(firstComputation,secondComputation);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(false);\n        }\n\n        \n        \n        \n        \n        \n        try {\n            fieldOne.getDifference(100000L, 1000L);\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n\n        try {\n            int firstDifference = hoursDuration.getDifference(100000L, 1000L);\n            int secondDifference = fieldTwo.getDifference(100000L, 1000L);\n            assertEquals(firstDifference,secondDifference);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(false);\n        }\n\n        \n        \n        \n        \n        \n        try {\n            fieldOne.getDifferenceAsLong(100000L, 1000L);\n            assertTrue(false);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(true);\n        }\n\n        try {\n            long firstDifference = hoursDuration.getDifference(100000L, 1000L);\n            long secondDifference = fieldTwo.getDifference(100000L, 1000L);\n            assertEquals(firstDifference,secondDifference);\n        } catch (UnsupportedOperationException e) {\n            assertTrue(false);\n        }\n    }", "comment": "/**\n     * As this is an unsupported date/time field, many normal methods are\n     * unsupported. Some delegate and can possibly throw an\n     * UnsupportedOperationException or have a valid return. Verify that each\n     * method correctly throws this exception when appropriate and delegates\n     * correctly based on the Duration used to get the instance.\n     */"}}
{"code": {"body": "    public void testToString() {\n        DateTimeField fieldOne = UnsupportedDateTimeField.getInstance(\n                dateTimeFieldTypeOne, UnsupportedDurationField\n                        .getInstance(weeks));\n\n        String debugMessage = fieldOne.toString();\n        assertNotNull(debugMessage);\n        assertTrue(debugMessage.length() > 0);\n    }", "comment": "/**\n    * The toString method should return a suitable debug message (not null).\n    * Ensure that the toString method returns a string with length greater than\n    * 0 (and not null)\n    * \n    */"}}
{"code": {"body": "    private int getOffset(TimeZone zone, long millis) {\n        Date date = new Date(millis);\n        if (zone.inDaylightTime(date)) {\n            return zone.getRawOffset() + 3600000;\n        }\n        return zone.getRawOffset();\n    }", "comment": "/** Make test compile on JDK 1.3. */"}}
{"code": {"body": "public AccountController(){\n        accountContainer = AccountContainer.getInstance();\n\n    }", "comment": "/**\n     * Konstrukt\u00f8r for objekter af klassen CustomerController\n     */"}}
{"code": {"body": "    public void createdummydata(){\n        Integer i = 1;\n        int index = 0;\n        String k = \"\";\n\n        while(index<10){\n\n            createAccount(\"\", \"\", \n                \"\", \"\", k, \"\");  \n            i++;\n            k = i.toString();\n            index++;\n        }    \n    }", "comment": "/**\n     * opretter dummy accounts\n     */"}}
{"code": {"body": "public LoanController(){\n        loanCon = LoanContainer.getInstance();\n        pController = new ProductController();\n        aC = new AccountController();\n    }", "comment": "/**\n     * Constructor for objects of class LoanController\n     */"}}
{"code": {"body": "    public int createLoan(int day, String phone){\n        Loan loan = new Loan(day);\n        loanCon.addLoan(loan);\n        aC.addLoan(phone, loan);\n        return loan.getId();\n    }", "comment": "/**\n     * kalder metoden addLoan nede fra loanContainer\n     * @return loan id\n     */"}}
{"code": {"body": "    public String returnItem(int id,int bar, int serial){\n        pController.returnItem(bar, loanCon.returnItem(id,serial));\n        return \"\";\n    }", "comment": "/**\n     * returnere et l\u00e5n og tilf\u00f8jer varen til productContaineren igen\n     * @param bar barcode\n     * @param serial serialNo\n     * @return String \n     */"}}
{"code": {"body": "public OrderController(){\n        orderContainer = OrderContainer.getInstance();\n        productController = new ProductController();\n        accountController = new AccountController();\n\n    }", "comment": "/**\n     * Konstrukt\u00f8r for objekter af klassen OrderController\n     */"}}
{"code": {"body": "    public double getDicount(double discount, String phone, int id){\n        double totalDiscount = 0;\n        double temp = (1 - accountController.getDiscount(phone))*100;\n        double temp2 = 0;\n        String s = \"\";\n        int amount = orderContainer.amountOfProduct(id);\n        if(amount < 10){\n            temp2 = 10;\n        }\n        totalDiscount = temp + temp2 + discount;\n        if(totalDiscount > 30){\n            totalDiscount = 30;\n        }\n        if(totalDiscount != 1){\n            s = \"\" + totalDiscount + \"\";\n        }\n        totalDiscount = 1 - totalDiscount/100;\n        orderContainer.setTotalPrice(id, orderContainer.totalPrice(id)*totalDiscount);\n        \n        return totalDiscount;\n    }", "comment": "/**\n     * sp\u00f8rg om der skal gives rabat og udregner rabaten der bliver givet og giver en ny totalPrice med rabat.\n     * rabaten kan ikke overskride 30%\n     * @return totalDiscount\n     */"}}
{"code": {"body": "public ProductController()", "comment": "/**\n     * Konstrukt\u00f8r for objekter af klassen ProductController\n     */"}}
{"code": {"body": "    public void createdummydata(){\n        Integer i = 1;\n        int index = 0;\n        String k = \"\";\n\n        while(index<10){\n\n            createMassProduct(i, \"\", \"\", 100, 2000, 10, 50);  \n            i++;\n            index++;\n        }   \n\n    }", "comment": "/**\n     * opretter dummy produkter\n     */"}}
{"code": {"body": "public SupplierController(){\n        \n        supplierCon = SupplierContainer.getInstance();\n        \n    }", "comment": "/**\n     * kalder metoden addSupplier fra modellayer\n     * @return String\n     */"}}
{"code": {"body": "    public String createSupplier(String firmName, int amountOfOrders){\n        Supplier supplier = new Supplier(firmName, amountOfOrders);\n        supplierCon.addSupplier(supplier);\n        return (\"\");\n    }", "comment": "/**\n     * kalder metoden addSupplier fra modellayer\n     * @return String\n     */"}}
{"code": {"body": "public Account (String name, String address, ", "comment": "/**\n     * tjekker tilgodehavende, p\u00e5 en kunde der bliver fundet i containeren,\n     * ved at tr\u00e6kke kundens keyset ud og k\u00f8re igennem\n     * en kundes hashmap og finder ud af hvor meget de skylder. \n     */"}}
{"code": {"body": "    public void setName(String newName){\n        name = newName;\n    }", "comment": "/**\n     * tjekker tilgodehavende, p\u00e5 en kunde der bliver fundet i containeren,\n     * ved at tr\u00e6kke kundens keyset ud og k\u00f8re igennem\n     * en kundes hashmap og finder ud af hvor meget de skylder. \n     */"}}
{"code": {"body": "    public void setAddress(String newAddress){\n        address = newAddress;\n    }", "comment": "/**\n     * tjekker tilgodehavende, p\u00e5 en kunde der bliver fundet i containeren,\n     * ved at tr\u00e6kke kundens keyset ud og k\u00f8re igennem\n     * en kundes hashmap og finder ud af hvor meget de skylder. \n     */"}}
{"code": {"body": "    public void setZip(String newZip){\n        zip = newZip;\n    }", "comment": "/**\n     * tjekker tilgodehavende, p\u00e5 en kunde der bliver fundet i containeren,\n     * ved at tr\u00e6kke kundens keyset ud og k\u00f8re igennem\n     * en kundes hashmap og finder ud af hvor meget de skylder. \n     */"}}
{"code": {"body": "    public void setCity(String newCity){\n        city = newCity;\n    }", "comment": "/**\n     * tjekker tilgodehavende, p\u00e5 en kunde der bliver fundet i containeren,\n     * ved at tr\u00e6kke kundens keyset ud og k\u00f8re igennem\n     * en kundes hashmap og finder ud af hvor meget de skylder. \n     */"}}
{"code": {"body": "    public void setPhone(String newPhone){\n        phone = newPhone;\n    }", "comment": "/**\n     * tjekker tilgodehavende, p\u00e5 en kunde der bliver fundet i containeren,\n     * ved at tr\u00e6kke kundens keyset ud og k\u00f8re igennem\n     * en kundes hashmap og finder ud af hvor meget de skylder. \n     */"}}
{"code": {"body": "    public String getName(){\n        return name;\n    }", "comment": "/**\n     * tjekker tilgodehavende, p\u00e5 en kunde der bliver fundet i containeren,\n     * ved at tr\u00e6kke kundens keyset ud og k\u00f8re igennem\n     * en kundes hashmap og finder ud af hvor meget de skylder. \n     */"}}
{"code": {"body": "    public String getAddress(){\n        return address;\n    }", "comment": "/**\n     * tjekker tilgodehavende, p\u00e5 en kunde der bliver fundet i containeren,\n     * ved at tr\u00e6kke kundens keyset ud og k\u00f8re igennem\n     * en kundes hashmap og finder ud af hvor meget de skylder. \n     */"}}
{"code": {"body": "    public String getZip(){\n        return zip;\n    }", "comment": "/**\n     * tjekker tilgodehavende, p\u00e5 en kunde der bliver fundet i containeren,\n     * ved at tr\u00e6kke kundens keyset ud og k\u00f8re igennem\n     * en kundes hashmap og finder ud af hvor meget de skylder. \n     */"}}
{"code": {"body": "    public String getCity(){\n        return city;\n    }", "comment": "/**\n     * tjekker tilgodehavende, p\u00e5 en kunde der bliver fundet i containeren,\n     * ved at tr\u00e6kke kundens keyset ud og k\u00f8re igennem\n     * en kundes hashmap og finder ud af hvor meget de skylder. \n     */"}}
{"code": {"body": "    public String getPhone(){\n        return phone;\n    }", "comment": "/**\n     * tjekker tilgodehavende, p\u00e5 en kunde der bliver fundet i containeren,\n     * ved at tr\u00e6kke kundens keyset ud og k\u00f8re igennem\n     * en kundes hashmap og finder ud af hvor meget de skylder. \n     */"}}
{"code": {"body": "    public int getAccId(){\n        return accountId;\n    }", "comment": "/**\n     * tjekker tilgodehavende, p\u00e5 en kunde der bliver fundet i containeren,\n     * ved at tr\u00e6kke kundens keyset ud og k\u00f8re igennem\n     * en kundes hashmap og finder ud af hvor meget de skylder. \n     */"}}
{"code": {"body": "    public void addOrder(Order order){\n        this.order.put(order.getId(), order);\n    }", "comment": "/**\n     * tjekker tilgodehavende, p\u00e5 en kunde der bliver fundet i containeren,\n     * ved at tr\u00e6kke kundens keyset ud og k\u00f8re igennem\n     * en kundes hashmap og finder ud af hvor meget de skylder. \n     */"}}
{"code": {"body": "    public void addLoan(Loan loan){\n        loans.put(loan.getId(), loan);\n    }", "comment": "/**\n     * tjekker tilgodehavende, p\u00e5 en kunde der bliver fundet i containeren,\n     * ved at tr\u00e6kke kundens keyset ud og k\u00f8re igennem\n     * en kundes hashmap og finder ud af hvor meget de skylder. \n     */"}}
{"code": {"body": "    public HashMap getorders(){\n        return order;    \n    }", "comment": "/**\n     * tjekker tilgodehavende, p\u00e5 en kunde der bliver fundet i containeren,\n     * ved at tr\u00e6kke kundens keyset ud og k\u00f8re igennem\n     * en kundes hashmap og finder ud af hvor meget de skylder. \n     */"}}
{"code": {"body": "    public double customerReceivable(){\n        HashMap<Integer, Order> map = order;\n        double amount = 0;\n        for(Map.Entry<Integer,Order> entry : map.entrySet()){\n            int key = entry.getKey();\n            Order order = entry.getValue();\n            if(order.getbetalt()==false){\n                amount = amount + order.getTotalPrice();\n                \n            }\n        }\n        return amount;\n    }", "comment": "/**\n     * tjekker tilgodehavende, p\u00e5 en kunde der bliver fundet i containeren,\n     * ved at tr\u00e6kke kundens keyset ud og k\u00f8re igennem\n     * en kundes hashmap og finder ud af hvor meget de skylder. \n     */"}}
{"code": {"body": "    public static AccountContainer getInstance(){\n        if(instance == null){\n            instance = new AccountContainer();\n        }\n        return instance;\n    }", "comment": "/**\n     * laver en AccountContainer hvis en ikke eksistere og returnere den\n     * @return AccountContainer\n     */"}}
{"code": {"body": "    public Account findAccount(String phone) throws NullPointerException {\n        Account findCustomer = accountMap.get(phone);\n        if(findCustomer == null){\n            throw new NullPointerException(\"\");\n        }\n        return findCustomer;\n    }", "comment": "/**\n     * henter en account p\u00e5 phone og returnerer den\n     * @param String phone\n     * @return account \n     */"}}
{"code": {"body": "    public String updatePhone(String phone, String newPhone)  {\n        Account a = findAccount(phone);\n        accountMap.remove(phone);\n        a.setPhone(newPhone);\n        addAccount(a);\n        return \"\";\n    }", "comment": "/**\n     * Vigitig funktion - Vi bruger den som key til at store vores values i HashMappet\n     * henter en account p\u00e5 phone\n     * fjerne eksisterende phone og s\u00e6tter newPhone\n     * @param String newPhone bliver til phone\n     * @return String bekr\u00e6ftelse af opdatering\n     */"}}
{"code": {"body": "    public void addOrder(String phone,Order order){\n        findAccount(phone).addOrder(order);\n    }", "comment": "/**\n     * tilf\u00f8jer en order til en account som hentes p\u00e5 phone \n     * @param String phone og Order order\n     */"}}
{"code": {"body": "    public void addLoan(String phone, Loan loan){\n        accountMap.get(phone).addLoan(loan);\n    }", "comment": "/**\n     * tilf\u00f8jer et l\u00e5n til en account som hentes p\u00e5 phone \n     * @param Loan loan og String phone \n     */"}}
{"code": {"body": "    public double customerReceivable(String phone){\n        return findAccount(phone).customerReceivable();\n    }", "comment": "/**\n     * se costumerRecieveable i Account\n     */"}}
{"code": {"body": "    public Item returnItem(int Serial){       \n        Date date = new Date();\n        if(date.after(returnDate)){\n            totalPrice += 500;\n        }\n        return itemMap.remove(Serial);\n    }", "comment": "/**\n     * returnerer et item og tjekker om det er afleveret for sent, hvis det \n     * l\u00e6gger 500 til totalprice.\n     */"}}
{"code": {"body": "    public static LoanContainer getInstance(){\n        if(instance == null){\n            instance = new LoanContainer();\n        }\n        return instance;\n    }", "comment": "/**\n     * laver en LoanContainer hvis der ikke er en og returnerer \n     * den nye eller den ekstisterende \n     */"}}
{"code": {"body": "    public void addLoan(Loan loan){\n        this.loan.put(loan.getId(),loan);\n    }", "comment": "/**\n     * tilf\u00f8jer et l\u00e5n til containerens hashmap\n     * @param Loan loan\n     */"}}
{"code": {"body": "    public void returnLoan(int id){\n        findLoan(id).returnItem(id);\n    }", "comment": "/**\n     * returnerer et l\u00e5n p\u00e5 id \n     * @param id p\u00e5 l\u00e5net \n     */"}}
{"code": {"body": "    public String payLoan(int id){\n        findLoan(id).pay();\n        return \"\";\n    }", "comment": "/**\n     * finder et l\u00e5n og s\u00e6tter status til betalt\n     * @param id p\u00e5 l\u00e5n \n     * @return String \n     */"}}
{"code": {"body": "    public Loan findLoan(int id){\n        return loan.get(id);\n    }", "comment": "/**\n     * finder et l\u00e5n p\u00e5 id\n     * @param id p\u00e5 loan\n     * @return returnerer et l\u00e5n objekt \n     */"}}
{"code": {"body": "    public void addItem(int id, Item  item){\n        findLoan(id).addItem(item);\n    }", "comment": "/**\n     * tilf\u00f8jer et item til et l\u00e5n p\u00e5 l\u00e5ns id og tager et item objekt\n     * @param id p\u00e5 l\u00e5n og et item objekt \n     */"}}
{"code": {"body": "    public Item returnItem(int id, int serial){\n        return findLoan(id).returnItem(serial);\n    }", "comment": "/**\n     * returnere et item og \u00e6ndrer status p\u00e5 objekt\n     * @param id p\u00e5 l\u00e5n og serienummer p\u00e5 et item\n     * @return returnere et item objekt\n     */"}}
{"code": {"body": "public MassProduct(int barcode, String name, String description, int price, int amount, int min, int max){\n        super(barcode, name, description, price, amount, min, max);\n    }", "comment": "/**\n     * constructor til objekter af class MassProduct\n     */"}}
{"code": {"body": "public MassProduct Sale(int i){\n        setAmount(getAmount() -i);\n        return this;\n    }", "comment": "/**\n     * tr\u00e6kker en m\u00e6nge af massprodukt og returnerer produktet der er solgt noget af\n     * @param int i\n     * @return Item\n     */"}}
{"code": {"body": "    public void addItem(int i){\n        setAmount(getAmount() + i);\n    }", "comment": "/**\n     * tilf\u00f8jer en m\u00e6ngde af produkter til amount\n     * @param int i\n     */"}}
{"code": {"body": "    public MassProduct Sale(int i){\n        setAmount(getAmount() -i);\n        return this;\n    }", "comment": "/**\n     * tr\u00e6kker en m\u00e6nge af massprodukt og returnerer produktet der er solgt noget af\n     * @param int i\n     * @return Item\n     */"}}
{"code": {"body": "public Order(boolean delivery, String address){\n        \n        orderId = counter++;\n        this.delivery = delivery;\n        deliveryAddress = address;\n        orderLine = new LinkedList<>();\n        betalt=false;\n        dato = new Date();\n        datop=setDate();\n\n    }", "comment": "/**\n     * laver en tom linkedlist og gemmer informationen fra Orderline i vores OrderLineList\n     * @return OrderLineList\n     */"}}
{"code": {"body": "    public void addOrderUniqueLine(Item item){\n        OrderLine oL = new UniqueLine(item);\n        orderLine.add(oL);\n        totalPrice =+ oL.getPrice();\n    }", "comment": "/**\n     * laver en tom linkedlist og gemmer informationen fra Orderline i vores OrderLineList\n     * @return OrderLineList\n     */"}}
{"code": {"body": "    public void addOrderSimpleLine(Product product, int amount){\n        OrderLine oL = new SimpleLine(amount, product);\n        orderLine.add(oL);\n        totalPrice =+ oL.getPrice();\n    }", "comment": "/**\n     * laver en tom linkedlist og gemmer informationen fra Orderline i vores OrderLineList\n     * @return OrderLineList\n     */"}}
{"code": {"body": "    public String setDate(){\n        String date1;\n        date1= dato.getDate()+(\"\")+(dato.getMonth()+1)+(\"\")+(dato.getYear()+1900);\n        return date1;\n\n    }", "comment": "/**\n     * laver en tom linkedlist og gemmer informationen fra Orderline i vores OrderLineList\n     * @return OrderLineList\n     */"}}
{"code": {"body": "    public void setTotalPrice(double newTotalPrice){\n        totalPrice = newTotalPrice;\n    }", "comment": "/**\n     * laver en tom linkedlist og gemmer informationen fra Orderline i vores OrderLineList\n     * @return OrderLineList\n     */"}}
{"code": {"body": "    public void setDelivery(boolean newDelivery){\n        delivery = newDelivery;\n    }", "comment": "/**\n     * laver en tom linkedlist og gemmer informationen fra Orderline i vores OrderLineList\n     * @return OrderLineList\n     */"}}
{"code": {"body": "    public String getDate(){\n        return datop;\n    }", "comment": "/**\n     * laver en tom linkedlist og gemmer informationen fra Orderline i vores OrderLineList\n     * @return OrderLineList\n     */"}}
{"code": {"body": "    public double getTotalPrice(){\n        return totalPrice;\n    }", "comment": "/**\n     * laver en tom linkedlist og gemmer informationen fra Orderline i vores OrderLineList\n     * @return OrderLineList\n     */"}}
{"code": {"body": "    public boolean getDelivery(){\n        return delivery;\n    }", "comment": "/**\n     * laver en tom linkedlist og gemmer informationen fra Orderline i vores OrderLineList\n     * @return OrderLineList\n     */"}}
{"code": {"body": "    public String getAdress(){\n        return deliveryAddress;\n    }", "comment": "/**\n     * laver en tom linkedlist og gemmer informationen fra Orderline i vores OrderLineList\n     * @return OrderLineList\n     */"}}
{"code": {"body": "    public int getId(){\n        return orderId;\n    }", "comment": "/**\n     * laver en tom linkedlist og gemmer informationen fra Orderline i vores OrderLineList\n     * @return OrderLineList\n     */"}}
{"code": {"body": "    public boolean getbetalt(){\n        return betalt;\n    }", "comment": "/**\n     * laver en tom linkedlist og gemmer informationen fra Orderline i vores OrderLineList\n     * @return OrderLineList\n     */"}}
{"code": {"body": "    public boolean setbetalt(){\n        betalt = true;\n        return betalt;\n    }", "comment": "/**\n     * laver en tom linkedlist og gemmer informationen fra Orderline i vores OrderLineList\n     * @return OrderLineList\n     */"}}
{"code": {"body": "    public LinkedList getOrderLines(){\n        return orderLine; \n    }", "comment": "/**\n     * laver en tom linkedlist og gemmer informationen fra Orderline i vores OrderLineList\n     * @return OrderLineList\n     */"}}
{"code": {"body": "    public LinkedList<String> getOrderLine(){\n        double fakturatotalprice = 0;\n        LinkedList<String> orderLineList = new LinkedList<String>();\n        for(OrderLine tmp: orderLine){\n            orderLineList.add(tmp.getName()+\"\"+\"\"+tmp.getAmount()+\"\"+\"\"+tmp.getUnitPrice()+\"\"\n            +\"\"+(tmp.getAmount()*tmp.getUnitPrice()));\n            fakturatotalprice = fakturatotalprice + (tmp.getAmount()*tmp.getUnitPrice());\n\n        }\n        return orderLineList;\n    }", "comment": "/**\n     * laver en tom linkedlist og gemmer informationen fra Orderline i vores OrderLineList\n     * @return OrderLineList\n     */"}}
{"code": {"body": "    public static OrderContainer getInstance(){\n        if(instance == null){\n            instance = new OrderContainer();\n        }\n        return instance;\n    }", "comment": "/**\n     * laver en OrderContainer hvis der ikke er en og returnerer \n     * den nye eller den ekstisterende \n     */"}}
{"code": {"body": "    public void addOrder(Order order){\n        orderMap.put(order.getId(),order);\n    }", "comment": "/**\n     * tilf\u00f8jer en order til orders hashmap\n     * @param Order order\n     */"}}
{"code": {"body": "    public String addProduct(int id,Product product, int amount){\n        getOrder(id).addOrderSimpleLine(product, amount);\n        return \"\";\n    }", "comment": "/**\n     * Tilf\u00f8jer et product til\n     */"}}
{"code": {"body": "public OrderLine(int amount)", "comment": "/**\n     * getter og setter metoder\n     */"}}
{"code": {"body": "    public void setAmount(int newAmount){\n        amount = newAmount;\n    }", "comment": "/**\n     * getter og setter metoder\n     */"}}
{"code": {"body": "public Product(int barcode, String name, String description, int price, int amount, int min,int max){\n        this.barcode = barcode;\n        this.name = name;\n        this.description = description;\n        this.price = price;\n        this.price = price;\n        minAmount = min;\n        maxAmount = max;\n    }", "comment": "/**\n     * Constructor for objects of class ProductMain\n     */"}}
{"code": {"body": "    public static ProductContainer getInstance(){\n        if(instance == null){\n            instance = new ProductContainer(); \n        }\n        return instance;\n    }", "comment": "/**\n     * laver en ProductContainer hvis der ikke er en og returnerer \n     * den nye eller den ekstisterende \n     */"}}
{"code": {"body": "    public Product findProduct(int barcode){\n        return productMap.get(barcode); \n    }", "comment": "/**\n     * finder et produkt ved hj\u00e6lp af barcode or returnerer den\n     * @param int barcode \n     * @return Product \n     */"}}
{"code": {"body": "    public Boolean isUnique(int barcode){\n        boolean type = false;\n        if(findProduct(barcode) instanceof UniqueProduct){\n            type = true;\n        }\n        return type;\n    }", "comment": "/**\n     * tjekker om varen er unik og returnerer en boolean \n     * @param int barcode\n     * @return boolean \n     */"}}
{"code": {"body": "    public Item saleItem(int bar, int serial){\n        return findProduct(bar).Sale(serial);\n    }", "comment": "/**\n     * fjerner et uniqueItem fra et produkt og returnerer det\n     * @param barcoden p\u00e5 et produkt og og et serienummer p\u00e5 et item  \n     * @return et item objekt\n     */"}}
{"code": {"body": "    public MassProduct saleProduct(int bar, int amount) throws NullPointerException {\n        MassProduct findProduct = findProduct(bar).Sale(amount);\n        if(findProduct == null){\n            throw new NullPointerException();\n        }\n        return findProduct;\n    }", "comment": "/**\n     * tr\u00e6kker amount fra et massProduct og returnerer massProduktet \n     * @param barcoden p\u00e5 et produkt og m\u00e6ngden af det \u00f8nskede produkt \n     * @return et massproduct objekt \n     */"}}
{"code": {"body": "    public double getPrice(int bar){\n        return findProduct(bar).getPrice();    \n\n    }", "comment": "/**\n     * henter prisen fra et item baseret p\u00e5 barcode \n     * @param et produkt barcode\n     * @return price fra et produkt \n     */"}}
{"code": {"body": "public SimpleLine(int amount, Product product){\n        super(amount);\n        this.product = product;\n        setPrice(product.getPrice()*getAmount());\n        setUnitPrice(product.getPrice());\n    }", "comment": "/**\n     * Constructor til objekter af class SimpleLine\n     */"}}
{"code": {"body": "    public static SupplierContainer getInstance(){\n        if(instance == null){\n            instance = new SupplierContainer(); \n        }\n        return instance;\n    }", "comment": "/**\n     * laver en SupplierContainer hvis der ikke er en og returnerer \n     * den nye eller den ekstisterende \n     */"}}
{"code": {"body": "    public void addSupplier(Supplier supplier){\n        supplierMap.put(supplier.getFirmName(), supplier);\n    }", "comment": "/**\n     * tilf\u00f8jer en supplier til suppliers hashmap\n     * @param Supplier supplier\n     */"}}
{"code": {"body": "public UniqueLine(Item item){\n        super(1);\n        this.item = item;\n        setPrice(item.getPrice());\n        setUnitPrice(item.getPrice());\n    }", "comment": "/**\n     * constructor til objekter af class UniqueLine\n     */"}}
{"code": {"body": "public UniqueProduct(int barcode, String name, String description, int price, int amount, int min,int max) {\n        super(barcode,name,description,price, amount, min, max);\n        itemMap = new HashMap<Integer,Item>();\n    }", "comment": "/**\n     * constructor til objekter af class UniqueProduct\n     */"}}
{"code": {"body": "    public String create(String name, String description, int price, boolean udlevering){\n        Item item = new Item (name, description, price, udlevering);\n        addItem(item);\n        return item.toString();\n    }", "comment": "/**\n     * Tager et item objekt og tilf\u00f8jer det til vores UniqueProduct hashmap\n     */"}}
{"code": {"body": "\tpublic void setTextOverImage(CharSequence textOverImage) {\n\t\tmTextOverImage = textOverImage;\n\t}", "comment": "/**\n\t * Sets the title over the image\n\t *\n\t * @param textOverImage\n\t */"}}
{"code": {"body": "\tpublic void setSubTitle(CharSequence subTitle) {\n\t\tmSubTitle = subTitle;\n\t}", "comment": "/**\n\t * Sets the subtitle\n\t * @param subTitle\n\t */"}}
{"code": {"body": "\tprotected MaterialLargeImageCardThumbnail initializeCardThumbnail(){\n\t\treturn new MaterialLargeImageCardThumbnail(mContext);\n\t}", "comment": "/**\n\t * Initialize the MaterialLargeImageCardThumbnail\n\t * @return\n\t */"}}
{"code": {"body": "\tpublic CharSequence getTextOverImage() {\n\t\treturn mTextOverImage;\n\t}", "comment": "/**\n\t * Returns\n\t * the title over the image\n\t * @return\n\t */"}}
{"code": {"body": "\tpublic void setTextOverImageResId(int textOverImageResId) {\n\t\tmTextOverImageResId = textOverImageResId;\n\t}", "comment": "/**\n\t * Sets the Resource Id to use for the title over the image\n\t * @param textOverImageResId\n\t */"}}
{"code": {"body": "\tpublic int getDrawableIdCardThumbnail() {\n\t\treturn mDrawableIdCardThumbnail;\n\t}", "comment": "/**\n\t * Returns the Resource Drawable ID\n\t *\n\t * @return\n\t */"}}
{"code": {"body": "\tpublic void setDrawableIdCardThumbnail(int drawableIdCardThumbnail) {\n\t\tmDrawableIdCardThumbnail = drawableIdCardThumbnail;\n\t}", "comment": "/**\n\t * Sets the Resource Drawable ID\n\t *\n\t * @param drawableIdCardThumbnail\n\t */"}}
{"code": {"body": "\tpublic String getUrlCardThumbnail() {\n\t\treturn mUrlCardThumbnail;\n\t}", "comment": "/**\n\t * Returns the Drawable URL\n\t * @return\n\t */"}}
{"code": {"body": "\tpublic void setUrlCardThumbnail(String urlCardThumbnail) {\n\t\tmUrlCardThumbnail = urlCardThumbnail;\n\t}", "comment": "/**\n\t * Sets the Drawable URL\n\t *\n\t * @param urlCardThumbnail\n\t */"}}
{"code": {"body": "\tpublic void setExternalCardThumbnail(DrawableExternal externalCardThumbnail) {\n\t\tmExternalCardThumbnail = externalCardThumbnail;\n\t}", "comment": "/**\n\t * Sets the interface to be called with the thumbnail\n\t * @param externalCardThumbnail\n\t */"}}
{"code": {"body": "\tpublic CharSequence getSubTitle() {\n\t\treturn mSubTitle;\n\t}", "comment": "/**\n\t * Returns the subtitle\n\t * @return\n\t */"}}
{"code": {"body": "\t\tpublic void onDataAvailable(String response);\n\n\t", "comment": "/* forming th java.net.URL object */"}}
{"code": {"body": "\t\tpublic void onError(String reponse, Exception e);\n\n\t", "comment": "/* forming th java.net.URL object */"}}
{"code": {"body": "\tpublic static HttpHandler getSharedInstance(){\n\t\tif(mInstance == null) {\n\t\t\tmInstance = new HttpHandler();\n\t\t}\n\t\treturn mInstance;\n\t}", "comment": "/* forming th java.net.URL object */"}}
{"code": {"body": "\tpublic void getBook(HttpDataListener dataListener, BaseParser parser) {\n\t\tfinal String url = Constants.BASE_URL_WITH_VERSION + \"\" + Constants.BOOK;\n\t\tnew AsyncHttpTask(dataListener, parser).execute(url, \"\");\n\n\t}", "comment": "/* forming th java.net.URL object */"}}
{"code": {"body": "\t\tprotected Integer doInBackground(String... params) {\n\t\t\tInputStream inputStream = null;\n\t\t\tHttpURLConnection urlConnection = null;\n\t\t\tInteger result = 0;\n\t\t\ttry {\n\n                \n\t\t\t\tURL url = new URL(params[0]);\n\t\t\t\tString httpMethod = params[1];\n\t\t\t\turlConnection = (HttpURLConnection) url.openConnection();\n\n                 \n\t\t\t\turlConnection.setRequestProperty(\"\", \"\");\n\t\t\t\turlConnection.setRequestProperty(\"\", \"\");\n\t\t\t\turlConnection.setRequestMethod(httpMethod);\n\n\t\t\t\tif(httpMethod.equals(\"\")){\n\t\t\t\t\tbyte[] outputInBytes = params[2].getBytes(\"\");\n\t\t\t\t\tOutputStream os = urlConnection.getOutputStream();\n\t\t\t\t\tos.write( outputInBytes );\n\t\t\t\t\tos.close();\n\t\t\t\t}\n\n\t\t\t\tLog.d(\"\", url.toString());\n\t\t\t\tint statusCode = urlConnection.getResponseCode();\n\n\t\t\t\tif (statusCode >= 200 && statusCode < 300) {\n\t\t\t\t\tinputStream = new BufferedInputStream(urlConnection.getInputStream());\n\t\t\t\t\tresponse = convertInputStreamToString(inputStream);\n\t\t\t\t\tLog.d(\"\", response);\n\n\t\t\t\t\tresult = 1;\n\n\t\t\t\t\t\n\t\t\t\t\tif(response.contains(\"\")) {\n\t\t\t\t\t\tresult = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tLog.e(TAG, \"\" + statusCode);\n\t\t\t\t}\n\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn result;\n\t\t}", "comment": "/* forming th java.net.URL object */"}}
{"code": {"body": "    public static PageEntity getCache(String url){\n        return cacheMap.get(url);\n    }", "comment": "/**\n     * \u53d6\u51fa\u7f13\u5b58\u4fe1\u606f\n     * @param url\n     * @return\n     */"}}
{"code": {"body": "    public static void addCache(String url, PageEntity entity){\n        cacheMap.put(url, entity);\n    }", "comment": "/**\n     * \u4fe1\u606f\u4fdd\u5b58\u5230\u7f13\u5b58\u4e2d\n     * @param entity\n     */"}}
{"code": {"body": "public AppTest( String testName )", "comment": "/**\n     * Create the test case\n     *\n     * @param testName name of the test case\n     */"}}
{"code": {"body": "    public static Test suite()\n    {\n        return new TestSuite( AppTest.class );\n    }", "comment": "/**\n     * @return the suite of tests being tested\n     */"}}
{"code": {"body": "    public void testApp()\n    {\n        assertTrue( true );\n    }", "comment": "/**\n     * Rigourous Test :-)\n     */"}}
{"code": {"body": "    public static PageEntity getWebContent(String loadUrl) {\n        PageEntity pEntity = null;\n        List<InfoDetailEntity> details = null;\n        StringBuffer sb = new StringBuffer(\"\");\n        try {\n            URL url = new URL(loadUrl);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setDoInput(true);\n            conn.setConnectTimeout(6000);\n            conn.connect();\n            String temp;\n            InputStream is = conn.getInputStream();\n            BufferedReader in = new BufferedReader(new InputStreamReader(\n                    is, \"\"));\n            while ((temp = in.readLine()) != null) {\n                sb.append(\"\");\n                sb.append(temp);\n            }\n            in.close();\n            is.close();\n        } catch (Exception ee) {\n\n        }\n        System.out.println(sb.toString());\n        pEntity = new PageEntity();\n        details = new ArrayList<InfoDetailEntity>();\n        Pattern patternB = Pattern.compile(prexAndNextSrcStr);\n        Matcher matcherB = patternB.matcher(sb);\n        String prexDayUrl = null;\n        String nextDayUrl = null;\n        while(matcherB.find()){\n            String str = matcherB.group();\n            String prexSrc = str.substring(str.indexOf(\"\"), str.lastIndexOf(\"\"));\n            prexDayUrl = getHref(prexSrc);\n            String nextSrc = str.substring(str.lastIndexOf(\"\"), str.lastIndexOf(\"\"));\n            nextDayUrl = getHref(nextSrc);\n        }\n        \n        pEntity.setPrevUrl(prexDayUrl);\n        pEntity.setNextUrl(nextDayUrl);\n        pEntity.setIndex(loadUrl);\n        \n        Pattern pattern = Pattern.compile(regTitleAndImageSrcStr);\n        Matcher matcher = pattern.matcher(sb);\n        InfoDetailEntity entity = null;\n        while(matcher.find()){\n            String str = matcher.group();\n            String strTitle = str.substring(str.indexOf(\"\") + 3, str.indexOf(\"\"));\n            String strImageSrc = str.substring(str.indexOf(\"\"), str.indexOf(\"\"));\n            entity = new InfoDetailEntity();\n            entity.setTitle(strTitle);\n            entity.setImgUrl(strImageSrc);\n            details.add(entity);\n        }\n        pEntity.setDatas(details);\n        return pEntity;\n    }", "comment": "/**\n     * \u83b7\u53d6\u9875\u9762\u5185\u5bb9\n     * @param loadUrl\n     * @return\n     */"}}
{"code": {"body": "    private static String getHref(String str){\n        if(str.contains(\"\")){\n            return str.substring(str.indexOf(\"\") + 6, str.lastIndexOf(\"\"));\n        }\n        return \"\";\n    }", "comment": "/**\n     * \u83b7\u53d6\u8d85\u94fe\u63a5\u4fe1\u606f\n     * @param str\n     * @return\n     */"}}
{"code": {"body": "public AppTest( String testName )", "comment": "/**\n     * Create the test case\n     *\n     * @param testName name of the test case\n     */"}}
{"code": {"body": "    public static Test suite()\n    {\n        return new TestSuite( AppTest.class );\n    }", "comment": "/**\n     * @return the suite of tests being tested\n     */"}}
{"code": {"body": "    public void testApp()\n    {\n        assertTrue( true );\n    }", "comment": "/**\n     * Rigourous Test :-)\n     */"}}
{"code": {"body": "    public static String getURLResponse(String urlString){\n        HttpURLConnection conn = null; \n        InputStream is = null;\n        String resultData = \"\";\n        try {\n            URL url = new URL(urlString); \n            conn = (HttpURLConnection)url.openConnection(); \n            conn.setDoInput(true); \n            conn.setDoOutput(true); \n            conn.setUseCaches(false); \n            conn.setRequestMethod(\"\"); \n            is = conn.getInputStream();   \n            InputStreamReader isr = new InputStreamReader(is);\n            BufferedReader bufferReader = new BufferedReader(isr);\n            String inputLine  = \"\";\n            while((inputLine = bufferReader.readLine()) != null){\n                resultData += inputLine + \"\";\n            }\n\n        } catch (MalformedURLException e) {\n            \n            e.printStackTrace();\n        }catch (IOException e) {\n            \n            e.printStackTrace();\n        }finally{\n            if(is != null){\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    \n                    e.printStackTrace();\n                }\n            }\n            if(conn != null){\n                conn.disconnect();\n            }\n        }\n\n        return resultData;\n    }", "comment": "/**\n     * \u83b7\u53d6\u6307\u5b9aURL\u7684\u54cd\u5e94\u5b57\u7b26\u4e32\n     * @param urlString\n     * @return\n     */"}}
{"code": {"body": "    public static String sendPostRequest(String urlString, String jsondata){\n\n        try {\n\n            URL url = new URL(urlString);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setConnectTimeout(5000);\n            conn.setRequestMethod(\"\");\n            conn.setDoInput(true); \n            conn.setDoOutput(true); \n            conn.setUseCaches(false); \n            conn.setRequestProperty(\"\", \"\");\n\n            byte data[] = jsondata.getBytes(\"\"); \n            conn.getOutputStream().write(data);\n\n            StringBuffer sBuffer = new StringBuffer();\n            if(conn.getResponseCode() == HttpURLConnection.HTTP_OK){\n                String line = null;\n                InputStream in = conn.getInputStream();\n                BufferedReader bReader = new BufferedReader(new InputStreamReader(in));\n                while((line = bReader.readLine()) != null) {\n                    sBuffer.append(line);\n                }\n                return sBuffer.toString();\n            }\n\n        } catch (Exception e) {\n\n            return e.toString();\n\n        }\n\n        return \"\";\n\n    }", "comment": "/* send the request by POST method\n     * @param a url path\n     * \t\t  for the ehelp project, must provide the url path\n     *        like \"http://120.24.208.130:1501/account/login...\"\n     *        a String with json format\n     * @return a string that the server respond with json format\n     * \t\t   a string \"false\"/null indicate some errors happened\n     */"}}
{"code": {"body": "    public static String uploadFile(String urlString, File file) {\n\n        String PREFIX = \"\";\n        String LINE_END = \"\";\n        String BOUNDARY = UUID.randomUUID().toString(); \n\n\n        try {\n\n            URL url = new URL(urlString);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setConnectTimeout(50000);\n            conn.setReadTimeout(50000);\n            conn.setRequestMethod(\"\");\n            conn.setDoInput(true); \n            conn.setDoOutput(true); \n            conn.setUseCaches(false); \n            conn.setRequestProperty(\"\", \"\");\n            conn.setRequestProperty(\"\", \"\"+\"\"\n                    + BOUNDARY);\n            conn.setRequestProperty(\"\", \"\");\n\n            if(file != null) {\n                OutputStream outputStream = conn.getOutputStream();\n                DataOutputStream doStream = new DataOutputStream(outputStream);\n\n                \n                StringBuffer sBuffer = new StringBuffer();\n                sBuffer.append(PREFIX);\n                sBuffer.append(BOUNDARY);\n                sBuffer.append(LINE_END);\n                sBuffer.append(\"\"\n                        + file.getName() + \"\" + LINE_END);\n                sBuffer.append(\"\" + LINE_END);\n                sBuffer.append(LINE_END);\n\n                doStream.write(sBuffer.toString().getBytes());\n\n                InputStream in = new FileInputStream(file);\n                byte[] bytes = new byte[2014];\n                int len = 0;\n                while((len = in.read(bytes)) != -1) {\n                    doStream.write(bytes, 0, len);\n                }\n                in.close();\n                doStream.write(LINE_END.getBytes());\n\n                doStream.write(\n                        (PREFIX + BOUNDARY + PREFIX + LINE_END).getBytes());\n                doStream.flush();\n\n                StringBuffer resBuffer = new StringBuffer();\n                if(conn.getResponseCode() == HttpURLConnection.HTTP_OK){\n                    String line = null;\n                    InputStream resin = conn.getInputStream();\n                    BufferedReader bReader = new BufferedReader(new InputStreamReader(resin));\n                    while((line = bReader.readLine()) != null) {\n                        resBuffer.append(line);\n                    }\n                    return resBuffer.toString();\n                }\n\n            }\n\n\n        } catch (MalformedURLException e) {\n\n            e.printStackTrace();\n\n        } catch (IOException e) {\n\n            e.printStackTrace();\n\n        }\n\n        return \"\";\n\n    }", "comment": "/* send a file(.jpg) to server by POST method\n\t * @params a url path\n\t * \t\t   a image file\n\t * @return a String \"true\" if upload successfully,0\n\t * \t\t   \"false\" otherwise\n\t */"}}
{"code": {"body": "    public static boolean TestGetURL(String urlString){\n\n        try {\n\n            URL url = new URL(urlString);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setConnectTimeout(500);\n            conn.setRequestMethod(\"\");\n            conn.setDoInput(true); \n            conn.setDoOutput(false); \n            conn.setUseCaches(false); \n            int a = conn.getResponseCode();\n\n            if(conn.getResponseCode() == HttpURLConnection.HTTP_OK){\n\n                return true;\n\n            }\n\n        } catch (Exception e) {\n\n            e.printStackTrace();\n            String sss = e.toString();\n            String a = sss;\n            Log.v(\"\", a);\n\n        }\n\n        return false;\n    }", "comment": "/*\n    * Test the validation of url\n    * @param urlString, the path of url\n    * @return True if connected successfully\n    *         False if fails\n    */"}}
{"code": {"body": "\tpublic int authorUpdate(AuthorVo authorVo) {\n\t\t\n\t\tConnection conn = null;\n\t\tPreparedStatement pstmt = null;\n\t\tint count = 0;\n\t\ttry {\n\t\t\t\n\t\t\tClass.forName(driver);\n\t\t\t\n\t\t\tString url = url1;\n\t\t\tconn = DriverManager.getConnection(url, id, pw);\n\t\t\t\n\t\t\t\n\t\t\tString query = \"\";\n\t\t\tquery += \"\";\n\t\t\tquery += \"\";\n\t\t\tquery += \"\";\n\t\t\tquery += \"\";\n\t\t\t\n\t\t\t\n\t\t\tpstmt = conn.prepareStatement(query); \n\t\t\tpstmt.setString(1, authorVo.authorName);\n\t\t\tpstmt.setString(2, authorVo.authorDesc);\n\t\t\tpstmt.setInt(3, authorVo.authorId);\n\t\t\t\n\t\t\tcount = pstmt.executeUpdate();\n\t\t\t\n\t\t\t\n\t\t\tSystem.out.println(\"\" + count + \"\");\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tSystem.out.println(\"\" + e);\n\t\t} catch (SQLException e) {\n\t\t\tSystem.out.println(\"\" + e);\n\t\t} finally {\n\n\t\t\t\n\t\t\ttry {\n\t\t\t\tif (pstmt != null) {\n\t\t\t\t\tpstmt.close();\n\t\t\t\t}\n\t\t\t\tif (conn != null) {\n\t\t\t\t\tconn.close();\n\t\t\t\t}\n\t\t\t} catch (SQLException e) {\n\t\t\t\tSystem.out.println(\"\" + e);\n\t\t\t}\n\n\t\t}\n\t\treturn count;\n\t}", "comment": "/*\n\t\t\t * UPDATE author set author_desc = '\uc11c\uc6b8\uc2dc \uc11c\ucd08\uad6c \ud558\uc774\ubbf8\ub514\uc5b4 \ubcc4\uad00' WHERE author_id = 21;\n\t\t\t */"}}
{"code": {"body": "\tpublic int bookInsert(BookVo bVo) {\n\n\t\t\n\t\tConnection conn = null;\n\t\tPreparedStatement pstmt = null;\n\t\t\n\n\t\tint count = 0;\n\n\t\ttry {\n\t\t\t\n\t\t\tClass.forName(driver);\n\n\t\t\t\n\t\t\tconn = DriverManager.getConnection(url, id, pw);\n\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tString query = \"\";\n\t\t\tpstmt = conn.prepareStatement(query);\n\t\t\tpstmt.setString(1, bVo.getTitle());\n\t\t\tpstmt.setString(2, bVo.getPubs());\n\t\t\tpstmt.setString(3, bVo.getPub_date());\n\t\t\tpstmt.setInt(4, bVo.getAuthor_id());\n\t\t\tSystem.out.println(query);\n\t\t\tcount = pstmt.executeUpdate(); \n\n\t\t\t\n\n\t\t\t\n\t\t\tSystem.out.println(\"\" + count + \"\");\n\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tSystem.out.println(\"\" + e);\n\t\t} catch (SQLException e) {\n\t\t\tSystem.out.println(\"\" + e);\n\t\t} finally {\n\n\t\t\t\n\t\t\ttry {\n\t\t\t\t\n\t\t\t\tif (pstmt != null) {\n\t\t\t\t\tpstmt.close();\n\t\t\t\t}\n\t\t\t\tif (conn != null) {\n\t\t\t\t\tconn.close();\n\t\t\t\t}\n\t\t\t} catch (SQLException e) {\n\t\t\t\tSystem.out.println(\"\" + e);\n\t\t\t}\n\n\t\t}\n\n\t\treturn count;\n\n\t}", "comment": "/*\n\t\t\t\t * if (rs != null) { rs.close(); }\n\t\t\t\t */"}}
{"code": {"body": "    public static String byte2bits(byte b){\n\n        StringBuffer sb = new StringBuffer();\n        int offset = 1<<7;\n        int i= 7;\n        while(i>=0) {\n            sb.append((offset & b)>>i);\n            offset>>=1;\n            i--;\n        }\n        return  sb.toString();\n    }", "comment": "/**\n     * \u5b57\u8282\u8f6c\u6362\u4e3abit\n     * @param b\n     * @return\n     */"}}
{"code": {"body": "    public static String int2hex(int value){\n\n        return Integer.toHexString(value);\n\n    }", "comment": "/**\n     * \u5341\u8fdb\u5236\u8f6c\u6362\u4e3a16\u8fdb\u5236\u5b57\u7b26\u4e32\n     * @param value\n     * @return\n     */"}}
{"code": {"body": "    public static int hex2int(String hexValue){\n\n        return Integer.valueOf(hexValue,16);\n    }", "comment": "/**\n     * \u5341\u516d\u8fdb\u5236\u8f6c\u6362\u4e3aInteger\n     * @param hexValue\n     * @return\n     */"}}
{"code": {"body": "public NetInput(BlockingQueue<ByteBuffer> queue, Selector channelSelector) {\n\n        mOutputQueue = queue;\n        mChannelSelector = channelSelector;\n\n    }", "comment": "/**\n     * \u76d1\u542c\u6765\u81ea\u7f51\u7edc\u7684\u6570\u636e,\u5e76\u5c06\u76f8\u5173\u6570\u636e\u89e3\u6790\u4e22\u56de\u7ed9\u865a\u62df\u7f51\u5361\u53bb\u5904\u7406\n     * @param queue\n     * @param channelSelector\n     */"}}
{"code": {"body": "    public void quit() {\n        mQuit = true;\n        interrupt();\n\n    }", "comment": "/**\n     * \u6807\u5fd7\u4f4d\u9000\u51fa,\u5373\u4f7f\u8c03\u7528interrupt\u4e0d\u4e00\u5b9a\u4f1a\u9000\u51fa,\u53cc\u91cd\u4fdd\u8bc1\n     */"}}
{"code": {"body": "    private void transData(TCB tcb, SelectionKey key, boolean isUdp) {\n\n\n\n\n\n\n\n        ByteBuffer responseBuffer = ByteBufferPool.acquire();\n\n\n        int readBytes = 0;\n        \n        try {\n            if (!isUdp) {\n                responseBuffer.position(Packet.IP4_HEADER_SIZE + Packet.TCP_HEADER_SIZE);\n                SocketChannel channel = (SocketChannel) key.channel();\n                readBytes = channel.read(responseBuffer);\n            } else if (key.channel() instanceof DatagramChannel) {\n                responseBuffer.position(Packet.IP4_HEADER_SIZE + Packet.UDP_HEADER_SIZE);\n                DatagramChannel channel = (DatagramChannel) key.channel();\n                readBytes = channel.read(responseBuffer);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n\n            ByteBufferPool.release(responseBuffer);\n\n        }\n\n\n\n\n\n        synchronized (tcb) {\n            Packet responsePacket = tcb.referencePacket;\n            Log.d(TAG, \"\" + readBytes);\n            if (readBytes == -1) {\n                \n                key.interestOps(0);\n                tcb.tcbStatus = TCB.TCB_STATUS_LAST_ACK;\n\n                if (!isUdp) {\n                    responsePacket.updateTCPBuffer(responseBuffer, (byte) (Packet.TCPHeader.FIN | Packet.TCPHeader.ACK), tcb.mySequenceNum, tcb.myAcknowledgementNum, 0);\n                }\n\n                tcb.mySequenceNum++;\n\n                mOutputQueue.offer(responseBuffer);\n                Log.d(TAG, \"\");\n                return;\n            }\n            tcb.calculateTransBytes(readBytes);\n            Log.d(TAG, \"\" + responseBuffer.limit() + \"\" + responseBuffer.position());\n            Log.d(TAG, \"\" + tcb.mySequenceNum);\n            Log.d(TAG, \"\" + responseBuffer.limit() + \"\" + responseBuffer.position());\n            if (!isUdp) {\n                responsePacket.updateTCPBuffer(responseBuffer, (byte) (Packet.TCPHeader.ACK | Packet.TCPHeader.PSH), tcb.mySequenceNum, tcb.myAcknowledgementNum, readBytes);\n                tcb.mySequenceNum = tcb.mySequenceNum + readBytes;\n                \n                \n                responseBuffer.position(Packet.IP4_HEADER_SIZE + Packet.TCP_HEADER_SIZE + readBytes);\n            } else {\n                responsePacket.updateUDPBuffer(responseBuffer, readBytes);\n                responseBuffer.position(Packet.IP4_HEADER_SIZE + Packet.UDP_HEADER_SIZE + readBytes);\n            }\n        }\n\n        mOutputQueue.offer(responseBuffer);\n    }", "comment": "/**\n     * \u4f20\u8f93\u6570\u636e\u54af,\u5199\u56de\u5b9e\u9645\u8fd4\u56de\u6570\u636e\u5230\u865a\u62df\u7f51\u5361\n     *\n     * @param tcb\n     * @param key\n     */"}}
{"code": {"body": "    private void buildConnection(TCB tcb, SelectionKey key) {\n\n\n        try {\n            if (key.channel() instanceof SocketChannel) {\n                if (!((SocketChannel) key.channel()).finishConnect()) {\n                    Log.d(TAG, \"\");\n                    return;\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        \n        try {\n            key.interestOps(SelectionKey.OP_READ);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return;\n        }\n\n        Packet responsePacket = tcb.referencePacket;\n\n        ByteBuffer responseBuffer = ByteBufferPool.acquire();\n        if (key.channel() instanceof SocketChannel) {\n            responsePacket.updateTCPBuffer(responseBuffer, (byte) (Packet.TCPHeader.SYN | Packet.TCPHeader.ACK), tcb.mySequenceNum, tcb.myAcknowledgementNum, 0);\n        } \n        \n\n        tcb.tcbStatus = TCB.TCB_STATUS_SYN_RECEIVED;\n        tcb.mySequenceNum++;\n\n\n\n        mOutputQueue.offer(responseBuffer);\n\n    }", "comment": "/**\n     * \u975e\u963b\u585e\u72b6\u6001\u65f6,\u5b9e\u9645\u7684channel\u5efa\u7acb\u4e0d\u662f\u7acb\u9a6c\u5b8c\u6210\u7684\n     * \u865a\u62df\u7f51\u5361\u7684\u63e1\u624b\u5fc5\u987b\u7b49\u5b9e\u9645channel\u5efa\u7acb\u5b8c\u6210\n     *\n     * @param tcb\n     * @param key\n     */"}}
{"code": {"body": "public NetOutput(BlockingQueue<Packet> inputQueue, BlockingQueue<ByteBuffer> outputQueue, VpnService vpnService, Selector selector, BlockingQueue<App> appCacheQueue) {\n        mOutputQueue = outputQueue;\n        mInputQueue = inputQueue;\n\n        mVpnService = vpnService;\n        mChannelSelector = selector;\n\n        mUdpSockCache = new HashMap<>();\n    }", "comment": "/**\n     * \u53d1\u8d77\u5b9e\u9645\u7684\u7f51\u7edc\u8bf7\u6c42\u6570\u636e,tcp\u901a\u8fc7socketServer\u5b9e\u73b0,udp\u5f85\u5b8c\u6210\n     * \u9700\u8981\u5904\u7406\u83b7\u53d6\u7684\u865a\u62df\u7f51\u5361\u6570\u636e\n     * @param inputQueue\n     * @param outputQueue\n     * @param vpnService\n     * @param selector\n     * @param appCacheQueue\n     */"}}
{"code": {"body": "    private void dealDuplicatedSYN(TCB tcb, String ipAndPort, Packet currentPacket, ByteBuffer responseBuffer) {\n\n        synchronized (tcb) {\n            if (tcb.tcbStatus == TCB.TCB_STATUS_SYN_SENT) {\n\n                \n                tcb.myAcknowledgementNum = currentPacket.tcpHeader.sequenceNumber + 1;\n                return;\n            }\n        }\n\n        sendRST(tcb, ipAndPort, 1, responseBuffer);\n\n    }", "comment": "/**\n     * \u5904\u7406\u5197\u4f59\u7684SYN\n     *\n     * @param tcb\n     * @param ipAndPort\n     * @param currentPacket\n     * @param responseBuffer\n     */"}}
{"code": {"body": "    private void finishConnect(TCB tcb, String ipAndPort, Packet currentPacket, ByteBuffer responseBuffer) {\n\n        synchronized (tcb) {\n\n            \n            tcb.myAcknowledgementNum = currentPacket.tcpHeader.sequenceNumber + 1;\n\n            tcb.tcbStatus = TCB.TCB_STATUS_LAST_ACK;\n            currentPacket.updateTCPBuffer(responseBuffer, (byte) (Packet.TCPHeader.FIN | Packet.TCPHeader.ACK),\n                    tcb.mySequenceNum, tcb.myAcknowledgementNum, 0);\n            tcb.mySequenceNum++;\n            \n\n\n\n\n        }\n        TCBCachePool.closeTCB(ipAndPort);\n\n\n        mOutputQueue.offer(responseBuffer);\n\n    }", "comment": "/**\n     * \u5173\u95ed\u8fde\u63a5\u54af\n     *\n     * @param ipAndPort\n     * @param currentPacket\n     * @param responseBuffer\n     */"}}
{"code": {"body": "    private void transData(String ipAndPort, TCB tcb, Packet currentPacket, ByteBuffer dataBuffer, ByteBuffer responseBuffer) {\n\n        \n\n        int payloadSize = dataBuffer.limit() - dataBuffer.position();\n\n        \n        synchronized (tcb) {\n\n\n            if (tcb.tcbStatus == TCB.TCB_STATUS_LAST_ACK) {\n                \n                Log.d(TAG, \"\");\n                TCBCachePool.closeTCB(ipAndPort);\n                return;\n            }\n\n\n            \n            if (payloadSize == 0) {\n\n                Log.d(TAG, \"\");\n                return;\n            }\n\n\n            Log.d(TAG, \"\" + payloadSize);\n\n            \n\n            SelectionKey outKey = tcb.selectionKey;\n            if (outKey == null) {\n                Log.d(TAG, \"\");\n                return;\n            }\n\n            \n            if (tcb.tcbStatus == TCB.TCB_STATUS_SYN_RECEIVED) {\n                tcb.tcbStatus = TCB.TCB_STATUS_ESTABLISHED;\n\n            } else if (tcb.tcbStatus == TCB.TCB_STATUS_ESTABLISHED) {\n\n                Log.d(TAG, \"\");\n\n\n            } else {\n\n                Log.d(TAG, \"\" + tcb.tcbStatus);\n                Log.d(TAG, \"\");\n                return;\n            }\n            if (outKey.channel() instanceof SocketChannel) {\n                SocketChannel outChannel = (SocketChannel) outKey.channel();\n\n                if (outChannel.isConnected() && outChannel.isOpen()) {\n                    Log.d(TAG, \"\");\n                    try {\n                        while (dataBuffer.hasRemaining()) {\n\n                            outChannel.write(dataBuffer);\n                        }\n\n                        \n                        tcb.calculateTransBytes(payloadSize);\n\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                        Log.d(TAG, \"\");\n                        \n                        sendRST(tcb, ipAndPort, payloadSize, responseBuffer);\n\n                    }\n\n                } else {\n                    Log.d(TAG, \"\");\n                }\n            } else if (outKey.channel() instanceof DatagramChannel) {\n                DatagramChannel outChannel = (DatagramChannel) outKey.channel();\n                if (outChannel.isConnected()) {\n                    Log.d(TAG, \"\");\n                    try {\n                        while (dataBuffer.hasRemaining()) {\n\n                            outChannel.write(dataBuffer);\n                        }\n\n                        \n                        tcb.calculateTransBytes(payloadSize);\n\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                        Log.d(TAG, \"\");\n                        \n\n\n                    }\n                }\n            }\n\n\n            currentPacket.swapSourceAndDestination();\n            if (currentPacket.isTCP()) {\n                tcb.myAcknowledgementNum = currentPacket.tcpHeader.sequenceNumber + payloadSize;\n                currentPacket.updateTCPBuffer(responseBuffer, (byte) Packet.TCPHeader.ACK, tcb.mySequenceNum, tcb.myAcknowledgementNum, 0);\n            } else if (currentPacket.isUDP()) {\n                currentPacket.updateUDPBuffer(responseBuffer, 0);\n            }\n\n            Log.d(TAG, \"\" + responseBuffer.limit() + \"\" + responseBuffer.position());\n\n        }\n\n\n        \n        mOutputQueue.offer(responseBuffer);\n\n\n    }", "comment": "/**\n     * \u4f20\u9012\u5b9e\u9645\u7684\u6570\u636e\n     *\n     * @param tcb\n     */"}}
{"code": {"body": "    private void initTCB(String ipAndPort, Packet referencePacket, InetAddress desAddress, int desPort, ByteBuffer responseBuffer) {\n\n\n        Log.d(TAG, \"\");\n\n        \n\n        long passAppId = filterPacket(referencePacket);\n        if (passAppId == -1) {\n            \n\n            return;\n        }\n\n\n\n        ByteBuffer sourceBuffer = ByteBufferPool.acquire();\n        if (referencePacket.isTCP()) {\n            referencePacket.updateTCPBuffer(sourceBuffer, (byte) Packet.TCPHeader.SYN, referencePacket.tcpHeader.sequenceNumber,\n                    referencePacket.tcpHeader.acknowledgementNumber, 0);\n        } else if (referencePacket.isUDP()) {\n            referencePacket.updateUDPBuffer(sourceBuffer, 0);\n        }\n\n        ByteBufferPool.release(sourceBuffer);\n\n\n        referencePacket.swapSourceAndDestination();\n        TCB tcb = null;\n        if (referencePacket.isTCP()) {\n            tcb = new TCB(ipAndPort, new Random().nextInt(Short.MAX_VALUE), referencePacket.tcpHeader.sequenceNumber,\n                    referencePacket.tcpHeader.sequenceNumber + 1, referencePacket.tcpHeader.acknowledgementNumber, referencePacket);\n        } else if (referencePacket.isUDP()) {\n            tcb = new TCB(ipAndPort, new Random().nextInt(Short.MAX_VALUE), 0,\n                    1, 0, referencePacket);\n        }\n        \n        tcb.setAppId(passAppId);\n\n\n        \n        TCBCachePool.putTCB(ipAndPort, tcb);\n\n\n        try {\n            if (referencePacket.isUDP()) {\n                DatagramChannel socketChannel = DatagramChannel.open();\n                socketChannel.configureBlocking(false);\n                mVpnService.protect(socketChannel.socket());\n                socketChannel.connect(new InetSocketAddress(desAddress, desPort));\n                tcb.tcbStatus = TCB.TCB_STATUS_SYN_RECEIVED;\n                mChannelSelector.wakeup();\n                tcb.selectionKey = socketChannel.register(mChannelSelector, SelectionKey.OP_READ, \"\");\n\n            } else {\n                SocketChannel socketChannel = SocketChannel.open();\n\n                socketChannel.configureBlocking(false);\n                \n                mVpnService.protect(socketChannel.socket());\n                socketChannel.connect(new InetSocketAddress(desAddress, desPort));\n\n\n                \n                if (socketChannel.finishConnect()) {\n                    \n\n\n                    \n                    Log.d(TAG, \"\");\n                    tcb.tcbStatus = TCB.TCB_STATUS_SYN_RECEIVED;\n                    if (referencePacket.isTCP()) {\n                        referencePacket.updateTCPBuffer(responseBuffer, (byte) (Packet.TCPHeader.SYN | Packet.TCPHeader.ACK), tcb.mySequenceNum, tcb.myAcknowledgementNum, 0);\n                        tcb.mySequenceNum++;\n                    }\n\n                    \n                    mChannelSelector.wakeup();\n                    tcb.selectionKey = socketChannel.register(mChannelSelector, SelectionKey.OP_READ, ipAndPort);\n\n\n                } else {\n                    \n\n                    tcb.tcbStatus = TCB.TCB_STATUS_SYN_SENT;\n                    mChannelSelector.wakeup();\n                    SelectionKey key = socketChannel.register(mChannelSelector, SelectionKey.OP_CONNECT, ipAndPort);\n\n                    tcb.selectionKey = key;\n\n                    Log.d(TAG, \"\");\n\n\n                    ByteBufferPool.release(responseBuffer);\n                    return;\n                    \n\n                }\n            }\n\n\n        } catch (IOException e) {\n            e.printStackTrace();\n            ByteBufferPool.release(responseBuffer);\n        }\n\n        \n        mOutputQueue.offer(responseBuffer);\n\n    }", "comment": "/**\n     * \u521d\u59cb\u5316TCB\u4ee5\u53ca\u76f8\u5173\u8fde\u63a5\n     */"}}
{"code": {"body": "    private long filterPacket(Packet transPacket) {\n\n\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        int port = 0;\n        if (transPacket.isTCP()) {\n            port = transPacket.tcpHeader.sourcePort;\n        } else if (transPacket.isUDP()) {\n            port = transPacket.udpHeader.sourcePort;\n        }\n        int uid = NetUtils.readProcFile(port);\n        Log.d(TAG, \"\" + uid);\n\n        if (uid < 10000) {\n\n            Log.e(TAG, \"\");\n\n            return -1;\n        }\n        \n\n\n        \n\n        \n\n\n       \n\n\n        return uid;\n    }", "comment": "/**\n     * \u8fc7\u6ee4\u76f8\u5173\u7684\u5305,\u8fd4\u56de\u7684\u4e3aappId,\u5982\u679c\u4e3a-1,\u5219\u8bf4\u660e\u7981\u6b62\u8bbf\u95ee\n     * ip,domain name\n     * uid\n     */"}}
{"code": {"body": "    private boolean matchBlockIp(String[] ip, String[] beginIp, String[] endIp) {\n\n        int diffIndex = findDiffIndex(beginIp, endIp);\n\n        for (int i = 0; i < diffIndex; i++) {\n\n            if (!ip[i].equals(beginIp[i])) {\n                return false;\n            }\n\n        }\n\n        if (Integer.parseInt(ip[diffIndex]) > Integer.parseInt(beginIp[diffIndex])\n                && Integer.parseInt(ip[diffIndex]) < Integer.parseInt(endIp[diffIndex])) {\n            return true;\n        }\n        return false;\n    }", "comment": "/**\n     * \u770b\u662f\u5426\u5339\u914d,\u5339\u914d\u8fd4\u56detrue\n     *\n     * @param ip\n     * @param beginIp\n     * @param endIp\n     * @return\n     */"}}
{"code": {"body": "    public static int readProcFile(int packetPort) {\n        if (sUid > 0 && sUid != 1000) {\n            return sUid;\n        }\n\n\n        File readFile =  new File(\"\");\n        if(!readFile.exists()){\n            Log.d(\"\",\"\");\n            return -1;\n        }\n\n\n        int uid = -1;\n\n        try {\n            FileInputStream inputStream = new FileInputStream(readFile);\n\n            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n\n            \n            String line = bufferedReader.readLine();\n\n\n            while((line=bufferedReader.readLine())!=null){\n\n                uid= dealLine(line,packetPort);\n                if(uid!=-1){\n                    Log.d(\"\",\"\");\n                    break;\n                }\n            }\n\n            inputStream.close();\n\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            return uid;\n        }\n\n\n    }", "comment": "/**\n     * \u8bfb/proc/net/tcp6\u7684\u6570\u636e\u54af\n     * \u6839\u636e\u6307\u5b9a\u7684port,\u6620\u5c04\u627e\u5230\u5bf9\u5e94\u7684uid\n     */"}}
{"code": {"body": "    private static int  dealLine(String line,int reqPort){\n\n\n\n        String[] strs = line.split(\"\");\n\n        int localAddrIndex = 0 ;\n        int i ;\n        for(i=0;i<strs.length;i++){\n\n            if(!strs[i].equals(\"\")){\n                localAddrIndex = i+1;\n                break;\n            }\n        }\n\n        \n        String[] localAddr = strs[localAddrIndex].substring(24).split(\"\");\n\n        String ip = EncodeUtils.hex2int(localAddr[0].substring(6))+\"\"\n                +EncodeUtils.hex2int(localAddr[0].substring(4,6))+\"\"\n                +EncodeUtils.hex2int(localAddr[0].substring(2,4))+\"\"\n                +EncodeUtils.hex2int(localAddr[0].substring(0,2));\n\n        if(!ip.equals(VpnServiceDemo.VPN_ADDRESS)){\n            Log.d(\"\",\"\");\n            return -1;\n        }\n\n\n        int port = EncodeUtils.hex2int(localAddr[1]);\n\n        if(port!=reqPort){\n            Log.d(\"\",\"\");\n            return -1;\n        }\n\n        int uidIndex = localAddrIndex+6;\n\n        \n        if(strs[uidIndex].equals(\"\")) {\n\n            \n            for (i = uidIndex; i < strs.length; i++) {\n\n                if (!strs[i].equals(\"\")) {\n                    uidIndex = i;\n                    break;\n                }\n            }\n        }\n\n\n        System.out.println(\"\"+ip+ \"\"+port+\"\"+strs[uidIndex]);\n        sUid = Integer.parseInt(strs[uidIndex]);\n\n        return sUid;\n    }", "comment": "/**\n     * \u5904\u7406\u67d0\u4e00\u884c\u7684\u6570\u636e\n     * @param line\n     */"}}
{"code": {"body": "    public int getPayloadSize(){\n        if(backingBuffer!=null){\n\n          return  backingBuffer.limit() - backingBuffer.position();\n        }\n        return 0;\n    }", "comment": "/**\n     * \u83b7\u53d6payloadSize\u7684\u5927\u5c0f\n     * @return\n     */"}}
{"code": {"body": "    public void calculateTransBytes(int payloadSize){\n\n        \n    }", "comment": "/**\n     * \u8fd9\u91cc\u4e3b\u8981\u662f\u8bb0\u5f55\u5e94\u7528\u5c42\u4f20\u8f93\u7684\u6570\u636e\n     * \u5ffd\u7565\u63e1\u624b\u548cFin\u7684\u5f71\u54cd\n     * @param payloadSize\n     */"}}
{"code": {"body": "    public static void putTCB(String ipAndPort,TCB tcb){\n\n        if(TextUtils.isEmpty(ipAndPort)||tcb ==null){\n            Log.e(TAG,\"\");\n            return;\n        }\n        mPool.put(ipAndPort,tcb);\n\n\n\n    }", "comment": "/**\n     * \u5b58\u50a8TCB\n     * @param ipAndPort\n     * @param tcb\n     */"}}
{"code": {"body": "    public static TCB getTCB(String ipAndPort){\n        TCB tcb = mPool.get(ipAndPort);\n\n        return tcb;\n    }", "comment": "/**\n     * \u83b7\u53d6TCB\u54af\n     * @param ipAndPort\n     * @return\n     */"}}
{"code": {"body": "    public static void closeTCB(String ipAndPort){\n\n\n\n\n        saveTrafficInfo(mPool.get(ipAndPort));\n\n        mPool.remove(ipAndPort);\n\n\n\n\n\n\n\n\n\n    }", "comment": "/**\n     * \u5173\u95edTCB,\u79fb\u9664it\n     * @param ipAndPort\n     */"}}
{"code": {"body": "    public static void closeAll() {\n\n        Iterator iter = mPool.entrySet().iterator();\n        while (iter.hasNext()) {\n            Map.Entry entry = (Map.Entry) iter.next();\n            TCB val = (TCB) entry.getValue();\n            saveTrafficInfo(val);\n            try {\n                val.selectionKey.channel().close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        Log.d(\"\",\"\");\n\n        mPool.clear();\n    }", "comment": "/**\n     * \u79fb\u9664\u6240\u6709,\u5305\u62ec\u76f8\u5173\u7684channel\n     */"}}
{"code": {"body": "    public void close() {\n\n\n        isRunning = false;\n        mNetInput.quit();\n        mNetOutput.quit();\n\n\n\n        try {\n            mChannelSelector.close();\n            mInterface.close();\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }", "comment": "/**\n     * \u5173\u95ed\u76f8\u5173\u8d44\u6e90\n     */"}}
{"code": {"body": "    protected void uploadSpecimens() {\n\t\t\n\t\t\n\t}", "comment": "/**\n     * Not yet implemented.\n     */"}}
{"code": {"body": "    private void findSpecimen() {\n    \t\n    \tIntent plantSearchIntent = new Intent(this, PlantSearchActivity.class);\n    \t\n    \tstartActivityForResult(plantSearchIntent, 1);\n    }", "comment": "/**\n     * Find plants from which we can create specimens.\n     * This will redirect us to the Plant Search screen.\n     */"}}
{"code": {"body": "    private void save() {\n    \tString strLat = txtLatitudeValue.getText().toString();\n    \tString strLng = txtLongitudeValue.getText().toString();\n    \tString strDescription = edtDescription.getText().toString();\n    \t\n    \t\n    \tSpecimen thisSpecimen = new Specimen();\n    \tthisSpecimen.setLatitude(Double.parseDouble(strLat));\n    \tthisSpecimen.setLongitude(Double.parseDouble(strLng));\n    \tthisSpecimen.setDescription(strDescription);\n    \tthisSpecimen.setPlantId(1);\n    \t\n    \t\n    \ttry {\n\t\t\tplantService.saveSpecimen(thisSpecimen);\n\t\t\t\n\t    \t\n\t    \tToast.makeText(this, \"\" + strDescription, Toast.LENGTH_LONG).show();\n\n\t\t} catch (Exception e) {\n\t\t\t\n\t\t\te.printStackTrace();\n\t    \t\n\t    \tToast.makeText(this, \"\" + strDescription + \"\" + e.getMessage(), Toast.LENGTH_LONG).show();\n\t    \tLog.e(this.getClass().getName(), e.getMessage(), e);\n\n\t\t}\n    \t\n    \t\n    }", "comment": "/**\n     * Save the specimen to the persistence layer.\n     */"}}
{"code": {"body": "    protected void removeUpdates() {\n    \tlocationManager.removeUpdates(locationListener);\n    \t\n    }", "comment": "/**\n     * Stop listening for locations.\n     */"}}
{"code": {"body": "    protected void requestUpdates() {\n    \t\n    \tif (locationListener != null && locationManager != null) {\n    \t\tlocationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, gpsInterval  * 1000, 0, locationListener);\n    \t}\n    }", "comment": "/**\n     * Start listening for locations.\n     */"}}
{"code": {"body": "public Settings() {\n        SIZE = 6;\n        blindFoldGame = false;\n        \n        SHIPS.add(new Destroyer());\n        SHIPS.add(new BattleShip());\n        SHIPS.add(new BattleShip());\n    }", "comment": "/**\n     * Default settings.\n     */"}}
{"code": {"body": "    public int getSize() {\n        return this.size;\n    }", "comment": "/**\n     * Returns the size of the ship. The size is the number of cells occupied.\n     * \n     * @return the size of the ship\n     */"}}
{"code": {"body": "    public int getUntargeted() {\n        return this.untargeted;\n    }", "comment": "/**\n     * Returns the number of intact \"cells\".\n     * \n     * @return the number of intact \"cells\" \n     */"}}
{"code": {"body": "    public void hit() {\n        this.untargeted--;\n    }", "comment": "/**\n     * Hits one cell of the ship\n     */"}}
{"code": {"body": "    public boolean isFloating() {\n        return this.untargeted > 0;\n    }", "comment": "/**\n     * Checks whether a ship is floating.\n     * \n     * @return true if the ship is still floating\n     */"}}
{"code": {"body": "\tpublic void savePins(int numOfPin) {\n\t\tpins.add(numOfPin);\n\t}", "comment": "/*\n\t * savePins : \uc4f0\ub7ec\ud2b8\ub9b0 \ud540\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n\t */"}}
{"code": {"body": "\tpublic void checkS(){\n\t\tif (pins.size()==1){\n\t\t\tisStrike = checkStrike();\n\t\t\treturn;\n\t\t}\n\t\tisSpare=checkSpare();\n\t}", "comment": "/*\n\t * checkS : \uc2a4\ud2b8\ub77c\uc774\ud06c, \uc2a4\ud398\uc5b4 \uc5ec\ubd80\ub97c \ud655\uc778\ud55c\ub2e4.\n\t */"}}
{"code": {"body": "\tpublic boolean checkStrike(){\n\t\tif(pins.get(0)==10) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}", "comment": "/*\n\t * checkStrike : \uc2a4\ud2b8\ub77c\uc774\ud06c \uc5ec\ubd80\ub97c \ud655\uc778 \ud6c4, \uadf8 \uacb0\uacfc\ub97c \ubc18\ud658\ud55c\ub2e4.\n\t */"}}
{"code": {"body": "\tpublic boolean checkSpare(){\n\t\tif(pins.size()==1)\n\t\t\treturn false;\n\t\tif(pins.get(0)+pins.get(1)==10)\n\t\t\treturn true;\n\t\treturn false;\n\t}", "comment": "/*\n\t * checkSpare : \uc2a4\ud2b8\ub77c\uc774\ud06c \uc5ec\ubd80\ub97c \ud655\uc778 \ud6c4, \uadf8 \uacb0\uacfc\ub97c \ubc18\ud658\ud55c\ub2e4.\n\t */"}}
{"code": {"body": "\tpublic int getFirstPoint() {\n\t\treturn pins.get(0);\n\t}", "comment": "/*\n\t * getFirstPoint : \uccab\ubc88\uc9f8\ub85c \uc4f0\ub7ec\ud2b8\ub9b0 \ud540\uc758 \uac1c\uc218\ub97c \ubc18\ud658\ud55c\ub2e4.\n\t */"}}
{"code": {"body": "\tpublic int getSecondPoint() {\n\t\treturn pins.get(1);\n\t}", "comment": "/*\n\t * getFirstPoint : \ub450\ubc88\uc9f8\ub85c \uc4f0\ub7ec\ud2b8\ub9b0 \ud540\uc758 \uac1c\uc218\ub97c \ubc18\ud658\ud55c\ub2e4.\n\t */"}}
{"code": {"body": "\tpublic int getFrameTotal() {\n\t\tint total=0;\n\t\tfor(int i=0; i<pins.size(); i++){\n\t\t\ttotal += pins.get(i);\n\t\t}\n\t\treturn total;\n\t}", "comment": "/*\n\t * getFrameTotal : \ud604\uc7ac \ud504\ub808\uc784\uc5d0\uc11c \uc4f0\ub7ec\ud2b8\ub9b0 \ud540\uc758 \ucd1d \uac1c\uc218\ub97c \ubc18\ud658\ud55c\ub2e4.\n\t */"}}
{"code": {"body": "\tpublic String getFrameScore(){\n\t\tString score=\"\";\n\t\t\n\t\tcheckS();\n\t\t\n\t\tif (isStrike)\n\t\t\treturn \"\";\n\t\tif (isSpare)\n\t\t\treturn pins.get(0) + \"\" ;\n\t\t\n\t\tfor(int i=0; i<pins.size(); i++){\n\t\t\tif(pins.get(i)==0)\n\t\t\t\tscore += \"\";\n\t\t\telse{\n\t\t\t\tscore += pins.get(i);\n\t\t\t\tscore += \"\";\n\t\t\t}\n\t\t}\n\t\treturn score;\n\t}", "comment": "/*\n\t * getFrameScore : scoreBoard\uc5d0\uc11c \ud504\ub9b0\ud2b8\ud560 \uac01 \ud504\ub808\uc784\uc758 \uc810\uc218\ud310\uc744 \ubc18\ud658\ud55c\ub2e4.\n\t */"}}
{"code": {"body": "\tpublic String getFrameScore(){\n\t\tString score=\"\";\n\t\tString thirdPoint;\n\t\tcheckS();\n\t\t\n\t\t\n\t\tif(pins.size()!=3)\n\t\t\treturn super.getFrameScore();\n\t\t\n\t\t\n\t\tif(pins.get(2)==10)\n\t\t\tthirdPoint=\"\";\n\t\telse if(pins.get(2)==0)\n\t\t\tthirdPoint=\"\";\n\t\telse\n\t\t\tthirdPoint=pins.get(2)+\"\";\n\n\t\tif (isStrike)\n\t\t\treturn (super.getFrameScore() + thirdPoint + \"\");\n\t\t\n\t\tif (isSpare)\n\t\t\treturn (super.getFrameScore() + thirdPoint + \"\");\n\t\t\n\t\tfor(int i=0; i<pins.size()-1; i++){\n\t\t\tif(pins.get(i)==0)\n\t\t\t\tscore += \"\";\n\t\t\telse{\n\t\t\t\tscore += pins.get(i);\n\t\t\t\tscore += \"\";\n\t\t\t}\n\t\t}\n\t\treturn score+\"\";\n\t}", "comment": "/* override\n\t * getFrameScore : scoreBoard\uc5d0\uc11c \ud504\ub9b0\ud2b8\ud560 \uac01 \ud504\ub808\uc784\uc758 \uc810\uc218\ud310\uc744 \ubc18\ud658\ud55c\ub2e4.\n\t */"}}
{"code": {"body": "\tpublic void startGame() throws GameOverException{\n\t\tSystem.out.println(\"\");\n\t\twhile(true){\n\t\t\tkey=keyboard.nextLine();\n\t\t\n\t\t\tpins = player.roll(numOfRoll);\n\t\t\tscoreBoard.saveScore(numOfRoll, pins);\n\t\t\tscoreBoard.printBoard();\n\t\t\tnumOfRoll++;\n\t\t\n\t\t\tif(numOfRoll==22)\n\t\t\t\tthrow new GameOverException(\"\");\n\t\t}\n\t}", "comment": "/*\n\t * startGame : \ubcfc\ub9c1 \uac8c\uc784\uc744 \uc2dc\uc791\ud55c\ub2e4.\n\t * 1. \ud50c\ub808\uc774\uc5b4\uac00 \uacf5\uc744 \uad74\ub824 \uc4f0\ub7ec\ud2b8\ub9b0 \ud540\uc758 \uac1c\uc218(pins)\ub97c \uad6c\ud55c\ub2e4.\n\t * 2. scoreBoard\uc5d0 \uc4f0\ub7ec\ud2b8\ub9b0 \ud540\uc758 \uac1c\uc218\ub97c \uae30\ub85d\ud55c\ub2e4.\n\t * 3. \ud604\uc7ac\uae4c\uc9c0 \ud50c\ub808\uc774\ud55c \uacb0\uacfc\ub97c \ucd9c\ub825\ud55c\ub2e4.\n\t */"}}
{"code": {"body": "\tpublic int roll(int numOfRoll) {\n\t\tif(numOfRoll==20){\n\t\t\tpins= ((int)(Math.random()*leftPins));\n\t\t\tleftPins-=pins;\n\t\t\treturn pins;\n\t\t}\n\t\t\n\t\tif(numOfRoll==21){\n\t\t\tif(leftPins==0){\n\t\t\t\tpins= ((int) (Math.random()*MAXPINS) + 1);\n\t\t\t\treturn pins;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif (numOfRoll%2!=0){\n\t\t\tpins= ((int) (Math.random()*MAXPINS) + 1);\n\t\t\tleftPins=MAXPINS-pins;\n\t\t\treturn pins;\n\t\t}\n\t\t\n\t\tif(leftPins==0)\n\t\t\treturn 0;\n\t\tpins= ((int)(Math.random()*leftPins));\n\t\treturn pins;\n\t}", "comment": "/*\n\t * roll : \uacf5\uc744 \uad74\ub824 \uc4f0\ub7ec\ud2b8\ub9b0 \ud540\uc758 \uac1c\uc218\ub97c \ubc18\ud658\ud55c\ub2e4.\n\t * - \uac01 \ud504\ub808\uc784\uc758 \uccab\ubc88\uc9f8 \uc2dc\ub3c4 \ub54c, \ud540\uc758 \uac1c\uc218\ub97c 0~10\uc0ac\uc774\uc758 \uc22b\uc790\ub97c \ub79c\ub364\uc73c\ub85c \ubc1c\uc0dd\uc2dc\ud0a4\uace0, \ub0a8\uc740 \ud540\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud574\ub454\ub2e4.\n\t * - \uac01 \ud504\ub808\uc784\uc758 \ub450\ubc88\uc9f8 \uc2dc\ub3c4 \ub54c, \ub0a8\uc75c \ud540\uc758 \uac1c\uc218 \uc911 \ub79c\ub364\uc73c\ub85c \uc22b\uc790\uac00 \ubc1c\uc0dd\ud55c\ub2e4.\n\t * - \ub9c8\uc9c0\ub9c9 \ud504\ub808\uc784\uc758 \ub450\ubc88\uc9f8 \uc2dc\ub3c4 \ub54c, \ub0a8\uc740 \ud540\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud574\ub454\ub2e4.\n\t * - \ub9cc\uc57d \uc704\uc5d0\uc11c \uc800\uc7a5\ud55c \ud540\uc758 \uac1c\uc218\uac00 0\uac1c\ub77c\uba74, \ubcf4\ub108\uc2a4 \ubcf4\ub108\uc2a4 \ud22c\uad6c\ub97c \ud55c\ub2e4.\n\t */"}}
{"code": {"body": "public ScoreBoard() {\n\t\tint i;\n\t\tfor(i=0; i<9; i++){\n\t\t\tscoreBoard[i] = new Frame();\n\t\t}\n\t\tscoreBoard[i] = new LastFrame();\n\t}", "comment": "/*\n\t * ScoreBoard : \uc810\uc218\ud310\uc740 9\uac1c\uc758 \uc77c\ubc18 \ud504\ub808\uc784\uacfc 1\uac1c\uc758 \ub9c8\uc9c0\ub9c9 \ud504\ub808\uc784\uc73c\ub85c \uc774\ub8e8\uc5b4\uc9c4\ub2e4.\n\t */"}}
{"code": {"body": "\tpublic void saveScore(int numOfRoll, int pins){\n\t\tif (numOfRoll%2!=0 && numOfRoll!=21)\n\t\t\tcurrentFrame++;\n\t\tscoreBoard[currentFrame-1].savePins(pins);\n\t\tthis.currentRoll=numOfRoll;\n\t}", "comment": "/*\n\t * saveScore : \ud22c\uad6c \ud69f\uc218\uc5d0 \ub530\ub77c \ud604\uc7ac \ud504\ub808\uc784\uc218\ub97c \uacc4\uc0b0\ud558\uace0, \uc774 \ud504\ub808\uc784\uc5d0 \uc4f0\ub7ec\ud2b8\ub9b0 \ud540\uc758 \uac1c\uc218\ub97c \uae30\ub85d\ud55c\ub2e4.\n\t */"}}
{"code": {"body": "\tpublic void printBoard(){\n\t\tprintInfo();\n\t\tprintOutline();\n\t\tprintFrameNumber();\n\t\tprintInnerLine();\n\t\tprintFrameScore();\n\t\tprintTotalScore();\n\t\tprintOutline();\n\t}", "comment": "/*\n\t * printBoard : \uc810\uc218\ud310\uc744 \ucd9c\ub825\ud55c\ub2e4.\n\t */"}}
{"code": {"body": "\tpublic void printTotalScore(){\t\t\t\n\t\tint totalScore=0;\n\t\tfor(int i=0; i<currentFrame; i++){\n\t\t\ttotalScore += scoreBoard[i].getFrameTotal();\n\t\t\ttotalScore += this.getBonusScore(i);\n\t\t\tSystem.out.printf(\"\", totalScore);\n\t\t}\n\t\tif(currentRoll==21)\n\t\t\tSystem.out.printf(\"\", totalScore);\n\t\tSystem.out.println(\"\");\n\t}", "comment": "/*\n\t *  printTotalScore : \uac01 \ud504\ub808\uc784\uc758 \uc810\uc218\ub97c \ucd9c\ub825\ud55c\ub2e4.\n\t *  - \ud504\ub808\uc784\uc758 \ucd1d\uc810\uc740 \uae30\ubcf8 \uc810\uc218\uc640 \ubcf4\ub108\uc2a4 \uc810\uc218\ub85c \uad6c\uc131\ub41c\ub2e4.\n\t *  - \uae30\ubcf8 \uc810\uc218\ub294 \uccab \ubc88\uc9f8, \ub450 \ubc88\uc9f8 \uc2dc\ub3c4 \ub54c \uc4f0\ub7ec\ud2b8\ub9b0 \ud540\uc758 \uac1c\uc218(getFrameTotal)\uc774\ub2e4.\n\t *  - \ubcf4\ub108\uc2a4 \uc810\uc218(getbonusScore)\ub294 \uc2a4\ud2b8\ub77c\uc774\ud06c\ub098 \uc2a4\ud398\uc5b4 \ubc1c\uc0dd \uc2dc, \ub2e4\uc74c \ud504\ub808\uc784\uc758 \uc4f0\ub7ec\ud2b8\ub9b0 \ud540\uc758 \uac1c\uc218\ub85c \uacb0\uc815\ub418\ub294 \uc810\uc218\uc774\ub2e4.\n\t */"}}
{"code": {"body": "\tpublic int getBonusScore (int numOfFrame){\n\t\tint bonusFirst;\n\t\tint bonusSecond;\n\t\t\n\t\tif(numOfFrame==currentFrame-1)\n\t\t\treturn 0;\n\t\t\n\t\tif(scoreBoard[numOfFrame].checkStrike()){\n\t\t\tif(numOfFrame==currentFrame-2 && currentRoll%2==1)\n\t\t\t\treturn 0;\n\t\t\t\n\t\t\tbonusFirst = scoreBoard[numOfFrame+1].getFirstPoint();\n\t\t\t\n\t\t\tif(bonusFirst==10){\n\t\t\t\tif(numOfFrame==currentFrame-2)\n\t\t\t\t\treturn 0;\n\t\t\t\tbonusSecond=scoreBoard[numOfFrame+2].getFirstPoint();\n\t\t\t\treturn bonusFirst+bonusSecond;\n\t\t\t}\n\t\t\tbonusSecond=scoreBoard[numOfFrame+1].getSecondPoint();\t\n\t\t\treturn bonusFirst+bonusSecond;\n\t\t}\n\t\t\n\t\tif(scoreBoard[numOfFrame].checkSpare()){\n\t\t\treturn scoreBoard[numOfFrame+1].getFirstPoint();\n\t\t}\n\t\t\n\t\treturn 0;\n\t}", "comment": "/*\n\t *  printTotalScore : \uac01 \ud504\ub808\uc784\uc758 \ubcf4\ub108\uc2a4 \uc810\uc218\ub97c \ucd9c\ub825\ud55c\ub2e4.\n\t *  - \ub2e4\uc74c \ud504\ub808\uc784\uc774 \uc9c4\ud589\ub418\uc9c0 \uc54a\uc558\uc744 \ub54c, \ubcf4\ub108\uc2a4 \uc810\uc218\ub294 0\uc810\uc73c\ub85c \ubc18\ud658\ud55c\ub2e4. (\uac8c\uc784\uc774 \uc9c4\ud589\ub41c \ud6c4 \uac31\uc2e0 \uac00\ub2a5)\n\t *  - \uc2a4\ud2b8\ub77c\uc774\ud06c\ub97c \ud588\uc744 \ub550, \uc774\ud6c4 \ub450 \ubc88\uc758 \ud22c\uad6c\ub85c \uc4f0\ub7ec\ud2b8\ub9b0 \ud540\uc758 \uac1c\uc218\ub97c \ubc18\ud658\ud55c\ub2e4.\n\t *  - \uc774 \ub450\ubc88\uc758 \ud22c\uad6c\ub294 \uc77c\ubc18\uc801\uc73c\ub85c \ub2e4\uc74c \ud504\ub808\uc784\uc758 \uccab \ubc88\uc9f8, \ub450 \ubc88\uc9f8 \uc2dc\ub3c4\ub85c \uacb0\uc815\ub418\ub098, \n\t *  \uccab \ubc88\uc9f8 \uc2dc\ub3c4\uc5d0 \ub610 \ub2e4\uc2dc \uc2a4\ud2b8\ub77c\uc774\ud06c\uac00 \ubc1c\uc0dd\ud558\uba74 \uadf8 \ub2e4\uc74c \ud504\ub808\uc784\uc758 \uccab \ubc88\uc9f8 \uc2dc\ub3c4\ub85c \uacb0\uc815\ub41c\ub2e4.\n\t *  - \uc2a4\ud398\uc5b4\ub97c \ud588\uc744 \ub550, \uc774\ud6c4 \ud55c \ubc88\uc758 \ud22c\uad6c(\ub2e4\uc74c \ud504\ub808\uc784\uc758 \uccab \ubc88\uc9f8 \uc2dc\ub3c4)\ub85c \uc4f0\ub7ec\ud2b8\ub9b0 \ud540\uc758 \uac1c\uc218\ub97c \ubc18\ud658\ud55c\ub2e4.\n\t */"}}
{"code": {"body": "\tprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\t\n\t}", "comment": "/**\n\t * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)\n\t */"}}
{"code": {"body": "public BadPlayer(Card[] cards){this.hand = new ArrayList<Card>(Arrays.asList(cards));}", "comment": "/* play a card */"}}
{"code": {"body": "\tpublic boolean play(DiscardPile       discardPile, \n\t                    Stack<Card>       drawPile, \n\t\t\t\t\t\t\t\t\t\t\tArrayList<Player> players)\n\t{\n\t\tdiscardPile.add(this.hand.remove(0));\n\t\tif( this.hand.size() == 0 ){return true;}\n\t\treturn false;\n\t}", "comment": "/* play a card */"}}
{"code": {"body": "public Card(String suit, String rank){\n        \n        this.suit = suit;\n        this.rank = rank;\n        this.rankValue = new HashMap<String,Integer>(15);\n        for(int r = 2; r < RANKS.length; r+=1){\n            this.rankValue.put(RANKS[r], r);\n        }\n    }", "comment": "/** creates a card with specified suit and rank\n     *\n     * @param suit is the suit of the card (must be a string from Card.SUITS)\n     * @param rank is the rank of the card (must be a string from Card.RANKS)\n     */"}}
{"code": {"body": "    public int getRank(){\n        if(this.rank.equals(RANKS[0])){ return -1; }   \n        return rankValue.get(this.rank);\n    }", "comment": "/** the numerical representation of the rank of the current card\n     *  <p>\n     * ranks have the numerical values\n     *  2 = 2, 3 = 3, ..., 10 = 10\n     *  Jack = 11, Queen = 12, King = 13, Ace = 14\n     *\n     * @return the numerical rank of this card\n     */"}}
{"code": {"body": "    public String getRankString(){ return this.rank; }", "comment": "/** the string representation of the rank of the current card\n     *\n     * @return the string representation of the rank of this card (must be a string from Card.RANKS)\n     */"}}
{"code": {"body": "    public String getSuit(){ return this.suit; }", "comment": "/** the suit of the current card\n     *\n     * @return the suit of this card (must be a string from Card.SUITS)\n     */"}}
{"code": {"body": "    public static void main(String[] args){\n\n\t\t\n        Card[] deck = new Card[52];\n        int index = 0;\n        for(int r=2; r<=14; r+=1){\n            for(int s=0; s<4; s+=1){\n                deck[index++] = new Card(Card.SUITS[s], Card.RANKS[r]);\n            }\n        }\n\n\t\t\n        Random rnd = new Random();\n        Card swap;\n        for(int i = deck.length-1; i>=0; i=i-1){\n            int pos = rnd.nextInt(i+1);\n            swap = deck[pos];\n            deck[pos] = deck[i];\n            deck[i] = swap;\n        }\n\n\t\t\n        Player[] players = new Player[5];\n        players[0] = new HamperLeader( Arrays.copyOfRange(deck, 0, 5) );\n        System.out.println(\"\" + Arrays.toString( Arrays.copyOfRange(deck, 0, 5)));\n        players[1] = new BadPlayer( Arrays.copyOfRange(deck, 5, 10) );\n        System.out.println(\"\" + Arrays.toString( Arrays.copyOfRange(deck, 5, 10)));\n        players[2] = new BadPlayer( Arrays.copyOfRange(deck, 10, 15) );\n        System.out.println(\"\" + Arrays.toString( Arrays.copyOfRange(deck, 10, 15)));\n        players[3] = new BadPlayer( Arrays.copyOfRange(deck, 15, 20) );\n        System.out.println(\"\" + Arrays.toString( Arrays.copyOfRange(deck, 15, 20)));\n        players[4] = new BadPlayer( Arrays.copyOfRange(deck, 20, 25) );\n        System.out.println(\"\" + Arrays.toString( Arrays.copyOfRange(deck, 20,35 )));\n\n\n\t\t\n        DiscardPile discardPile = new DiscardPile();\n        Stack<Card> drawPile = new Stack<Card>();\n        for(int i=15; i<deck.length; i++){\n            drawPile.push(deck[i]);\n        }\n\n        System.out.println(\"\" + Arrays.toString( Arrays.copyOfRange(deck, 15, deck.length) ));\n\n        deck = null;\n\n        boolean win = false;\n        int player = -1;    \n\n        ArrayList<Player> people = new ArrayList<Player>(Arrays.asList(players));\n        discardPile.add( drawPile.pop() );\n\n\n        while( !win ){\n\n            \n            if ((player <= 0) && (negate==(-1))) {\n              player = players.length-1;\n            } else if ((player >= players.length-1) && (negate == 1)) {\n              player = 0;\n            } else {\n              player = player + negate;\n            }\n            System.out.println(\"\" + player);\n            System.out.println(\"\" + drawPile.peek() );\n            System.out.println(\"\" + discardPile.top() );\n\n            win = people.get(player).play(discardPile, drawPile, people);\n\n            System.out.println(\"\" + drawPile.peek() );\n            System.out.println(\"\" + discardPile.top() );\n\n            if (discardPile.top().getRank() == 7){              \n                negate *= -1;\n                System.out.println(\"\");\n                System.out.println(\"\");\n                System.out.println(\"\");\n            }\n            else if(discardPile.top().getRank() == 4){          \n                player = (player + negate);\n                System.out.println(\"\");\n                System.out.println(\"\");\n                System.out.println(\"\");\n            }\n\n        }\n        System.out.println(\"\" + player);\n\n    }", "comment": "/* create the deck */"}}
{"code": {"body": "    public static void main(String[] args) {\n\n        Card[] deck = new Card[52];\n        int index = 0;\n\n        for (int r = 2; r <= 14; r += 1) {\n            for (int s = 0; s < 4; s += 1) {\n                deck[index++] = new Card(Card.SUITS[s], Card.RANKS[r]);\n            }\n        }\n        \n        Random rnd = new Random();\n        Card swap;\n        for (int i = deck.length - 1; i >= 0; i = i - 1) {\n            int pos = rnd.nextInt(i + 1);\n            swap = deck[pos];\n            deck[pos] = deck[i];\n            deck[i] = swap;\n        }\n\n        \n        \n\n        Card[] deck0 = new Card[6];\n        Card[] deck1 = new Card[6];\n\n\n        \n        deck0[0] = new Card (Card.SUITS[0], Card.RANKS[7]);\n        deck0[1] = new Card (Card.SUITS[3], Card.RANKS[5]);\n        deck0[2] = new Card (Card.SUITS[3], Card.RANKS[4]);\n        deck0[3] = new Card (Card.SUITS[0], Card.RANKS[2]);\n        deck0[4] = new Card (Card.SUITS[3], Card.RANKS[8]);\n        deck0[5] = new Card (Card.SUITS[3], Card.RANKS[4]);\n\n        \n        deck1[0] = new Card (Card.SUITS[1], Card.RANKS[8]);\n        deck1[1] = new Card (Card.SUITS[0], Card.RANKS[2]);\n        deck1[2] = new Card (Card.SUITS[1], Card.RANKS[4]);\n        deck1[3] = new Card (Card.SUITS[2], Card.RANKS[5]);\n        deck1[4] = new Card (Card.SUITS[1], Card.RANKS[5]);\n        deck1[5] = new Card (Card.SUITS[1], Card.RANKS[13]);\n\n\n\n        Player[] players = new Player[2];\n        players[0] = new BadPlayer( deck0 );\n        System.out.println(\"\" + players[0].hand);\n        players[1] = new DiscardHighPoints( deck1 );\n        System.out.println(\"\" + players[1].hand);\n\n\n\n        \n        DiscardPile discardPile = new DiscardPile();\n        Stack<Card> drawPile = new Stack<Card>();\n        for (int i = 15; i < deck.length; i++) {\n            drawPile.push(deck[i]);\n        }\n\n        System.out.println(\"\" + Arrays.toString(Arrays.copyOfRange(deck, 15, deck.length)));\n\n        deck = null;\n\n        boolean win = false;\n        int player = -1;    \n\n        ArrayList<Player> people = new ArrayList<Player>(Arrays.asList(players));\n        discardPile.add(drawPile.pop());\n        int negate = 1;\n\n        while (!win) {\n\n            \n            if ((player <= 0) && (negate==(-1))) {\n                player = players.length-1;\n            } else if ((player >= players.length-1) && (negate == 1)) {\n                player = 0;\n            } else {\n                player = player + negate;\n            }\n            System.out.println(\"\");\n\n\n            System.out.println(\"\" + player);\n            System.out.println(\"\" + players[player].hand);\n\n            if (!drawPile.isEmpty()){\n                System.out.println(\"\" + drawPile.peek());\n            }\n            else{\n                System.out.println(\"\");\n            }\n\n            System.out.println(\"\" + discardPile.top());\n            if (discardPile.top().getRank() == 2){\n                discardPile.top().rounds++;\n            }\n\n            win = people.get(player).play(discardPile, drawPile, people);\n\n            System.out.println(\"\" + players[player].hand);\n\n            if (!drawPile.isEmpty()){\n                System.out.println(\"\" + drawPile.peek());\n            }\n            else{\n                System.out.println(\"\");\n            }\n\n\n            System.out.println(\"\" + discardPile.top());\n\n            System.out.println(\"\");\n\n            if (players[player].getSizeOfHand() == 0){\n                break;\n            }\n            else if (discardPile.top().getRank() == 7){              \n                negate *= -1;\n            }\n            else if (discardPile.top().getRank() == 4) {          \n                player = (player + negate);\n            }\n\n        }\n        System.out.println(\"\" + player);\n        int pointsAdded = addPoints(players);\n        for (Player p: players){\n            if (p.equals(players[player])){\n                p.points = p.points + pointsAdded;\n            }\n        }\n\n\n\n    }", "comment": "/* shuffle the deck */"}}
{"code": {"body": "    public static void main(String[] args) {\n\n        int pointsNeeded = 0;\n        boolean flag = false;\n\n        while(!flag){\n\n            Card[] deck = new Card[52];\n            int index = 0;\n\n            for (int r = 2; r <= 14; r += 1) {\n                for (int s = 0; s < 4; s += 1) {\n                    deck[index++] = new Card(Card.SUITS[s], Card.RANKS[r]);\n                }\n            }\n            \n            Random rnd = new Random();\n            Card swap;\n            for (int i = deck.length - 1; i >= 0; i = i - 1) {\n                int pos = rnd.nextInt(i + 1);\n                swap = deck[pos];\n                deck[pos] = deck[i];\n                deck[i] = swap;\n            }\n\n            \n\n            \n\n\n\n            Card[] deck0 = new Card[7];\n            Card[] deck1 = new Card[6];\n\n\n            \n            deck0[0] = new Card (Card.SUITS[0], Card.RANKS[7]);\n            deck0[1] = new Card (Card.SUITS[3], Card.RANKS[5]);\n            deck0[2] = new Card (Card.SUITS[1], Card.RANKS[3]);\n            deck0[3] = new Card (Card.SUITS[3], Card.RANKS[4]);\n            deck0[4] = new Card (Card.SUITS[0], Card.RANKS[2]);\n            deck0[5] = new Card (Card.SUITS[3], Card.RANKS[8]);\n            deck0[6] = new Card (Card.SUITS[3], Card.RANKS[4]);\n\n            \n            deck1[0] = new Card (Card.SUITS[1], Card.RANKS[8]);\n            deck1[1] = new Card (Card.SUITS[0], Card.RANKS[2]);\n            deck1[2] = new Card (Card.SUITS[1], Card.RANKS[4]);\n            deck1[3] = new Card (Card.SUITS[2], Card.RANKS[5]);\n            deck1[4] = new Card (Card.SUITS[1], Card.RANKS[5]);\n            deck1[5] = new Card (Card.SUITS[1], Card.RANKS[13]);\n\n\n\n\n            Player[] players = new Player[2];\n            players[0] = new BadPlayer( deck0 );\n            System.out.println(\"\" + players[0].hand);\n            players[1] = new DiscardHighPoints( deck1 );\n            System.out.println(\"\" + players[1].hand);\n\n\n\n\n\n            \n            DiscardPile discardPile = new DiscardPile();\n            Stack<Card> drawPile = new Stack<Card>();\n            for (int i = 15; i < deck.length; i++) {\n                drawPile.push(deck[i]);\n            }\n\n            System.out.println(\"\" + Arrays.toString(Arrays.copyOfRange(deck, 15, deck.length)));\n\n            deck = null;\n\n            boolean win = false;\n            int player = -1;    \n\n            ArrayList<Player> people = new ArrayList<Player>(Arrays.asList(players));\n            discardPile.add(drawPile.pop());\n            int negate = 1;\n\n            while (!win) {\n\n                \n                if ((player <= 0) && (negate==(-1))) {\n                    player = players.length-1;\n                } else if ((player >= players.length-1) && (negate == 1)) {\n                    player = 0;\n                } else {\n                    player = player + negate;\n                }\n                System.out.println(\"\");\n\n\n                System.out.println(\"\" + player);\n                System.out.println(\"\" + players[player].hand);\n\n                if (!drawPile.isEmpty()){\n                    System.out.println(\"\" + drawPile.peek());\n                }\n                else{\n                    System.out.println(\"\");\n                }\n\n                System.out.println(\"\" + discardPile.top());\n                if (discardPile.top().getRank() == 2){\n                    discardPile.top().rounds++;\n                }\n                else if (discardPile.top().getRank() == 4){\n                    discardPile.top().rounds++;\n                }\n\n                win = people.get(player).play(discardPile, drawPile, people);\n\n                System.out.println(\"\" + players[player].hand);\n\n                if (!drawPile.isEmpty()){\n                    System.out.println(\"\" + drawPile.peek());\n                }\n                else{\n                    System.out.println(\"\");\n                }\n\n\n                System.out.println(\"\" + discardPile.top());\n\n                System.out.println(\"\");\n\n                if (players[player].getSizeOfHand() == 0){\n                    break;\n                }\n                else if (discardPile.top().getRank() == 7){              \n                    negate *= -1;\n                }\n                \n\n\n            }\n            System.out.println(\"\" + player);\n            int pointsAdded = addPoints(players);\n            for (Player p: players){\n                if (p.equals(players[player])){\n                    p.points = p.points + pointsAdded;\n                    if (p.points >= pointsNeeded){\n                        flag = true;\n                    }\n                }\n            }\n        }\n    }", "comment": "/* shuffle the deck */"}}
{"code": {"body": "public DiscardHighPoints(Card[] cards){this.hand = new ArrayList<Card>(Arrays.asList(cards));}", "comment": "/* play a card */"}}
{"code": {"body": "    public boolean play(DiscardPile       discardPile,\n                        Stack<Card>       drawPile,\n                        ArrayList<Player> players)\n    {\n        Card highestPointCard = this.highest_card();        \n        Card previousCard = discardPile.top();              \n\n\n        \n        if (previousCard.getRank() == 2 && previousCard.rounds == 1){\n\n            int drawCount = 0;\n            while (drawCount < 2){\n                if(!drawPile.isEmpty()){\n                    hand.add(drawPile.pop());\n                }\n                drawCount++;\n            }\n            System.out.println(\"\");\n        }\n        else if (previousCard.getRank() == 4 && previousCard.rounds == 1){\n            System.out.println(\"\");\n        }\n        \n        else if (highestPointCard.getRank() == 8){\n\n            discardPile.add(this.hand.remove(0));\n            highestPointCard = this.highest_card();\n            Card suitChange = new Card(highestPointCard.getSuit(), \"\");\n            discardPile.add(suitChange);\n\n            System.out.println(\"\");\n        }\n        \n        else if (highestPointCard.getSuit().equals(previousCard.getSuit()) && !(highestPointCard.getRank() == 8)){\n            discardPile.add(this.hand.remove(0));\n\n            System.out.println(\"\");\n        }\n        \n        else if (canPlay(previousCard)){\n\n            \n            if (highest_card_counter() > 0){               \n                int cardAdded = 0;\n\n                for (int i = 0; i < hand.size() - 1; i++){\n\n                    if ((hand.get(i+1).getSuit().equals(previousCard.getSuit()) || hand.get(i+1).getRank() == previousCard.getRank()) && (cardPoints(hand.get(i+1)) == cardPoints(highest_card()))){\n\n                        discardPile.add(hand.get(i+1));\n                        hand.remove(hand.get(i+1));\n                        cardAdded = cardAdded + 1;\n                        break;\n                    }\n                }\n                if (cardAdded != 0){\n                    System.out.println(\"\");\n                }\n\n                                                        \n                if (cardAdded == 0){\n                    for (int i = 0; i < highest_card_counter() + 1; i++){\n                        for (Card c: hand){\n\n                            if (c.getSuit().equals(hand.get(i).getSuit()) && c.getRank() == previousCard.getRank()){\n                                discardPile.add(c);\n                                hand.remove(c);\n                                cardAdded++;\n                                break;\n                            }\n                        }\n                        if (cardAdded != 0){\n                            System.out.println(\"\");\n                            break;\n                        }\n                    }\n                }\n                                                            \n                if (cardAdded == 0){\n                    for (Card c: hand){\n                        if (c.getSuit().equals(previousCard.getSuit()) || c.getRank() == previousCard.getRank()){\n                            discardPile.add(c);\n                            hand.remove(c);\n                            System.out.println(\"\");\n                            break;\n                        }\n                    }\n                }\n            }\n\n            \n            else{\n                int cardAdded = 0;\n                for (Card c: hand){                         \n\n                    if (c.getSuit().equals(highestPointCard.getSuit()) && c.getRank() == previousCard.getRank()){\n                        discardPile.add(c);\n                        hand.remove(c);\n                        cardAdded++;\n                        System.out.println(\"\");\n                        break;\n                    }\n                }\n                if (cardAdded == 0){                        \n                    for (Card c: hand){\n                        if (c.getSuit().equals(previousCard.getSuit()) || c.getRank() == previousCard.getRank()){\n                            discardPile.add(c);\n                            hand.remove(c);\n                            System.out.println(\"\");\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        \n        \n        else{\n            \n            if (!drawPile.isEmpty()){\n\n                boolean checker = false;\n                Card fromDraw;\n\n                while (!checker && !drawPile.isEmpty()){\n                    fromDraw = drawPile.pop();\n                    if ((fromDraw.getSuit().equals(previousCard.getSuit())) ||\n                            (fromDraw.getRank() == previousCard.getRank())){\n\n                        discardPile.add(fromDraw);\n                        System.out.println(\"\");\n                        checker = true;\n                    }\n                    else{\n                        hand.add(fromDraw);\n                        System.out.println(\"\");\n                    }\n                }\n            }\n        }\n\n        if( this.hand.size() == 0 ){return true;}\n        return false;\n    }", "comment": "/* play a card */"}}
{"code": {"body": "\tpublic Card top(){ \n\t\tif(cards.isEmpty()){\t\n\t\t\treturn new Card(\"\",\"\");\n\t\t}\n\t\treturn cards.peek(); \n\t}", "comment": "/* the top card on the discard pile */"}}
{"code": {"body": "\tpublic void add(Card card){\n\t\tcards.push(card);\n\t}", "comment": "/* add a card to the discard pile */"}}
{"code": {"body": "    public boolean play(DiscardPile       discardPile,\n                        Stack<Card>       drawPile,\n                        ArrayList<Player> players)\n    {\n        Card previousCard = discardPile.top();\n        int smallestHand = 52;\n        Player smallestPlayer = null;\n\n        \n        for (Player p: players){\n            if (p.getSizeOfHand() < smallestHand){\n\n                smallestPlayer = p;\n            }\n        }\n        if (smallestPlayer.equals(players.indexOf(this) + 1) ||\n                (smallestPlayer.equals(players.get(0)) && this.equals(players.get(players.size()-1)))){\n\n            if (hasSpecial()){\n\n                if (smallestPlayer.equals(players.indexOf(this) + 1) ||\n                        (smallestPlayer.equals(players.get(0)) && this.equals(players.get(players.size()-1)))) {\n                    for (Card c : hand) {\n                        if (c.getRank() == 8 || c.getRank() == 2 || c.getRank() == 4) {\n                            discardPile.add(c);\n                            hand.remove(c);\n                            break;\n                        }\n                    }\n\n                }\n                else if (smallestPlayer.equals(players.indexOf(this) - 1) ||\n                        (smallestPlayer.equals(players.get(players.size()-1)) && this.equals((players.get(0))))){\n                    if (hasSeven()){\n                        for (Card c : hand) {\n                            if (c.getRank() == 7) {\n                                discardPile.add(c);\n                                hand.remove(c);\n                                break;\n                            }\n                        }\n                    }\n                    else{\n                        for (Card c: hand){\n                            if (c.getRank() == previousCard.getRank() || c.getSuit().equals(previousCard.getSuit())){\n                                discardPile.add(c);\n                                hand.remove(c);\n                            }\n                        }\n                    }\n                }\n            }\n            else if (canPlay(previousCard)){\n                for (Card c: hand){\n                    if (c.getRank() == previousCard.getRank() || c.getSuit().equals(previousCard.getSuit())){\n                        discardPile.add(c);\n                        hand.remove(c);\n                    }\n                }\n            }\n            else{\n                if (!drawPile.isEmpty()){\n\n                    boolean checker = false;\n                    Card fromDraw;\n\n                    while (!checker){\n                        fromDraw = drawPile.pop();\n                        if ((fromDraw.getSuit().equals(previousCard.getSuit())) ||\n                                (fromDraw.getRank() == previousCard.getRank())){\n\n                            discardPile.add(fromDraw);\n                            checker = true;\n                        }\n                        else{\n                            hand.add(fromDraw);\n                        }\n                    }\n                }\n            }\n        }\n\n        if( this.hand.size() == 0 ){return true;}\n        return false;\n\n    }", "comment": "/* play a card */"}}
{"code": {"body": "    public static void main(String[] args){\n\n\n      \n          Card[] deck = new Card[52];\n          int index = 0;\n          for(int r=2; r<=14; r+=1){\n              for(int s=0; s<4; s+=1){\n                  deck[index++] = new Card(Card.SUITS[s], Card.RANKS[r]);\n              }\n          }\n\n  \t\t\n          Random rnd = new Random();\n          Card swap;\n          for(int i = deck.length-1; i>=0; i=i-1){\n              int pos = rnd.nextInt(i+1);\n              swap = deck[pos];\n              deck[pos] = deck[i];\n              deck[i] = swap;\n          }\n\n  \t\t\n          Player[] players = new Player[5];\n          players[0] = new HamperLeader( Arrays.copyOfRange(deck, 0, 5) );\n          System.out.println(\"\" + Arrays.toString( Arrays.copyOfRange(deck, 0, 5)));\n          players[1] = new RandomPlayer( Arrays.copyOfRange(deck, 5, 10) );\n          System.out.println(\"\" + Arrays.toString( Arrays.copyOfRange(deck, 5, 10)));\n          players[2] = new RandomPlayer( Arrays.copyOfRange(deck, 10, 15) );\n          System.out.println(\"\" + Arrays.toString( Arrays.copyOfRange(deck, 10, 15)));\n          players[3] = new RandomPlayer( Arrays.copyOfRange(deck, 15, 20) );\n          System.out.println(\"\" + Arrays.toString( Arrays.copyOfRange(deck, 15, 20)));\n          players[4] = new RandomPlayer( Arrays.copyOfRange(deck, 20, 25) );\n          System.out.println(\"\" + Arrays.toString( Arrays.copyOfRange(deck, 20,25 )));\n\n\n  \t\t\n          DiscardPile discardPile = new DiscardPile();\n          Stack<Card> drawPile = new Stack<Card>();\n          for(int i=15; i<deck.length; i++){\n              drawPile.push(deck[i]);\n          }\n\n          System.out.println(\"\" + Arrays.toString( Arrays.copyOfRange(deck, 15, deck.length) ));\n\n          deck = null;\n\n          boolean win = false;\n          int player = -1;    \n\n          ArrayList<Player> people = new ArrayList<Player>(Arrays.asList(players));\n          discardPile.add( drawPile.pop() );\n\n\n            while( !win && !drawPile.isEmpty() ){\n\n                \n                if ((player <= 0) && (negate==(-1))) {\n                  player = players.length-1;\n                } else if ((player >= players.length-1) && (negate == 1)) {\n                  player = 0;\n                } else {\n                  player = player + negate;\n                }\n\n                System.out.println(\"\" + player + \"\");\n                if( !drawPile.isEmpty()){\n                System.out.println(\"\" + drawPile.peek() );\n              }\n                System.out.println(\"\" + discardPile.top() );\n\n                win = people.get(player).play(discardPile, drawPile, people);\n                if( !drawPile.isEmpty()){\n                System.out.println(\"\" + drawPile.peek() );\n              }\n                System.out.println(\"\" + discardPile.top() );\n\n                if (discardPile.top().getRank() == 7){              \n                    negate *= -1;\n                    System.out.println(\"\");\n                    System.out.println(\"\");\n                    System.out.println(\"\");\n                }\n                else if(discardPile.top().getRank() == 4){          \n                    player = (player + negate);\n                    System.out.println(\"\");\n                    System.out.println(\"\");\n                    System.out.println(\"\");\n                }\n\n            }\n            System.out.println(\"\" + player);\n\n\n  }", "comment": "/* create the deck */"}}
{"code": {"body": "    public boolean play(DiscardPile       discardPile,\n                        Stack<Card>       drawPile,\n                        ArrayList<Player> players)\n    {\n        Card previousCard = discardPile.top();              \n\n        int myEights = 0;\n        int smallestHand = 52;\n\n        \n        for (Card c: hand){\n            if (c.getRank() == 8){\n                myEights++;\n            }\n        }\n\n        \n        for (Player p: players){\n            if (p.getSizeOfHand() < smallestHand){\n                smallestHand = p.getSizeOfHand();\n            }\n        }\n\n        \n        if (myEights == smallestHand && myEights != 0){\n            for (Card c: hand){\n                if (c.getRank() == 8){\n                    discardPile.add(c);\n                    hand.remove(c);\n                }\n            }\n        }\n        else if (canPlay(previousCard)){\n            for (Card c: hand){\n                if (c.getRank() == previousCard.getRank() || c.getSuit().equals(previousCard.getSuit())){\n                    discardPile.add(c);\n                    hand.remove(c);\n                }\n            }\n        }\n        else{\n            if (!drawPile.isEmpty()){\n\n                boolean checker = false;\n                Card fromDraw;\n\n                while (!checker){\n                    fromDraw = drawPile.pop();\n                    if ((fromDraw.getSuit().equals(previousCard.getSuit())) ||\n                            (fromDraw.getRank() == previousCard.getRank())){\n\n                        discardPile.add(fromDraw);\n                        checker = true;\n                    }\n                    else{\n                        hand.add(fromDraw);\n                    }\n                }\n            }\n        }\n\n        if( this.hand.size() == 0 ){return true;}\n        return false;\n\n    }", "comment": "/* play a card */"}}
{"code": {"body": "    public boolean play(DiscardPile       discardPile,\n                        Stack<Card>       drawPile,\n                        ArrayList<Player> players)\n    {\n        Card previousCard = discardPile.top();              \n\n        int myEights = 0;\n        int smallestHand = 52;\n\n        \n        for (Card c: hand){\n            if (c.getRank() == 8){\n                myEights++;\n            }\n        }\n\n        \n        for (Player p: players){\n            if (p.getSizeOfHand() < smallestHand){\n                smallestHand = p.getSizeOfHand();\n            }\n        }\n\n        \n        if (myEights == smallestHand && myEights != 0){\n            for (Card c: hand){\n                if (c.getRank() == 8){\n                    discardPile.add(c);\n                    hand.remove(c);\n                }\n            }\n        }\n        else if (canPlay(previousCard)){\n            for (Card c: hand){\n                if (c.getRank() == previousCard.getRank() || c.getSuit().equals(previousCard.getSuit())){\n                    discardPile.add(c);\n                    hand.remove(c);\n                }\n            }\n        }\n        else{\n            if (!drawPile.isEmpty()){\n\n                boolean checker = false;\n                Card fromDraw;\n\n                while (!checker){\n                    fromDraw = drawPile.pop();\n                    if ((fromDraw.getSuit().equals(previousCard.getSuit())) ||\n                            (fromDraw.getRank() == previousCard.getRank())){\n\n                        discardPile.add(fromDraw);\n                        checker = true;\n                    }\n                    else{\n                        hand.add(fromDraw);\n                    }\n                }\n            }\n        }\n\n        if( this.hand.size() == 0 ){return true;}\n        return false;\n\n    }", "comment": "/* play a card */"}}
{"code": {"body": "    public int getSizeOfHand(){\n        return hand.size();\n    }", "comment": "/* play a card  */"}}
{"code": {"body": "public RandomPlayer(Card[] cards) {\n    this.hand = new ArrayList<Card>(Arrays.asList(cards));\n  }", "comment": "/* play a card */"}}
{"code": {"body": "\tpublic boolean play(DiscardPile       discardPile,\n\t                    Stack<Card>       drawPile,\n\t\t\t\t\t\t\t\t\t\t\tArrayList<Player> players)\n\t{\n\n    \n\t\tif (discardPile.top().getRank() == 2) {\n      getCard(drawPile);\n      getCard(drawPile);\n    }\n\n    Card        previous = discardPile.top();\n    int     previousRank = previous.getRank();\n    String  previousSuit = previous.getSuit();\n    boolean       played = false;\n\n    \n    for (Card c : hand) {\n      if (hand.size() > 0) {\n        if ((c.getRank() == previousRank) || (c.getSuit().equals(previousSuit) || (c.getRank() == 8))) {\n          discardPile.add(c);\n          hand.remove(c);\n          System.out.println(\"\" + c);\n          played = true;\n          break;\n        }\n      }\n    }\n\n    \n    if (!played) {\n      getCard(drawPile);\n      played = true;\n    }\n\n    \n    if (hand.size() == 0) {\n      return true;\n    }\n    return false;\n\t}", "comment": "/* play a card */"}}
{"code": {"body": "    public static void main(String[] args){\n\n      int[] wins = {0,0,0,0,0,0};\n\n        for (int x = 0; x < 1000; x ++ ) {\n\n          System.out.println(\"\");\n          System.out.println(\"\");\n          System.out.println(\"\");\n\n          \n              Card[] deck = new Card[52];\n              int index = 0;\n              for(int r=2; r<=14; r+=1){\n                  for(int s=0; s<4; s+=1){\n                      deck[index++] = new Card(Card.SUITS[s], Card.RANKS[r]);\n                  }\n              }\n\n      \t\t\n              Random rnd = new Random();\n              Card swap;\n              for(int i = deck.length-1; i>=0; i=i-1){\n                  int pos = rnd.nextInt(i+1);\n                  swap = deck[pos];\n                  deck[pos] = deck[i];\n                  deck[i] = swap;\n              }\n\n      \t\t\n              Player[] players = new Player[5];\n              players[0] = new ExtraCards( Arrays.copyOfRange(deck, 0, 5) );\n              System.out.println(\"\" + Arrays.toString( Arrays.copyOfRange(deck, 0, 5)));\n              players[1] = new DiscardHighPoints( Arrays.copyOfRange(deck, 5, 10) );\n              System.out.println(\"\" + Arrays.toString( Arrays.copyOfRange(deck, 5, 10)));\n              players[2] = new RandomPlayer( Arrays.copyOfRange(deck, 10, 15) );\n              System.out.println(\"\" + Arrays.toString( Arrays.copyOfRange(deck, 10, 15)));\n              players[3] = new ExtraCards( Arrays.copyOfRange(deck, 15, 20) );\n              System.out.println(\"\" + Arrays.toString( Arrays.copyOfRange(deck, 15, 20)));\n              players[4] = new HamperLeader( Arrays.copyOfRange(deck, 20, 25) );\n              System.out.println(\"\" + Arrays.toString( Arrays.copyOfRange(deck, 20,35 )));\n\n\n      \t\t\n              DiscardPile discardPile = new DiscardPile();\n              Stack<Card> drawPile = new Stack<Card>();\n              for(int i=15; i<deck.length; i++){\n                  drawPile.push(deck[i]);\n              }\n\n              System.out.println(\"\" + Arrays.toString( Arrays.copyOfRange(deck, 15, deck.length) ));\n\n              deck = null;\n\n              boolean win = false;\n              int player = -1;    \n\n              ArrayList<Player> people = new ArrayList<Player>(Arrays.asList(players));\n              discardPile.add( drawPile.pop() );\n\n\n\n\n          while( (!win) && (!drawPile.isEmpty())  ){\n\n              \n              if ((player <= 0) && (negate==(-1))) {\n                player = players.length-1;\n              } else if ((player >= players.length-1) && (negate == 1)) {\n                player = 0;\n              } else {\n                player = player + negate;\n              }\n\n\n\n\n              System.out.println(\"\");\n              System.out.println(\"\");\n              System.out.println(\"\" + player);\n              System.out.println(\"\" + drawPile.peek() );\n              System.out.println(\"\" + discardPile.top() );\n\n\n              win = people.get(player).play(discardPile, drawPile, people);\n              if (!drawPile.isEmpty()) {\n                System.out.println(\"\" + drawPile.peek() );\n              }\n              System.out.println(\"\" + discardPile.top() );\n\n              if (discardPile.top().getRank() == 7){              \n                  negate *= -1;\n                  System.out.println(\"\");\n                  System.out.println(\"\");\n                  System.out.println(\"\");\n              }\n              else if(discardPile.top().getRank() == 4){          \n                  player = (player + negate);\n                  System.out.println(\"\");\n                  System.out.println(\"\");\n                  System.out.println(\"\");\n              }\n              System.out.println(\"\");\n              System.out.println(\"\");\n\n          }\n\n          if ((player <= 0) && (negate==(-1))) {\n            player = players.length-1;\n          } else if ((player >= players.length-1) && (negate == 1)) {\n            player = 0;\n          } else {\n            player = player + negate;\n          }\n\n          if ((drawPile.isEmpty())) {\n            boolean playerWin = false;\n            for (int y = 0; y < wins.length - 1; y ++) {\n              if (people.get(y).getSizeOfHand() == 0) {\n                playerWin = true;\n              }\n            }\n            if (!playerWin) {\n              wins[5] += 1;\n            }\n          } else if (people.get(player).getSizeOfHand() == 0) {\n            if ((player > 0) && (player < wins.length - 1)) {\n              wins[player] += 1;\n            }\n          }\n\n          for (int y = 0; y < wins.length - 1; y ++) {\n            if (people.get(y).getSizeOfHand() == 0) {\n              wins[y] += 1;\n            }\n          }\n\n\n\n      }\n\n      for (int y = 0; y < wins.length - 1; y ++) {\n        System.out.println(\"\" + y + \"\" + wins[y]+ \"\");\n      }\n\n      System.out.println((wins[5]) + \"\");\n\n\n\n\n\n    }", "comment": "/* create the deck */"}}
{"code": {"body": "    public static void main(String[] args){\n\n      int[] wins = {0,0,0,0,0,0};\n\n        for (int x = 0; x < 10; x ++ ) {\n\n          System.out.println(\"\");\n          System.out.println(\"\");\n          System.out.println(\"\");\n\n          \n              Card[] deck = new Card[52];\n              int index = 0;\n              for(int r=2; r<=14; r+=1){\n                  for(int s=0; s<4; s+=1){\n                      deck[index++] = new Card(Card.SUITS[s], Card.RANKS[r]);\n                  }\n              }\n\n      \t\t\n              Random rnd = new Random();\n              Card swap;\n              for(int i = deck.length-1; i>=0; i=i-1){\n                  int pos = rnd.nextInt(i+1);\n                  swap = deck[pos];\n                  deck[pos] = deck[i];\n                  deck[i] = swap;\n              }\n\n      \t\t\n              Player[] players = new Player[5];\n              players[0] = new ExtraCards( Arrays.copyOfRange(deck, 0, 5) );\n              System.out.println(\"\" + Arrays.toString( Arrays.copyOfRange(deck, 0, 5)));\n              players[1] = new RandomPlayer( Arrays.copyOfRange(deck, 5, 10) );\n              System.out.println(\"\" + Arrays.toString( Arrays.copyOfRange(deck, 5, 10)));\n              players[2] = new RandomPlayer( Arrays.copyOfRange(deck, 10, 15) );\n              System.out.println(\"\" + Arrays.toString( Arrays.copyOfRange(deck, 10, 15)));\n              players[3] = new ExtraCards( Arrays.copyOfRange(deck, 15, 20) );\n              System.out.println(\"\" + Arrays.toString( Arrays.copyOfRange(deck, 15, 20)));\n              players[4] = new RandomPlayer( Arrays.copyOfRange(deck, 20, 25) );\n              System.out.println(\"\" + Arrays.toString( Arrays.copyOfRange(deck, 20,35 )));\n\n\n      \t\t\n              DiscardPile discardPile = new DiscardPile();\n              Stack<Card> drawPile = new Stack<Card>();\n              for(int i=15; i<deck.length; i++){\n                  drawPile.push(deck[i]);\n              }\n\n              System.out.println(\"\" + Arrays.toString( Arrays.copyOfRange(deck, 15, deck.length) ));\n\n              deck = null;\n\n              boolean win = false;\n              int player = -1;    \n\n              ArrayList<Player> people = new ArrayList<Player>(Arrays.asList(players));\n              discardPile.add( drawPile.pop() );\n\n\n\n\n          while( (!win) && (!drawPile.isEmpty())  ){\n\n              \n              if ((player <= 0) && (negate==(-1))) {\n                player = players.length-1;\n              } else if ((player >= players.length-1) && (negate == 1)) {\n                player = 0;\n              } else {\n                player = player + negate;\n              }\n\n\n\n\n              System.out.println(\"\");\n              System.out.println(\"\");\n              System.out.println(\"\" + player);\n              System.out.println(\"\" + drawPile.peek() );\n              System.out.println(\"\" + discardPile.top() );\n\n\n              win = people.get(player).play(discardPile, drawPile, people);\n              if (!drawPile.isEmpty()) {\n                System.out.println(\"\" + drawPile.peek() );\n              }\n              System.out.println(\"\" + discardPile.top() );\n\n              if (discardPile.top().getRank() == 7){              \n                  negate *= -1;\n                  System.out.println(\"\");\n                  System.out.println(\"\");\n                  System.out.println(\"\");\n              }\n              else if(discardPile.top().getRank() == 4){          \n                  player = (player + negate);\n                  System.out.println(\"\");\n                  System.out.println(\"\");\n                  System.out.println(\"\");\n              }\n              System.out.println(\"\");\n              System.out.println(\"\");\n\n          }\n\n          if ((player <= 0) && (negate==(-1))) {\n            player = players.length-1;\n          } else if ((player >= players.length-1) && (negate == 1)) {\n            player = 0;\n          } else {\n            player = player + negate;\n          }\n\n          if ((drawPile.isEmpty())) {\n            boolean playerWin = false;\n            for (int y = 0; y < wins.length - 1; y ++) {\n              if (people.get(y).getSizeOfHand() == 0) {\n                playerWin = true;\n              }\n            }\n            if (!playerWin) {\n              wins[5] += 1;\n            }\n          } else if (people.get(player).getSizeOfHand() == 0) {\n            if ((player > 0) && (player < wins.length - 1)) {\n              wins[player] += 1;\n            }\n          }\n\n          for (int y = 0; y < wins.length - 1; y ++) {\n            if (people.get(y).getSizeOfHand() == 0) {\n              wins[y] += 1;\n            }\n          }\n\n\n\n\n\n      }\n\n      for (int y = 0; y < wins.length - 1; y ++) {\n        System.out.println(\"\" + y + \"\" + wins[y]+ \"\");\n      }\n\n      System.out.println((wins[5]) + \"\");\n\n\n\n\n\n    }", "comment": "/* create the deck */"}}
{"code": {"body": "public Login_Form() {\n        initComponents();\n        this.setLocationRelativeTo(null); \n    }", "comment": "/**\n     * Creates new form Login_Form\n     */"}}
{"code": {"body": "    public static void main(String args[]) {\n        \n        \n        \n        try {\n            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {\n                if (\"\".equals(info.getName())) {\n                    javax.swing.UIManager.setLookAndFeel(info.getClassName());\n                    break;\n                }\n            }\n        } catch (ClassNotFoundException ex) {\n            java.util.logging.Logger.getLogger(Login_Form.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (InstantiationException ex) {\n            java.util.logging.Logger.getLogger(Login_Form.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (IllegalAccessException ex) {\n            java.util.logging.Logger.getLogger(Login_Form.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (javax.swing.UnsupportedLookAndFeelException ex) {\n            java.util.logging.Logger.getLogger(Login_Form.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        }\n        \n\n        \n        java.awt.EventQueue.invokeLater(new Runnable() {\n            public void run() {\n                new Login_Form().setVisible(true);\n            }\n        });\n    }", "comment": "/**\n     * @param args the command line arguments\n     */"}}
{"code": {"body": "public Register_Form() {\n        initComponents();\n    }", "comment": "/**\n     * Creates new form Register_Form\n     */"}}
{"code": {"body": "    public static void main(String args[]) {\n        \n        \n        \n        try {\n            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {\n                if (\"\".equals(info.getName())) {\n                    javax.swing.UIManager.setLookAndFeel(info.getClassName());\n                    break;\n                }\n            }\n        } catch (ClassNotFoundException ex) {\n            java.util.logging.Logger.getLogger(Register_Form.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (InstantiationException ex) {\n            java.util.logging.Logger.getLogger(Register_Form.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (IllegalAccessException ex) {\n            java.util.logging.Logger.getLogger(Register_Form.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (javax.swing.UnsupportedLookAndFeelException ex) {\n            java.util.logging.Logger.getLogger(Register_Form.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        }\n        \n\n        \n        java.awt.EventQueue.invokeLater(new Runnable() {\n            public void run() {\n                new Register_Form().setVisible(true);\n            }\n        });\n    }", "comment": "/**\n     * @param args the command line arguments\n     */"}}
{"code": {"body": "public admin_ui() {\n        initComponents();\n        \n    }", "comment": "/**\n     * Creates new form admin_ui\n     */"}}
{"code": {"body": "    public static void main(String args[]) {\n        \n        \n        \n        try {\n            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {\n                if (\"\".equals(info.getName())) {\n                    javax.swing.UIManager.setLookAndFeel(info.getClassName());\n                    break;\n                }\n            }\n        } catch (ClassNotFoundException ex) {\n            java.util.logging.Logger.getLogger(admin_ui.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (InstantiationException ex) {\n            java.util.logging.Logger.getLogger(admin_ui.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (IllegalAccessException ex) {\n            java.util.logging.Logger.getLogger(admin_ui.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (javax.swing.UnsupportedLookAndFeelException ex) {\n            java.util.logging.Logger.getLogger(admin_ui.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        }\n        \n\n        \n        java.awt.EventQueue.invokeLater(new Runnable() {\n            public void run() {\n                new admin_ui().setVisible(true);\n            }\n        });\n    }", "comment": "/**\n     * @param args the command line arguments\n     */"}}
{"code": {"body": "public foreLogin() {\n        initComponents();\n        this.setLocationRelativeTo(null);\n    }", "comment": "/**\n     * Creates new form foreLogin\n     */"}}
{"code": {"body": "    public static void main(String args[]) {\n        \n        \n        \n        try {\n            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {\n                if (\"\".equals(info.getName())) {\n                    javax.swing.UIManager.setLookAndFeel(info.getClassName());\n                    break;\n                }\n            }\n        } catch (ClassNotFoundException ex) {\n            java.util.logging.Logger.getLogger(foreLogin.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (InstantiationException ex) {\n            java.util.logging.Logger.getLogger(foreLogin.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (IllegalAccessException ex) {\n            java.util.logging.Logger.getLogger(foreLogin.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (javax.swing.UnsupportedLookAndFeelException ex) {\n            java.util.logging.Logger.getLogger(foreLogin.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        }\n        \n\n        \n        java.awt.EventQueue.invokeLater(new Runnable() {\n            public void run() {\n                new foreLogin().setVisible(true);\n            }\n        });\n    }", "comment": "/**\n     * @param args the command line arguments\n     */"}}
{"code": {"body": "public forereg() {\n        initComponents();\n    }", "comment": "/**\n     * Creates new form forereg\n     */"}}
{"code": {"body": "    public static void main(String args[]) {\n        \n        \n        \n        try {\n            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {\n                if (\"\".equals(info.getName())) {\n                    javax.swing.UIManager.setLookAndFeel(info.getClassName());\n                    break;\n                }\n            }\n        } catch (ClassNotFoundException ex) {\n            java.util.logging.Logger.getLogger(forereg.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (InstantiationException ex) {\n            java.util.logging.Logger.getLogger(forereg.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (IllegalAccessException ex) {\n            java.util.logging.Logger.getLogger(forereg.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (javax.swing.UnsupportedLookAndFeelException ex) {\n            java.util.logging.Logger.getLogger(forereg.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        }\n        \n\n        \n        java.awt.EventQueue.invokeLater(new Runnable() {\n            public void run() {\n                new forereg().setVisible(true);\n            }\n        });\n    }", "comment": "/**\n     * @param args the command line arguments\n     */"}}
{"code": {"body": "public guest_ui() {\n        initComponents();\n    }", "comment": "/**\n     * Creates new form guest_ui\n     */"}}
{"code": {"body": "    public static void main(String args[]) {\n        \n        \n        \n        try {\n            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {\n                if (\"\".equals(info.getName())) {\n                    javax.swing.UIManager.setLookAndFeel(info.getClassName());\n                    break;\n                }\n            }\n        } catch (ClassNotFoundException ex) {\n            java.util.logging.Logger.getLogger(guest_ui.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (InstantiationException ex) {\n            java.util.logging.Logger.getLogger(guest_ui.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (IllegalAccessException ex) {\n            java.util.logging.Logger.getLogger(guest_ui.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (javax.swing.UnsupportedLookAndFeelException ex) {\n            java.util.logging.Logger.getLogger(guest_ui.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        }\n        \n\n        \n        java.awt.EventQueue.invokeLater(new Runnable() {\n            public void run() {\n                new guest_ui().setVisible(true);\n            }\n        });\n    }", "comment": "/**\n     * @param args the command line arguments\n     */"}}
{"code": {"body": "public Login_Form() {\n        initComponents();\n        this.setLocationRelativeTo(null); \n    }", "comment": "/**\n     * Creates new form Login_Form\n     */"}}
{"code": {"body": "    public static void main(String args[]) {\n        \n        \n        \n        try {\n            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {\n                if (\"\".equals(info.getName())) {\n                    javax.swing.UIManager.setLookAndFeel(info.getClassName());\n                    break;\n                }\n            }\n        } catch (ClassNotFoundException ex) {\n            java.util.logging.Logger.getLogger(Login_Form.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (InstantiationException ex) {\n            java.util.logging.Logger.getLogger(Login_Form.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (IllegalAccessException ex) {\n            java.util.logging.Logger.getLogger(Login_Form.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (javax.swing.UnsupportedLookAndFeelException ex) {\n            java.util.logging.Logger.getLogger(Login_Form.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        }\n        \n\n        \n        java.awt.EventQueue.invokeLater(new Runnable() {\n            public void run() {\n                new Login_Form().setVisible(true);\n            }\n        });\n    }", "comment": "/**\n     * @param args the command line arguments\n     */"}}
{"code": {"body": "public Register_Form() {\n        initComponents();\n    }", "comment": "/**\n     * Creates new form Register_Form\n     */"}}
{"code": {"body": "    public static void main(String args[]) {\n        \n        \n        \n        try {\n            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {\n                if (\"\".equals(info.getName())) {\n                    javax.swing.UIManager.setLookAndFeel(info.getClassName());\n                    break;\n                }\n            }\n        } catch (ClassNotFoundException ex) {\n            java.util.logging.Logger.getLogger(Register_Form.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (InstantiationException ex) {\n            java.util.logging.Logger.getLogger(Register_Form.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (IllegalAccessException ex) {\n            java.util.logging.Logger.getLogger(Register_Form.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (javax.swing.UnsupportedLookAndFeelException ex) {\n            java.util.logging.Logger.getLogger(Register_Form.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        }\n        \n\n        \n        java.awt.EventQueue.invokeLater(new Runnable() {\n            public void run() {\n                new Register_Form().setVisible(true);\n            }\n        });\n    }", "comment": "/**\n     * @param args the command line arguments\n     */"}}
{"code": {"body": "public admin_ui() {\n        initComponents();\n        \n    }", "comment": "/**\n     * Creates new form admin_ui\n     */"}}
{"code": {"body": "    public static void main(String args[]) {\n        \n        \n        \n        try {\n            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {\n                if (\"\".equals(info.getName())) {\n                    javax.swing.UIManager.setLookAndFeel(info.getClassName());\n                    break;\n                }\n            }\n        } catch (ClassNotFoundException ex) {\n            java.util.logging.Logger.getLogger(admin_ui.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (InstantiationException ex) {\n            java.util.logging.Logger.getLogger(admin_ui.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (IllegalAccessException ex) {\n            java.util.logging.Logger.getLogger(admin_ui.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (javax.swing.UnsupportedLookAndFeelException ex) {\n            java.util.logging.Logger.getLogger(admin_ui.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        }\n        \n\n        \n        java.awt.EventQueue.invokeLater(new Runnable() {\n            public void run() {\n                new admin_ui().setVisible(true);\n            }\n        });\n    }", "comment": "/**\n     * @param args the command line arguments\n     */"}}
{"code": {"body": "public foreLogin() {\n        initComponents();\n        this.setLocationRelativeTo(null);\n    }", "comment": "/**\n     * Creates new form foreLogin\n     */"}}
{"code": {"body": "    public static void main(String args[]) {\n        \n        \n        \n        try {\n            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {\n                if (\"\".equals(info.getName())) {\n                    javax.swing.UIManager.setLookAndFeel(info.getClassName());\n                    break;\n                }\n            }\n        } catch (ClassNotFoundException ex) {\n            java.util.logging.Logger.getLogger(foreLogin.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (InstantiationException ex) {\n            java.util.logging.Logger.getLogger(foreLogin.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (IllegalAccessException ex) {\n            java.util.logging.Logger.getLogger(foreLogin.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (javax.swing.UnsupportedLookAndFeelException ex) {\n            java.util.logging.Logger.getLogger(foreLogin.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        }\n        \n\n        \n        java.awt.EventQueue.invokeLater(new Runnable() {\n            public void run() {\n                new foreLogin().setVisible(true);\n            }\n        });\n    }", "comment": "/**\n     * @param args the command line arguments\n     */"}}
{"code": {"body": "public forereg() {\n        initComponents();\n    }", "comment": "/**\n     * Creates new form forereg\n     */"}}
{"code": {"body": "    public static void main(String args[]) {\n        \n        \n        \n        try {\n            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {\n                if (\"\".equals(info.getName())) {\n                    javax.swing.UIManager.setLookAndFeel(info.getClassName());\n                    break;\n                }\n            }\n        } catch (ClassNotFoundException ex) {\n            java.util.logging.Logger.getLogger(forereg.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (InstantiationException ex) {\n            java.util.logging.Logger.getLogger(forereg.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (IllegalAccessException ex) {\n            java.util.logging.Logger.getLogger(forereg.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (javax.swing.UnsupportedLookAndFeelException ex) {\n            java.util.logging.Logger.getLogger(forereg.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        }\n        \n\n        \n        java.awt.EventQueue.invokeLater(new Runnable() {\n            public void run() {\n                new forereg().setVisible(true);\n            }\n        });\n    }", "comment": "/**\n     * @param args the command line arguments\n     */"}}
{"code": {"body": "public guest_ui() {\n        initComponents();\n    }", "comment": "/**\n     * Creates new form guest_ui\n     */"}}
{"code": {"body": "    public static void main(String args[]) {\n        \n        \n        \n        try {\n            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {\n                if (\"\".equals(info.getName())) {\n                    javax.swing.UIManager.setLookAndFeel(info.getClassName());\n                    break;\n                }\n            }\n        } catch (ClassNotFoundException ex) {\n            java.util.logging.Logger.getLogger(guest_ui.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (InstantiationException ex) {\n            java.util.logging.Logger.getLogger(guest_ui.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (IllegalAccessException ex) {\n            java.util.logging.Logger.getLogger(guest_ui.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (javax.swing.UnsupportedLookAndFeelException ex) {\n            java.util.logging.Logger.getLogger(guest_ui.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        }\n        \n\n        \n        java.awt.EventQueue.invokeLater(new Runnable() {\n            public void run() {\n                new guest_ui().setVisible(true);\n            }\n        });\n    }", "comment": "/**\n     * @param args the command line arguments\n     */"}}
{"code": {"body": "public user_ui() {\n        initComponents();\n    }", "comment": "/**\n     * Creates new form user_ui\n     */"}}
{"code": {"body": "    public static void main(String args[]) {\n        \n        \n        \n        try {\n            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {\n                if (\"\".equals(info.getName())) {\n                    javax.swing.UIManager.setLookAndFeel(info.getClassName());\n                    break;\n                }\n            }\n        } catch (ClassNotFoundException ex) {\n            java.util.logging.Logger.getLogger(user_ui.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (InstantiationException ex) {\n            java.util.logging.Logger.getLogger(user_ui.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (IllegalAccessException ex) {\n            java.util.logging.Logger.getLogger(user_ui.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (javax.swing.UnsupportedLookAndFeelException ex) {\n            java.util.logging.Logger.getLogger(user_ui.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        }\n        \n\n        \n        java.awt.EventQueue.invokeLater(new Runnable() {\n            public void run() {\n                new user_ui().setVisible(true);\n            }\n        });\n    }", "comment": "/**\n     * @param args the command line arguments\n     */"}}
{"code": {"body": "public user_ui() {\n        initComponents();\n    }", "comment": "/**\n     * Creates new form user_ui\n     */"}}
{"code": {"body": "    public static void main(String args[]) {\n        \n        \n        \n        try {\n            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {\n                if (\"\".equals(info.getName())) {\n                    javax.swing.UIManager.setLookAndFeel(info.getClassName());\n                    break;\n                }\n            }\n        } catch (ClassNotFoundException ex) {\n            java.util.logging.Logger.getLogger(user_ui.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (InstantiationException ex) {\n            java.util.logging.Logger.getLogger(user_ui.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (IllegalAccessException ex) {\n            java.util.logging.Logger.getLogger(user_ui.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (javax.swing.UnsupportedLookAndFeelException ex) {\n            java.util.logging.Logger.getLogger(user_ui.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        }\n        \n\n        \n        java.awt.EventQueue.invokeLater(new Runnable() {\n            public void run() {\n                new user_ui().setVisible(true);\n            }\n        });\n    }", "comment": "/**\n     * @param args the command line arguments\n     */"}}
{"code": {"body": "    public static Charset toCharset(final String charset) {\n        return charset == null ? Charset.defaultCharset() : Charset.forName(charset);\n    }", "comment": "/**\n     * Returns a Charset for the named charset. If the name is null, return the default Charset.\n     *\n     * @param charset\n     *            The name of the requested charset, may be null.\n     * @return a Charset for the named charset\n     * @throws java.nio.charset.UnsupportedCharsetException\n     *             If the named charset is unavailable\n     */"}}
{"code": {"body": "public DecoderException() {\n        super();\n    }", "comment": "/**\n     * Constructs a new exception with <code>null</code> as its detail message. The cause is not initialized, and may\n     * subsequently be initialized by a call to {@link #initCause}.\n     *\n     * @since 1.4\n     */"}}
{"code": {"body": "public DecoderException(final String message) {\n        super(message);\n    }", "comment": "/**\n     * Constructs a new exception with the specified detail message. The cause is not initialized, and may subsequently\n     * be initialized by a call to {@link #initCause}.\n     *\n     * @param message\n     *            The detail message which is saved for later retrieval by the {@link #getMessage()} method.\n     */"}}
{"code": {"body": "public DecoderException(final String message, final Throwable cause) {\n        super(message, cause);\n    }", "comment": "/**\n     * Constructs a new exception with the specified detail message and cause.\n     * <p>\n     * Note that the detail message associated with <code>cause</code> is not automatically incorporated into this\n     * exception's detail message.\n     *\n     * @param message\n     *            The detail message which is saved for later retrieval by the {@link #getMessage()} method.\n     * @param cause\n     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A <code>null</code>\n     *            value is permitted, and indicates that the cause is nonexistent or unknown.\n     * @since 1.4\n     */"}}
{"code": {"body": "public DecoderException(final Throwable cause) {\n        super(cause);\n    }", "comment": "/**\n     * Constructs a new exception with the specified cause and a detail message of <code>(cause==null ?\n     * null : cause.toString())</code> (which typically contains the class and detail message of <code>cause</code>).\n     * This constructor is useful for exceptions that are little more than wrappers for other throwables.\n     *\n     * @param cause\n     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A <code>null</code>\n     *            value is permitted, and indicates that the cause is nonexistent or unknown.\n     * @since 1.4\n     */"}}
{"code": {"body": "public EncoderException() {\n        super();\n    }", "comment": "/**\n     * Constructs a new exception with <code>null</code> as its detail message. The cause is not initialized, and may\n     * subsequently be initialized by a call to {@link #initCause}.\n     *\n     * @since 1.4\n     */"}}
{"code": {"body": "public EncoderException(final String message) {\n        super(message);\n    }", "comment": "/**\n     * Constructs a new exception with the specified detail message. The cause is not initialized, and may subsequently\n     * be initialized by a call to {@link #initCause}.\n     *\n     * @param message\n     *            a useful message relating to the encoder specific error.\n     */"}}
{"code": {"body": "public EncoderException(final String message, final Throwable cause) {\n        super(message, cause);\n    }", "comment": "/**\n     * Constructs a new exception with the specified detail message and cause.\n     *\n     * <p>\n     * Note that the detail message associated with <code>cause</code> is not automatically incorporated into this\n     * exception's detail message.\n     * </p>\n     *\n     * @param message\n     *            The detail message which is saved for later retrieval by the {@link #getMessage()} method.\n     * @param cause\n     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A <code>null</code>\n     *            value is permitted, and indicates that the cause is nonexistent or unknown.\n     * @since 1.4\n     */"}}
{"code": {"body": "public EncoderException(final Throwable cause) {\n        super(cause);\n    }", "comment": "/**\n     * Constructs a new exception with the specified cause and a detail message of <code>(cause==null ?\n     * null : cause.toString())</code> (which typically contains the class and detail message of <code>cause</code>).\n     * This constructor is useful for exceptions that are little more than wrappers for other throwables.\n     *\n     * @param cause\n     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A <code>null</code>\n     *            value is permitted, and indicates that the cause is nonexistent or unknown.\n     * @since 1.4\n     */"}}
{"code": {"body": "public StringEncoderComparator(final StringEncoder stringEncoder) {\n        this.stringEncoder = stringEncoder;\n    }", "comment": "/**\n     * Constructs a new instance with the given algorithm.\n     *\n     * @param stringEncoder\n     *            the StringEncoder used for comparisons.\n     */"}}
{"code": {"body": "public Base32() {\n        this(false);\n    }", "comment": "/**\n     * Creates a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length is 0 (no chunking).\n     * </p>\n     *\n     */"}}
{"code": {"body": "public Base32(final byte pad) {\n        this(false, pad);\n    }", "comment": "/**\n     * Creates a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length is 0 (no chunking).\n     * </p>\n     * @param pad byte used as padding byte.\n     */"}}
{"code": {"body": "public Base32(final boolean useHex) {\n        this(0, null, useHex, PAD_DEFAULT);\n    }", "comment": "/**\n     * Creates a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length is 0 (no chunking).\n     * </p>\n     * @param useHex if {@code true} then use Base32 Hex alphabet\n     */"}}
{"code": {"body": "public Base32(final boolean useHex, final byte pad) {\n        this(0, null, useHex, pad);\n    }", "comment": "/**\n     * Creates a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length is 0 (no chunking).\n     * </p>\n     * @param useHex if {@code true} then use Base32 Hex alphabet\n     * @param pad byte used as padding byte.\n     */"}}
{"code": {"body": "public Base32(final int lineLength) {\n        this(lineLength, CHUNK_SEPARATOR);\n    }", "comment": "/**\n     * Creates a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length is given in the constructor, the line separator is CRLF.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     */"}}
{"code": {"body": "public Base32(final int lineLength, final byte[] lineSeparator) {\n        this(lineLength, lineSeparator, false, PAD_DEFAULT);\n    }", "comment": "/**\n     * Creates a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some Base32 characters. That's not going to work!\n     */"}}
{"code": {"body": "public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex) {\n        this(lineLength, lineSeparator, useHex, PAD_DEFAULT);\n    }", "comment": "/**\n     * Creates a Base32 / Base32 Hex codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param useHex\n     *            if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some Base32 characters. That's not going to work! Or the\n     *             lineLength &gt; 0 and lineSeparator is null.\n     */"}}
{"code": {"body": "public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex, final byte pad) {\n        super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK, lineLength,\n                lineSeparator == null ? 0 : lineSeparator.length, pad);\n        if (useHex) {\n            this.encodeTable = HEX_ENCODE_TABLE;\n            this.decodeTable = HEX_DECODE_TABLE;\n        } else {\n            this.encodeTable = ENCODE_TABLE;\n            this.decodeTable = DECODE_TABLE;\n        }\n        if (lineLength > 0) {\n            if (lineSeparator == null) {\n                throw new IllegalArgumentException(\"\" + lineLength + \"\");\n            }\n            \n            if (containsAlphabetOrPad(lineSeparator)) {\n                final String sep = StringUtils.newStringUtf8(lineSeparator);\n                throw new IllegalArgumentException(\"\" + sep + \"\");\n            }\n            this.encodeSize = BYTES_PER_ENCODED_BLOCK + lineSeparator.length;\n            this.lineSeparator = new byte[lineSeparator.length];\n            System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        } else {\n            this.encodeSize = BYTES_PER_ENCODED_BLOCK;\n            this.lineSeparator = null;\n        }\n        this.decodeSize = this.encodeSize - 1;\n\n        if (isInAlphabet(pad) || isWhiteSpace(pad)) {\n            throw new IllegalArgumentException(\"\");\n        }\n    }", "comment": "/**\n     * Creates a Base32 / Base32 Hex codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param useHex\n     *            if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet\n     * @param pad byte used as padding byte.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some Base32 characters. That's not going to work! Or the\n     *             lineLength &gt; 0 and lineSeparator is null.\n     */"}}
{"code": {"body": "public Base32InputStream(final InputStream in) {\n        this(in, false);\n    }", "comment": "/**\n     * Creates a Base32InputStream such that all data read is Base32-decoded from the original provided InputStream.\n     *\n     * @param in\n     *            InputStream to wrap.\n     */"}}
{"code": {"body": "public Base32InputStream(final InputStream in, final boolean doEncode) {\n        super(in, new Base32(false), doEncode);\n    }", "comment": "/**\n     * Creates a Base32InputStream such that all data read is either Base32-encoded or Base32-decoded from the original\n     * provided InputStream.\n     *\n     * @param in\n     *            InputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data read from us, false if we should decode.\n     */"}}
{"code": {"body": "public Base32InputStream(final InputStream in, final boolean doEncode)", "comment": "/**\n     * Creates a Base32InputStream such that all data read is either Base32-encoded or Base32-decoded from the original\n     * provided InputStream.\n     *\n     * @param in\n     *            InputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data read from us, false if we should decode.\n     */"}}
{"code": {"body": "public Base32OutputStream(final OutputStream out) {\n        this(out, true);\n    }", "comment": "/**\n     * Creates a Base32OutputStream such that all data written is Base32-encoded to the original provided OutputStream.\n     *\n     * @param out\n     *            OutputStream to wrap.\n     */"}}
{"code": {"body": "public Base32OutputStream(final OutputStream out, final boolean doEncode) {\n        super(out, new Base32(false), doEncode);\n    }", "comment": "/**\n     * Creates a Base32OutputStream such that all data written is either Base32-encoded or Base32-decoded to the\n     * original provided OutputStream.\n     *\n     * @param out\n     *            OutputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data written to us, false if we should decode.\n     */"}}
{"code": {"body": "public Base32OutputStream(final OutputStream out, final boolean doEncode)", "comment": "/**\n     * Creates a Base32OutputStream such that all data written is either Base32-encoded or Base32-decoded to the\n     * original provided OutputStream.\n     *\n     * @param out\n     *            OutputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data written to us, false if we should decode.\n     */"}}
{"code": {"body": "public Base64() {\n        this(0);\n    }", "comment": "/**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is 0 (no chunking), and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     *\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     */"}}
{"code": {"body": "public Base64(final boolean urlSafe) {\n        this(MIME_CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n    }", "comment": "/**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n     * <p>\n     * When encoding the line length is 76, the line separator is CRLF, and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     *\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     *\n     * @param urlSafe\n     *            if <code>true</code>, URL-safe encoding is used. In most cases this should be set to\n     *            <code>false</code>.\n     * @since 1.4\n     */"}}
{"code": {"body": "public Base64(final int lineLength) {\n        this(lineLength, CHUNK_SEPARATOR);\n    }", "comment": "/**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n     *            4). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     * @since 1.4\n     */"}}
{"code": {"body": "public Base64(final int lineLength, final byte[] lineSeparator) {\n        this(lineLength, lineSeparator, false);\n    }", "comment": "/**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n     *            4). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @throws IllegalArgumentException\n     *             Thrown when the provided lineSeparator included some base64 characters.\n     * @since 1.4\n     */"}}
{"code": {"body": "public Base64(final int lineLength, final byte[] lineSeparator, final boolean urlSafe) {\n        super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK,\n                lineLength,\n                lineSeparator == null ? 0 : lineSeparator.length);\n        \n        \n        if (lineSeparator != null) {\n            if (containsAlphabetOrPad(lineSeparator)) {\n                final String sep = StringUtils.newStringUtf8(lineSeparator);\n                throw new IllegalArgumentException(\"\" + sep + \"\");\n            }\n            if (lineLength > 0){ \n                this.encodeSize = BYTES_PER_ENCODED_BLOCK + lineSeparator.length;\n                this.lineSeparator = new byte[lineSeparator.length];\n                System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n            } else {\n                this.encodeSize = BYTES_PER_ENCODED_BLOCK;\n                this.lineSeparator = null;\n            }\n        } else {\n            this.encodeSize = BYTES_PER_ENCODED_BLOCK;\n            this.lineSeparator = null;\n        }\n        this.decodeSize = this.encodeSize - 1;\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n    }", "comment": "/**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n     *            4). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param urlSafe\n     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode\n     *            operations. Decoding seamlessly handles both modes.\n     *            <b>Note: no padding is added when using the URL-safe alphabet.</b>\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some base64 characters. That's not going to work!\n     * @since 1.4\n     */"}}
{"code": {"body": "    public boolean isUrlSafe() {\n        return this.encodeTable == URL_SAFE_ENCODE_TABLE;\n    }", "comment": "/**\n     * Returns our current encode mode. True if we're URL-SAFE, false otherwise.\n     *\n     * @return true if we're in URL-SAFE mode, false otherwise.\n     * @since 1.4\n     */"}}
{"code": {"body": "    public static boolean isBase64(final byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {\n                return false;\n            }\n        }\n        return true;\n    }", "comment": "/**\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the\n     * method treats whitespace as valid.\n     *\n     * @param arrayOctet\n     *            byte array to test\n     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;\n     *         <code>false</code>, otherwise\n     * @since 1.5\n     */"}}
{"code": {"body": "    public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked,\n                                      final boolean urlSafe, final int maxResultSize) {\n        if (binaryData == null || binaryData.length == 0) {\n            return binaryData;\n        }\n\n        \n        \n        final Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n        final long len = b64.getEncodedLength(binaryData);\n        if (len > maxResultSize) {\n            throw new IllegalArgumentException(\"\" +\n                len +\n                \"\" +\n                maxResultSize);\n        }\n\n        return b64.encode(binaryData);\n    }", "comment": "/**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     *\n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     *            <b>Note: no padding is added when encoding using the URL-safe alphabet.</b>\n     * @param maxResultSize\n     *            The maximum result size to accept.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than maxResultSize\n     * @since 1.4\n     */"}}
{"code": {"body": "    public static String encodeBase64String(final byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false));\n    }", "comment": "/**\n     * Encodes binary data using the base64 algorithm but does not chunk the output.\n     *\n     * NOTE:  We changed the behaviour of this method from multi-line chunking (commons-codec-1.4) to\n     * single-line non-chunking (commons-codec-1.5).\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters.\n     * @since 1.4 (NOTE:  1.4 chunked the output, whereas 1.5 does not).\n     */"}}
{"code": {"body": "    public static byte[] encodeBase64URLSafe(final byte[] binaryData) {\n        return encodeBase64(binaryData, false, true);\n    }", "comment": "/**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     * <b>Note: no padding is added.</b>\n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     * @since 1.4\n     */"}}
{"code": {"body": "    public static String encodeBase64URLSafeString(final byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n    }", "comment": "/**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     * <b>Note: no padding is added.</b>\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters\n     * @since 1.4\n     */"}}
{"code": {"body": "    public static byte[] encodeBase64Chunked(final byte[] binaryData) {\n        return encodeBase64(binaryData, true);\n    }", "comment": "/**\n     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return Base64 characters chunked in 76 character blocks\n     */"}}
{"code": {"body": "    public static byte[] decodeBase64(final byte[] base64Data) {\n        return new Base64().decode(base64Data);\n    }", "comment": "/**\n     * Decodes Base64 data into octets.\n     * <p>\n     * <b>Note:</b> this method seamlessly handles data encoded in URL-safe or normal mode.\n     * </p>\n     *\n     * @param base64Data\n     *            Byte array containing Base64 data\n     * @return Array containing decoded data.\n     */"}}
{"code": {"body": "    public static BigInteger decodeInteger(final byte[] pArray) {\n        return new BigInteger(1, decodeBase64(pArray));\n    }", "comment": "/**\n     * Decodes a byte64-encoded integer according to crypto standards such as W3C's XML-Signature.\n     *\n     * @param pArray\n     *            a byte array containing base64 character data\n     * @return A BigInteger\n     * @since 1.4\n     */"}}
{"code": {"body": "    public static byte[] encodeInteger(final BigInteger bigInt) {\n        if (bigInt == null) {\n            throw new NullPointerException(\"\");\n        }\n        return encodeBase64(toIntegerBytes(bigInt), false);\n    }", "comment": "/**\n     * Encodes to a byte64-encoded integer according to crypto standards such as W3C's XML-Signature.\n     *\n     * @param bigInt\n     *            a BigInteger\n     * @return A byte array containing base64 character data\n     * @throws NullPointerException\n     *             if null is passed in\n     * @since 1.4\n     */"}}
{"code": {"body": "    static byte[] toIntegerBytes(final BigInteger bigInt) {\n        int bitlen = bigInt.bitLength();\n        \n        bitlen = ((bitlen + 7) >> 3) << 3;\n        final byte[] bigBytes = bigInt.toByteArray();\n\n        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {\n            return bigBytes;\n        }\n        \n        int startSrc = 0;\n        int len = bigBytes.length;\n\n        \n        if ((bigInt.bitLength() % 8) == 0) {\n            startSrc = 1;\n            len--;\n        }\n        final int startDst = bitlen / 8 - len; \n        final byte[] resizedBytes = new byte[bitlen / 8];\n        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);\n        return resizedBytes;\n    }", "comment": "/**\n     * Returns a byte-array representation of a <code>BigInteger</code> without sign bit.\n     *\n     * @param bigInt\n     *            <code>BigInteger</code> to be converted\n     * @return a byte array representation of the BigInteger parameter\n     */"}}
{"code": {"body": "public Base64InputStream(final InputStream in) {\n        this(in, false);\n    }", "comment": "/**\n     * Creates a Base64InputStream such that all data read is Base64-decoded from the original provided InputStream.\n     *\n     * @param in\n     *            InputStream to wrap.\n     */"}}
{"code": {"body": "public Base64InputStream(final InputStream in, final boolean doEncode) {\n        super(in, new Base64(false), doEncode);\n    }", "comment": "/**\n     * Creates a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original\n     * provided InputStream.\n     *\n     * @param in\n     *            InputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data read from us, false if we should decode.\n     */"}}
{"code": {"body": "public Base64InputStream(final InputStream in, final boolean doEncode)", "comment": "/**\n     * Creates a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original\n     * provided InputStream.\n     *\n     * @param in\n     *            InputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data read from us, false if we should decode.\n     */"}}
{"code": {"body": "public Base64OutputStream(final OutputStream out) {\n        this(out, true);\n    }", "comment": "/**\n     * Creates a Base64OutputStream such that all data written is Base64-encoded to the original provided OutputStream.\n     *\n     * @param out\n     *            OutputStream to wrap.\n     */"}}
{"code": {"body": "public Base64OutputStream(final OutputStream out, final boolean doEncode) {\n        super(out,new Base64(false), doEncode);\n    }", "comment": "/**\n     * Creates a Base64OutputStream such that all data written is either Base64-encoded or Base64-decoded to the\n     * original provided OutputStream.\n     *\n     * @param out\n     *            OutputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data written to us, false if we should decode.\n     */"}}
{"code": {"body": "public Base64OutputStream(final OutputStream out, final boolean doEncode)", "comment": "/**\n     * Creates a Base64OutputStream such that all data written is either Base64-encoded or Base64-decoded to the\n     * original provided OutputStream.\n     *\n     * @param out\n     *            OutputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data written to us, false if we should decode.\n     */"}}
{"code": {"body": "    boolean hasData(final Context context) {  \n        return context.buffer != null;\n    }", "comment": "/**\n     * Returns true if this object has buffered data for reading.\n     *\n     * @param context the context to be used\n     * @return true if there is data still available for reading.\n     */"}}
{"code": {"body": "    int available(final Context context) {  \n        return context.buffer != null ? context.pos - context.readPos : 0;\n    }", "comment": "/**\n     * Returns the amount of buffered data available for reading.\n     *\n     * @param context the context to be used\n     * @return The amount of buffered data available for reading.\n     */"}}
{"code": {"body": "    protected int getDefaultBufferSize() {\n        return DEFAULT_BUFFER_SIZE;\n    }", "comment": "/**\n     * Get the default buffer size. Can be overridden.\n     *\n     * @return {@link #DEFAULT_BUFFER_SIZE}\n     */"}}
{"code": {"body": "    private byte[] resizeBuffer(final Context context) {\n        if (context.buffer == null) {\n            context.buffer = new byte[getDefaultBufferSize()];\n            context.pos = 0;\n            context.readPos = 0;\n        } else {\n            final byte[] b = new byte[context.buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];\n            System.arraycopy(context.buffer, 0, b, 0, context.buffer.length);\n            context.buffer = b;\n        }\n        return context.buffer;\n    }", "comment": "/**\n     * Increases our buffer by the {@link #DEFAULT_BUFFER_RESIZE_FACTOR}.\n     * @param context the context to be used\n     */"}}
{"code": {"body": "    protected byte[] ensureBufferSize(final int size, final Context context){\n        if ((context.buffer == null) || (context.buffer.length < context.pos + size)){\n            return resizeBuffer(context);\n        }\n        return context.buffer;\n    }", "comment": "/**\n     * Ensure that the buffer has room for <code>size</code> bytes\n     *\n     * @param size minimum spare space required\n     * @param context the context to be used\n     * @return the buffer\n     */"}}
{"code": {"body": "    int readResults(final byte[] b, final int bPos, final int bAvail, final Context context) {\n        if (context.buffer != null) {\n            final int len = Math.min(available(context), bAvail);\n            System.arraycopy(context.buffer, context.readPos, b, bPos, len);\n            context.readPos += len;\n            if (context.readPos >= context.pos) {\n                context.buffer = null; \n            }\n            return len;\n        }\n        return context.eof ? EOF : 0;\n    }", "comment": "/**\n     * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail\n     * bytes. Returns how many bytes were actually extracted.\n     * <p>\n     * Package protected for access from I/O streams.\n     *\n     * @param b\n     *            byte[] array to extract the buffered data into.\n     * @param bPos\n     *            position in byte[] array to start extraction at.\n     * @param bAvail\n     *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).\n     * @param context\n     *            the context to be used\n     * @return The number of bytes successfully extracted into the provided byte[] array.\n     */"}}
{"code": {"body": "    protected static boolean isWhiteSpace(final byte byteToCheck) {\n        switch (byteToCheck) {\n            case '' :\n            case '' :\n            case '' :\n            case '' :\n                return true;\n            default :\n                return false;\n        }\n    }", "comment": "/**\n     * Checks if a byte value is whitespace or not.\n     * Whitespace is taken to mean: space, tab, CR, LF\n     * @param byteToCheck\n     *            the byte to check\n     * @return true if byte is whitespace, false otherwise\n     */"}}
{"code": {"body": "    public String encodeToString(final byte[] pArray) {\n        return StringUtils.newStringUtf8(encode(pArray));\n    }", "comment": "/**\n     * Encodes a byte[] containing binary data, into a String containing characters in the Base-N alphabet.\n     * Uses UTF8 encoding.\n     *\n     * @param pArray\n     *            a byte array containing binary data\n     * @return A String containing only Base-N character data\n     */"}}
{"code": {"body": "    public String encodeAsString(final byte[] pArray){\n        return StringUtils.newStringUtf8(encode(pArray));\n    }", "comment": "/**\n     * Encodes a byte[] containing binary data, into a String containing characters in the appropriate alphabet.\n     * Uses UTF8 encoding.\n     *\n     * @param pArray a byte array containing binary data\n     * @return String containing only character data in the appropriate alphabet.\n    */"}}
{"code": {"body": "    public boolean isInAlphabet(final String basen) {\n        return isInAlphabet(StringUtils.getBytesUtf8(basen), true);\n    }", "comment": "/**\n     * Tests a given String to see if it contains only valid characters within the alphabet.\n     * The method treats whitespace and PAD as valid.\n     *\n     * @param basen String to test\n     * @return <code>true</code> if all characters in the String are valid characters in the alphabet or if\n     *         the String is empty; <code>false</code>, otherwise\n     * @see #isInAlphabet(byte[], boolean)\n     */"}}
{"code": {"body": "    protected boolean containsAlphabetOrPad(final byte[] arrayOctet) {\n        if (arrayOctet == null) {\n            return false;\n        }\n        for (final byte element : arrayOctet) {\n            if (pad == element || isInAlphabet(element)) {\n                return true;\n            }\n        }\n        return false;\n    }", "comment": "/**\n     * Tests a given byte array to see if it contains any characters within the alphabet or PAD.\n     *\n     * Intended for use in checking line-ending arrays\n     *\n     * @param arrayOctet\n     *            byte array to test\n     * @return <code>true</code> if any byte is a valid character in the alphabet or PAD; <code>false</code> otherwise\n     */"}}
{"code": {"body": "    public long getEncodedLength(final byte[] pArray) {\n        \n        \n        long len = ((pArray.length + unencodedBlockSize-1)  / unencodedBlockSize) * (long) encodedBlockSize;\n        if (lineLength > 0) { \n            \n            len += ((len + lineLength-1) / lineLength) * chunkSeparatorLength;\n        }\n        return len;\n    }", "comment": "/**\n     * Calculates the amount of space needed to encode the supplied array.\n     *\n     * @param pArray byte[] array which will later be encoded\n     *\n     * @return amount of space needed to encoded the supplied array.\n     * Returns a long since a max-len array will require &gt; Integer.MAX_VALUE\n     */"}}
{"code": {"body": "    public byte[] toByteArray(final String ascii) {\n        if (ascii == null) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        return fromAscii(ascii.toCharArray());\n    }", "comment": "/**\n     * Decodes a String where each char of the String represents an ASCII '0' or '1'.\n     *\n     * @param ascii\n     *                  String of '0' and '1' characters\n     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument\n     * @see org.apache.commons.codec.Decoder#decode(Object)\n     */"}}
{"code": {"body": "    public static byte[] fromAscii(final byte[] ascii) {\n        if (isEmpty(ascii)) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        \n        final byte[] l_raw = new byte[ascii.length >> 3];\n        \n        for (int ii = 0, jj = ascii.length - 1; ii < l_raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if (ascii[jj - bits] == '') {\n                    l_raw[ii] |= BITS[bits];\n                }\n            }\n        }\n        return l_raw;\n    }", "comment": "/**\n     * Decodes a byte array where each byte represents an ASCII '0' or '1'.\n     *\n     * @param ascii\n     *                  each byte represents an ASCII '0' or '1'\n     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument\n     */"}}
{"code": {"body": "    private static boolean isEmpty(final byte[] array) {\n        return array == null || array.length == 0;\n    }", "comment": "/**\n     * Returns <code>true</code> if the given array is <code>null</code> or empty (size 0.)\n     *\n     * @param array\n     *            the source array\n     * @return <code>true</code> if the given array is <code>null</code> or empty (size 0.)\n     */"}}
{"code": {"body": "    public static byte[] toAsciiBytes(final byte[] raw) {\n        if (isEmpty(raw)) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        \n        final byte[] l_ascii = new byte[raw.length << 3];\n        \n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\n                    l_ascii[jj - bits] = '';\n                } else {\n                    l_ascii[jj - bits] = '';\n                }\n            }\n        }\n        return l_ascii;\n    }", "comment": "/**\n     * Converts an array of raw binary data into an array of ASCII 0 and 1 character bytes - each byte is a truncated\n     * char.\n     *\n     * @param raw\n     *                  the raw binary data to convert\n     * @return an array of 0 and 1 character bytes for each bit of the argument\n     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])\n     */"}}
{"code": {"body": "    public static char[] toAsciiChars(final byte[] raw) {\n        if (isEmpty(raw)) {\n            return EMPTY_CHAR_ARRAY;\n        }\n        \n        final char[] l_ascii = new char[raw.length << 3];\n        \n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\n                    l_ascii[jj - bits] = '';\n                } else {\n                    l_ascii[jj - bits] = '';\n                }\n            }\n        }\n        return l_ascii;\n    }", "comment": "/**\n     * Converts an array of raw binary data into an array of ASCII 0 and 1 characters.\n     *\n     * @param raw\n     *                  the raw binary data to convert\n     * @return an array of 0 and 1 characters for each bit of the argument\n     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])\n     */"}}
{"code": {"body": "    public static String toAsciiString(final byte[] raw) {\n        return new String(toAsciiChars(raw));\n    }", "comment": "/**\n     * Converts an array of raw binary data into a String of ASCII 0 and 1 characters.\n     *\n     * @param raw\n     *                  the raw binary data to convert\n     * @return a String of 0 and 1 characters representing the binary data\n     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])\n     */"}}
{"code": {"body": "    static boolean regionMatches(final CharSequence cs, final boolean ignoreCase, final int thisStart,\n            final CharSequence substring, final int start, final int length) {\n        if (cs instanceof String && substring instanceof String) {\n            return ((String) cs).regionMatches(ignoreCase, thisStart, (String) substring, start, length);\n        }\n        int index1 = thisStart;\n        int index2 = start;\n        int tmpLen = length;\n\n        while (tmpLen-- > 0) {\n            char c1 = cs.charAt(index1++);\n            char c2 = substring.charAt(index2++);\n\n            if (c1 == c2) {\n                continue;\n            }\n\n            if (!ignoreCase) {\n                return false;\n            }\n\n            \n            if (Character.toUpperCase(c1) != Character.toUpperCase(c2) &&\n                    Character.toLowerCase(c1) != Character.toLowerCase(c2)) {\n                return false;\n            }\n        }\n\n        return true;\n    }", "comment": "/**\n     * Green implementation of regionMatches.\n     *\n     * @param cs\n     *            the <code>CharSequence</code> to be processed\n     * @param ignoreCase\n     *            whether or not to be case insensitive\n     * @param thisStart\n     *            the index to start on the <code>cs</code> CharSequence\n     * @param substring\n     *            the <code>CharSequence</code> to be looked for\n     * @param start\n     *            the index to start on the <code>substring</code> CharSequence\n     * @param length\n     *            character length of the region\n     * @return whether the region matched\n     */"}}
{"code": {"body": "public Hex() {\n        \n        this.charset = DEFAULT_CHARSET;\n    }", "comment": "/**\n     * Creates a new codec with the default charset name {@link #DEFAULT_CHARSET}\n     */"}}
{"code": {"body": "public Hex(final Charset charset) {\n        this.charset = charset;\n    }", "comment": "/**\n     * Creates a new codec with the given Charset.\n     *\n     * @param charset\n     *            the charset.\n     * @since 1.7\n     */"}}
{"code": {"body": "public Hex(final String charsetName) {\n        this(Charset.forName(charsetName));\n    }", "comment": "/**\n     * Creates a new codec with the given charset name.\n     *\n     * @param charsetName\n     *            the charset name.\n     * @throws java.nio.charset.UnsupportedCharsetException\n     *             If the named charset is unavailable\n     * @since 1.4\n     * @since 1.7 throws UnsupportedCharsetException if the named charset is unavailable\n     */"}}
{"code": {"body": "    public static byte[] decodeHex(final char[] data) throws DecoderException {\n\n        final int len = data.length;\n\n        if ((len & 0x01) != 0) {\n            throw new DecoderException(\"\");\n        }\n\n        final byte[] out = new byte[len >> 1];\n\n        \n        for (int i = 0, j = 0; j < len; i++) {\n            int f = toDigit(data[j], j) << 4;\n            j++;\n            f = f | toDigit(data[j], j);\n            j++;\n            out[i] = (byte) (f & 0xFF);\n        }\n\n        return out;\n    }", "comment": "/**\n     * Converts an array of characters representing hexadecimal values into an array of bytes of those same values. The\n     * returned array will be half the length of the passed array, as it takes two characters to represent any given\n     * byte. An exception is thrown if the passed char array has an odd number of elements.\n     *\n     * @param data\n     *            An array of characters containing hexadecimal digits\n     * @return A byte array containing binary data decoded from the supplied char array.\n     * @throws DecoderException\n     *             Thrown if an odd number or illegal of characters is supplied\n     */"}}
{"code": {"body": "    protected static char[] encodeHex(final byte[] data, final char[] toDigits) {\n        final int l = data.length;\n        final char[] out = new char[l << 1];\n        \n        for (int i = 0, j = 0; i < l; i++) {\n            out[j++] = toDigits[(0xF0 & data[i]) >>> 4];\n            out[j++] = toDigits[0x0F & data[i]];\n        }\n        return out;\n    }", "comment": "/**\n     * Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.\n     * The returned array will be double the length of the passed array, as it takes two characters to represent any\n     * given byte.\n     *\n     * @param data\n     *            a byte[] to convert to Hex characters\n     * @param toDigits\n     *            the output alphabet\n     * @return A char[] containing hexadecimal characters\n     * @since 1.4\n     */"}}
{"code": {"body": "    public static String encodeHexString(final byte[] data) {\n        return new String(encodeHex(data));\n    }", "comment": "/**\n     * Converts an array of bytes into a String representing the hexadecimal values of each byte in order. The returned\n     * String will be double the length of the passed array, as it takes two characters to represent any given byte.\n     *\n     * @param data\n     *            a byte[] to convert to Hex characters\n     * @return A String containing hexadecimal characters\n     * @since 1.4\n     */"}}
{"code": {"body": "    protected static int toDigit(final char ch, final int index) throws DecoderException {\n        final int digit = Character.digit(ch, 16);\n        if (digit == -1) {\n            throw new DecoderException(\"\" + ch + \"\" + index);\n        }\n        return digit;\n    }", "comment": "/**\n     * Converts a hexadecimal character to an integer.\n     *\n     * @param ch\n     *            A character to convert to an integer digit\n     * @param index\n     *            The index of the character in the source\n     * @return An integer\n     * @throws DecoderException\n     *             Thrown if ch is an illegal hex character\n     */"}}
{"code": {"body": "    public Charset getCharset() {\n        return this.charset;\n    }", "comment": "/**\n     * Gets the charset.\n     *\n     * @return the charset.\n     * @since 1.7\n     */"}}
{"code": {"body": "    public String getCharsetName() {\n        return this.charset.name();\n    }", "comment": "/**\n     * Gets the charset name.\n     *\n     * @return the charset name.\n     * @since 1.4\n     */"}}
{"code": {"body": "    public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n        if (cs1 == cs2) {\n            return true;\n        }\n        if (cs1 == null || cs2 == null) {\n            return false;\n        }\n        if (cs1 instanceof String && cs2 instanceof String) {\n            return cs1.equals(cs2);\n        }\n        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n    }", "comment": "/**\n     * <p>\n     * Compares two CharSequences, returning <code>true</code> if they represent equal sequences of characters.\n     * </p>\n     *\n     * <p>\n     * <code>null</code>s are handled without exceptions. Two <code>null</code> references are considered to be equal.\n     * The comparison is case sensitive.\n     * </p>\n     *\n     * <pre>\n     * StringUtils.equals(null, null)   = true\n     * StringUtils.equals(null, \"abc\")  = false\n     * StringUtils.equals(\"abc\", null)  = false\n     * StringUtils.equals(\"abc\", \"abc\") = true\n     * StringUtils.equals(\"abc\", \"ABC\") = false\n     * </pre>\n     *\n     * <p>\n     * Copied from Apache Commons Lang r1583482 on April 10, 2014 (day of 3.3.2 release).\n     * </p>\n     *\n     * @see Object#equals(Object)\n     * @param cs1\n     *            the first CharSequence, may be <code>null</code>\n     * @param cs2\n     *            the second CharSequence, may be <code>null</code>\n     * @return <code>true</code> if the CharSequences are equal (case-sensitive), or both <code>null</code>\n     * @since 1.10\n     */"}}
{"code": {"body": "    private static byte[] getBytes(final String string, final Charset charset) {\n        if (string == null) {\n            return null;\n        }\n        return string.getBytes(charset);\n    }", "comment": "/**\n     * Calls {@link String#getBytes(Charset)}\n     *\n     * @param string\n     *            The string to encode (if null, return null).\n     * @param charset\n     *            The {@link Charset} to encode the <code>String</code>\n     * @return the encoded bytes\n     */"}}
{"code": {"body": "    public static byte[] getBytesIso8859_1(final String string) {\n        return getBytes(string, Charsets.ISO_8859_1);\n    }", "comment": "/**\n     * Encodes the given string into a sequence of bytes using the ISO-8859-1 charset, storing the result into a new\n     * byte array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */"}}
{"code": {"body": "    public static byte[] getBytesUnchecked(final String string, final String charsetName) {\n        if (string == null) {\n            return null;\n        }\n        try {\n            return string.getBytes(charsetName);\n        } catch (final UnsupportedEncodingException e) {\n            throw StringUtils.newIllegalStateException(charsetName, e);\n        }\n    }", "comment": "/**\n     * Encodes the given string into a sequence of bytes using the named charset, storing the result into a new byte\n     * array.\n     * <p>\n     * This method catches {@link UnsupportedEncodingException} and rethrows it as {@link IllegalStateException}, which\n     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.\n     * </p>\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @param charsetName\n     *            The name of a required {@link java.nio.charset.Charset}\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws IllegalStateException\n     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a\n     *             required charset name.\n     * @see CharEncoding\n     * @see String#getBytes(String)\n     */"}}
{"code": {"body": "    public static byte[] getBytesUsAscii(final String string) {\n        return getBytes(string, Charsets.US_ASCII);\n    }", "comment": "/**\n     * Encodes the given string into a sequence of bytes using the US-ASCII charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#US_ASCII} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */"}}
{"code": {"body": "    public static byte[] getBytesUtf16(final String string) {\n        return getBytes(string, Charsets.UTF_16);\n    }", "comment": "/**\n     * Encodes the given string into a sequence of bytes using the UTF-16 charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */"}}
{"code": {"body": "    public static byte[] getBytesUtf16Be(final String string) {\n        return getBytes(string, Charsets.UTF_16BE);\n    }", "comment": "/**\n     * Encodes the given string into a sequence of bytes using the UTF-16BE charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16BE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */"}}
{"code": {"body": "    public static byte[] getBytesUtf16Le(final String string) {\n        return getBytes(string, Charsets.UTF_16LE);\n    }", "comment": "/**\n     * Encodes the given string into a sequence of bytes using the UTF-16LE charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16LE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */"}}
{"code": {"body": "    public static byte[] getBytesUtf8(final String string) {\n        return getBytes(string, Charsets.UTF_8);\n    }", "comment": "/**\n     * Encodes the given string into a sequence of bytes using the UTF-8 charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */"}}
{"code": {"body": "    public static String newString(final byte[] bytes, final String charsetName) {\n        if (bytes == null) {\n            return null;\n        }\n        try {\n            return new String(bytes, charsetName);\n        } catch (final UnsupportedEncodingException e) {\n            throw StringUtils.newIllegalStateException(charsetName, e);\n        }\n    }", "comment": "/**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the given charset.\n     * <p>\n     * This method catches {@link UnsupportedEncodingException} and re-throws it as {@link IllegalStateException}, which\n     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.\n     * </p>\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters, may be <code>null</code>\n     * @param charsetName\n     *            The name of a required {@link java.nio.charset.Charset}\n     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws IllegalStateException\n     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a\n     *             required charset name.\n     * @see CharEncoding\n     * @see String#String(byte[], String)\n     */"}}
{"code": {"body": "    public static String newStringIso8859_1(final byte[] bytes) {\n        return new String(bytes, Charsets.ISO_8859_1);\n    }", "comment": "/**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters, may be <code>null</code>\n     * @return A new <code>String</code> decoded from the specified array of bytes using the ISO-8859-1 charset, or\n     *         <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */"}}
{"code": {"body": "    public static String newStringUsAscii(final byte[] bytes) {\n        return new String(bytes, Charsets.US_ASCII);\n    }", "comment": "/**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the US-ASCII charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#US_ASCII} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */"}}
{"code": {"body": "    public static String newStringUtf16(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16);\n    }", "comment": "/**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16 charset\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */"}}
{"code": {"body": "    public static String newStringUtf16Be(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16BE);\n    }", "comment": "/**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16BE charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16BE charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16BE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */"}}
{"code": {"body": "    public static String newStringUtf16Le(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16LE);\n    }", "comment": "/**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16LE charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16LE charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16LE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */"}}
{"code": {"body": "    public static String newStringUtf8(final byte[] bytes) {\n        return newString(bytes, Charsets.UTF_8);\n    }", "comment": "/**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-8 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-8 charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */"}}
{"code": {"body": "    static void b64from24bit(final byte b2, final byte b1, final byte b0, final int outLen,\n                             final StringBuilder buffer) {\n        \n        int w = ((b2 << 16) & 0x00ffffff) | ((b1 << 8) & 0x00ffff) | (b0 & 0xff);\n        \n        int n = outLen;\n        while (n-- > 0) {\n            buffer.append(B64T.charAt(w & 0x3f));\n            w >>= 6;\n        }\n    }", "comment": "/**\n     * Base64 like conversion of bytes to ASCII chars.\n     *\n     * @param b2\n     *            A byte from the result.\n     * @param b1\n     *            A byte from the result.\n     * @param b0\n     *            A byte from the result.\n     * @param outLen\n     *            The number of expected output chars.\n     * @param buffer\n     *            Where the output chars is appended to.\n     */"}}
{"code": {"body": "    static String getRandomSalt(final int num) {\n        final StringBuilder saltString = new StringBuilder();\n        for (int i = 1; i <= num; i++) {\n            saltString.append(B64T.charAt(new Random().nextInt(B64T.length())));\n        }\n        return saltString.toString();\n    }", "comment": "/**\n     * Generates a string of random chars from the B64T set.\n     *\n     * @param num\n     *            Number of chars to generate.\n     */"}}
{"code": {"body": "    public static String crypt(final String key, final String salt) {\n        return crypt(key.getBytes(Charsets.UTF_8), salt);\n    }", "comment": "/**\n     * Encrypts a password in a crypt(3) compatible way.\n     * <p>\n     * The exact algorithm depends on the format of the salt string:\n     * <ul>\n     * <li>SHA-512 salts start with {@code $6$} and are up to 16 chars long.\n     * <li>SHA-256 salts start with {@code $5$} and are up to 16 chars long\n     * <li>MD5 salts start with {@code $1$} and are up to 8 chars long\n     * <li>DES, the traditional UnixCrypt algorithm is used with only 2 chars\n     * <li>Only the first 8 chars of the passwords are used in the DES algorithm!\n     * </ul>\n     * The magic strings {@code \"$apr1$\"} and {@code \"$2a$\"} are not recognized by this method as its output should be\n     * identical with that of the libc implementation.\n     * <p>\n     * The rest of the salt string is drawn from the set {@code [a-zA-Z0-9./]} and is cut at the maximum length of if a\n     * {@code \"$\"} sign is encountered. It is therefore valid to enter a complete hash value as salt to e.g. verify a\n     * password with:\n     *\n     * <pre>\n     * storedPwd.equals(crypt(enteredPwd, storedPwd))\n     * </pre>\n     * <p>\n     * The resulting string starts with the marker string ({@code $6$}), continues with the salt value and ends with a\n     * {@code \"$\"} sign followed by the actual hash value. For DES the string only contains the salt and actual hash.\n     * It's total length is dependent on the algorithm used:\n     * <ul>\n     * <li>SHA-512: 106 chars\n     * <li>SHA-256: 63 chars\n     * <li>MD5: 34 chars\n     * <li>DES: 13 chars\n     * </ul>\n     * <p>\n     * Example:\n     *\n     * <pre>\n     *      crypt(\"secret\", \"$1$xxxx\") =&gt; \"$1$xxxx$aMkevjfEIpa35Bh3G4bAc.\"\n     *      crypt(\"secret\", \"xx\") =&gt; \"xxWAum7tHdIUw\"\n     * </pre>\n     * <p>\n     * This method comes in a variation that accepts a byte[] array to support input strings that are not encoded in\n     * UTF-8 but e.g. in ISO-8859-1 where equal characters result in different byte values.\n     *\n     * @see \"The man page of the libc crypt (3) function.\"\n     * @param key\n     *            plaintext password as entered by the used\n     * @param salt\n     *            salt value\n     * @return hash value, i.e. encrypted password including the salt string\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     * @throws RuntimeException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught. *\n     */"}}
{"code": {"body": "    private static byte[] digest(final MessageDigest digest, final InputStream data) throws IOException {\n        return updateDigest(digest, data).digest();\n    }", "comment": "/**\n     * Read through an InputStream and returns the digest for the data\n     *\n     * @param digest\n     *            The MessageDigest to use (e.g. MD5)\n     * @param data\n     *            Data to digest\n     * @return the digest\n     * @throws IOException\n     *             On error reading from the stream\n     */"}}
{"code": {"body": "    public static MessageDigest getDigest(final String algorithm) {\n        try {\n            return MessageDigest.getInstance(algorithm);\n        } catch (final NoSuchAlgorithmException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }", "comment": "/**\n     * Returns a <code>MessageDigest</code> for the given <code>algorithm</code>.\n     *\n     * @param algorithm\n     *            the name of the algorithm requested. See <a\n     *            href=\"http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA\"\n     *            >Appendix A in the Java Cryptography Architecture Reference Guide</a> for information about standard\n     *            algorithm names.\n     * @return A digest instance.\n     * @see MessageDigest#getInstance(String)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught.\n     */"}}
{"code": {"body": "    public static MessageDigest getMd2Digest() {\n        return getDigest(MessageDigestAlgorithms.MD2);\n    }", "comment": "/**\n     * Returns an MD2 MessageDigest.\n     *\n     * @return An MD2 digest instance.\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught, which should never happen because MD2 is a\n     *             built-in algorithm\n     * @see MessageDigestAlgorithms#MD2\n     * @since 1.7\n     */"}}
{"code": {"body": "    public static MessageDigest getMd5Digest() {\n        return getDigest(MessageDigestAlgorithms.MD5);\n    }", "comment": "/**\n     * Returns an MD5 MessageDigest.\n     *\n     * @return An MD5 digest instance.\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught, which should never happen because MD5 is a\n     *             built-in algorithm\n     * @see MessageDigestAlgorithms#MD5\n     */"}}
{"code": {"body": "    public static MessageDigest getSha1Digest() {\n        return getDigest(MessageDigestAlgorithms.SHA_1);\n    }", "comment": "/**\n     * Returns an SHA-1 digest.\n     *\n     * @return An SHA-1 digest instance.\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught, which should never happen because SHA-1 is a\n     *             built-in algorithm\n     * @see MessageDigestAlgorithms#SHA_1\n     * @since 1.7\n     */"}}
{"code": {"body": "    public static MessageDigest getSha256Digest() {\n        return getDigest(MessageDigestAlgorithms.SHA_256);\n    }", "comment": "/**\n     * Returns an SHA-256 digest.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @return An SHA-256 digest instance.\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught, which should never happen because SHA-256 is a\n     *             built-in algorithm\n     * @see MessageDigestAlgorithms#SHA_256\n     */"}}
{"code": {"body": "    public static MessageDigest getSha384Digest() {\n        return getDigest(MessageDigestAlgorithms.SHA_384);\n    }", "comment": "/**\n     * Returns an SHA-384 digest.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @return An SHA-384 digest instance.\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught, which should never happen because SHA-384 is a\n     *             built-in algorithm\n     * @see MessageDigestAlgorithms#SHA_384\n     */"}}
{"code": {"body": "    public static MessageDigest getSha512Digest() {\n        return getDigest(MessageDigestAlgorithms.SHA_512);\n    }", "comment": "/**\n     * Returns an SHA-512 digest.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @return An SHA-512 digest instance.\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught, which should never happen because SHA-512 is a\n     *             built-in algorithm\n     * @see MessageDigestAlgorithms#SHA_512\n     */"}}
{"code": {"body": "    public static byte[] md2(final String data) {\n        return md2(StringUtils.getBytesUtf8(data));\n    }", "comment": "/**\n     * Calculates the MD2 digest and returns the value as a 16 element <code>byte[]</code>.\n     *\n     * @param data\n     *            Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return MD2 digest\n     * @since 1.7\n     */"}}
{"code": {"body": "    public static String md2Hex(final String data) {\n        return Hex.encodeHexString(md2(data));\n    }", "comment": "/**\n     * Calculates the MD2 digest and returns the value as a 32 character hex string.\n     *\n     * @param data\n     *            Data to digest\n     * @return MD2 digest as a hex string\n     * @since 1.7\n     */"}}
{"code": {"body": "    public static byte[] md5(final String data) {\n        return md5(StringUtils.getBytesUtf8(data));\n    }", "comment": "/**\n     * Calculates the MD5 digest and returns the value as a 16 element <code>byte[]</code>.\n     *\n     * @param data\n     *            Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return MD5 digest\n     */"}}
{"code": {"body": "    public static String md5Hex(final String data) {\n        return Hex.encodeHexString(md5(data));\n    }", "comment": "/**\n     * Calculates the MD5 digest and returns the value as a 32 character hex string.\n     *\n     * @param data\n     *            Data to digest\n     * @return MD5 digest as a hex string\n     */"}}
{"code": {"body": "    public static byte[] sha1(final String data) {\n        return sha1(StringUtils.getBytesUtf8(data));\n    }", "comment": "/**\n     * Calculates the SHA-1 digest and returns the value as a <code>byte[]</code>.\n     *\n     * @param data\n     *            Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return SHA-1 digest\n     */"}}
{"code": {"body": "    public static String sha1Hex(final String data) {\n        return Hex.encodeHexString(sha1(data));\n    }", "comment": "/**\n     * Calculates the SHA-1 digest and returns the value as a hex string.\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-1 digest as a hex string\n     * @since 1.7\n     */"}}
{"code": {"body": "    public static byte[] sha256(final String data) {\n        return sha256(StringUtils.getBytesUtf8(data));\n    }", "comment": "/**\n     * Calculates the SHA-256 digest and returns the value as a <code>byte[]</code>.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return SHA-256 digest\n     * @since 1.4\n     */"}}
{"code": {"body": "    public static String sha256Hex(final String data) {\n        return Hex.encodeHexString(sha256(data));\n    }", "comment": "/**\n     * Calculates the SHA-256 digest and returns the value as a hex string.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-256 digest as a hex string\n     * @since 1.4\n     */"}}
{"code": {"body": "    public static byte[] sha384(final String data) {\n        return sha384(StringUtils.getBytesUtf8(data));\n    }", "comment": "/**\n     * Calculates the SHA-384 digest and returns the value as a <code>byte[]</code>.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return SHA-384 digest\n     * @since 1.4\n     */"}}
{"code": {"body": "    public static String sha384Hex(final String data) {\n        return Hex.encodeHexString(sha384(data));\n    }", "comment": "/**\n     * Calculates the SHA-384 digest and returns the value as a hex string.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-384 digest as a hex string\n     * @since 1.4\n     */"}}
{"code": {"body": "    public static byte[] sha512(final String data) {\n        return sha512(StringUtils.getBytesUtf8(data));\n    }", "comment": "/**\n     * Calculates the SHA-512 digest and returns the value as a <code>byte[]</code>.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return SHA-512 digest\n     * @since 1.4\n     */"}}
{"code": {"body": "    public static String sha512Hex(final String data) {\n        return Hex.encodeHexString(sha512(data));\n    }", "comment": "/**\n     * Calculates the SHA-512 digest and returns the value as a hex string.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-512 digest as a hex string\n     * @since 1.4\n     */"}}
{"code": {"body": "    public static MessageDigest updateDigest(final MessageDigest messageDigest, final String valueToDigest) {\n        messageDigest.update(StringUtils.getBytesUtf8(valueToDigest));\n        return messageDigest;\n    }", "comment": "/**\n     * Updates the given {@link MessageDigest}.\n     *\n     * @param messageDigest\n     *            the {@link MessageDigest} to update\n     * @param valueToDigest\n     *            the value to update the {@link MessageDigest} with;\n     *            converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return the updated {@link MessageDigest}\n     * @since 1.7\n     */"}}
{"code": {"body": "    public static Mac getHmacMd5(final byte[] key) {\n        return getInitializedMac(HmacAlgorithms.HMAC_MD5, key);\n    }", "comment": "/**\n     * Returns an initialized <code>Mac</code> for the HmacMD5 algorithm.\n     * <p>\n     * Every implementation of the Java platform is required to support this standard Mac algorithm.\n     * </p>\n     *\n     * @param key\n     *            They key for the keyed digest (must not be null)\n     * @return A Mac instance initialized with the given key.\n     * @see Mac#getInstance(String)\n     * @see Mac#init(Key)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     */"}}
{"code": {"body": "    public static Mac getHmacSha1(final byte[] key) {\n        return getInitializedMac(HmacAlgorithms.HMAC_SHA_1, key);\n    }", "comment": "/**\n     * Returns an initialized <code>Mac</code> for the HmacSHA1 algorithm.\n     * <p>\n     * Every implementation of the Java platform is required to support this standard Mac algorithm.\n     * </p>\n     *\n     * @param key\n     *            They key for the keyed digest (must not be null)\n     * @return A Mac instance initialized with the given key.\n     * @see Mac#getInstance(String)\n     * @see Mac#init(Key)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     */"}}
{"code": {"body": "    public static Mac getHmacSha256(final byte[] key) {\n        return getInitializedMac(HmacAlgorithms.HMAC_SHA_256, key);\n    }", "comment": "/**\n     * Returns an initialized <code>Mac</code> for the HmacSHA256 algorithm.\n     * <p>\n     * Every implementation of the Java platform is required to support this standard Mac algorithm.\n     * </p>\n     *\n     * @param key\n     *            They key for the keyed digest (must not be null)\n     * @return A Mac instance initialized with the given key.\n     * @see Mac#getInstance(String)\n     * @see Mac#init(Key)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     */"}}
{"code": {"body": "    public static Mac getHmacSha384(final byte[] key) {\n        return getInitializedMac(HmacAlgorithms.HMAC_SHA_384, key);\n    }", "comment": "/**\n     * Returns an initialized <code>Mac</code> for the HmacSHA384 algorithm.\n     * <p>\n     * Every implementation of the Java platform is <em>not</em> required to support this Mac algorithm.\n     * </p>\n     *\n     * @param key\n     *            They key for the keyed digest (must not be null)\n     * @return A Mac instance initialized with the given key.\n     * @see Mac#getInstance(String)\n     * @see Mac#init(Key)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     */"}}
{"code": {"body": "    public static Mac getHmacSha512(final byte[] key) {\n        return getInitializedMac(HmacAlgorithms.HMAC_SHA_512, key);\n    }", "comment": "/**\n     * Returns an initialized <code>Mac</code> for the HmacSHA512 algorithm.\n     * <p>\n     * Every implementation of the Java platform is <em>not</em> required to support this Mac algorithm.\n     * </p>\n     *\n     * @param key\n     *            They key for the keyed digest (must not be null)\n     * @return A Mac instance initialized with the given key.\n     * @see Mac#getInstance(String)\n     * @see Mac#init(Key)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     */"}}
{"code": {"body": "    public static Mac getInitializedMac(final String algorithm, final byte[] key) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n\n        try {\n            final SecretKeySpec keySpec = new SecretKeySpec(key, algorithm);\n            final Mac mac = Mac.getInstance(algorithm);\n            mac.init(keySpec);\n            return mac;\n        } catch (final NoSuchAlgorithmException e) {\n            throw new IllegalArgumentException(e);\n        } catch (final InvalidKeyException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }", "comment": "/**\n     * Returns an initialized <code>Mac</code> for the given <code>algorithm</code>.\n     *\n     * @param algorithm\n     *            the name of the algorithm requested. See <a href=\n     *            \"http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA\" >Appendix\n     *            A in the Java Cryptography Architecture Reference Guide</a> for information about standard algorithm\n     *            names.\n     * @param key\n     *            They key for the keyed digest (must not be null)\n     * @return A Mac instance initialized with the given key.\n     * @see Mac#getInstance(String)\n     * @see Mac#init(Key)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     */"}}
{"code": {"body": "    public static byte[] hmacMd5(final String key, final String valueToDigest) {\n        return hmacMd5(StringUtils.getBytesUtf8(key), StringUtils.getBytesUtf8(valueToDigest));\n    }", "comment": "/**\n     * Returns a HmacMD5 Message Authentication Code (MAC) for the given key and value.\n     *\n     * @param key\n     *            They key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacMD5 MAC for the given key and value\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     */"}}
{"code": {"body": "    public static String hmacMd5Hex(final String key, final String valueToDigest) {\n        return Hex.encodeHexString(hmacMd5(key, valueToDigest));\n    }", "comment": "/**\n     * Returns a HmacMD5 Message Authentication Code (MAC) as a hex string (lowercase) for the given key and value.\n     *\n     * @param key\n     *            They key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacMD5 MAC for the given key and value as a hex string (lowercase)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     */"}}
{"code": {"body": "    public static byte[] hmacSha1(final String key, final String valueToDigest) {\n        return hmacSha1(StringUtils.getBytesUtf8(key), StringUtils.getBytesUtf8(valueToDigest));\n    }", "comment": "/**\n     * Returns a HmacSHA1 Message Authentication Code (MAC) for the given key and value.\n     *\n     * @param key\n     *            They key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA1 MAC for the given key and value\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     */"}}
{"code": {"body": "    public static String hmacSha1Hex(final String key, final String valueToDigest) {\n        return Hex.encodeHexString(hmacSha1(key, valueToDigest));\n    }", "comment": "/**\n     * Returns a HmacSHA1 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\n     *\n     * @param key\n     *            They key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA1 MAC for the given key and value as hex string (lowercase)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     */"}}
{"code": {"body": "    public static byte[] hmacSha256(final String key, final String valueToDigest) {\n        return hmacSha256(StringUtils.getBytesUtf8(key), StringUtils.getBytesUtf8(valueToDigest));\n    }", "comment": "/**\n     * Returns a HmacSHA256 Message Authentication Code (MAC) for the given key and value.\n     *\n     * @param key\n     *            They key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA256 MAC for the given key and value\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     */"}}
{"code": {"body": "    public static String hmacSha256Hex(final String key, final String valueToDigest) {\n        return Hex.encodeHexString(hmacSha256(key, valueToDigest));\n    }", "comment": "/**\n     * Returns a HmacSHA256 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\n     *\n     * @param key\n     *            They key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA256 MAC for the given key and value as hex string (lowercase)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     */"}}
{"code": {"body": "    public static byte[] hmacSha384(final String key, final String valueToDigest) {\n        return hmacSha384(StringUtils.getBytesUtf8(key), StringUtils.getBytesUtf8(valueToDigest));\n    }", "comment": "/**\n     * Returns a HmacSHA384 Message Authentication Code (MAC) for the given key and value.\n     *\n     * @param key\n     *            They key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA384 MAC for the given key and value\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     */"}}
{"code": {"body": "    public static String hmacSha384Hex(final String key, final String valueToDigest) {\n        return Hex.encodeHexString(hmacSha384(key, valueToDigest));\n    }", "comment": "/**\n     * Returns a HmacSHA384 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\n     *\n     * @param key\n     *            They key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA384 MAC for the given key and value as hex string (lowercase)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     */"}}
{"code": {"body": "    public static byte[] hmacSha512(final String key, final String valueToDigest) {\n        return hmacSha512(StringUtils.getBytesUtf8(key), StringUtils.getBytesUtf8(valueToDigest));\n    }", "comment": "/**\n     * Returns a HmacSHA512 Message Authentication Code (MAC) for the given key and value.\n     *\n     * @param key\n     *            They key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA512 MAC for the given key and value\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     */"}}
{"code": {"body": "    public static String hmacSha512Hex(final String key, final String valueToDigest) {\n        return Hex.encodeHexString(hmacSha512(key, valueToDigest));\n    }", "comment": "/**\n     * Returns a HmacSHA512 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\n     *\n     * @param key\n     *            They key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA512 MAC for the given key and value as hex string (lowercase)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     */"}}
{"code": {"body": "    public static Mac updateHmac(final Mac mac, final String valueToDigest) {\n        mac.reset();\n        mac.update(StringUtils.getBytesUtf8(valueToDigest));\n        return mac;\n    }", "comment": "/**\n     * Updates the given {@link Mac}. This generates a digest for valueToDigest and the key the Mac was initialized\n     *\n     * @param mac\n     *            the initialized {@link Mac} to update\n     * @param valueToDigest\n     *            the value to update the {@link Mac} with (maybe null or empty)\n     * @return the updated {@link Mac}\n     * @throws IllegalStateException\n     *             if the Mac was not initialized\n     * @since 1.x\n     */"}}
{"code": {"body": "    public static String apr1Crypt(final String keyBytes, final String salt) {\n        return apr1Crypt(keyBytes.getBytes(Charsets.UTF_8), salt);\n    }", "comment": "/**\n     * Generates an Apache htpasswd compatible \"$apr1$\" MD5 based hash value.\n     * <p>\n     * The algorithm is identical to the crypt(3) \"$1$\" one but produces different outputs due to the different salt\n     * prefix.\n     *\n     * @param keyBytes\n     *            plaintext string to hash.\n     * @param salt\n     *            salt string including the prefix and optionally garbage at the end. Will be generated randomly if\n     *            null.\n     * @return the hash value\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     * @throws RuntimeException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     */"}}
{"code": {"body": "    public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) {\n        final int keyLen = keyBytes.length;\n\n        \n        String saltString;\n        if (salt == null) {\n            saltString = B64.getRandomSalt(8);\n        } else {\n            final Pattern p = Pattern.compile(\"\" + prefix.replace(\"\", \"\") + \"\");\n            final Matcher m = p.matcher(salt);\n            if (m == null || !m.find()) {\n                throw new IllegalArgumentException(\"\" + salt);\n            }\n            saltString = m.group(1);\n        }\n        final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);\n\n        final MessageDigest ctx = DigestUtils.getMd5Digest();\n\n        \n        ctx.update(keyBytes);\n\n        \n        ctx.update(prefix.getBytes(Charsets.UTF_8));\n\n        \n        ctx.update(saltBytes);\n\n        \n        MessageDigest ctx1 = DigestUtils.getMd5Digest();\n        ctx1.update(keyBytes);\n        ctx1.update(saltBytes);\n        ctx1.update(keyBytes);\n        byte[] finalb = ctx1.digest();\n        int ii = keyLen;\n        while (ii > 0) {\n            ctx.update(finalb, 0, ii > 16 ? 16 : ii);\n            ii -= 16;\n        }\n\n        \n        Arrays.fill(finalb, (byte) 0);\n\n        \n        ii = keyLen;\n        final int j = 0;\n        while (ii > 0) {\n            if ((ii & 1) == 1) {\n                ctx.update(finalb[j]);\n            } else {\n                ctx.update(keyBytes[j]);\n            }\n            ii >>= 1;\n        }\n\n        \n        final StringBuilder passwd = new StringBuilder(prefix + saltString + \"\");\n        finalb = ctx.digest();\n\n        \n        for (int i = 0; i < ROUNDS; i++) {\n            ctx1 = DigestUtils.getMd5Digest();\n            if ((i & 1) != 0) {\n                ctx1.update(keyBytes);\n            } else {\n                ctx1.update(finalb, 0, BLOCKSIZE);\n            }\n\n            if (i % 3 != 0) {\n                ctx1.update(saltBytes);\n            }\n\n            if (i % 7 != 0) {\n                ctx1.update(keyBytes);\n            }\n\n            if ((i & 1) != 0) {\n                ctx1.update(finalb, 0, BLOCKSIZE);\n            } else {\n                ctx1.update(keyBytes);\n            }\n            finalb = ctx1.digest();\n        }\n\n        \n        \n        \n        B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);\n        B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);\n        B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);\n        B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);\n        B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);\n        B64.b64from24bit((byte) 0, (byte) 0, finalb[11], 2, passwd);\n\n        \n        \n        ctx.reset();\n        ctx1.reset();\n        Arrays.fill(keyBytes, (byte) 0);\n        Arrays.fill(saltBytes, (byte) 0);\n        Arrays.fill(finalb, (byte) 0);\n\n        return passwd.toString();\n    }", "comment": "/**\n     * Generates a libc6 crypt() \"$1$\" or Apache htpasswd \"$apr1$\" hash value.\n     * <p>\n     * See {@link Crypt#crypt(String, String)} or {@link #apr1Crypt(String, String)} for details.\n     *\n     * @param keyBytes\n     *            plaintext string to hash.\n     * @param salt May be null.\n     * @param prefix salt prefix\n     * @return the hash value\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     * @throws RuntimeException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     */"}}
{"code": {"body": "    public static String sha256Crypt(final byte[] keyBytes, String salt) {\n        if (salt == null) {\n            salt = SHA256_PREFIX + B64.getRandomSalt(8);\n        }\n        return sha2Crypt(keyBytes, salt, SHA256_PREFIX, SHA256_BLOCKSIZE, MessageDigestAlgorithms.SHA_256);\n    }", "comment": "/**\n     * Generates a libc6 crypt() compatible \"$5$\" hash value.\n     * <p>\n     * See {@link Crypt#crypt(String, String)} for details.\n     *\n     * @param keyBytes\n     *            plaintext to hash\n     * @param salt\n     *            real salt value without prefix or \"rounds=\"\n     * @return complete hash value including salt\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     * @throws RuntimeException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     */"}}
{"code": {"body": "    private static String sha2Crypt(final byte[] keyBytes, final String salt, final String saltPrefix,\n            final int blocksize, final String algorithm) {\n\n        final int keyLen = keyBytes.length;\n\n        \n        int rounds = ROUNDS_DEFAULT;\n        boolean roundsCustom = false;\n        if (salt == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n\n        final Matcher m = SALT_PATTERN.matcher(salt);\n        if (m == null || !m.find()) {\n            throw new IllegalArgumentException(\"\" + salt);\n        }\n        if (m.group(3) != null) {\n            rounds = Integer.parseInt(m.group(3));\n            rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));\n            roundsCustom = true;\n        }\n        final String saltString = m.group(4);\n        final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);\n        final int saltLen = saltBytes.length;\n\n        \n        \n        MessageDigest ctx = DigestUtils.getDigest(algorithm);\n\n        \n        \n        ctx.update(keyBytes);\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ctx.update(saltBytes);\n\n        \n        \n        MessageDigest altCtx = DigestUtils.getDigest(algorithm);\n\n        \n        \n        altCtx.update(keyBytes);\n\n        \n        \n        altCtx.update(saltBytes);\n\n        \n        \n        altCtx.update(keyBytes);\n\n        \n        \n        byte[] altResult = altCtx.digest();\n\n        \n        \n        \n        \n        int cnt = keyBytes.length;\n        while (cnt > blocksize) {\n            ctx.update(altResult, 0, blocksize);\n            cnt -= blocksize;\n        }\n\n        \n        \n        ctx.update(altResult, 0, cnt);\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        cnt = keyBytes.length;\n        while (cnt > 0) {\n            if ((cnt & 1) != 0) {\n                ctx.update(altResult, 0, blocksize);\n            } else {\n                ctx.update(keyBytes);\n            }\n            cnt >>= 1;\n        }\n\n        \n        \n        altResult = ctx.digest();\n\n        \n        \n        altCtx = DigestUtils.getDigest(algorithm);\n\n        \n        \n        \n        \n        \n        for (int i = 1; i <= keyLen; i++) {\n            altCtx.update(keyBytes);\n        }\n\n        \n        \n        byte[] tempResult = altCtx.digest();\n\n        \n        \n        \n        \n        \n        \n        \n        \n        final byte[] pBytes = new byte[keyLen];\n        int cp = 0;\n        while (cp < keyLen - blocksize) {\n            System.arraycopy(tempResult, 0, pBytes, cp, blocksize);\n            cp += blocksize;\n        }\n        System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);\n\n        \n        \n        altCtx = DigestUtils.getDigest(algorithm);\n\n        \n        \n        \n        \n        \n        for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {\n            altCtx.update(saltBytes);\n        }\n\n        \n        \n        tempResult = altCtx.digest();\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        final byte[] sBytes = new byte[saltLen];\n        cp = 0;\n        while (cp < saltLen - blocksize) {\n            System.arraycopy(tempResult, 0, sBytes, cp, blocksize);\n            cp += blocksize;\n        }\n        System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        for (int i = 0; i <= rounds - 1; i++) {\n            \n            \n            ctx = DigestUtils.getDigest(algorithm);\n\n            \n            \n            \n            if ((i & 1) != 0) {\n                ctx.update(pBytes, 0, keyLen);\n            } else {\n                ctx.update(altResult, 0, blocksize);\n            }\n\n            \n            \n            if (i % 3 != 0) {\n                ctx.update(sBytes, 0, saltLen);\n            }\n\n            \n            \n            if (i % 7 != 0) {\n                ctx.update(pBytes, 0, keyLen);\n            }\n\n            \n            \n            \n            if ((i & 1) != 0) {\n                ctx.update(altResult, 0, blocksize);\n            } else {\n                ctx.update(pBytes, 0, keyLen);\n            }\n\n            \n            \n            altResult = ctx.digest();\n        }\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        final StringBuilder buffer = new StringBuilder(saltPrefix);\n        if (roundsCustom) {\n            buffer.append(ROUNDS_PREFIX);\n            buffer.append(rounds);\n            buffer.append(\"\");\n        }\n        buffer.append(saltString);\n        buffer.append(\"\");\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        \n        \n\n        if (blocksize == 32) {\n            B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);\n            B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);\n            B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);\n            B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);\n            B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);\n            B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);\n            B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);\n            B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);\n            B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);\n            B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);\n            B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);\n        } else {\n            B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);\n            B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);\n            B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);\n            B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);\n            B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);\n            B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);\n            B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);\n            B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);\n            B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);\n            B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);\n            B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);\n            B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);\n            B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);\n            B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);\n            B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);\n            B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);\n            B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);\n            B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);\n            B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);\n            B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);\n            B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);\n            B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);\n        }\n\n        \n        \n        Arrays.fill(tempResult, (byte) 0);\n        Arrays.fill(pBytes, (byte) 0);\n        Arrays.fill(sBytes, (byte) 0);\n        ctx.reset();\n        altCtx.reset();\n        Arrays.fill(keyBytes, (byte) 0);\n        Arrays.fill(saltBytes, (byte) 0);\n\n        return buffer.toString();\n    }", "comment": "/**\n     * Generates a libc6 crypt() compatible \"$5$\" or \"$6$\" SHA2 based hash value.\n     * <p>\n     * This is a nearly line by line conversion of the original C function. The numbered comments are from the algorithm\n     * description, the short C-style ones from the original C code and the ones with \"Remark\" from me.\n     * <p>\n     * See {@link Crypt#crypt(String, String)} for details.\n     *\n     * @param keyBytes\n     *            plaintext to hash\n     * @param salt\n     *            real salt value without prefix or \"rounds=\"\n     * @param saltPrefix\n     *            either $5$ or $6$\n     * @param blocksize\n     *            a value that differs between $5$ and $6$\n     * @param algorithm\n     *            {@link MessageDigest} algorithm identifier string\n     * @return complete hash value including prefix and salt\n     * @throws IllegalArgumentException\n     *             if the given salt is <code>null</code> or does not match the allowed pattern\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught\n     * @see MessageDigestAlgorithms\n     */"}}
{"code": {"body": "    public static String sha512Crypt(final byte[] keyBytes, String salt) {\n        if (salt == null) {\n            salt = SHA512_PREFIX + B64.getRandomSalt(8);\n        }\n        return sha2Crypt(keyBytes, salt, SHA512_PREFIX, SHA512_BLOCKSIZE, MessageDigestAlgorithms.SHA_512);\n    }", "comment": "/**\n     * Generates a libc6 crypt() compatible \"$6$\" hash value.\n     * <p>\n     * See {@link Crypt#crypt(String, String)} for details.\n     *\n     * @param keyBytes\n     *            plaintext to hash\n     * @param salt\n     *            real salt value without prefix or \"rounds=\"\n     * @return complete hash value including salt\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     * @throws RuntimeException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     */"}}
{"code": {"body": "    public static String crypt(final String original, final String salt) {\n        return crypt(original.getBytes(Charsets.UTF_8), salt);\n    }", "comment": "/**\n     * Generates a crypt(3) compatible hash using the DES algorithm.\n     *\n     * @param original\n     *            plaintext password\n     * @param salt\n     *            a two character string drawn from [a-zA-Z0-9./] or null for a random one\n     * @return a 13 character string starting with the salt string\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     */"}}
{"code": {"body": "public AbstractCaverphone() {\n        super();\n    }", "comment": "/**\n     * Creates an instance of the Caverphone encoder\n     */"}}
{"code": {"body": "    public boolean isEncodeEqual(final String str1, final String str2) throws EncoderException {\n        return this.encode(str1).equals(this.encode(str2));\n    }", "comment": "/**\n     * Tests if the encodings of two strings are equal.\n     *\n     * This method might be promoted to a new AbstractStringEncoder superclass.\n     *\n     * @param str1\n     *            First of two strings to compare\n     * @param str2\n     *            Second of two strings to compare\n     * @return <code>true</code> if the encodings of these strings are identical, <code>false</code> otherwise.\n     * @throws EncoderException\n     *             thrown if there is an error condition during the encoding process.\n     */"}}
{"code": {"body": "public Caverphone() {\n        super();\n    }", "comment": "/**\n     * Creates an instance of the Caverphone encoder\n     */"}}
{"code": {"body": "    public String caverphone(final String source) {\n        return this.encoder.encode(source);\n    }", "comment": "/**\n     * Encodes the given String into a Caverphone value.\n     *\n     * @param source\n     *            String the source string\n     * @return A caverphone code for the given String\n     */"}}
{"code": {"body": "    public boolean isCaverphoneEqual(final String str1, final String str2) {\n        return this.caverphone(str1).equals(this.caverphone(str2));\n    }", "comment": "/**\n     * Tests if the caverphones of two strings are identical.\n     *\n     * @param str1\n     *            First of two strings to compare\n     * @param str2\n     *            Second of two strings to compare\n     * @return <code>true</code> if the caverphones of these strings are identical, <code>false</code> otherwise.\n     */"}}
{"code": {"body": "    private static boolean arrayContains(final char[] arr, final char key) {\n        for (final char element : arr) {\n            if (element == key) {\n                return true;\n            }\n        }\n        return false;\n    }", "comment": "/*\n     * Returns whether the array contains the key, or not.\n     */"}}
{"code": {"body": "    public String colognePhonetic(String text) {\n        if (text == null) {\n            return null;\n        }\n\n        text = preprocess(text);\n\n        final CologneOutputBuffer output = new CologneOutputBuffer(text.length() * 2);\n        final CologneInputBuffer input = new CologneInputBuffer(text.toCharArray());\n\n        char nextChar;\n\n        char lastChar = '';\n        char lastCode = '';\n        char code;\n        char chr;\n\n        int rightLength = input.length();\n\n        while (rightLength > 0) {\n            chr = input.removeNext();\n\n            if ((rightLength = input.length()) > 0) {\n                nextChar = input.getNextChar();\n            } else {\n                nextChar = '';\n            }\n\n            if (arrayContains(AEIJOUY, chr)) {\n                code = '';\n            } else if (chr == '' || chr < '' || chr > '') {\n                if (lastCode == '') {\n                    continue;\n                }\n                code = '';\n            } else if (chr == '' || (chr == '' && nextChar != '')) {\n                code = '';\n            } else if ((chr == '' || chr == '') && !arrayContains(SCZ, nextChar)) {\n                code = '';\n            } else if (arrayContains(WFPV, chr)) {\n                code = '';\n            } else if (arrayContains(GKQ, chr)) {\n                code = '';\n            } else if (chr == '' && !arrayContains(CKQ, lastChar)) {\n                code = '';\n                input.addLeft('');\n                rightLength++;\n            } else if (chr == '' || chr == '') {\n                code = '';\n            } else if (chr == '') {\n                if (lastCode == '') {\n                    if (arrayContains(AHKLOQRUX, nextChar)) {\n                        code = '';\n                    } else {\n                        code = '';\n                    }\n                } else {\n                    if (arrayContains(SZ, lastChar) || !arrayContains(AHOUKQX, nextChar)) {\n                        code = '';\n                    } else {\n                        code = '';\n                    }\n                }\n            } else if (arrayContains(TDX, chr)) {\n                code = '';\n            } else if (chr == '') {\n                code = '';\n            } else if (chr == '') {\n                code = '';\n            } else if (chr == '' || chr == '') {\n                code = '';\n            } else {\n                code = chr;\n            }\n\n            if (code != '' && (lastCode != code && (code != '' || lastCode == '') || code < '' || code > '')) {\n                output.addRight(code);\n            }\n\n            lastChar = chr;\n            lastCode = code;\n        }\n        return output.toString();\n    }", "comment": "/**\n     * <p>\n     * Implements the <i>K&ouml;lner Phonetik</i> algorithm.\n     * </p>\n     * <p>\n     * In contrast to the initial description of the algorithm, this implementation does the encoding in one pass.\n     * </p>\n     *\n     * @param text The source text to encode\n     * @return the corresponding encoding according to the <i>K&ouml;lner Phonetik</i> algorithm\n     */"}}
{"code": {"body": "    private String preprocess(String text) {\n        text = text.toUpperCase(Locale.GERMAN);\n\n        final char[] chrs = text.toCharArray();\n\n        for (int index = 0; index < chrs.length; index++) {\n            if (chrs[index] > '') {\n                for (final char[] element : PREPROCESS_MAP) {\n                    if (chrs[index] == element[0]) {\n                        chrs[index] = element[1];\n                        break;\n                    }\n                }\n            }\n        }\n        return new String(chrs);\n    }", "comment": "/**\n     * Converts the string to upper case and replaces germanic characters as defined in {@link #PREPROCESS_MAP}.\n     */"}}
{"code": {"body": "public DaitchMokotoffSoundex() {\n        this(true);\n    }", "comment": "/**\n     * Creates a new instance with ASCII-folding enabled.\n     */"}}
{"code": {"body": "public DaitchMokotoffSoundex(final boolean folding) {\n        this.folding = folding;\n    }", "comment": "/**\n     * Creates a new instance.\n     * <p>\n     * With ASCII-folding enabled, certain accented characters will be transformed to equivalent ASCII characters, e.g.\n     * \u00e8 -&gt; e.\n     * </p>\n     *\n     * @param folding\n     *            if ASCII-folding shall be performed before encoding\n     */"}}
{"code": {"body": "        public Branch createBranch() {\n            final Branch branch = new Branch();\n            branch.builder.append(toString());\n            branch.lastReplacement = this.lastReplacement;\n            return branch;\n        }", "comment": "/**\n         * Creates a new branch, identical to this branch.\n         *\n         * @return a new, identical branch\n         */"}}
{"code": {"body": "        public void finish() {\n            while (builder.length() < MAX_LENGTH) {\n                builder.append('');\n                cachedString = null;\n            }\n        }", "comment": "/**\n         * Finish this branch by appending '0's until the maximum code length has been reached.\n         */"}}
{"code": {"body": "        public void processNextReplacement(final String replacement, final boolean forceAppend) {\n            final boolean append = lastReplacement == null || !lastReplacement.endsWith(replacement) || forceAppend;\n\n            if (append && builder.length() < MAX_LENGTH) {\n                builder.append(replacement);\n                \n                if (builder.length() > MAX_LENGTH) {\n                    builder.delete(MAX_LENGTH, builder.length());\n                }\n                cachedString = null;\n            }\n\n            lastReplacement = replacement;\n        }", "comment": "/**\n         * Process the next replacement to be added to this branch.\n         *\n         * @param replacement\n         *            the next replacement to append\n         * @param forceAppend\n         *            indicates if the default processing shall be overridden\n         */"}}
{"code": {"body": "    private String cleanup(final String input) {\n        final StringBuilder sb = new StringBuilder();\n        for (char ch : input.toCharArray()) {\n            if (Character.isWhitespace(ch)) {\n                continue;\n            }\n\n            ch = Character.toLowerCase(ch);\n            if (folding && FOLDINGS.containsKey(ch)) {\n                ch = FOLDINGS.get(ch);\n            }\n            sb.append(ch);\n        }\n        return sb.toString();\n    }", "comment": "/**\n     * Performs a cleanup of the input string before the actual soundex transformation.\n     * <p>\n     * Removes all whitespace characters and performs ASCII folding if enabled.\n     * </p>\n     *\n     * @param input\n     *            the input string to cleanup\n     * @return a cleaned up string\n     */"}}
{"code": {"body": "    private String[] soundex(final String source, final boolean branching) {\n        if (source == null) {\n            return null;\n        }\n\n        final String input = cleanup(source);\n\n        final Set<Branch> currentBranches = new LinkedHashSet<Branch>();\n        currentBranches.add(new Branch());\n\n        char lastChar = '';\n        for (int index = 0; index < input.length(); index++) {\n            final char ch = input.charAt(index);\n\n            \n            if (Character.isWhitespace(ch)) {\n                continue;\n            }\n\n            final String inputContext = input.substring(index);\n            final List<Rule> rules = RULES.get(ch);\n            if (rules == null) {\n                continue;\n            }\n\n            \n            @SuppressWarnings(\"\")\n            final List<Branch> nextBranches = branching ? new ArrayList<Branch>() : Collections.EMPTY_LIST;\n\n            for (final Rule rule : rules) {\n                if (rule.matches(inputContext)) {\n                    if (branching) {\n                        nextBranches.clear();\n                    }\n                    final String[] replacements = rule.getReplacements(inputContext, lastChar == '');\n                    final boolean branchingRequired = replacements.length > 1 && branching;\n\n                    for (final Branch branch : currentBranches) {\n                        for (final String nextReplacement : replacements) {\n                            \n                            final Branch nextBranch = branchingRequired ? branch.createBranch() : branch;\n\n                            \n                            final boolean force = (lastChar == '' && ch == '') || (lastChar == '' && ch == '');\n\n                            nextBranch.processNextReplacement(nextReplacement, force);\n\n                            if (branching) {\n                                nextBranches.add(nextBranch);\n                            } else {\n                                break;\n                            }\n                        }\n                    }\n\n                    if (branching) {\n                        currentBranches.clear();\n                        currentBranches.addAll(nextBranches);\n                    }\n                    index += rule.getPatternLength() - 1;\n                    break;\n                }\n            }\n\n            lastChar = ch;\n        }\n\n        final String[] result = new String[currentBranches.size()];\n        int index = 0;\n        for (final Branch branch : currentBranches) {\n            branch.finish();\n            result[index++] = branch.toString();\n        }\n\n        return result;\n    }", "comment": "/**\n     * Perform the actual DM Soundex algorithm on the input string.\n     *\n     * @param source\n     *            A String object to encode\n     * @param branching\n     *            If branching shall be performed\n     * @return A string array containing all DM Soundex codes corresponding to the String supplied depending on the\n     *         selected branching mode\n     */"}}
{"code": {"body": "public DoubleMetaphone() {\n        super();\n    }", "comment": "/**\n     * Creates an instance of this DoubleMetaphone encoder\n     */"}}
{"code": {"body": "    public String doubleMetaphone(String value, final boolean alternate) {\n        value = cleanInput(value);\n        if (value == null) {\n            return null;\n        }\n\n        final boolean slavoGermanic = isSlavoGermanic(value);\n        int index = isSilentStart(value) ? 1 : 0;\n\n        final DoubleMetaphoneResult result = new DoubleMetaphoneResult(this.getMaxCodeLen());\n\n        while (!result.isComplete() && index <= value.length() - 1) {\n            switch (value.charAt(index)) {\n            case '':\n            case '':\n            case '':\n            case '':\n            case '':\n            case '':\n                index = handleAEIOUY(result, index);\n                break;\n            case '':\n                result.append('');\n                index = charAt(value, index + 1) == '' ? index + 2 : index + 1;\n                break;\n            case '':\n                \n                result.append('');\n                index++;\n                break;\n            case '':\n                index = handleC(value, result, index);\n                break;\n            case '':\n                index = handleD(value, result, index);\n                break;\n            case '':\n                result.append('');\n                index = charAt(value, index + 1) == '' ? index + 2 : index + 1;\n                break;\n            case '':\n                index = handleG(value, result, index, slavoGermanic);\n                break;\n            case '':\n                index = handleH(value, result, index);\n                break;\n            case '':\n                index = handleJ(value, result, index, slavoGermanic);\n                break;\n            case '':\n                result.append('');\n                index = charAt(value, index + 1) == '' ? index + 2 : index + 1;\n                break;\n            case '':\n                index = handleL(value, result, index);\n                break;\n            case '':\n                result.append('');\n                index = conditionM0(value, index) ? index + 2 : index + 1;\n                break;\n            case '':\n                result.append('');\n                index = charAt(value, index + 1) == '' ? index + 2 : index + 1;\n                break;\n            case '':\n                \n                result.append('');\n                index++;\n                break;\n            case '':\n                index = handleP(value, result, index);\n                break;\n            case '':\n                result.append('');\n                index = charAt(value, index + 1) == '' ? index + 2 : index + 1;\n                break;\n            case '':\n                index = handleR(value, result, index, slavoGermanic);\n                break;\n            case '':\n                index = handleS(value, result, index, slavoGermanic);\n                break;\n            case '':\n                index = handleT(value, result, index);\n                break;\n            case '':\n                result.append('');\n                index = charAt(value, index + 1) == '' ? index + 2 : index + 1;\n                break;\n            case '':\n                index = handleW(value, result, index);\n                break;\n            case '':\n                index = handleX(value, result, index);\n                break;\n            case '':\n                index = handleZ(value, result, index, slavoGermanic);\n                break;\n            default:\n                index++;\n                break;\n            }\n        }\n\n        return alternate ? result.getAlternate() : result.getPrimary();\n    }", "comment": "/**\n     * Encode a value with Double Metaphone, optionally using the alternate encoding.\n     *\n     * @param value String to encode\n     * @param alternate use alternate encode\n     * @return an encoded string\n     */"}}
{"code": {"body": "    public boolean isDoubleMetaphoneEqual(final String value1, final String value2, final boolean alternate) {\n        return StringUtils.equals(doubleMetaphone(value1, alternate), doubleMetaphone(value2, alternate));\n    }", "comment": "/**\n     * Check if the Double Metaphone values of two <code>String</code> values\n     * are equal, optionally using the alternate value.\n     *\n     * @param value1 The left-hand side of the encoded {@link String#equals(Object)}.\n     * @param value2 The right-hand side of the encoded {@link String#equals(Object)}.\n     * @param alternate use the alternate value if <code>true</code>.\n     * @return <code>true</code> if the encoded <code>String</code>s are equal;\n     *          <code>false</code> otherwise.\n     */"}}
{"code": {"body": "    public int getMaxCodeLen() {\n        return this.maxCodeLen;\n    }", "comment": "/**\n     * Returns the maxCodeLen.\n     * @return int\n     */"}}
{"code": {"body": "    public void setMaxCodeLen(final int maxCodeLen) {\n        this.maxCodeLen = maxCodeLen;\n    }", "comment": "/**\n     * Sets the maxCodeLen.\n     * @param maxCodeLen The maxCodeLen to set\n     */"}}
{"code": {"body": "    private int handleAEIOUY(final DoubleMetaphoneResult result, final int index) {\n        if (index == 0) {\n            result.append('');\n        }\n        return index + 1;\n    }", "comment": "/**\n     * Handles 'A', 'E', 'I', 'O', 'U', and 'Y' cases.\n     */"}}
{"code": {"body": "    private int handleC(final String value, final DoubleMetaphoneResult result, int index) {\n        if (conditionC0(value, index)) {  \n            result.append('');\n            index += 2;\n        } else if (index == 0 && contains(value, index, 6, \"\")) {\n            result.append('');\n            index += 2;\n        } else if (contains(value, index, 2, \"\")) {\n            index = handleCH(value, result, index);\n        } else if (contains(value, index, 2, \"\") &&\n                   !contains(value, index - 2, 4, \"\")) {\n            \n            result.append('', '');\n            index += 2;\n        } else if (contains(value, index + 1, 3, \"\")) {\n            \n            result.append('');\n            index += 3;\n        } else if (contains(value, index, 2, \"\") &&\n                   !(index == 1 && charAt(value, 0) == '')) {\n            \n            return handleCC(value, result, index);\n        } else if (contains(value, index, 2, \"\", \"\", \"\")) {\n            result.append('');\n            index += 2;\n        } else if (contains(value, index, 2, \"\", \"\", \"\")) {\n            \n            if (contains(value, index, 3, \"\", \"\", \"\")) {\n                result.append('', '');\n            } else {\n                result.append('');\n            }\n            index += 2;\n        } else {\n            result.append('');\n            if (contains(value, index + 1, 2, \"\", \"\", \"\")) {\n                \n                index += 3;\n            } else if (contains(value, index + 1, 1, \"\", \"\", \"\") &&\n                       !contains(value, index + 1, 2, \"\", \"\")) {\n                index += 2;\n            } else {\n                index++;\n            }\n        }\n\n        return index;\n    }", "comment": "/**\n     * Handles 'C' cases.\n     */"}}
{"code": {"body": "    private int handleCC(final String value, final DoubleMetaphoneResult result, int index) {\n        if (contains(value, index + 2, 1, \"\", \"\", \"\") &&\n            !contains(value, index + 2, 2, \"\")) {\n            \n            if ((index == 1 && charAt(value, index - 1) == '') ||\n                contains(value, index - 1, 5, \"\", \"\")) {\n                \n                result.append(\"\");\n            } else {\n                \n                result.append('');\n            }\n            index += 3;\n        } else {    \n            result.append('');\n            index += 2;\n        }\n\n        return index;\n    }", "comment": "/**\n     * Handles 'CC' cases.\n     */"}}
{"code": {"body": "    private int handleCH(final String value, final DoubleMetaphoneResult result, final int index) {\n        if (index > 0 && contains(value, index, 4, \"\")) {   \n            result.append('', '');\n            return index + 2;\n        } else if (conditionCH0(value, index)) {\n            \n            result.append('');\n            return index + 2;\n        } else if (conditionCH1(value, index)) {\n            \n            result.append('');\n            return index + 2;\n        } else {\n            if (index > 0) {\n                if (contains(value, 0, 2, \"\")) {\n                    result.append('');\n                } else {\n                    result.append('', '');\n                }\n            } else {\n                result.append('');\n            }\n            return index + 2;\n        }\n    }", "comment": "/**\n     * Handles 'CH' cases.\n     */"}}
{"code": {"body": "    private int handleD(final String value, final DoubleMetaphoneResult result, int index) {\n        if (contains(value, index, 2, \"\")) {\n            \n            if (contains(value, index + 2, 1, \"\", \"\", \"\")) {\n                result.append('');\n                index += 3;\n                \n            } else {\n                result.append(\"\");\n                index += 2;\n            }\n        } else if (contains(value, index, 2, \"\", \"\")) {\n            result.append('');\n            index += 2;\n        } else {\n            result.append('');\n            index++;\n        }\n        return index;\n    }", "comment": "/**\n     * Handles 'D' cases.\n     */"}}
{"code": {"body": "    private int handleG(final String value, final DoubleMetaphoneResult result, int index,\n                        final boolean slavoGermanic) {\n        if (charAt(value, index + 1) == '') {\n            index = handleGH(value, result, index);\n        } else if (charAt(value, index + 1) == '') {\n            if (index == 1 && isVowel(charAt(value, 0)) && !slavoGermanic) {\n                result.append(\"\", \"\");\n            } else if (!contains(value, index + 2, 2, \"\") &&\n                       charAt(value, index + 1) != '' && !slavoGermanic) {\n                result.append(\"\", \"\");\n            } else {\n                result.append(\"\");\n            }\n            index = index + 2;\n        } else if (contains(value, index + 1, 2, \"\") && !slavoGermanic) {\n            result.append(\"\", \"\");\n            index += 2;\n        } else if (index == 0 &&\n                   (charAt(value, index + 1) == '' ||\n                    contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) {\n            \n            result.append('', '');\n            index += 2;\n        } else if ((contains(value, index + 1, 2, \"\") ||\n                    charAt(value, index + 1) == '') &&\n                   !contains(value, 0, 6, \"\", \"\", \"\") &&\n                   !contains(value, index - 1, 1, \"\", \"\") &&\n                   !contains(value, index - 1, 3, \"\", \"\")) {\n            \n            result.append('', '');\n            index += 2;\n        } else if (contains(value, index + 1, 1, \"\", \"\", \"\") ||\n                   contains(value, index - 1, 4, \"\", \"\")) {\n            \n            if (contains(value, 0 ,4, \"\", \"\") ||\n                contains(value, 0, 3, \"\") ||\n                contains(value, index + 1, 2, \"\")) {\n                \n                result.append('');\n            } else if (contains(value, index + 1, 3, \"\")) {\n                result.append('');\n            } else {\n                result.append('', '');\n            }\n            index += 2;\n        } else if (charAt(value, index + 1) == '') {\n            index += 2;\n            result.append('');\n        } else {\n            index++;\n            result.append('');\n        }\n        return index;\n    }", "comment": "/**\n     * Handles 'G' cases.\n     */"}}
{"code": {"body": "    private int handleGH(final String value, final DoubleMetaphoneResult result, int index) {\n        if (index > 0 && !isVowel(charAt(value, index - 1))) {\n            result.append('');\n            index += 2;\n        } else if (index == 0) {\n            if (charAt(value, index + 2) == '') {\n                result.append('');\n            } else {\n                result.append('');\n            }\n            index += 2;\n        } else if ((index > 1 && contains(value, index - 2, 1, \"\", \"\", \"\")) ||\n                   (index > 2 && contains(value, index - 3, 1, \"\", \"\", \"\")) ||\n                   (index > 3 && contains(value, index - 4, 1, \"\", \"\"))) {\n            \n            index += 2;\n        } else {\n            if (index > 2 && charAt(value, index - 1) == '' &&\n                contains(value, index - 3, 1, \"\", \"\", \"\", \"\", \"\")) {\n                \n                result.append('');\n            } else if (index > 0 && charAt(value, index - 1) != '') {\n                result.append('');\n            }\n            index += 2;\n        }\n        return index;\n    }", "comment": "/**\n     * Handles 'GH' cases.\n     */"}}
{"code": {"body": "    private int handleH(final String value, final DoubleMetaphoneResult result, int index) {\n        \n        if ((index == 0 || isVowel(charAt(value, index - 1))) &&\n            isVowel(charAt(value, index + 1))) {\n            result.append('');\n            index += 2;\n            \n        } else {\n            index++;\n        }\n        return index;\n    }", "comment": "/**\n     * Handles 'H' cases.\n     */"}}
{"code": {"body": "    private int handleJ(final String value, final DoubleMetaphoneResult result, int index,\n                        final boolean slavoGermanic) {\n        if (contains(value, index, 4, \"\") || contains(value, 0, 4, \"\")) {\n                \n                if ((index == 0 && (charAt(value, index + 4) == '') ||\n                     value.length() == 4) || contains(value, 0, 4, \"\")) {\n                    result.append('');\n                } else {\n                    result.append('', '');\n                }\n                index++;\n            } else {\n                if (index == 0 && !contains(value, index, 4, \"\")) {\n                    result.append('', '');\n                } else if (isVowel(charAt(value, index - 1)) && !slavoGermanic &&\n                           (charAt(value, index + 1) == '' || charAt(value, index + 1) == '')) {\n                    result.append('', '');\n                } else if (index == value.length() - 1) {\n                    result.append('', '');\n                } else if (!contains(value, index + 1, 1, L_T_K_S_N_M_B_Z) &&\n                           !contains(value, index - 1, 1, \"\", \"\", \"\")) {\n                    result.append('');\n                }\n\n                if (charAt(value, index + 1) == '') {\n                    index += 2;\n                } else {\n                    index++;\n                }\n            }\n        return index;\n    }", "comment": "/**\n     * Handles 'J' cases.\n     */"}}
{"code": {"body": "    private int handleL(final String value, final DoubleMetaphoneResult result, int index) {\n        if (charAt(value, index + 1) == '') {\n            if (conditionL0(value, index)) {\n                result.appendPrimary('');\n            } else {\n                result.append('');\n            }\n            index += 2;\n        } else {\n            index++;\n            result.append('');\n        }\n        return index;\n    }", "comment": "/**\n     * Handles 'L' cases.\n     */"}}
{"code": {"body": "    private int handleP(final String value, final DoubleMetaphoneResult result, int index) {\n        if (charAt(value, index + 1) == '') {\n            result.append('');\n            index += 2;\n        } else {\n            result.append('');\n            index = contains(value, index + 1, 1, \"\", \"\") ? index + 2 : index + 1;\n        }\n        return index;\n    }", "comment": "/**\n     * Handles 'P' cases.\n     */"}}
{"code": {"body": "    private int handleR(final String value, final DoubleMetaphoneResult result, final int index,\n                        final boolean slavoGermanic) {\n        if (index == value.length() - 1 && !slavoGermanic &&\n            contains(value, index - 2, 2, \"\") &&\n            !contains(value, index - 4, 2, \"\", \"\")) {\n            result.appendAlternate('');\n        } else {\n            result.append('');\n        }\n        return charAt(value, index + 1) == '' ? index + 2 : index + 1;\n    }", "comment": "/**\n     * Handles 'R' cases.\n     */"}}
{"code": {"body": "    private int handleS(final String value, final DoubleMetaphoneResult result, int index,\n                        final boolean slavoGermanic) {\n        if (contains(value, index - 1, 3, \"\", \"\")) {\n            \n            index++;\n        } else if (index == 0 && contains(value, index, 5, \"\")) {\n            \n            result.append('', '');\n            index++;\n        } else if (contains(value, index, 2, \"\")) {\n            if (contains(value, index + 1, 4, \"\", \"\", \"\", \"\")) {\n                \n                result.append('');\n            } else {\n                result.append('');\n            }\n            index += 2;\n        } else if (contains(value, index, 3, \"\", \"\") || contains(value, index, 4, \"\")) {\n            \n            if (slavoGermanic) {\n                result.append('');\n            } else {\n                result.append('', '');\n            }\n            index += 3;\n        } else if ((index == 0 && contains(value, index + 1, 1, \"\", \"\", \"\", \"\")) ||\n                   contains(value, index + 1, 1, \"\")) {\n            \n            \n            \n            \n            result.append('', '');\n            index = contains(value, index + 1, 1, \"\") ? index + 2 : index + 1;\n        } else if (contains(value, index, 2, \"\")) {\n            index = handleSC(value, result, index);\n        } else {\n            if (index == value.length() - 1 && contains(value, index - 2, 2, \"\", \"\")) {\n                \n                result.appendAlternate('');\n            } else {\n                result.append('');\n            }\n            index = contains(value, index + 1, 1, \"\", \"\") ? index + 2 : index + 1;\n        }\n        return index;\n    }", "comment": "/**\n     * Handles 'S' cases.\n     */"}}
{"code": {"body": "    private int handleSC(final String value, final DoubleMetaphoneResult result, final int index) {\n        if (charAt(value, index + 2) == '') {\n            \n            if (contains(value, index + 3, 2, \"\", \"\", \"\", \"\", \"\", \"\")) {\n                \n                if (contains(value, index + 3, 2, \"\", \"\")) {\n                    \n                    result.append(\"\", \"\");\n                } else {\n                    result.append(\"\");\n                }\n            } else {\n                if (index == 0 && !isVowel(charAt(value, 3)) && charAt(value, 3) != '') {\n                    result.append('', '');\n                } else {\n                    result.append('');\n                }\n            }\n        } else if (contains(value, index + 2, 1, \"\", \"\", \"\")) {\n            result.append('');\n        } else {\n            result.append(\"\");\n        }\n        return index + 3;\n    }", "comment": "/**\n     * Handles 'SC' cases.\n     */"}}
{"code": {"body": "    private int handleT(final String value, final DoubleMetaphoneResult result, int index) {\n        if (contains(value, index, 4, \"\")) {\n            result.append('');\n            index += 3;\n        } else if (contains(value, index, 3, \"\", \"\")) {\n            result.append('');\n            index += 3;\n        } else if (contains(value, index, 2, \"\") || contains(value, index, 3, \"\")) {\n            if (contains(value, index + 2, 2, \"\", \"\") ||\n                \n                contains(value, 0, 4, \"\", \"\") ||\n                contains(value, 0, 3, \"\")) {\n                result.append('');\n            } else {\n                result.append('', '');\n            }\n            index += 2;\n        } else {\n            result.append('');\n            index = contains(value, index + 1, 1, \"\", \"\") ? index + 2 : index + 1;\n        }\n        return index;\n    }", "comment": "/**\n     * Handles 'T' cases.\n     */"}}
{"code": {"body": "    private int handleW(final String value, final DoubleMetaphoneResult result, int index) {\n        if (contains(value, index, 2, \"\")) {\n            \n            result.append('');\n            index += 2;\n        } else {\n            if (index == 0 && (isVowel(charAt(value, index + 1)) ||\n                               contains(value, index, 2, \"\"))) {\n                if (isVowel(charAt(value, index + 1))) {\n                    \n                    result.append('', '');\n                } else {\n                    \n                    result.append('');\n                }\n                index++;\n            } else if ((index == value.length() - 1 && isVowel(charAt(value, index - 1))) ||\n                       contains(value, index - 1, 5, \"\", \"\", \"\", \"\") ||\n                       contains(value, 0, 3, \"\")) {\n                \n                result.appendAlternate('');\n                index++;\n            } else if (contains(value, index, 4, \"\", \"\")) {\n                \n                result.append(\"\", \"\");\n                index += 4;\n            } else {\n                index++;\n            }\n        }\n        return index;\n    }", "comment": "/**\n     * Handles 'W' cases.\n     */"}}
{"code": {"body": "    private int handleX(final String value, final DoubleMetaphoneResult result, int index) {\n        if (index == 0) {\n            result.append('');\n            index++;\n        } else {\n            if (!((index == value.length() - 1) &&\n                  (contains(value, index - 3, 3, \"\", \"\") ||\n                   contains(value, index - 2, 2, \"\", \"\")))) {\n                \n                result.append(\"\");\n            }\n            index = contains(value, index + 1, 1, \"\", \"\") ? index + 2 : index + 1;\n        }\n        return index;\n    }", "comment": "/**\n     * Handles 'X' cases.\n     */"}}
{"code": {"body": "    private int handleZ(final String value, final DoubleMetaphoneResult result, int index,\n                        final boolean slavoGermanic) {\n        if (charAt(value, index + 1) == '') {\n            \n            result.append('');\n            index += 2;\n        } else {\n            if (contains(value, index + 1, 2, \"\", \"\", \"\") ||\n                (slavoGermanic && (index > 0 && charAt(value, index - 1) != ''))) {\n                result.append(\"\", \"\");\n            } else {\n                result.append('');\n            }\n            index = charAt(value, index + 1) == '' ? index + 2 : index + 1;\n        }\n        return index;\n    }", "comment": "/**\n     * Handles 'Z' cases.\n     */"}}
{"code": {"body": "    private boolean conditionC0(final String value, final int index) {\n        if (contains(value, index, 4, \"\")) {\n            return true;\n        } else if (index <= 1) {\n            return false;\n        } else if (isVowel(charAt(value, index - 2))) {\n            return false;\n        } else if (!contains(value, index - 1, 3, \"\")) {\n            return false;\n        } else {\n            final char c = charAt(value, index + 2);\n            return (c != '' && c != '') ||\n                    contains(value, index - 2, 6, \"\", \"\");\n        }\n    }", "comment": "/**\n     * Complex condition 0 for 'C'.\n     */"}}
{"code": {"body": "    private boolean conditionCH0(final String value, final int index) {\n        if (index != 0) {\n            return false;\n        } else if (!contains(value, index + 1, 5, \"\", \"\") &&\n                   !contains(value, index + 1, 3, \"\", \"\", \"\", \"\")) {\n            return false;\n        } else if (contains(value, 0, 5, \"\")) {\n            return false;\n        } else {\n            return true;\n        }\n    }", "comment": "/**\n     * Complex condition 0 for 'CH'.\n     */"}}
{"code": {"body": "    private boolean conditionCH1(final String value, final int index) {\n        return ((contains(value, 0, 4, \"\", \"\") || contains(value, 0, 3, \"\")) ||\n                contains(value, index - 2, 6, \"\", \"\", \"\") ||\n                contains(value, index + 2, 1, \"\", \"\") ||\n                ((contains(value, index - 1, 1, \"\", \"\", \"\", \"\") || index == 0) &&\n                 (contains(value, index + 2, 1, L_R_N_M_B_H_F_V_W_SPACE) || index + 1 == value.length() - 1)));\n    }", "comment": "/**\n     * Complex condition 1 for 'CH'.\n     */"}}
{"code": {"body": "    private boolean conditionL0(final String value, final int index) {\n        if (index == value.length() - 3 &&\n            contains(value, index - 1, 4, \"\", \"\", \"\")) {\n            return true;\n        } else if ((contains(value, value.length() - 2, 2, \"\", \"\") ||\n                    contains(value, value.length() - 1, 1, \"\", \"\")) &&\n                   contains(value, index - 1, 4, \"\")) {\n            return true;\n        } else {\n            return false;\n        }\n    }", "comment": "/**\n     * Complex condition 0 for 'L'.\n     */"}}
{"code": {"body": "    private boolean conditionM0(final String value, final int index) {\n        if (charAt(value, index + 1) == '') {\n            return true;\n        }\n        return contains(value, index - 1, 3, \"\") &&\n               ((index + 1) == value.length() - 1 || contains(value, index + 2, 2, \"\"));\n    }", "comment": "/**\n     * Complex condition 0 for 'M'.\n     */"}}
{"code": {"body": "    private boolean isSlavoGermanic(final String value) {\n        return value.indexOf('') > -1 || value.indexOf('') > -1 ||\n            value.indexOf(\"\") > -1 || value.indexOf(\"\") > -1;\n    }", "comment": "/**\n     * Determines whether or not a value is of slavo-germanic origin. A value is\n     * of slavo-germanic origin if it contians any of 'W', 'K', 'CZ', or 'WITZ'.\n     */"}}
{"code": {"body": "    private boolean isVowel(final char ch) {\n        return VOWELS.indexOf(ch) != -1;\n    }", "comment": "/**\n     * Determines whether or not a character is a vowel or not\n     */"}}
{"code": {"body": "    private boolean isSilentStart(final String value) {\n        boolean result = false;\n        for (final String element : SILENT_START) {\n            if (value.startsWith(element)) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }", "comment": "/**\n     * Determines whether or not the value starts with a silent letter.  It will\n     * return <code>true</code> if the value starts with any of 'GN', 'KN',\n     * 'PN', 'WR' or 'PS'.\n     */"}}
{"code": {"body": "    private String cleanInput(String input) {\n        if (input == null) {\n            return null;\n        }\n        input = input.trim();\n        if (input.length() == 0) {\n            return null;\n        }\n        return input.toUpperCase(java.util.Locale.ENGLISH);\n    }", "comment": "/**\n     * Cleans the input.\n     */"}}
{"code": {"body": "    protected char charAt(final String value, final int index) {\n        if (index < 0 || index >= value.length()) {\n            return Character.MIN_VALUE;\n        }\n        return value.charAt(index);\n    }", "comment": "/*\n     * Gets the character at index <code>index</code> if available, otherwise\n     * it returns <code>Character.MIN_VALUE</code> so that there is some sort\n     * of a default.\n     */"}}
{"code": {"body": "    protected static boolean contains(final String value, final int start, final int length,\n                                      final String... criteria) {\n        boolean result = false;\n        if (start >= 0 && start + length <= value.length()) {\n            final String target = value.substring(start, start + length);\n\n            for (final String element : criteria) {\n                if (target.equals(element)) {\n                    result = true;\n                    break;\n                }\n            }\n        }\n        return result;\n    }", "comment": "/*\n     * Determines whether <code>value</code> contains any of the criteria starting at index <code>start</code> and\n     * matching up to length <code>length</code>.\n     */"}}
{"code": {"body": "    String cleanName(final String name) {\n        String upperName = name.toUpperCase(Locale.ENGLISH);\n\n        final String[] charsToTrim = { \"\", \"\", \"\", \"\", \"\" };\n        for (final String str : charsToTrim) {\n            upperName = upperName.replaceAll(str, EMPTY);\n        }\n\n        upperName = removeAccents(upperName);\n        upperName = upperName.replaceAll(\"\", EMPTY);\n\n        return upperName;\n    }", "comment": "/**\n     * Cleans up a name: 1. Upper-cases everything 2. Removes some common punctuation 3. Removes accents 4. Removes any\n     * spaces.\n     *\n     * <h2>API Usage</h2>\n     * <p>\n     * Consider this method private, it is package protected for unit testing only.\n     * </p>\n     *\n     * @param name\n     *            The name to be cleaned\n     * @return The cleaned name\n     */"}}
{"code": {"body": "    String getFirst3Last3(final String name) {\n        final int nameLength = name.length();\n\n        if (nameLength > SIX) {\n            final String firstThree = name.substring(0, THREE);\n            final String lastThree = name.substring(nameLength - THREE, nameLength);\n            return firstThree + lastThree;\n        } else {\n            return name;\n        }\n    }", "comment": "/**\n     * Gets the first and last 3 letters of a name (if &gt; 6 characters) Else just returns the name.\n     *\n     * <h2>API Usage</h2>\n     * <p>\n     * Consider this method private, it is package protected for unit testing only.\n     * </p>\n     *\n     * @param name\n     *            The string to get the substrings from\n     * @return Annexed first and last 3 letters of input word.\n     */"}}
{"code": {"body": "    int getMinRating(final int sumLength) {\n        int minRating = 0;\n\n        if (sumLength <= FOUR) {\n            minRating = FIVE;\n        } else if (sumLength >= FIVE && sumLength <= SEVEN) {\n            minRating = FOUR;\n        } else if (sumLength >= EIGHT && sumLength <= ELEVEN) {\n            minRating = THREE;\n        } else if (sumLength == TWELVE) {\n            minRating = TWO;\n        } else {\n            minRating = ONE; \n        }\n\n        return minRating;\n    }", "comment": "/**\n     * Obtains the min rating of the length sum of the 2 names. In essence the larger the sum length the smaller the\n     * min rating. Values strictly from documentation.\n     *\n     * <h2>API Usage</h2>\n     * <p>\n     * Consider this method private, it is package protected for unit testing only.\n     * </p>\n     *\n     * @param sumLength\n     *            The length of 2 strings sent down\n     * @return The min rating value\n     */"}}
{"code": {"body": "    public boolean isEncodeEquals(String name1, String name2) {\n        \n        if (name1 == null || EMPTY.equalsIgnoreCase(name1) || SPACE.equalsIgnoreCase(name1)) {\n            return false;\n        } else if (name2 == null || EMPTY.equalsIgnoreCase(name2) || SPACE.equalsIgnoreCase(name2)) {\n            return false;\n        } else if (name1.length() == 1 || name2.length() == 1) {\n            return false;\n        } else if (name1.equalsIgnoreCase(name2)) {\n            return true;\n        }\n\n        \n        name1 = cleanName(name1);\n        name2 = cleanName(name2);\n\n        \n\n        \n        name1 = removeVowels(name1);\n        name2 = removeVowels(name2);\n\n        \n        name1 = removeDoubleConsonants(name1);\n        name2 = removeDoubleConsonants(name2);\n\n        \n        name1 = getFirst3Last3(name1);\n        name2 = getFirst3Last3(name2);\n\n        \n        \n        if (Math.abs(name1.length() - name2.length()) >= THREE) {\n            return false;\n        }\n\n        \n        \n        final int sumLength = Math.abs(name1.length() + name2.length());\n        int minRating = 0;\n        minRating = getMinRating(sumLength);\n\n        \n        \n        final int count = leftToRightThenRightToLeftProcessing(name1, name2);\n\n        \n        \n        return count >= minRating;\n\n    }", "comment": "/**\n     * Determines if two names are homophonous via Match Rating Approach (MRA) algorithm. It should be noted that the\n     * strings are cleaned in the same way as {@link #encode(String)}.\n     *\n     * @param name1\n     *            First of the 2 strings (names) to compare\n     * @param name2\n     *            Second of the 2 names to compare\n     * @return <code>true</code> if the encodings are identical <code>false</code> otherwise.\n     */"}}
{"code": {"body": "    boolean isVowel(final String letter) {\n        return letter.equalsIgnoreCase(\"\") || letter.equalsIgnoreCase(\"\") || letter.equalsIgnoreCase(\"\") ||\n               letter.equalsIgnoreCase(\"\") || letter.equalsIgnoreCase(\"\");\n    }", "comment": "/**\n     * Determines if a letter is a vowel.\n     *\n     * <h2>API Usage</h2>\n     * <p>\n     * Consider this method private, it is package protected for unit testing only.\n     * </p>\n     *\n     * @param letter\n     *            The letter under investiagtion\n     * @return True if a vowel, else false\n     */"}}
{"code": {"body": "    int leftToRightThenRightToLeftProcessing(final String name1, final String name2) {\n        final char[] name1Char = name1.toCharArray();\n        final char[] name2Char = name2.toCharArray();\n\n        final int name1Size = name1.length() - 1;\n        final int name2Size = name2.length() - 1;\n\n        String name1LtRStart = EMPTY;\n        String name1LtREnd = EMPTY;\n\n        String name2RtLStart = EMPTY;\n        String name2RtLEnd = EMPTY;\n\n        for (int i = 0; i < name1Char.length; i++) {\n            if (i > name2Size) {\n                break;\n            }\n\n            name1LtRStart = name1.substring(i, i + 1);\n            name1LtREnd = name1.substring(name1Size - i, name1Size - i + 1);\n\n            name2RtLStart = name2.substring(i, i + 1);\n            name2RtLEnd = name2.substring(name2Size - i, name2Size - i + 1);\n\n            \n            if (name1LtRStart.equals(name2RtLStart)) {\n                name1Char[i] = '';\n                name2Char[i] = '';\n            }\n\n            \n            if (name1LtREnd.equals(name2RtLEnd)) {\n                name1Char[name1Size - i] = '';\n                name2Char[name2Size - i] = '';\n            }\n        }\n\n        \n        final String strA = new String(name1Char).replaceAll(\"\", EMPTY);\n        final String strB = new String(name2Char).replaceAll(\"\", EMPTY);\n\n        \n        if (strA.length() > strB.length()) {\n            return Math.abs(SIX - strA.length());\n        } else {\n            return Math.abs(SIX - strB.length());\n        }\n    }", "comment": "/**\n     * Processes the names from left to right (first) then right to left removing identical letters in same positions.\n     * Then subtracts the longer string that remains from 6 and returns this.\n     *\n     * <h2>API Usage</h2>\n     * <p>\n     * Consider this method private, it is package protected for unit testing only.\n     * </p>\n     *\n     * @param name1\n     *            name2\n     * @return\n     */"}}
{"code": {"body": "    String removeAccents(final String accentedWord) {\n        if (accentedWord == null) {\n            return null;\n        }\n\n        final StringBuilder sb = new StringBuilder();\n        final int n = accentedWord.length();\n\n        for (int i = 0; i < n; i++) {\n            final char c = accentedWord.charAt(i);\n            final int pos = UNICODE.indexOf(c);\n            if (pos > -1) {\n                sb.append(PLAIN_ASCII.charAt(pos));\n            } else {\n                sb.append(c);\n            }\n        }\n\n        return sb.toString();\n    }", "comment": "/**\n     * Removes accented letters and replaces with non-accented ascii equivalent Case is preserved.\n     * http://www.codecodex.com/wiki/Remove_accent_from_letters_%28ex_.%C3%A9_to_e%29\n     *\n     * @param accentedWord\n     *            The word that may have accents in it.\n     * @return De-accented word\n     */"}}
{"code": {"body": "    String removeDoubleConsonants(final String name) {\n        String replacedName = name.toUpperCase();\n        for (final String dc : DOUBLE_CONSONANT) {\n            if (replacedName.contains(dc)) {\n                final String singleLetter = dc.substring(0, 1);\n                replacedName = replacedName.replace(dc, singleLetter);\n            }\n        }\n        return replacedName;\n    }", "comment": "/**\n     * Replaces any double consonant pair with the single letter equivalent.\n     *\n     * <h2>API Usage</h2>\n     * <p>\n     * Consider this method private, it is package protected for unit testing only.\n     * </p>\n     *\n     * @param name\n     *            String to have double consonants removed\n     * @return Single consonant word\n     */"}}
{"code": {"body": "    String removeVowels(String name) {\n        \n        final String firstLetter = name.substring(0, 1);\n\n        name = name.replaceAll(\"\", EMPTY);\n        name = name.replaceAll(\"\", EMPTY);\n        name = name.replaceAll(\"\", EMPTY);\n        name = name.replaceAll(\"\", EMPTY);\n        name = name.replaceAll(\"\", EMPTY);\n\n        name = name.replaceAll(\"\", SPACE);\n\n        \n        if (isVowel(firstLetter)) {\n            return firstLetter + name;\n        } else {\n            return name;\n        }\n    }", "comment": "/**\n     * Deletes all vowels unless the vowel begins the word.\n     *\n     * <h2>API Usage</h2>\n     * <p>\n     * Consider this method private, it is package protected for unit testing only.\n     * </p>\n     *\n     * @param name\n     *            The name to have vowels removed\n     * @return De-voweled word\n     */"}}
{"code": {"body": "public Metaphone() {\n        super();\n    }", "comment": "/**\n     * Creates an instance of the Metaphone encoder\n     */"}}
{"code": {"body": "    public String metaphone(final String txt) {\n        boolean hard = false;\n        int txtLength;\n        if (txt == null || (txtLength = txt.length()) == 0) {\n            return \"\";\n        }\n        \n        if (txtLength == 1) {\n            return txt.toUpperCase(java.util.Locale.ENGLISH);\n        }\n\n        final char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();\n\n        final StringBuilder local = new StringBuilder(40); \n        final StringBuilder code = new StringBuilder(10); \n        \n        switch(inwd[0]) {\n        case '':\n        case '':\n        case '': \n            if (inwd[1] == '') {\n                local.append(inwd, 1, inwd.length - 1);\n            } else {\n                local.append(inwd);\n            }\n            break;\n        case '': \n            if (inwd[1] == '') {\n                local.append(inwd, 1, inwd.length - 1);\n            } else {\n                local.append(inwd);\n            }\n            break;\n        case '': \n            if (inwd[1] == '') {   \n                local.append(inwd, 1, inwd.length - 1);\n                break;\n            }\n            if (inwd[1] == '') {\n                local.append(inwd, 1, inwd.length - 1);\n                local.setCharAt(0, ''); \n            } else {\n                local.append(inwd);\n            }\n            break;\n        case '': \n            inwd[0] = '';\n            local.append(inwd);\n            break;\n        default:\n            local.append(inwd);\n        } \n\n        final int wdsz = local.length();\n        int n = 0;\n\n        while (code.length() < this.getMaxCodeLen() &&\n               n < wdsz ) { \n            final char symb = local.charAt(n);\n            \n            if (symb != '' && isPreviousChar( local, n, symb ) ) {\n                n++;\n            } else { \n                switch(symb) {\n                case '':\n                case '':\n                case '':\n                case '':\n                case '':\n                    if (n == 0) {\n                        code.append(symb);\n                    }\n                    break; \n                case '':\n                    if ( isPreviousChar(local, n, '') &&\n                         isLastChar(wdsz, n) ) { \n                        break;\n                    }\n                    code.append(symb);\n                    break;\n                case '': \n                    \n                    if ( isPreviousChar(local, n, '') &&\n                         !isLastChar(wdsz, n) &&\n                         FRONTV.indexOf(local.charAt(n + 1)) >= 0 ) {\n                        break;\n                    }\n                    if (regionMatch(local, n, \"\")) { \n                        code.append('');\n                        break;\n                    }\n                    if (!isLastChar(wdsz, n) &&\n                        FRONTV.indexOf(local.charAt(n + 1)) >= 0) {\n                        code.append('');\n                        break; \n                    }\n                    if (isPreviousChar(local, n, '') &&\n                        isNextChar(local, n, '') ) { \n                        code.append('');\n                        break;\n                    }\n                    if (isNextChar(local, n, '')) { \n                        if (n == 0 &&\n                            wdsz >= 3 &&\n                            isVowel(local,2) ) { \n                            code.append('');\n                        } else {\n                            code.append(''); \n                        }\n                    } else {\n                        code.append('');\n                    }\n                    break;\n                case '':\n                    if (!isLastChar(wdsz, n + 1) &&\n                        isNextChar(local, n, '') &&\n                        FRONTV.indexOf(local.charAt(n + 2)) >= 0) { \n                        code.append(''); n += 2;\n                    } else {\n                        code.append('');\n                    }\n                    break;\n                case '': \n                    if (isLastChar(wdsz, n + 1) &&\n                        isNextChar(local, n, '')) {\n                        break;\n                    }\n                    if (!isLastChar(wdsz, n + 1) &&\n                        isNextChar(local,n,'') &&\n                        !isVowel(local,n+2)) {\n                        break;\n                    }\n                    if (n > 0 &&\n                        ( regionMatch(local, n, \"\") ||\n                          regionMatch(local, n, \"\") ) ) {\n                        break; \n                    }\n                    if (isPreviousChar(local, n, '')) {\n                        \n                        hard = true;\n                    } else {\n                        hard = false;\n                    }\n                    if (!isLastChar(wdsz, n) &&\n                        FRONTV.indexOf(local.charAt(n + 1)) >= 0 &&\n                        !hard) {\n                        code.append('');\n                    } else {\n                        code.append('');\n                    }\n                    break;\n                case '':\n                    if (isLastChar(wdsz, n)) {\n                        break; \n                    }\n                    if (n > 0 &&\n                        VARSON.indexOf(local.charAt(n - 1)) >= 0) {\n                        break;\n                    }\n                    if (isVowel(local,n+1)) {\n                        code.append(''); \n                    }\n                    break;\n                case '':\n                case '':\n                case '':\n                case '':\n                case '':\n                case '':\n                    code.append(symb);\n                    break;\n                case '':\n                    if (n > 0) { \n                        if (!isPreviousChar(local, n, '')) {\n                            code.append(symb);\n                        }\n                    } else {\n                        code.append(symb); \n                    }\n                    break;\n                case '':\n                    if (isNextChar(local,n,'')) {\n                        \n                        code.append('');\n                    } else {\n                        code.append(symb);\n                    }\n                    break;\n                case '':\n                    code.append('');\n                    break;\n                case '':\n                    if (regionMatch(local,n,\"\") ||\n                        regionMatch(local,n,\"\") ||\n                        regionMatch(local,n,\"\")) {\n                        code.append('');\n                    } else {\n                        code.append('');\n                    }\n                    break;\n                case '':\n                    if (regionMatch(local,n,\"\") ||\n                        regionMatch(local,n,\"\")) {\n                        code.append('');\n                        break;\n                    }\n                    if (regionMatch(local,n,\"\")) {\n                        \n                        break;\n                    }\n                    \n                    if (regionMatch(local,n,\"\")) {\n                        code.append('');\n                    } else {\n                        code.append('');\n                    }\n                    break;\n                case '':\n                    code.append(''); break;\n                case '':\n                case '': \n                    if (!isLastChar(wdsz,n) &&\n                        isVowel(local,n+1)) {\n                        code.append(symb);\n                    }\n                    break;\n                case '':\n                    code.append('');\n                    code.append('');\n                    break;\n                case '':\n                    code.append('');\n                    break;\n                default:\n                    \n                    break;\n                } \n                n++;\n            } \n            if (code.length() > this.getMaxCodeLen()) {\n                code.setLength(this.getMaxCodeLen());\n            }\n        }\n        return code.toString();\n    }", "comment": "/**\n     * Find the metaphone value of a String. This is similar to the\n     * soundex algorithm, but better at finding similar sounding words.\n     * All input is converted to upper case.\n     * Limitations: Input format is expected to be a single ASCII word\n     * with only characters in the A - Z range, no punctuation or numbers.\n     *\n     * @param txt String to find the metaphone code for\n     * @return A metaphone code corresponding to the String supplied\n     */"}}
{"code": {"body": "    public boolean isMetaphoneEqual(final String str1, final String str2) {\n        return metaphone(str1).equals(metaphone(str2));\n    }", "comment": "/**\n     * Tests is the metaphones of two strings are identical.\n     *\n     * @param str1 First of two strings to compare\n     * @param str2 Second of two strings to compare\n     * @return <code>true</code> if the metaphones of these strings are identical,\n     *        <code>false</code> otherwise.\n     */"}}
{"code": {"body": "    public int getMaxCodeLen() { return this.maxCodeLen; }", "comment": "/**\n     * Returns the maxCodeLen.\n     * @return int\n     */"}}
{"code": {"body": "    public void setMaxCodeLen(final int maxCodeLen) { this.maxCodeLen = maxCodeLen; }", "comment": "/**\n     * Sets the maxCodeLen.\n     * @param maxCodeLen The maxCodeLen to set\n     */"}}
{"code": {"body": "public Nysiis() {\n        this(true);\n    }", "comment": "/**\n     * Creates an instance of the {@link Nysiis} encoder with strict mode (original form),\n     * i.e. encoded strings have a maximum length of 6.\n     */"}}
{"code": {"body": "public Nysiis(final boolean strict) {\n        this.strict = strict;\n    }", "comment": "/**\n     * Create an instance of the {@link Nysiis} encoder with the specified strict mode:\n     *\n     * <ul>\n     *  <li><code>true</code>: encoded strings have a maximum length of 6</li>\n     *  <li><code>false</code>: encoded strings may have arbitrary length</li>\n     * </ul>\n     *\n     * @param strict\n     *            the strict mode\n     */"}}
{"code": {"body": "    private static boolean isVowel(final char c) {\n        return c == '' || c == '' || c == '' || c == '' || c == '';\n    }", "comment": "/**\n     * Tests if the given character is a vowel.\n     *\n     * @param c\n     *            the character to test\n     * @return <code>true</code> if the character is a vowel, <code>false</code> otherwise\n     */"}}
{"code": {"body": "    private static char[] transcodeRemaining(final char prev, final char curr, final char next, final char aNext) {\n        \n        if (curr == '' && next == '') {\n            return CHARS_AF;\n        }\n\n        \n        if (isVowel(curr)) {\n            return CHARS_A;\n        }\n\n        \n        if (curr == '') {\n            return CHARS_G;\n        } else if (curr == '') {\n            return CHARS_S;\n        } else if (curr == '') {\n            return CHARS_N;\n        }\n\n        \n        if (curr == '') {\n            if (next == '') {\n                return CHARS_NN;\n            } else {\n                return CHARS_C;\n            }\n        }\n\n        \n        if (curr == '' && next == '' && aNext == '') {\n            return CHARS_SSS;\n        }\n\n        \n        if (curr == '' && next == '') {\n            return CHARS_FF;\n        }\n\n        \n        if (curr == '' && (!isVowel(prev) || !isVowel(next))) {\n            return new char[] { prev };\n        }\n\n        \n        if (curr == '' && isVowel(prev)) {\n            return new char[] { prev };\n        }\n\n        return new char[] { curr };\n    }", "comment": "/**\n     * Transcodes the remaining parts of the String. The method operates on a sliding window, looking at 4 characters at\n     * a time: [i-1, i, i+1, i+2].\n     *\n     * @param prev\n     *            the previous character\n     * @param curr\n     *            the current character\n     * @param next\n     *            the next character\n     * @param aNext\n     *            the after next character\n     * @return a transcoded array of characters, starting from the current position\n     */"}}
{"code": {"body": "    public boolean isStrict() {\n        return this.strict;\n    }", "comment": "/**\n     * Indicates the strict mode for this {@link Nysiis} encoder.\n     *\n     * @return <code>true</code> if the encoder is configured for strict mode, <code>false</code> otherwise\n     */"}}
{"code": {"body": "    public String nysiis(String str) {\n        if (str == null) {\n            return null;\n        }\n\n        \n        str = SoundexUtils.clean(str);\n\n        if (str.length() == 0) {\n            return str;\n        }\n\n        \n        \n        str = PAT_MAC.matcher(str).replaceFirst(\"\");\n        str = PAT_KN.matcher(str).replaceFirst(\"\");\n        str = PAT_K.matcher(str).replaceFirst(\"\");\n        str = PAT_PH_PF.matcher(str).replaceFirst(\"\");\n        str = PAT_SCH.matcher(str).replaceFirst(\"\");\n\n        \n        \n        str = PAT_EE_IE.matcher(str).replaceFirst(\"\");\n        str = PAT_DT_ETC.matcher(str).replaceFirst(\"\");\n\n        \n        final StringBuilder key = new StringBuilder(str.length());\n        key.append(str.charAt(0));\n\n        \n        final char[] chars = str.toCharArray();\n        final int len = chars.length;\n\n        for (int i = 1; i < len; i++) {\n            final char next = i < len - 1 ? chars[i + 1] : SPACE;\n            final char aNext = i < len - 2 ? chars[i + 2] : SPACE;\n            final char[] transcoded = transcodeRemaining(chars[i - 1], chars[i], next, aNext);\n            System.arraycopy(transcoded, 0, chars, i, transcoded.length);\n\n            \n            if (chars[i] != chars[i - 1]) {\n                key.append(chars[i]);\n            }\n        }\n\n        if (key.length() > 1) {\n            char lastChar = key.charAt(key.length() - 1);\n\n            \n            if (lastChar == '') {\n                key.deleteCharAt(key.length() - 1);\n                lastChar = key.charAt(key.length() - 1);\n            }\n\n            if (key.length() > 2) {\n                final char last2Char = key.charAt(key.length() - 2);\n                \n                if (last2Char == '' && lastChar == '') {\n                    key.deleteCharAt(key.length() - 2);\n                }\n            }\n\n            \n            if (lastChar == '') {\n                key.deleteCharAt(key.length() - 1);\n            }\n        }\n\n        final String string = key.toString();\n        return this.isStrict() ? string.substring(0, Math.min(TRUE_LENGTH, string.length())) : string;\n    }", "comment": "/**\n     * Retrieves the NYSIIS code for a given String object.\n     *\n     * @param str\n     *            String to encode using the NYSIIS algorithm\n     * @return A NYSIIS code for the String supplied\n     */"}}
{"code": {"body": "public RefinedSoundex() {\n        this.soundexMapping = US_ENGLISH_MAPPING;\n    }", "comment": "/**\n     * Creates an instance of the RefinedSoundex object using the default US\n     * English mapping.\n     */"}}
{"code": {"body": "public RefinedSoundex(final char[] mapping) {\n        this.soundexMapping = new char[mapping.length];\n        System.arraycopy(mapping, 0, this.soundexMapping, 0, mapping.length);\n    }", "comment": "/**\n     * Creates a refined soundex instance using a custom mapping. This\n     * constructor can be used to customize the mapping, and/or possibly\n     * provide an internationalized mapping for a non-Western character set.\n     *\n     * @param mapping\n     *                  Mapping array to use when finding the corresponding code for\n     *                  a given character\n     */"}}
{"code": {"body": "public RefinedSoundex(final String mapping) {\n        this.soundexMapping = mapping.toCharArray();\n    }", "comment": "/**\n     * Creates a refined Soundex instance using a custom mapping. This constructor can be used to customize the mapping,\n     * and/or possibly provide an internationalized mapping for a non-Western character set.\n     *\n     * @param mapping\n     *            Mapping string to use when finding the corresponding code for a given character\n     * @since 1.4\n     */"}}
{"code": {"body": "    public int difference(final String s1, final String s2) throws EncoderException {\n        return SoundexUtils.difference(this, s1, s2);\n    }", "comment": "/**\n     * Returns the number of characters in the two encoded Strings that are the\n     * same. This return value ranges from 0 to the length of the shortest\n     * encoded String: 0 indicates little or no similarity, and 4 out of 4 (for\n     * example) indicates strong similarity or identical values. For refined\n     * Soundex, the return value can be greater than 4.\n     *\n     * @param s1\n     *                  A String that will be encoded and compared.\n     * @param s2\n     *                  A String that will be encoded and compared.\n     * @return The number of characters in the two encoded Strings that are the\n     *             same from 0 to to the length of the shortest encoded String.\n     *\n     * @see SoundexUtils#difference(StringEncoder,String,String)\n     * @see <a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\">\n     *          MS T-SQL DIFFERENCE</a>\n     *\n     * @throws EncoderException\n     *                  if an error occurs encoding one of the strings\n     * @since 1.3\n     */"}}
{"code": {"body": "    char getMappingCode(final char c) {\n        if (!Character.isLetter(c)) {\n            return 0;\n        }\n        return this.soundexMapping[Character.toUpperCase(c) - ''];\n    }", "comment": "/**\n     * Returns the mapping code for a given character. The mapping codes are\n     * maintained in an internal char array named soundexMapping, and the\n     * default values of these mappings are US English.\n     *\n     * @param c\n     *                  char to get mapping for\n     * @return A character (really a numeral) to return for the given char\n     */"}}
{"code": {"body": "    public String soundex(String str) {\n        if (str == null) {\n            return null;\n        }\n        str = SoundexUtils.clean(str);\n        if (str.length() == 0) {\n            return str;\n        }\n\n        final StringBuilder sBuf = new StringBuilder();\n        sBuf.append(str.charAt(0));\n\n        char last, current;\n        last = '';\n\n        for (int i = 0; i < str.length(); i++) {\n\n            current = getMappingCode(str.charAt(i));\n            if (current == last) {\n                continue;\n            } else if (current != 0) {\n                sBuf.append(current);\n            }\n\n            last = current;\n\n        }\n\n        return sBuf.toString();\n    }", "comment": "/**\n     * Retrieves the Refined Soundex code for a given String object.\n     *\n     * @param str\n     *                  String to encode using the Refined Soundex algorithm\n     * @return A soundex code for the String supplied\n     */"}}
{"code": {"body": "public Soundex() {\n        this.soundexMapping = US_ENGLISH_MAPPING;\n    }", "comment": "/**\n     * Creates an instance using US_ENGLISH_MAPPING\n     *\n     * @see Soundex#Soundex(char[])\n     * @see Soundex#US_ENGLISH_MAPPING\n     */"}}
{"code": {"body": "public Soundex(final char[] mapping) {\n        this.soundexMapping = new char[mapping.length];\n        System.arraycopy(mapping, 0, this.soundexMapping, 0, mapping.length);\n    }", "comment": "/**\n     * Creates a soundex instance using the given mapping. This constructor can be used to provide an internationalized\n     * mapping for a non-Western character set.\n     *\n     * Every letter of the alphabet is \"mapped\" to a numerical value. This char array holds the values to which each\n     * letter is mapped. This implementation contains a default map for US_ENGLISH\n     *\n     * @param mapping\n     *                  Mapping array to use when finding the corresponding code for a given character\n     */"}}
{"code": {"body": "public Soundex(final String mapping) {\n        this.soundexMapping = mapping.toCharArray();\n    }", "comment": "/**\n     * Creates a refined soundex instance using a custom mapping. This constructor can be used to customize the mapping,\n     * and/or possibly provide an internationalized mapping for a non-Western character set.\n     *\n     * @param mapping\n     *            Mapping string to use when finding the corresponding code for a given character\n     * @since 1.4\n     */"}}
{"code": {"body": "    public int difference(final String s1, final String s2) throws EncoderException {\n        return SoundexUtils.difference(this, s1, s2);\n    }", "comment": "/**\n     * Encodes the Strings and returns the number of characters in the two encoded Strings that are the same. This\n     * return value ranges from 0 through 4: 0 indicates little or no similarity, and 4 indicates strong similarity or\n     * identical values.\n     *\n     * @param s1\n     *                  A String that will be encoded and compared.\n     * @param s2\n     *                  A String that will be encoded and compared.\n     * @return The number of characters in the two encoded Strings that are the same from 0 to 4.\n     *\n     * @see SoundexUtils#difference(StringEncoder,String,String)\n     * @see <a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\"> MS\n     *          T-SQL DIFFERENCE </a>\n     *\n     * @throws EncoderException\n     *                  if an error occurs encoding one of the strings\n     * @since 1.3\n     */"}}
{"code": {"body": "    private char getMappingCode(final String str, final int index) {\n        \n        final char mappedChar = this.map(str.charAt(index));\n        \n        if (index > 1 && mappedChar != '') {\n            final char hwChar = str.charAt(index - 1);\n            if ('' == hwChar || '' == hwChar) {\n                final char preHWChar = str.charAt(index - 2);\n                final char firstCode = this.map(preHWChar);\n                if (firstCode == mappedChar || '' == preHWChar || '' == preHWChar) {\n                    return 0;\n                }\n            }\n        }\n        return mappedChar;\n    }", "comment": "/**\n     * Used internally by the SoundEx algorithm.\n     *\n     * Consonants from the same code group separated by W or H are treated as one.\n     *\n     * @param str\n     *                  the cleaned working string to encode (in upper case).\n     * @param index\n     *                  the character position to encode\n     * @return Mapping code for a particular character\n     * @throws IllegalArgumentException\n     *                  if the character is not mapped\n     */"}}
{"code": {"body": "    private char[] getSoundexMapping() {\n        return this.soundexMapping;\n    }", "comment": "/**\n     * Returns the soundex mapping.\n     *\n     * @return soundexMapping.\n     */"}}
{"code": {"body": "    private char map(final char ch) {\n        final int index = ch - '';\n        if (index < 0 || index >= this.getSoundexMapping().length) {\n            throw new IllegalArgumentException(\"\" + ch);\n        }\n        return this.getSoundexMapping()[index];\n    }", "comment": "/**\n     * Maps the given upper-case character to its Soundex code.\n     *\n     * @param ch\n     *                  An upper-case character.\n     * @return A Soundex code.\n     * @throws IllegalArgumentException\n     *                  Thrown if <code>ch</code> is not mapped.\n     */"}}
{"code": {"body": "    public String soundex(String str) {\n        if (str == null) {\n            return null;\n        }\n        str = SoundexUtils.clean(str);\n        if (str.length() == 0) {\n            return str;\n        }\n        final char out[] = {'', '', '', ''};\n        char last, mapped;\n        int incount = 1, count = 1;\n        out[0] = str.charAt(0);\n        \n        last = getMappingCode(str, 0);\n        while (incount < str.length() && count < out.length) {\n            mapped = getMappingCode(str, incount++);\n            if (mapped != 0) {\n                if (mapped != '' && mapped != last) {\n                    out[count++] = mapped;\n                }\n                last = mapped;\n            }\n        }\n        return new String(out);\n    }", "comment": "/**\n     * Retrieves the Soundex code for a given String object.\n     *\n     * @param str\n     *                  String to encode using the Soundex algorithm\n     * @return A soundex code for the String supplied\n     * @throws IllegalArgumentException\n     *                  if a character is not mapped\n     */"}}
{"code": {"body": "    static String clean(final String str) {\n        if (str == null || str.length() == 0) {\n            return str;\n        }\n        final int len = str.length();\n        final char[] chars = new char[len];\n        int count = 0;\n        for (int i = 0; i < len; i++) {\n            if (Character.isLetter(str.charAt(i))) {\n                chars[count++] = str.charAt(i);\n            }\n        }\n        if (count == len) {\n            return str.toUpperCase(java.util.Locale.ENGLISH);\n        }\n        return new String(chars, 0, count).toUpperCase(java.util.Locale.ENGLISH);\n    }", "comment": "/**\n     * Cleans up the input string before Soundex processing by only returning\n     * upper case letters.\n     *\n     * @param str\n     *                  The String to clean.\n     * @return A clean String.\n     */"}}
{"code": {"body": "    static int difference(final StringEncoder encoder, final String s1, final String s2) throws EncoderException {\n        return differenceEncoded(encoder.encode(s1), encoder.encode(s2));\n    }", "comment": "/**\n     * Encodes the Strings and returns the number of characters in the two\n     * encoded Strings that are the same.\n     * <ul>\n     * <li>For Soundex, this return value ranges from 0 through 4: 0 indicates\n     * little or no similarity, and 4 indicates strong similarity or identical\n     * values.</li>\n     * <li>For refined Soundex, the return value can be greater than 4.</li>\n     * </ul>\n     *\n     * @param encoder\n     *                  The encoder to use to encode the Strings.\n     * @param s1\n     *                  A String that will be encoded and compared.\n     * @param s2\n     *                  A String that will be encoded and compared.\n     * @return The number of characters in the two Soundex encoded Strings that\n     *             are the same.\n     *\n     * @see #differenceEncoded(String,String)\n     * @see <a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\">\n     *          MS T-SQL DIFFERENCE</a>\n     *\n     * @throws EncoderException\n     *                  if an error occurs encoding one of the strings\n     */"}}
{"code": {"body": "    static int differenceEncoded(final String es1, final String es2) {\n\n        if (es1 == null || es2 == null) {\n            return 0;\n        }\n        final int lengthToMatch = Math.min(es1.length(), es2.length());\n        int diff = 0;\n        for (int i = 0; i < lengthToMatch; i++) {\n            if (es1.charAt(i) == es2.charAt(i)) {\n                diff++;\n            }\n        }\n        return diff;\n    }", "comment": "/**\n     * Returns the number of characters in the two Soundex encoded Strings that\n     * are the same.\n     * <ul>\n     * <li>For Soundex, this return value ranges from 0 through 4: 0 indicates\n     * little or no similarity, and 4 indicates strong similarity or identical\n     * values.</li>\n     * <li>For refined Soundex, the return value can be greater than 4.</li>\n     * </ul>\n     *\n     * @param es1\n     *                  An encoded String.\n     * @param es2\n     *                  An encoded String.\n     * @return The number of characters in the two Soundex encoded Strings that\n     *             are the same.\n     *\n     * @see <a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\">\n     *          MS T-SQL DIFFERENCE</a>\n     */"}}
{"code": {"body": "    public NameType getNameType() {\n        return this.engine.getNameType();\n    }", "comment": "/**\n     * Gets the name type currently in operation.\n     *\n     * @return the NameType currently being used\n     */"}}
{"code": {"body": "    public RuleType getRuleType() {\n        return this.engine.getRuleType();\n    }", "comment": "/**\n     * Gets the rule type currently in operation.\n     *\n     * @return the RuleType currently being used\n     */"}}
{"code": {"body": "    public boolean isConcat() {\n        return this.engine.isConcat();\n    }", "comment": "/**\n     * Discovers if multiple possible encodings are concatenated.\n     *\n     * @return true if multiple encodings are concatenated, false if just the first one is returned\n     */"}}
{"code": {"body": "    public void setConcat(final boolean concat) {\n        this.engine = new PhoneticEngine(this.engine.getNameType(),\n                                         this.engine.getRuleType(),\n                                         concat,\n                                         this.engine.getMaxPhonemes());\n    }", "comment": "/**\n     * Sets how multiple possible phonetic encodings are combined.\n     *\n     * @param concat\n     *            true if multiple encodings are to be combined with a '|', false if just the first one is\n     *            to be considered\n     */"}}
{"code": {"body": "    public void setNameType(final NameType nameType) {\n        this.engine = new PhoneticEngine(nameType,\n                                         this.engine.getRuleType(),\n                                         this.engine.isConcat(),\n                                         this.engine.getMaxPhonemes());\n    }", "comment": "/**\n     * Sets the type of name. Use {@link NameType#GENERIC} unless you specifically want phonetic encodings\n     * optimized for Ashkenazi or Sephardic Jewish family names.\n     *\n     * @param nameType\n     *            the NameType in use\n     */"}}
{"code": {"body": "    public void setRuleType(final RuleType ruleType) {\n        this.engine = new PhoneticEngine(this.engine.getNameType(),\n                                         ruleType,\n                                         this.engine.isConcat(),\n                                         this.engine.getMaxPhonemes());\n    }", "comment": "/**\n     * Sets the rule type to apply. This will widen or narrow the range of phonetic encodings considered.\n     *\n     * @param ruleType\n     *            {@link RuleType#APPROX} or {@link RuleType#EXACT} for approximate or exact phonetic matches\n     */"}}
{"code": {"body": "    public void setMaxPhonemes(final int maxPhonemes) {\n        this.engine = new PhoneticEngine(this.engine.getNameType(),\n                                         this.engine.getRuleType(),\n                                         this.engine.isConcat(),\n                                         maxPhonemes);\n    }", "comment": "/**\n     * Sets the number of maximum of phonemes that shall be considered by the engine.\n     *\n     * @param maxPhonemes\n     *            the maximum number of phonemes returned by the engine\n     * @since 1.7\n     */"}}
{"code": {"body": "public Languages.LanguageSet guessLanguages(final String input) {\n        final String text = input.toLowerCase(Locale.ENGLISH);\n\n        final Set<String> langs = new HashSet<String>(this.languages.getLanguages());\n        for (final LangRule rule : this.rules) {\n            if (rule.matches(text)) {\n                if (rule.acceptOnMatch) {\n                    langs.retainAll(rule.languages);\n                } else {\n                    langs.removeAll(rule.languages);\n                }\n            }\n        }\n\n        final Languages.LanguageSet ls = Languages.LanguageSet.from(langs);\n        return ls.equals(Languages.NO_LANGUAGES) ? Languages.ANY_LANGUAGE : ls;\n    }", "comment": "/**\n     * Guesses the languages of a word.\n     *\n     * @param input\n     *            the word\n     * @return a Set of Strings of language names that are potential matches for the input word\n     */"}}
{"code": {"body": "    public static Lang instance(final NameType nameType) {\n        return Langs.get(nameType);\n    }", "comment": "/**\n     * Gets a Lang instance for one of the supported NameTypes.\n     *\n     * @param nameType\n     *            the NameType to look up\n     * @return a Lang encapsulating the language guessing rules for that name type\n     */"}}
{"code": {"body": "    public static Lang loadFromResource(final String languageRulesResourceName, final Languages languages) {\n        final List<LangRule> rules = new ArrayList<LangRule>();\n        final InputStream lRulesIS = Lang.class.getClassLoader().getResourceAsStream(languageRulesResourceName);\n\n        if (lRulesIS == null) {\n            throw new IllegalStateException(\"\" + LANGUAGE_RULES_RN);\n        }\n\n        final Scanner scanner = new Scanner(lRulesIS, ResourceConstants.ENCODING);\n        try {\n            boolean inExtendedComment = false;\n            while (scanner.hasNextLine()) {\n                final String rawLine = scanner.nextLine();\n                String line = rawLine;\n                if (inExtendedComment) {\n                    \n                    if (line.endsWith(ResourceConstants.EXT_CMT_END)) {\n                        inExtendedComment = false;\n                    }\n                } else {\n                    if (line.startsWith(ResourceConstants.EXT_CMT_START)) {\n                        inExtendedComment = true;\n                    } else {\n                        \n                        final int cmtI = line.indexOf(ResourceConstants.CMT);\n                        if (cmtI >= 0) {\n                            line = line.substring(0, cmtI);\n                        }\n\n                        \n                        line = line.trim();\n\n                        if (line.length() == 0) {\n                            continue; \n                        }\n\n                        \n                        final String[] parts = line.split(\"\");\n\n                        if (parts.length != 3) {\n                            throw new IllegalArgumentException(\"\" + rawLine +\n                                    \"\" + languageRulesResourceName + \"\");\n                        }\n\n                        final Pattern pattern = Pattern.compile(parts[0]);\n                        final String[] langs = parts[1].split(\"\");\n                        final boolean accept = parts[2].equals(\"\");\n\n                        rules.add(new LangRule(pattern, new HashSet<String>(Arrays.asList(langs)), accept));\n                    }\n                }\n            }\n        } finally {\n            scanner.close();\n        }\n        return new Lang(rules, languages);\n    }", "comment": "/**\n     * Loads language rules from a resource.\n     * <p>\n     * In normal use, you will obtain instances of Lang through the {@link #instance(NameType)} method.\n     * You will only need to call this yourself if you are developing custom language mapping rules.\n     *\n     * @param languageRulesResourceName\n     *            the fully-qualified resource name to load\n     * @param languages\n     *            the languages that these rules will support\n     * @return a Lang encapsulating the loaded language-guessing rules.\n     */"}}
{"code": {"body": "    public String guessLanguage(final String text) {\n        final Languages.LanguageSet ls = guessLanguages(text);\n        return ls.isSingleton() ? ls.getAny() : Languages.ANY;\n    }", "comment": "/**\n     * Guesses the language of a word.\n     *\n     * @param text\n     *            the word\n     * @return the language that the word originates from or {@link Languages#ANY} if there was no unique match\n     */"}}
{"code": {"body": "    public Languages.LanguageSet guessLanguages(final String input) {\n        final String text = input.toLowerCase(Locale.ENGLISH);\n\n        final Set<String> langs = new HashSet<String>(this.languages.getLanguages());\n        for (final LangRule rule : this.rules) {\n            if (rule.matches(text)) {\n                if (rule.acceptOnMatch) {\n                    langs.retainAll(rule.languages);\n                } else {\n                    langs.removeAll(rule.languages);\n                }\n            }\n        }\n\n        final Languages.LanguageSet ls = Languages.LanguageSet.from(langs);\n        return ls.equals(Languages.NO_LANGUAGES) ? Languages.ANY_LANGUAGE : ls;\n    }", "comment": "/**\n     * Guesses the languages of a word.\n     *\n     * @param input\n     *            the word\n     * @return a Set of Strings of language names that are potential matches for the input word\n     */"}}
{"code": {"body": "    public String getName() {\n        return this.name;\n    }", "comment": "/**\n     * Gets the short version of the name type.\n     *\n     * @return the NameType short string\n     */"}}
{"code": {"body": "public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concat) {\n        this(nameType, ruleType, concat, DEFAULT_MAX_PHONEMES);\n    }", "comment": "/**\n     * Generates a new, fully-configured phonetic engine.\n     *\n     * @param nameType\n     *            the type of names it will use\n     * @param ruleType\n     *            the type of rules it will apply\n     * @param concat\n     *            if it will concatenate multiple encodings\n     */"}}
{"code": {"body": "public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concat)", "comment": "/**\n     * Generates a new, fully-configured phonetic engine.\n     *\n     * @param nameType\n     *            the type of names it will use\n     * @param ruleType\n     *            the type of rules it will apply\n     * @param concat\n     *            if it will concatenate multiple encodings\n     */"}}
{"code": {"body": "        public static PhonemeBuilder empty(final Languages.LanguageSet languages) {\n            return new PhonemeBuilder(new Rule.Phoneme(\"\", languages));\n        }", "comment": "/**\n         * An empty builder where all phonemes must come from some set of languages. This will contain a single\n         * phoneme of zero characters. This can then be appended to. This should be the only way to create a new\n         * phoneme from scratch.\n         *\n         * @param languages the set of languages\n         * @return  a new, empty phoneme builder\n         */"}}
{"code": {"body": "        public void append(final CharSequence str) {\n            for (final Rule.Phoneme ph : this.phonemes) {\n                ph.append(str);\n            }\n        }", "comment": "/**\n         * Creates a new phoneme builder containing all phonemes in this one extended by <code>str</code>.\n         *\n         * @param str   the characters to append to the phonemes\n         */"}}
{"code": {"body": "        public void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {\n            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);\n\n            EXPR: for (final Rule.Phoneme left : this.phonemes) {\n                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {\n                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());\n                    if (!languages.isEmpty()) {\n                        final Rule.Phoneme join = new Phoneme(left, right, languages);\n                        if (newPhonemes.size() < maxPhonemes) {\n                            newPhonemes.add(join);\n                            if (newPhonemes.size() >= maxPhonemes) {\n                                break EXPR;\n                            }\n                        }\n                    }\n                }\n            }\n\n            this.phonemes.clear();\n            this.phonemes.addAll(newPhonemes);\n        }", "comment": "/**\n         * Applies the given phoneme expression to all phonemes in this phoneme builder.\n         * <p>\n         * This will lengthen phonemes that have compatible language sets to the expression, and drop those that are\n         * incompatible.\n         *\n         * @param phonemeExpr   the expression to apply\n         * @param maxPhonemes   the maximum number of phonemes to build up\n         */"}}
{"code": {"body": "        public Set<Rule.Phoneme> getPhonemes() {\n            return this.phonemes;\n        }", "comment": "/**\n         * Gets underlying phoneme set. Please don't mutate.\n         *\n         * @return  the phoneme set\n         */"}}
{"code": {"body": "        public String makeString() {\n            final StringBuilder sb = new StringBuilder();\n\n            for (final Rule.Phoneme ph : this.phonemes) {\n                if (sb.length() > 0) {\n                    sb.append(\"\");\n                }\n                sb.append(ph.getPhonemeText());\n            }\n\n            return sb.toString();\n        }", "comment": "/**\n         * Stringifies the phoneme set. This produces a single string of the strings of each phoneme,\n         * joined with a pipe. This is explicitly provided in place of toString as it is a potentially\n         * expensive operation, which should be avoided when debugging.\n         *\n         * @return  the stringified phoneme set\n         */"}}
{"code": {"body": "        public RulesApplication invoke() {\n            this.found = false;\n            int patternLength = 1;\n            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));\n            if (rules != null) {\n                for (final Rule rule : rules) {\n                    final String pattern = rule.getPattern();\n                    patternLength = pattern.length();\n                    if (rule.patternAndContextMatches(this.input, this.i)) {\n                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);\n                        this.found = true;\n                        break;\n                    }\n                }\n            }\n\n            if (!this.found) {\n                patternLength = 1;\n            }\n\n            this.i += patternLength;\n            return this;\n        }", "comment": "/**\n         * Invokes the rules. Loops over the rules list, stopping at the first one that has a matching context\n         * and pattern. Then applies this rule to the phoneme builder to produce updated phonemes. If there was no\n         * match, <code>i</code> is advanced one and the character is silently dropped from the phonetic spelling.\n         *\n         * @return <code>this</code>\n         */"}}
{"code": {"body": "    private static String join(final Iterable<String> strings, final String sep) {\n        final StringBuilder sb = new StringBuilder();\n        final Iterator<String> si = strings.iterator();\n        if (si.hasNext()) {\n            sb.append(si.next());\n        }\n        while (si.hasNext()) {\n            sb.append(sep).append(si.next());\n        }\n\n        return sb.toString();\n    }", "comment": "/**\n     * Joins some strings with an internal separator.\n     * @param strings   Strings to join\n     * @param sep       String to separate them with\n     * @return a single String consisting of each element of <code>strings</code> interleaved by <code>sep</code>\n     */"}}
{"code": {"body": "    private PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,\n                                           final Map<String, List<Rule>> finalRules) {\n        if (finalRules == null) {\n            throw new NullPointerException(\"\");\n        }\n        if (finalRules.isEmpty()) {\n            return phonemeBuilder;\n        }\n\n        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =\n            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);\n\n        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {\n            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());\n            final String phonemeText = phoneme.getPhonemeText().toString();\n\n            for (int i = 0; i < phonemeText.length();) {\n                final RulesApplication rulesApplication =\n                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();\n                final boolean found = rulesApplication.isFound();\n                subBuilder = rulesApplication.getPhonemeBuilder();\n\n                if (!found) {\n                    \n                    subBuilder.append(phonemeText.subSequence(i, i + 1));\n                }\n\n                i = rulesApplication.getI();\n            }\n\n            \n            \n            \n            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {\n                if (phonemes.containsKey(newPhoneme)) {\n                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);\n                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());\n                    phonemes.put(mergedPhoneme, mergedPhoneme);\n                } else {\n                    phonemes.put(newPhoneme, newPhoneme);\n                }\n            }\n        }\n\n        return new PhonemeBuilder(phonemes.keySet());\n    }", "comment": "/**\n     * Applies the final rules to convert from a language-specific phonetic representation to a\n     * language-independent representation.\n     *\n     * @param phonemeBuilder the current phonemes\n     * @param finalRules the final rules to apply\n     * @return the resulting phonemes\n     */"}}
{"code": {"body": "    public String encode(String input, final Languages.LanguageSet languageSet) {\n        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);\n        \n        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, \"\");\n        \n        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);\n\n        \n        \n        input = input.toLowerCase(Locale.ENGLISH).replace('', '').trim();\n\n        if (this.nameType == NameType.GENERIC) {\n            if (input.length() >= 2 && input.substring(0, 2).equals(\"\")) { \n                final String remainder = input.substring(2);\n                final String combined = \"\" + remainder;\n                return \"\" + encode(remainder) + \"\" + encode(combined) + \"\";\n            }\n            for (final String l : NAME_PREFIXES.get(this.nameType)) {\n                \n                if (input.startsWith(l + \"\")) {\n                    \n                    final String remainder = input.substring(l.length() + 1); \n                    final String combined = l + remainder; \n                    return \"\" + encode(remainder) + \"\" + encode(combined) + \"\";\n                }\n            }\n        }\n\n        final List<String> words = Arrays.asList(input.split(\"\"));\n        final List<String> words2 = new ArrayList<String>();\n\n        \n        switch (this.nameType) {\n        case SEPHARDIC:\n            for (final String aWord : words) {\n                final String[] parts = aWord.split(\"\");\n                final String lastPart = parts[parts.length - 1];\n                words2.add(lastPart);\n            }\n            words2.removeAll(NAME_PREFIXES.get(this.nameType));\n            break;\n        case ASHKENAZI:\n            words2.addAll(words);\n            words2.removeAll(NAME_PREFIXES.get(this.nameType));\n            break;\n        case GENERIC:\n            words2.addAll(words);\n            break;\n        default:\n            throw new IllegalStateException(\"\" + this.nameType);\n        }\n\n        if (this.concat) {\n            \n            input = join(words2, \"\");\n        } else if (words2.size() == 1) {\n            \n            input = words.iterator().next();\n        } else {\n            \n            final StringBuilder result = new StringBuilder();\n            for (final String word : words2) {\n                result.append(\"\").append(encode(word));\n            }\n            \n            return result.substring(1);\n        }\n\n        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);\n\n        \n        for (int i = 0; i < input.length();) {\n            final RulesApplication rulesApplication =\n                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();\n            i = rulesApplication.getI();\n            phonemeBuilder = rulesApplication.getPhonemeBuilder();\n        }\n\n        \n        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);\n        \n        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);\n\n        return phonemeBuilder.makeString();\n    }", "comment": "/**\n     * Encodes an input string into an output phonetic representation, given a set of possible origin languages.\n     *\n     * @param input\n     *            String to phoneticise; a String with dashes or spaces separating each word\n     * @param languageSet\n     *            set of possible origin languages\n     * @return a phonetic representation of the input; a String containing '-'-separated phonetic representations of the\n     *         input\n     */"}}
{"code": {"body": "    public Lang getLang() {\n        return this.lang;\n    }", "comment": "/**\n     * Gets the Lang language guessing rules being used.\n     *\n     * @return the Lang in use\n     */"}}
{"code": {"body": "    public NameType getNameType() {\n        return this.nameType;\n    }", "comment": "/**\n     * Gets the NameType being used.\n     *\n     * @return the NameType in use\n     */"}}
{"code": {"body": "    public RuleType getRuleType() {\n        return this.ruleType;\n    }", "comment": "/**\n     * Gets the RuleType being used.\n     *\n     * @return the RuleType in use\n     */"}}
{"code": {"body": "    public boolean isConcat() {\n        return this.concat;\n    }", "comment": "/**\n     * Gets if multiple phonetic encodings are concatenated or if just the first one is kept.\n     *\n     * @return true if multiple phonetic encodings are returned, false if just the first is\n     */"}}
{"code": {"body": "    public int getMaxPhonemes() {\n        return this.maxPhonemes;\n    }", "comment": "/**\n     * Gets the maximum number of phonemes the engine will calculate for a given input.\n     *\n     * @return the maximum number of phonemes\n     * @since 1.7\n     */"}}
{"code": {"body": "public Rule(final String pattern, final String lContext, final String rContext, final PhonemeExpr phoneme) {\n        this.pattern = pattern;\n        this.lContext = pattern(lContext + \"\");\n        this.rContext = pattern(\"\" + rContext);\n        this.phoneme = phoneme;\n    }", "comment": "/**\n     * Creates a new rule.\n     *\n     * @param pattern\n     *            the pattern\n     * @param lContext\n     *            the left context\n     * @param rContext\n     *            the right context\n     * @param phoneme\n     *            the resulting phoneme\n     */"}}
{"code": {"body": "        public Phoneme mergeWithLanguage(final LanguageSet lang) {\n          return new Phoneme(this.phonemeText.toString(), this.languages.merge(lang));\n        }", "comment": "/**\n         * Returns a new Phoneme with the same text but a union of its\n         * current language set and the given one.\n         *\n         * @param lang the language set to merge\n         * @return a new Phoneme\n         */"}}
{"code": {"body": "    public static List<Rule> getInstance(final NameType nameType, final RuleType rt, final String lang) {\n        return getInstance(nameType, rt, LanguageSet.from(new HashSet<String>(Arrays.asList(lang))));\n    }", "comment": "/**\n     * Gets rules for a combination of name type, rule type and a single language.\n     *\n     * @param nameType\n     *            the NameType to consider\n     * @param rt\n     *            the RuleType to consider\n     * @param lang\n     *            the language to consider\n     * @return a list of Rules that apply\n     */"}}
{"code": {"body": "    public static Map<String, List<Rule>> getInstanceMap(final NameType nameType, final RuleType rt,\n                                                         final String lang) {\n        final Map<String, List<Rule>> rules = RULES.get(nameType).get(rt).get(lang);\n\n        if (rules == null) {\n            throw new IllegalArgumentException(String.format(\"\",\n                                               nameType.getName(), rt.getName(), lang));\n        }\n\n        return rules;\n    }", "comment": "/**\n     * Gets rules for a combination of name type, rule type and a single language.\n     *\n     * @param nameType\n     *            the NameType to consider\n     * @param rt\n     *            the RuleType to consider\n     * @param lang\n     *            the language to consider\n     * @return a map containing all Rules that apply, grouped by the first character of the rule pattern\n     * @since 1.9\n     */"}}
{"code": {"body": "    private static RPattern pattern(final String regex) {\n        final boolean startsWith = regex.startsWith(\"\");\n        final boolean endsWith = regex.endsWith(\"\");\n        final String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length());\n        final boolean boxes = content.contains(\"\");\n\n        if (!boxes) {\n            if (startsWith && endsWith) {\n                \n                if (content.length() == 0) {\n                    \n                    return new RPattern() {\n                        @Override\n                        public boolean isMatch(final CharSequence input) {\n                            return input.length() == 0;\n                        }\n                    };\n                } else {\n                    return new RPattern() {\n                        @Override\n                        public boolean isMatch(final CharSequence input) {\n                            return input.equals(content);\n                        }\n                    };\n                }\n            } else if ((startsWith || endsWith) && content.length() == 0) {\n                \n                return ALL_STRINGS_RMATCHER;\n            } else if (startsWith) {\n                \n                return new RPattern() {\n                    @Override\n                    public boolean isMatch(final CharSequence input) {\n                        return startsWith(input, content);\n                    }\n                };\n            } else if (endsWith) {\n                \n                return new RPattern() {\n                    @Override\n                    public boolean isMatch(final CharSequence input) {\n                        return endsWith(input, content);\n                    }\n                };\n            }\n        } else {\n            final boolean startsWithBox = content.startsWith(\"\");\n            final boolean endsWithBox = content.endsWith(\"\");\n\n            if (startsWithBox && endsWithBox) {\n                String boxContent = content.substring(1, content.length() - 1);\n                if (!boxContent.contains(\"\")) {\n                    \n                    final boolean negate = boxContent.startsWith(\"\");\n                    if (negate) {\n                        boxContent = boxContent.substring(1);\n                    }\n                    final String bContent = boxContent;\n                    final boolean shouldMatch = !negate;\n\n                    if (startsWith && endsWith) {\n                        \n                        return new RPattern() {\n                            @Override\n                            public boolean isMatch(final CharSequence input) {\n                                return input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch;\n                            }\n                        };\n                    } else if (startsWith) {\n                        \n                        return new RPattern() {\n                            @Override\n                            public boolean isMatch(final CharSequence input) {\n                                return input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch;\n                            }\n                        };\n                    } else if (endsWith) {\n                        \n                        return new RPattern() {\n                            @Override\n                            public boolean isMatch(final CharSequence input) {\n                                return input.length() > 0 &&\n                                       contains(bContent, input.charAt(input.length() - 1)) == shouldMatch;\n                            }\n                        };\n                    }\n                }\n            }\n        }\n\n        return new RPattern() {\n            Pattern pattern = Pattern.compile(regex);\n\n            @Override\n            public boolean isMatch(final CharSequence input) {\n                final Matcher matcher = pattern.matcher(input);\n                return matcher.find();\n            }\n        };\n    }", "comment": "/**\n     * Attempts to compile the regex into direct string ops, falling back to Pattern and Matcher in the worst case.\n     *\n     * @param regex\n     *            the regular expression to compile\n     * @return an RPattern that will match this regex\n     */"}}
{"code": {"body": "    public RPattern getLContext() {\n        return this.lContext;\n    }", "comment": "/**\n     * Gets the left context. This is a regular expression that must match to the left of the pattern.\n     *\n     * @return the left context Pattern\n     */"}}
{"code": {"body": "    public String getPattern() {\n        return this.pattern;\n    }", "comment": "/**\n     * Gets the pattern. This is a string-literal that must exactly match.\n     *\n     * @return the pattern\n     */"}}
{"code": {"body": "    public PhonemeExpr getPhoneme() {\n        return this.phoneme;\n    }", "comment": "/**\n     * Gets the phoneme. If the rule matches, this is the phoneme associated with the pattern match.\n     *\n     * @return the phoneme\n     */"}}
{"code": {"body": "    public RPattern getRContext() {\n        return this.rContext;\n    }", "comment": "/**\n     * Gets the right context. This is a regular expression that must match to the right of the pattern.\n     *\n     * @return the right context Pattern\n     */"}}
{"code": {"body": "    public boolean patternAndContextMatches(final CharSequence input, final int i) {\n        if (i < 0) {\n            throw new IndexOutOfBoundsException(\"\");\n        }\n\n        final int patternLength = this.pattern.length();\n        final int ipl = i + patternLength;\n\n        if (ipl > input.length()) {\n            \n            return false;\n        }\n\n        \n        \n        if (!input.subSequence(i, ipl).equals(this.pattern)) {\n            return false;\n        } else if (!this.rContext.isMatch(input.subSequence(ipl, input.length()))) {\n            return false;\n        }\n        return this.lContext.isMatch(input.subSequence(0, i));\n    }", "comment": "/**\n     * Decides if the pattern and context match the input starting at a position. It is a match if the\n     * <code>lContext</code> matches <code>input</code> up to <code>i</code>, <code>pattern</code> matches at i and\n     * <code>rContext</code> matches from the end of the match of <code>pattern</code> to the end of <code>input</code>.\n     *\n     * @param input\n     *            the input String\n     * @param i\n     *            the int position within the input\n     * @return true if the pattern and left/right context match, false otherwise\n     */"}}
{"code": {"body": "    public String getName() {\n        return this.name;\n    }", "comment": "/**\n     * Gets the rule name.\n     *\n     * @return the rule name.\n     */"}}
{"code": {"body": "public BCodec() {\n        this(Charsets.UTF_8);\n    }", "comment": "/**\n     * Default constructor.\n     */"}}
{"code": {"body": "public BCodec(final Charset charset) {\n        this.charset = charset;\n    }", "comment": "/**\n     * Constructor which allows for the selection of a default charset\n     *\n     * @param charset\n     *            the default string charset to use.\n     *\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @since 1.7\n     */"}}
{"code": {"body": "public BCodec(final String charsetName) {\n        this(Charset.forName(charsetName));\n    }", "comment": "/**\n     * Constructor which allows for the selection of a default charset\n     *\n     * @param charsetName\n     *            the default charset to use.\n     * @throws java.nio.charset.UnsupportedCharsetException\n     *             If the named charset is unavailable\n     * @since 1.7 throws UnsupportedCharsetException if the named charset is unavailable\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     */"}}
{"code": {"body": "    public Charset getCharset() {\n        return this.charset;\n    }", "comment": "/**\n     * Gets the default charset name used for string decoding and encoding.\n     *\n     * @return the default charset name\n     * @since 1.7\n     */"}}
{"code": {"body": "    public String getDefaultCharset() {\n        return this.charset.name();\n    }", "comment": "/**\n     * Gets the default charset name used for string decoding and encoding.\n     *\n     * @return the default charset name\n     */"}}
{"code": {"body": "public QCodec() {\n        this(Charsets.UTF_8);\n    }", "comment": "/**\n     * Default constructor.\n     */"}}
{"code": {"body": "public QCodec(final Charset charset) {\n        super();\n        this.charset = charset;\n    }", "comment": "/**\n     * Constructor which allows for the selection of a default charset.\n     *\n     * @param charset\n     *            the default string charset to use.\n     *\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @since 1.7\n     */"}}
{"code": {"body": "public QCodec(final String charsetName) {\n        this(Charset.forName(charsetName));\n    }", "comment": "/**\n     * Constructor which allows for the selection of a default charset.\n     *\n     * @param charsetName\n     *            the charset to use.\n     * @throws java.nio.charset.UnsupportedCharsetException\n     *             If the named charset is unavailable\n     * @since 1.7 throws UnsupportedCharsetException if the named charset is unavailable\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     */"}}
{"code": {"body": "    public Charset getCharset() {\n        return this.charset;\n    }", "comment": "/**\n     * Gets the default charset name used for string decoding and encoding.\n     *\n     * @return the default charset name\n     * @since 1.7\n     */"}}
{"code": {"body": "    public String getDefaultCharset() {\n        return this.charset.name();\n    }", "comment": "/**\n     * Gets the default charset name used for string decoding and encoding.\n     *\n     * @return the default charset name\n     */"}}
{"code": {"body": "    public boolean isEncodeBlanks() {\n        return this.encodeBlanks;\n    }", "comment": "/**\n     * Tests if optional transformation of SPACE characters is to be used\n     *\n     * @return <code>true</code> if SPACE characters are to be transformed, <code>false</code> otherwise\n     */"}}
{"code": {"body": "    public void setEncodeBlanks(final boolean b) {\n        this.encodeBlanks = b;\n    }", "comment": "/**\n     * Defines whether optional transformation of SPACE characters is to be used\n     *\n     * @param b\n     *            <code>true</code> if SPACE characters are to be transformed, <code>false</code> otherwise\n     */"}}
{"code": {"body": "public QuotedPrintableCodec() {\n        this(Charsets.UTF_8, false);\n    }", "comment": "/**\n     * Default constructor, assumes default charset of {@link Charsets#UTF_8}\n     */"}}
{"code": {"body": "public QuotedPrintableCodec(final boolean strict) {\n        this(Charsets.UTF_8, strict);\n    }", "comment": "/**\n     * Constructor which allows for the selection of the strict mode.\n     *\n     * @param strict\n     *            if {@code true}, soft line breaks will be used\n     * @since 1.10\n     */"}}
{"code": {"body": "public QuotedPrintableCodec(final Charset charset) {\n        this(charset, false);\n    }", "comment": "/**\n     * Constructor which allows for the selection of a default charset.\n     *\n     * @param charset\n     *            the default string charset to use.\n     * @since 1.7\n     */"}}
{"code": {"body": "public QuotedPrintableCodec(final Charset charset, final boolean strict) {\n        this.charset = charset;\n        this.strict = strict;\n    }", "comment": "/**\n     * Constructor which allows for the selection of a default charset and strict mode.\n     *\n     * @param charset\n     *            the default string charset to use.\n     * @param strict\n     *            if {@code true}, soft line breaks will be used\n     * @since 1.10\n     */"}}
{"code": {"body": "public QuotedPrintableCodec(final String charsetName)", "comment": "/**\n     * Constructor which allows for the selection of a default charset.\n     *\n     * @param charsetName\n     *            the default string charset to use.\n     * @throws UnsupportedCharsetException\n     *             If no support for the named charset is available\n     *             in this instance of the Java virtual machine\n     * @throws IllegalArgumentException\n     *             If the given charsetName is null\n     * @throws IllegalCharsetNameException\n     *             If the given charset name is illegal\n     *\n     * @since 1.7 throws UnsupportedCharsetException if the named charset is unavailable\n     */"}}
{"code": {"body": "    public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes, boolean strict) {\n        if (bytes == null) {\n            return null;\n        }\n        if (printable == null) {\n            printable = PRINTABLE_CHARS;\n        }\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n\n        if (strict) {\n            int pos = 1;\n            \n            \n            for (int i = 0; i < bytes.length - 3; i++) {\n                int b = getUnsignedOctet(i, bytes);\n                if (pos < SAFE_LENGTH) {\n                    \n                    pos += encodeByte(b, !printable.get(b), buffer);\n                } else {\n                    \n                    encodeByte(b, !printable.get(b) || isWhitespace(b), buffer);\n\n                    \n                    buffer.write(ESCAPE_CHAR);\n                    buffer.write(CR);\n                    buffer.write(LF);\n                    pos = 1;\n                }\n            }\n\n            \n            \n            int b = getUnsignedOctet(bytes.length - 3, bytes);\n            boolean encode = !printable.get(b) || (isWhitespace(b) && pos > SAFE_LENGTH - 5);\n            pos += encodeByte(b, encode, buffer);\n\n            \n            \n            \n            if (pos > SAFE_LENGTH - 2) {\n                buffer.write(ESCAPE_CHAR);\n                buffer.write(CR);\n                buffer.write(LF);\n            }\n            for (int i = bytes.length - 2; i < bytes.length; i++) {\n                b = getUnsignedOctet(i, bytes);\n                \n                encode = !printable.get(b) || (i > bytes.length - 2 && isWhitespace(b));\n                encodeByte(b, encode, buffer);\n            }\n        } else {\n            for (final byte c : bytes) {\n                int b = c;\n                if (b < 0) {\n                    b = 256 + b;\n                }\n                if (printable.get(b)) {\n                    buffer.write(b);\n                } else {\n                    encodeQuotedPrintable(b, buffer);\n                }\n            }\n        }\n        return buffer.toByteArray();\n    }", "comment": "/**\n     * Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.\n     * <p>\n     * Depending on the selection of the {@code strict} parameter, this function either implements the full ruleset\n     * or only a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n     * RFC 1521 and is suitable for encoding binary data and unformatted text.\n     *\n     * @param printable\n     *            bitset of characters deemed quoted-printable\n     * @param bytes\n     *            array of bytes to be encoded\n     * @param strict\n     *            if {@code true} the full ruleset is used, otherwise only rule #1 and rule #2\n     * @return array of bytes containing quoted-printable data\n     * @since 1.10\n     */"}}
{"code": {"body": "    private static int getUnsignedOctet(final int index, final byte[] bytes) {\n        int b = bytes[index];\n        if (b < 0) {\n            b = 256 + b;\n        }\n        return b;\n    }", "comment": "/**\n     * Return the byte at position <code>index</code> of the byte array and\n     * make sure it is unsigned.\n     *\n     * @param index\n     *            position in the array\n     * @param bytes\n     *            the byte array\n     * @return the unsigned octet at position <code>index</code> from the array\n     */"}}
{"code": {"body": "    private static int encodeByte(final int b, final boolean encode,\n                                  final ByteArrayOutputStream buffer) {\n        if (encode) {\n            return encodeQuotedPrintable(b, buffer);\n        } else {\n            buffer.write(b);\n            return 1;\n        }\n    }", "comment": "/**\n     * Write a byte to the buffer.\n     *\n     * @param b\n     *            byte to write\n     * @param encode\n     *            indicates whether the octet shall be encoded\n     * @param buffer\n     *            the buffer to write to\n     * @return the number of bytes that have been written to the buffer\n     */"}}
{"code": {"body": "    private static boolean isWhitespace(final int b) {\n        return b == SPACE || b == TAB;\n    }", "comment": "/**\n     * Checks whether the given byte is whitespace.\n     *\n     * @param b\n     *            byte to be checked\n     * @return <code>true</code> if the byte is either a space or tab character\n     */"}}
{"code": {"body": "    public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {\n        if (bytes == null) {\n            return null;\n        }\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            final int b = bytes[i];\n            if (b == ESCAPE_CHAR) {\n                try {\n                    \n                    if (bytes[++i] == CR) {\n                        continue;\n                    }\n                    final int u = Utils.digit16(bytes[i]);\n                    final int l = Utils.digit16(bytes[++i]);\n                    buffer.write((char) ((u << 4) + l));\n                } catch (final ArrayIndexOutOfBoundsException e) {\n                    throw new DecoderException(\"\", e);\n                }\n            } else if (b != CR && b != LF) {\n                \n                buffer.write(b);\n            }\n        }\n        return buffer.toByteArray();\n    }", "comment": "/**\n     * Decodes an array quoted-printable characters into an array of original bytes. Escaped characters are converted\n     * back to their original representation.\n     * <p>\n     * This function fully implements the quoted-printable encoding specification (rule #1 through rule #5) as\n     * defined in RFC 1521.\n     *\n     * @param bytes\n     *            array of quoted-printable characters\n     * @return array of original bytes\n     * @throws DecoderException\n     *             Thrown if quoted-printable decoding is unsuccessful\n     */"}}
{"code": {"body": "    public String encode(final String str, final String charset) throws UnsupportedEncodingException {\n        if (str == null) {\n            return null;\n        }\n        return StringUtils.newStringUsAscii(encode(str.getBytes(charset)));\n    }", "comment": "/**\n     * Encodes a string into its quoted-printable form using the specified charset. Unsafe characters are escaped.\n     * <p>\n     * Depending on the selection of the {@code strict} parameter, this function either implements the full ruleset\n     * or only a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n     * RFC 1521 and is suitable for encoding binary data and unformatted text.\n     *\n     * @param str\n     *            string to convert to quoted-printable form\n     * @param charset\n     *            the charset for str\n     * @return quoted-printable string\n     * @throws UnsupportedEncodingException\n     *             Thrown if the charset is not supported\n     */"}}
{"code": {"body": "    public Charset getCharset() {\n        return this.charset;\n    }", "comment": "/**\n     * Gets the default charset name used for string decoding and encoding.\n     *\n     * @return the default charset name\n     * @since 1.7\n     */"}}
{"code": {"body": "    public String getDefaultCharset() {\n        return this.charset.name();\n    }", "comment": "/**\n     * Gets the default charset name used for string decoding and encoding.\n     *\n     * @return the default charset name\n     */"}}
{"code": {"body": "    protected String encodeText(final String text, final String charsetName)\n            throws EncoderException, UnsupportedEncodingException {\n        if (text == null) {\n            return null;\n        }\n        return this.encodeText(text, Charset.forName(charsetName));\n    }", "comment": "/**\n     * Applies an RFC 1522 compliant encoding scheme to the given string of text with the given charset.\n     * <p>\n     * This method constructs the \"encoded-word\" header common to all the RFC 1522 codecs and then invokes\n     * {@link #doEncoding(byte [])} method of a concrete class to perform the specific encoding.\n     *\n     * @param text\n     *            a string to encode\n     * @param charsetName\n     *            the charset to use\n     * @return RFC 1522 compliant \"encoded-word\"\n     * @throws EncoderException\n     *             thrown if there is an error condition during the Encoding process.\n     * @throws UnsupportedEncodingException\n     *             if charset is not available\n     *\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     */"}}
{"code": {"body": "    protected String decodeText(final String text)\n            throws DecoderException, UnsupportedEncodingException {\n        if (text == null) {\n            return null;\n        }\n        if (!text.startsWith(PREFIX) || !text.endsWith(POSTFIX)) {\n            throw new DecoderException(\"\");\n        }\n        final int terminator = text.length() - 2;\n        int from = 2;\n        int to = text.indexOf(SEP, from);\n        if (to == terminator) {\n            throw new DecoderException(\"\");\n        }\n        final String charset = text.substring(from, to);\n        if (charset.equals(\"\")) {\n            throw new DecoderException(\"\");\n        }\n        from = to + 1;\n        to = text.indexOf(SEP, from);\n        if (to == terminator) {\n            throw new DecoderException(\"\");\n        }\n        final String encoding = text.substring(from, to);\n        if (!getEncoding().equalsIgnoreCase(encoding)) {\n            throw new DecoderException(\"\" + encoding + \"\");\n        }\n        from = to + 1;\n        to = text.indexOf(SEP, from);\n        byte[] data = StringUtils.getBytesUsAscii(text.substring(from, to));\n        data = doDecoding(data);\n        return new String(data, charset);\n    }", "comment": "/**\n     * Applies an RFC 1522 compliant decoding scheme to the given string of text.\n     * <p>\n     * This method processes the \"encoded-word\" header common to all the RFC 1522 codecs and then invokes\n     * {@link #doEncoding(byte [])} method of a concrete class to perform the specific decoding.\n     *\n     * @param text\n     *            a string to decode\n     * @return A new decoded String or <code>null</code> if the input is <code>null</code>.\n     * @throws DecoderException\n     *             thrown if there is an error condition during the decoding process.\n     * @throws UnsupportedEncodingException\n     *             thrown if charset specified in the \"encoded-word\" header is not supported\n     */"}}
{"code": {"body": "public URLCodec() {\n        this(CharEncoding.UTF_8);\n    }", "comment": "/**\n     * Default constructor.\n     */"}}
{"code": {"body": "public URLCodec(final String charset) {\n        super();\n        this.charset = charset;\n    }", "comment": "/**\n     * Constructor which allows for the selection of a default charset.\n     *\n     * @param charset the default string charset to use.\n     */"}}
{"code": {"body": "    public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {\n        if (bytes == null) {\n            return null;\n        }\n        if (urlsafe == null) {\n            urlsafe = WWW_FORM_URL;\n        }\n\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (final byte c : bytes) {\n            int b = c;\n            if (b < 0) {\n                b = 256 + b;\n            }\n            if (urlsafe.get(b)) {\n                if (b == '') {\n                    b = '';\n                }\n                buffer.write(b);\n            } else {\n                buffer.write(ESCAPE_CHAR);\n                final char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));\n                final char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));\n                buffer.write(hex1);\n                buffer.write(hex2);\n            }\n        }\n        return buffer.toByteArray();\n    }", "comment": "/**\n     * Encodes an array of bytes into an array of URL safe 7-bit characters. Unsafe characters are escaped.\n     *\n     * @param urlsafe\n     *            bitset of characters deemed URL safe\n     * @param bytes\n     *            array of bytes to convert to URL safe characters\n     * @return array of bytes containing URL safe characters\n     */"}}
{"code": {"body": "    public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {\n        if (bytes == null) {\n            return null;\n        }\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            final int b = bytes[i];\n            if (b == '') {\n                buffer.write('');\n            } else if (b == ESCAPE_CHAR) {\n                try {\n                    final int u = Utils.digit16(bytes[++i]);\n                    final int l = Utils.digit16(bytes[++i]);\n                    buffer.write((char) ((u << 4) + l));\n                } catch (final ArrayIndexOutOfBoundsException e) {\n                    throw new DecoderException(\"\", e);\n                }\n            } else {\n                buffer.write(b);\n            }\n        }\n        return buffer.toByteArray();\n    }", "comment": "/**\n     * Decodes an array of URL safe 7-bit characters into an array of original bytes. Escaped characters are converted\n     * back to their original representation.\n     *\n     * @param bytes\n     *            array of URL safe characters\n     * @return array of original bytes\n     * @throws DecoderException\n     *             Thrown if URL decoding is unsuccessful\n     */"}}
{"code": {"body": "    public String getDefaultCharset() {\n        return this.charset;\n    }", "comment": "/**\n     * The default charset used for string decoding and encoding.\n     *\n     * @return the default string charset.\n     */"}}
{"code": {"body": "    static int digit16(final byte b) throws DecoderException {\n        final int i = Character.digit((char) b, URLCodec.RADIX);\n        if (i == -1) {\n            throw new DecoderException(\"\" + URLCodec.RADIX + \"\" + b);\n        }\n        return i;\n    }", "comment": "/**\n     * Returns the numeric value of the character <code>b</code> in radix 16.\n     *\n     * @param b\n     *            The byte to be converted.\n     * @return The numeric value represented by the character in radix 16.\n     *\n     * @throws DecoderException\n     *             Thrown when the byte is not valid per {@link Character#digit(char,int)}\n     */"}}
{"code": {"body": "    public static void close() {\n        if (!isInitialized) initialize();\n        try {\n            in.close();\n            isInitialized = false;\n        }\n        catch (IOException ioe) {\n            throw new IllegalStateException(\"\", ioe);\n        }\n    }", "comment": "/**\n     * Close this input stream and release any associated system resources.\n     */"}}
{"code": {"body": "    public static boolean isEmpty() {\n        if (!isInitialized) initialize();\n        return buffer == EOF;\n    }", "comment": "/**\n     * Returns true if standard input is empty.\n     * @return true if and only if standard input is empty\n     */"}}
{"code": {"body": "    public static boolean readBoolean() {\n        if (isEmpty()) throw new NoSuchElementException(\"\");\n        n--;\n        boolean bit = ((buffer >> n) & 1) == 1;\n        if (n == 0) fillBuffer();\n        return bit;\n    }", "comment": "/**\n     * Reads the next bit of data from standard input and return as a boolean.\n     *\n     * @return the next bit of data from standard input as a {@code boolean}\n     * @throws NoSuchElementException if standard input is empty\n     */"}}
{"code": {"body": "    public static char readChar(int r) {\n        if (r < 1 || r > 16) throw new IllegalArgumentException(\"\" + r);\n\n        \n        if (r == 8) return readChar();\n\n        char x = 0;\n        for (int i = 0; i < r; i++) {\n            x <<= 1;\n            boolean bit = readBoolean();\n            if (bit) x |= 1;\n        }\n        return x;\n    }", "comment": "/**\n     * Reads the next r bits from standard input and return as an r-bit character.\n     *\n     * @param  r number of bits to read.\n     * @return the next r bits of data from standard input as a {@code char}\n     * @throws NoSuchElementException if there are fewer than {@code r} bits available on standard input\n     * @throws IllegalArgumentException unless {@code 1 <= r <= 16}\n     */"}}
{"code": {"body": "    public static String readString() {\n        if (isEmpty()) throw new NoSuchElementException(\"\");\n\n        StringBuilder sb = new StringBuilder();\n        while (!isEmpty()) {\n            char c = readChar();\n            sb.append(c);\n        }\n        return sb.toString();\n    }", "comment": "/**\n     * Reads the remaining bytes of data from standard input and return as a string. \n     *\n     * @return the remaining bytes of data from standard input as a {@code String}\n     * @throws NoSuchElementException if standard input is empty or if the number of bits\n     *         available on standard input is not a multiple of 8 (byte-aligned)\n     */"}}
{"code": {"body": "    public static short readShort() {\n        short x = 0;\n        for (int i = 0; i < 2; i++) {\n            char c = readChar();\n            x <<= 8;\n            x |= c;\n        }\n        return x;\n    }", "comment": "/**\n     * Reads the next 16 bits from standard input and return as a 16-bit short.\n     *\n     * @return the next 16 bits of data from standard input as a {@code short}\n     * @throws NoSuchElementException if there are fewer than 16 bits available on standard input\n     */"}}
{"code": {"body": "    public static int readInt(int r) {\n        if (r < 1 || r > 32) throw new IllegalArgumentException(\"\" + r);\n\n        \n        if (r == 32) return readInt();\n\n        int x = 0;\n        for (int i = 0; i < r; i++) {\n            x <<= 1;\n            boolean bit = readBoolean();\n            if (bit) x |= 1;\n        }\n        return x;\n    }", "comment": "/**\n     * Reads the next r bits from standard input and return as an r-bit int.\n     *\n     * @param  r number of bits to read.\n     * @return the next r bits of data from standard input as a {@code int}\n     * @throws NoSuchElementException if there are fewer than {@code r} bits available on standard input\n     * @throws IllegalArgumentException unless {@code 1 <= r <= 32}\n     */"}}
{"code": {"body": "    public static long readLong() {\n        long x = 0;\n        for (int i = 0; i < 8; i++) {\n            char c = readChar();\n            x <<= 8;\n            x |= c;\n        }\n        return x;\n    }", "comment": "/**\n     * Reads the next 64 bits from standard input and return as a 64-bit long.\n     *\n     * @return the next 64 bits of data from standard input as a {@code long}\n     * @throws NoSuchElementException if there are fewer than 64 bits available on standard input\n     */"}}
{"code": {"body": "    public static double readDouble() {\n        return Double.longBitsToDouble(readLong());\n    }", "comment": "/**\n     * Reads the next 64 bits from standard input and return as a 64-bit double.\n     *\n     * @return the next 64 bits of data from standard input as a {@code double}\n     * @throws NoSuchElementException if there are fewer than 64 bits available on standard input\n     */"}}
{"code": {"body": "    public static float readFloat() {\n        return Float.intBitsToFloat(readInt());\n    }", "comment": "/**\n     * Reads the next 32 bits from standard input and return as a 32-bit float.\n     *\n     * @return the next 32 bits of data from standard input as a {@code float}\n     * @throws NoSuchElementException if there are fewer than 32 bits available on standard input\n     */"}}
{"code": {"body": "    public static byte readByte() {\n        char c = readChar();\n        return (byte) (c & 0xff);\n    }", "comment": "/**\n     * Reads the next 8 bits from standard input and return as an 8-bit byte.\n     *\n     * @return the next 8 bits of data from standard input as a {@code byte}\n     * @throws NoSuchElementException if there are fewer than 8 bits available on standard input\n     */"}}
{"code": {"body": "    public static void main(String[] args) {\n\n        \n        while (!BinaryStdIn.isEmpty()) {\n            char c = BinaryStdIn.readChar();\n            BinaryStdOut.write(c);\n        }\n        BinaryStdOut.flush();\n    }", "comment": "/**\n     * Test client. Reads in a binary input file from standard input and writes\n     * it to standard output.\n     *\n     * @param args the command-line arguments\n     */"}}
{"code": {"body": "    private static void writeBit(boolean bit) {\n        if (!isInitialized) initialize();\n\n        \n        buffer <<= 1;\n        if (bit) buffer |= 1;\n\n        \n        n++;\n        if (n == 8) clearBuffer();\n    }", "comment": "/**\n     * Writes the specified bit to standard output.\n     */"}}
{"code": {"body": "    private static void writeByte(int x) {\n        if (!isInitialized) initialize();\n\n        assert x >= 0 && x < 256;\n\n        \n        if (n == 0) {\n            try {\n                out.write(x);\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return;\n        }\n\n        \n        for (int i = 0; i < 8; i++) {\n            boolean bit = ((x >>> (8 - i - 1)) & 1) == 1;\n            writeBit(bit);\n        }\n    }", "comment": "/**\n     * Writes the 8-bit byte to standard output.\n     */"}}
{"code": {"body": "    public static void flush() {\n        clearBuffer();\n        try {\n            out.flush();\n        }\n        catch (IOException e) {\n            e.printStackTrace();\n        }\n    }", "comment": "/**\n     * Flushes standard output, padding 0s if number of bits written so far\n     * is not a multiple of 8.\n     */"}}
{"code": {"body": "    public static void close() {\n        flush();\n        try {\n            out.close();\n            isInitialized = false;\n        }\n        catch (IOException e) {\n            e.printStackTrace();\n        }\n    }", "comment": "/**\n     * Flushes and closes standard output. Once standard output is closed, you can no\n     * longer write bits to it.\n     */"}}
{"code": {"body": "    public static void write(String s, int r) {\n        for (int i = 0; i < s.length(); i++)\n            write(s.charAt(i), r);\n    }", "comment": "/**\n     * Writes the string of r-bit characters to standard output.\n     * @param s the {@code String} to write.\n     * @param r the number of relevants bits in each character.\n     * @throws IllegalArgumentException if r is not between 1 and 16.\n     * @throws IllegalArgumentException if any character in the string is not\n     * between 0 and 2<sup>r</sup> - 1.\n     */"}}
{"code": {"body": "    public static void main(String[] args) {\n        int m = Integer.parseInt(args[0]);\n\n        \n        for (int i = 0; i < m; i++) {\n            BinaryStdOut.write(i);\n        }\n        BinaryStdOut.flush();\n    }", "comment": "/**\n     * Tests the methods in this class.\n     *\n     * @param args the command-line arguments\n     */"}}
{"code": {"body": "public Queue() {\n        first = null;\n        last  = null;\n        n = 0;\n    }", "comment": "/**\n     * Initializes an empty queue.\n     */"}}
{"code": {"body": "    public boolean isEmpty() {\n        return first == null;\n    }", "comment": "/**\n     * Returns true if this queue is empty.\n     *\n     * @return {@code true} if this queue is empty; {@code false} otherwise\n     */"}}
{"code": {"body": "    public int size() {\n        return n;\n    }", "comment": "/**\n     * Returns the number of items in this queue.\n     *\n     * @return the number of items in this queue\n     */"}}
{"code": {"body": "    public Item peek() {\n        if (isEmpty()) throw new NoSuchElementException(\"\");\n        return first.item;\n    }", "comment": "/**\n     * Returns the item least recently added to this queue.\n     *\n     * @return the item least recently added to this queue\n     * @throws NoSuchElementException if this queue is empty\n     */"}}
{"code": {"body": "    public void enqueue(Item item) {\n        Node<Item> oldlast = last;\n        last = new Node<Item>();\n        last.item = item;\n        last.next = null;\n        if (isEmpty()) first = last;\n        else           oldlast.next = last;\n        n++;\n    }", "comment": "/**\n     * Adds the item to this queue.\n     *\n     * @param  item the item to add\n     */"}}
{"code": {"body": "    public Item dequeue() {\n        if (isEmpty()) throw new NoSuchElementException(\"\");\n        Item item = first.item;\n        first = first.next;\n        n--;\n        if (isEmpty()) last = null;   \n        return item;\n    }", "comment": "/**\n     * Removes and returns the item on this queue that was least recently added.\n     *\n     * @return the item on this queue that was least recently added\n     * @throws NoSuchElementException if this queue is empty\n     */"}}
{"code": {"body": "    public String toString() {\n        StringBuilder s = new StringBuilder();\n        for (Item item : this) {\n            s.append(item);\n            s.append('');\n        }\n        return s.toString();\n    }", "comment": "/**\n     * Returns a string representation of this queue.\n     *\n     * @return the sequence of items in FIFO order, separated by spaces\n     */"}}
{"code": {"body": "    public Iterator<Item> iterator()  {\n        return new ListIterator<Item>(first);  \n    }", "comment": "/**\n     * Returns an iterator that iterates over the items in this queue in FIFO order.\n     *\n     * @return an iterator that iterates over the items in this queue in FIFO order\n     */"}}
{"code": {"body": "    public static void main(String[] args) {\n        Queue<String> queue = new Queue<String>();\n        while (!StdIn.isEmpty()) {\n            String item = StdIn.readString();\n            if (!item.equals(\"\"))\n                queue.enqueue(item);\n            else if (!queue.isEmpty())\n                StdOut.print(queue.dequeue() + \"\");\n        }\n        StdOut.println(\"\" + queue.size() + \"\");\n    }", "comment": "/**\n     * Unit tests the {@code Queue} data type.\n     *\n     * @param args the command-line arguments\n     */"}}
{"code": {"body": "    public static boolean isEmpty() {\n        return !scanner.hasNext();\n    }", "comment": "/**\n     * Returns true if standard input is empty (except possibly for whitespace).\n     * Use this method to know whether the next call to {@link #readString()}, \n     * {@link #readDouble()}, etc will succeed.\n     *\n     * @return {@code true} if standard input is empty (except possibly\n     *         for whitespace); {@code false} otherwise\n     */"}}
{"code": {"body": "    public static boolean hasNextLine() {\n        return scanner.hasNextLine();\n    }", "comment": "/**\n     * Returns true if standard input has a next line.\n     * Use this method to know whether the\n     * next call to {@link #readLine()} will succeed.\n     * This method is functionally equivalent to {@link #hasNextChar()}.\n     *\n     * @return {@code true} if standard input has more input (including whitespace);\n     *         {@code false} otherwise\n     */"}}
{"code": {"body": "    public static boolean hasNextChar() {\n        scanner.useDelimiter(EMPTY_PATTERN);\n        boolean result = scanner.hasNext();\n        scanner.useDelimiter(WHITESPACE_PATTERN);\n        return result;\n    }", "comment": "/**\n     * Returns true if standard input has more input (including whitespace).\n     * Use this method to know whether the next call to {@link #readChar()} will succeed.\n     * This method is functionally equivalent to {@link #hasNextLine()}.\n     *\n     * @return {@code true} if standard input has more input (including whitespace);\n     *         {@code false} otherwise\n     */"}}
{"code": {"body": "    public static String readLine() {\n        String line;\n        try {\n            line = scanner.nextLine();\n        }\n        catch (NoSuchElementException e) {\n            line = null;\n        }\n        return line;\n    }", "comment": "/**\n     * Reads and returns the next line, excluding the line separator if present.\n     *\n     * @return the next line, excluding the line separator if present;\n     *         {@code null} if no such line\n     */"}}
{"code": {"body": "    public static char readChar() {\n        try {\n            scanner.useDelimiter(EMPTY_PATTERN);\n            String ch = scanner.next();\n            assert ch.length() == 1 : \"\"\n                + \"\";\n            scanner.useDelimiter(WHITESPACE_PATTERN);\n            return ch.charAt(0);\n        }\n        catch (NoSuchElementException e) {\n            throw new NoSuchElementException(\"\"\n                                           + \"\");\n        }\n    }", "comment": "/**\n     * Reads and returns the next character.\n     *\n     * @return the next {@code char}\n     * @throws NoSuchElementException if standard input is empty\n     */"}}
{"code": {"body": "    public static String readAll() {\n        if (!scanner.hasNextLine())\n            return \"\";\n\n        String result = scanner.useDelimiter(EVERYTHING_PATTERN).next();\n        \n        scanner.useDelimiter(WHITESPACE_PATTERN); \n        return result;\n    }", "comment": "/**\n     * Reads and returns the remainder of the input, as a string.\n     *\n     * @return the remainder of the input, as a string\n     * @throws NoSuchElementException if standard input is empty\n     */"}}
{"code": {"body": "    public static String readString() {\n        try {\n            return scanner.next();\n        }\n        catch (NoSuchElementException e) {\n            throw new NoSuchElementException(\"\"\n                                           + \"\");\n        }\n    }", "comment": "/**\n     * Reads the next token  and returns the {@code String}.\n     *\n     * @return the next {@code String}\n     * @throws NoSuchElementException if standard input is empty\n     */"}}
{"code": {"body": "    public static int readInt() {\n        try {\n            return scanner.nextInt();\n        }\n        catch (InputMismatchException e) {\n            String token = scanner.next();\n            throw new InputMismatchException(\"\"\n                                           + \"\" + token + \"\");\n        }\n        catch (NoSuchElementException e) {\n            throw new NoSuchElementException(\"\"\n                                           + \"\");\n        }\n\n    }", "comment": "/**\n     * Reads the next token from standard input, parses it as an integer, and returns the integer.\n     *\n     * @return the next integer on standard input\n     * @throws NoSuchElementException if standard input is empty\n     * @throws InputMismatchException if the next token cannot be parsed as an {@code int}\n     */"}}
{"code": {"body": "    public static double readDouble() {\n        try {\n            return scanner.nextDouble();\n        }\n        catch (InputMismatchException e) {\n            String token = scanner.next();\n            throw new InputMismatchException(\"\"\n                                           + \"\" + token + \"\");\n        }\n        catch (NoSuchElementException e) {\n            throw new NoSuchElementException(\"\"\n                                           + \"\");\n        }\n    }", "comment": "/**\n     * Reads the next token from standard input, parses it as a double, and returns the double.\n     *\n     * @return the next double on standard input\n     * @throws NoSuchElementException if standard input is empty\n     * @throws InputMismatchException if the next token cannot be parsed as a {@code double}\n     */"}}
{"code": {"body": "    public static float readFloat() {\n        try {\n            return scanner.nextFloat();\n        }\n        catch (InputMismatchException e) {\n            String token = scanner.next();\n            throw new InputMismatchException(\"\"\n                                           + \"\" + token + \"\");\n        }\n        catch (NoSuchElementException e) {\n            throw new NoSuchElementException(\"\"\n                                           + \"\");\n        }\n    }", "comment": "/**\n     * Reads the next token from standard input, parses it as a float, and returns the float.\n     *\n     * @return the next float on standard input\n     * @throws NoSuchElementException if standard input is empty\n     * @throws InputMismatchException if the next token cannot be parsed as a {@code float}\n     */"}}
{"code": {"body": "    public static long readLong() {\n        try {\n            return scanner.nextLong();\n        }\n        catch (InputMismatchException e) {\n            String token = scanner.next();\n            throw new InputMismatchException(\"\"\n                                           + \"\" + token + \"\");\n        }\n        catch (NoSuchElementException e) {\n            throw new NoSuchElementException(\"\"\n                                           + \"\");\n        }\n    }", "comment": "/**\n     * Reads the next token from standard input, parses it as a long integer, and returns the long integer.\n     *\n     * @return the next long integer on standard input\n     * @throws NoSuchElementException if standard input is empty\n     * @throws InputMismatchException if the next token cannot be parsed as a {@code long}\n     */"}}
{"code": {"body": "    public static short readShort() {\n        try {\n            return scanner.nextShort();\n        }\n        catch (InputMismatchException e) {\n            String token = scanner.next();\n            throw new InputMismatchException(\"\"\n                                           + \"\" + token + \"\");\n        }\n        catch (NoSuchElementException e) {\n            throw new NoSuchElementException(\"\"\n                                           + \"\");\n        }\n    }", "comment": "/**\n     * Reads the next token from standard input, parses it as a short integer, and returns the short integer.\n     *\n     * @return the next short integer on standard input\n     * @throws NoSuchElementException if standard input is empty\n     * @throws InputMismatchException if the next token cannot be parsed as a {@code short}\n     */"}}
{"code": {"body": "    public static byte readByte() {\n        try {\n            return scanner.nextByte();\n        }\n        catch (InputMismatchException e) {\n            String token = scanner.next();\n            throw new InputMismatchException(\"\"\n                                           + \"\" + token + \"\");\n        }\n        catch (NoSuchElementException e) {\n            throw new NoSuchElementException(\"\"\n                                           + \"\");\n        }\n    }", "comment": "/**\n     * Reads the next token from standard input, parses it as a byte, and returns the byte.\n     *\n     * @return the next byte on standard input\n     * @throws NoSuchElementException if standard input is empty\n     * @throws InputMismatchException if the next token cannot be parsed as a {@code byte}\n     */"}}
{"code": {"body": "    public static boolean readBoolean() {\n        try {\n            String token = readString();\n            if (\"\".equalsIgnoreCase(token))  return true;\n            if (\"\".equalsIgnoreCase(token)) return false;\n            if (\"\".equals(token))               return true;\n            if (\"\".equals(token))               return false;\n            throw new InputMismatchException(\"\"\n                                           + \"\" + token + \"\");\n        }\n        catch (NoSuchElementException e) {\n            throw new NoSuchElementException(\"\"\n                                           + \"\");\n        }\n\n    }", "comment": "/**\n     * Reads the next token from standard input, parses it as a boolean,\n     * and returns the boolean.\n     *\n     * @return the next boolean on standard input\n     * @throws NoSuchElementException if standard input is empty\n     * @throws InputMismatchException if the next token cannot be parsed as a {@code boolean}:\n     *    {@code true} or {@code 1} for true, and {@code false} or {@code 0} for false,\n     *    ignoring case\n     */"}}
{"code": {"body": "    public static String[] readAllStrings() {\n        \n        \n        String[] tokens = WHITESPACE_PATTERN.split(readAll());\n        if (tokens.length == 0 || tokens[0].length() > 0)\n            return tokens;\n\n        \n        String[] decapitokens = new String[tokens.length-1];\n        for (int i = 0; i < tokens.length - 1; i++)\n            decapitokens[i] = tokens[i+1];\n        return decapitokens;\n    }", "comment": "/**\n     * Reads all remaining tokens from standard input and returns them as an array of strings.\n     *\n     * @return all remaining tokens on standard input, as an array of strings\n     */"}}
{"code": {"body": "    public static String[] readAllLines() {\n        ArrayList<String> lines = new ArrayList<String>();\n        while (hasNextLine()) {\n            lines.add(readLine());\n        }\n        return lines.toArray(new String[lines.size()]);\n    }", "comment": "/**\n     * Reads all remaining lines from standard input and returns them as an array of strings.\n     * @return all remaining lines on standard input, as an array of strings\n     */"}}
{"code": {"body": "    public static int[] readAllInts() {\n        String[] fields = readAllStrings();\n        int[] vals = new int[fields.length];\n        for (int i = 0; i < fields.length; i++)\n            vals[i] = Integer.parseInt(fields[i]);\n        return vals;\n    }", "comment": "/**\n     * Reads all remaining tokens from standard input, parses them as integers, and returns\n     * them as an array of integers.\n     * @return all remaining integers on standard input, as an array\n     * @throws InputMismatchException if any token cannot be parsed as an {@code int}\n     */"}}
{"code": {"body": "    public static long[] readAllLongs() {\n        String[] fields = readAllStrings();\n        long[] vals = new long[fields.length];\n        for (int i = 0; i < fields.length; i++)\n            vals[i] = Long.parseLong(fields[i]);\n        return vals;\n    }", "comment": "/**\n     * Reads all remaining tokens from standard input, parses them as longs, and returns\n     * them as an array of longs.\n     * @return all remaining longs on standard input, as an array\n     * @throws InputMismatchException if any token cannot be parsed as a {@code long}\n     */"}}
{"code": {"body": "    public static double[] readAllDoubles() {\n        String[] fields = readAllStrings();\n        double[] vals = new double[fields.length];\n        for (int i = 0; i < fields.length; i++)\n            vals[i] = Double.parseDouble(fields[i]);\n        return vals;\n    }", "comment": "/**\n     * Reads all remaining tokens from standard input, parses them as doubles, and returns\n     * them as an array of doubles.\n     * @return all remaining doubles on standard input, as an array\n     * @throws InputMismatchException if any token cannot be parsed as a {@code double}\n     */"}}
{"code": {"body": "    private static void resync() {\n        setScanner(new Scanner(new java.io.BufferedInputStream(System.in), CHARSET_NAME));\n    }", "comment": "/**\n     * If StdIn changes, use this to reinitialize the scanner.\n     */"}}
{"code": {"body": "    public static void main(String[] args) {\n\n        StdOut.print(\"\");\n        String s = StdIn.readString();\n        StdOut.println(\"\" + s);\n        StdOut.println();\n\n        StdOut.print(\"\");\n        int a = StdIn.readInt();\n        StdOut.println(\"\" + a);\n        StdOut.println();\n\n        StdOut.print(\"\");\n        boolean b = StdIn.readBoolean();\n        StdOut.println(\"\" + b);\n        StdOut.println();\n\n        StdOut.print(\"\");\n        double c = StdIn.readDouble();\n        StdOut.println(\"\" + c);\n        StdOut.println();\n    }", "comment": "/**\n     * Interactive test of basic functionality.\n     *\n     * @param args the command-line arguments\n     */"}}
{"code": {"body": "    public static void println(byte x) {\n        out.println(x);\n    }", "comment": "/**\n     * Prints a byte to standard output and then terminates the line.\n     * <p>\n     * To write binary data, see {@link BinaryStdOut}.\n     *\n     * @param x the byte to print\n     */"}}
{"code": {"body": "    public static void print(byte x) {\n        out.print(x);\n        out.flush();\n    }", "comment": "/**\n     * Prints a byte to standard output and flushes standard output.\n     *\n     * @param x the byte to print\n     */"}}
{"code": {"body": "    public static void printf(Locale locale, String format, Object... args) {\n        out.printf(locale, format, args);\n        out.flush();\n    }", "comment": "/**\n     * Prints a formatted string to standard output, using the locale and\n     * the specified format string and arguments; then flushes standard output.\n     *\n     * @param locale the locale\n     * @param format the <a href = \"http://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html#syntax\">format string</a>\n     * @param args   the arguments accompanying the format string\n     */"}}
{"code": {"body": "    public int size() {\n        return n;\n    }", "comment": "/**\n     * Returns the number of key-value pairs in this symbol table.\n     * @return the number of key-value pairs in this symbol table\n     */"}}
{"code": {"body": "    public boolean contains(String key) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        return get(key) != null;\n    }", "comment": "/**\n     * Does this symbol table contain the given key?\n     * @param key the key\n     * @return {@code true} if this symbol table contains {@code key} and\n     *     {@code false} otherwise\n     * @throws IllegalArgumentException if {@code key} is {@code null}\n     */"}}
{"code": {"body": "    public String longestPrefixOf(String query) {\n        if (query == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (query.length() == 0) return null;\n        int length = 0;\n        Node<Value> x = root;\n        int i = 0;\n        while (x != null && i < query.length()) {\n            char c = query.charAt(i);\n            if      (c < x.c) x = x.left;\n            else if (c > x.c) x = x.right;\n            else {\n                i++;\n                if (x.val != null) length = i;\n                x = x.mid;\n            }\n        }\n        return query.substring(0, length);\n    }", "comment": "/**\n     * Returns the string in the symbol table that is the longest prefix of {@code query},\n     * or {@code null}, if no such string.\n     * @param query the query string\n     * @return the string in the symbol table that is the longest prefix of {@code query},\n     *     or {@code null} if no such string\n     * @throws IllegalArgumentException if {@code query} is {@code null}\n     */"}}
{"code": {"body": "    public Iterable<String> keys() {\n        Queue<String> queue = new Queue<String>();\n        collect(root, new StringBuilder(), queue);\n        return queue;\n    }", "comment": "/**\n     * Returns all keys in the symbol table as an {@code Iterable}.\n     * To iterate over all of the keys in the symbol table named {@code st},\n     * use the foreach notation: {@code for (Key key : st.keys())}.\n     * @return all keys in the symbol table as an {@code Iterable}\n     */"}}
{"code": {"body": "    public Iterable<String> keysWithPrefix(String prefix) {\n        if (prefix == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        Queue<String> queue = new Queue<String>();\n        Node<Value> x = get(root, prefix, 0);\n        if (x == null) return queue;\n        if (x.val != null) queue.enqueue(prefix);\n        collect(x.mid, new StringBuilder(prefix), queue);\n        return queue;\n    }", "comment": "/**\n     * Returns all of the keys in the set that start with {@code prefix}.\n     * @param prefix the prefix\n     * @return all of the keys in the set that start with {@code prefix},\n     *     as an iterable\n     * @throws IllegalArgumentException if {@code prefix} is {@code null}\n     */"}}
{"code": {"body": "    public Iterable<String> keysThatMatch(String pattern) {\n        Queue<String> queue = new Queue<String>();\n        collect(root, new StringBuilder(), 0, pattern, queue);\n        return queue;\n    }", "comment": "/**\n     * Returns all of the keys in the symbol table that match {@code pattern},\n     * where . symbol is treated as a wildcard character.\n     * @param pattern the pattern\n     * @return all of the keys in the symbol table that match {@code pattern},\n     *     as an iterable, where . is treated as a wildcard character.\n     */"}}
{"code": {"body": "    public static void main(String[] args) {\n\n        \n        TST<Integer> st = new TST<Integer>();\n        for (int i = 0; !StdIn.isEmpty(); i++) {\n            String key = StdIn.readString();\n            st.put(key, i);\n        }\n\n        \n        if (st.size() < 100) {\n            StdOut.println(\"\");\n            for (String key : st.keys()) {\n                StdOut.println(key + \"\" + st.get(key));\n            }\n            StdOut.println();\n        }\n\n        StdOut.println(\"\");\n        StdOut.println(st.longestPrefixOf(\"\"));\n        StdOut.println();\n\n        StdOut.println(\"\");\n        StdOut.println(st.longestPrefixOf(\"\"));\n        StdOut.println();\n\n        StdOut.println(\"\");\n        for (String s : st.keysWithPrefix(\"\"))\n            StdOut.println(s);\n        StdOut.println();\n\n        StdOut.println(\"\");\n        for (String s : st.keysThatMatch(\"\"))\n            StdOut.println(s);\n    }", "comment": "/**\n     * Unit tests the {@code TST} data type.\n     *\n     * @param args the command-line arguments\n     */"}}
{"code": {"body": "    public static void close() {\n        if (!isInitialized) initialize();\n        try {\n            in.close();\n            isInitialized = false;\n        }\n        catch (IOException ioe) {\n            throw new IllegalStateException(\"\", ioe);\n        }\n    }", "comment": "/**\n     * Close this input stream and release any associated system resources.\n     */"}}
{"code": {"body": "    public static boolean isEmpty() {\n        if (!isInitialized) initialize();\n        return buffer == EOF;\n    }", "comment": "/**\n     * Returns true if standard input is empty.\n     * @return true if and only if standard input is empty\n     */"}}
{"code": {"body": "    public static boolean readBoolean() {\n        if (isEmpty()) throw new NoSuchElementException(\"\");\n        n--;\n        boolean bit = ((buffer >> n) & 1) == 1;\n        if (n == 0) fillBuffer();\n        return bit;\n    }", "comment": "/**\n     * Reads the next bit of data from standard input and return as a boolean.\n     *\n     * @return the next bit of data from standard input as a {@code boolean}\n     * @throws NoSuchElementException if standard input is empty\n     */"}}
{"code": {"body": "    public static char readChar(int r) {\n        if (r < 1 || r > 16) throw new IllegalArgumentException(\"\" + r);\n\n        \n        if (r == 8) return readChar();\n\n        char x = 0;\n        for (int i = 0; i < r; i++) {\n            x <<= 1;\n            boolean bit = readBoolean();\n            if (bit) x |= 1;\n        }\n        return x;\n    }", "comment": "/**\n     * Reads the next r bits from standard input and return as an r-bit character.\n     *\n     * @param  r number of bits to read.\n     * @return the next r bits of data from standard input as a {@code char}\n     * @throws NoSuchElementException if there are fewer than {@code r} bits available on standard input\n     * @throws IllegalArgumentException unless {@code 1 <= r <= 16}\n     */"}}
{"code": {"body": "    public static String readString() {\n        if (isEmpty()) throw new NoSuchElementException(\"\");\n\n        StringBuilder sb = new StringBuilder();\n        while (!isEmpty()) {\n            char c = readChar();\n            sb.append(c);\n        }\n        return sb.toString();\n    }", "comment": "/**\n     * Reads the remaining bytes of data from standard input and return as a string. \n     *\n     * @return the remaining bytes of data from standard input as a {@code String}\n     * @throws NoSuchElementException if standard input is empty or if the number of bits\n     *         available on standard input is not a multiple of 8 (byte-aligned)\n     */"}}
{"code": {"body": "    public static short readShort() {\n        short x = 0;\n        for (int i = 0; i < 2; i++) {\n            char c = readChar();\n            x <<= 8;\n            x |= c;\n        }\n        return x;\n    }", "comment": "/**\n     * Reads the next 16 bits from standard input and return as a 16-bit short.\n     *\n     * @return the next 16 bits of data from standard input as a {@code short}\n     * @throws NoSuchElementException if there are fewer than 16 bits available on standard input\n     */"}}
{"code": {"body": "    public static int readInt(int r) {\n        if (r < 1 || r > 32) throw new IllegalArgumentException(\"\" + r);\n\n        \n        if (r == 32) return readInt();\n\n        int x = 0;\n        for (int i = 0; i < r; i++) {\n            x <<= 1;\n            boolean bit = readBoolean();\n            if (bit) x |= 1;\n        }\n        return x;\n    }", "comment": "/**\n     * Reads the next r bits from standard input and return as an r-bit int.\n     *\n     * @param  r number of bits to read.\n     * @return the next r bits of data from standard input as a {@code int}\n     * @throws NoSuchElementException if there are fewer than {@code r} bits available on standard input\n     * @throws IllegalArgumentException unless {@code 1 <= r <= 32}\n     */"}}
{"code": {"body": "    public static long readLong() {\n        long x = 0;\n        for (int i = 0; i < 8; i++) {\n            char c = readChar();\n            x <<= 8;\n            x |= c;\n        }\n        return x;\n    }", "comment": "/**\n     * Reads the next 64 bits from standard input and return as a 64-bit long.\n     *\n     * @return the next 64 bits of data from standard input as a {@code long}\n     * @throws NoSuchElementException if there are fewer than 64 bits available on standard input\n     */"}}
{"code": {"body": "    public static double readDouble() {\n        return Double.longBitsToDouble(readLong());\n    }", "comment": "/**\n     * Reads the next 64 bits from standard input and return as a 64-bit double.\n     *\n     * @return the next 64 bits of data from standard input as a {@code double}\n     * @throws NoSuchElementException if there are fewer than 64 bits available on standard input\n     */"}}
{"code": {"body": "    public static float readFloat() {\n        return Float.intBitsToFloat(readInt());\n    }", "comment": "/**\n     * Reads the next 32 bits from standard input and return as a 32-bit float.\n     *\n     * @return the next 32 bits of data from standard input as a {@code float}\n     * @throws NoSuchElementException if there are fewer than 32 bits available on standard input\n     */"}}
{"code": {"body": "    public static byte readByte() {\n        char c = readChar();\n        return (byte) (c & 0xff);\n    }", "comment": "/**\n     * Reads the next 8 bits from standard input and return as an 8-bit byte.\n     *\n     * @return the next 8 bits of data from standard input as a {@code byte}\n     * @throws NoSuchElementException if there are fewer than 8 bits available on standard input\n     */"}}
{"code": {"body": "    public static void main(String[] args) {\n\n        \n        while (!BinaryStdIn.isEmpty()) {\n            char c = BinaryStdIn.readChar();\n            BinaryStdOut.write(c);\n        }\n        BinaryStdOut.flush();\n    }", "comment": "/**\n     * Test client. Reads in a binary input file from standard input and writes\n     * it to standard output.\n     *\n     * @param args the command-line arguments\n     */"}}
{"code": {"body": "    public static void writeBit(boolean bit) {\n        if (!isInitialized) initialize();\n\n        \n        buffer <<= 1;\n        if (bit) buffer |= 1;\n\n        \n        n++;\n        if (n == 8) clearBuffer();\n    }", "comment": "/**\n     * Writes the specified bit to standard output.\n     */"}}
{"code": {"body": "    private static void writeByte(int x) {\n        if (!isInitialized) initialize();\n\n        assert x >= 0 && x < 256;\n\n        \n        if (n == 0) {\n            try {\n                out.write(x);\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return;\n        }\n\n        \n        for (int i = 0; i < 8; i++) {\n            boolean bit = ((x >>> (8 - i - 1)) & 1) == 1;\n            writeBit(bit);\n        }\n    }", "comment": "/**\n     * Writes the 8-bit byte to standard output.\n     */"}}
{"code": {"body": "    public static void flush() {\n        clearBuffer();\n        try {\n            out.flush();\n        }\n        catch (IOException e) {\n            e.printStackTrace();\n        }\n    }", "comment": "/**\n     * Flushes standard output, padding 0s if number of bits written so far\n     * is not a multiple of 8.\n     */"}}
{"code": {"body": "    public static void close() {\n        flush();\n        try {\n            out.close();\n            isInitialized = false;\n        }\n        catch (IOException e) {\n            e.printStackTrace();\n        }\n    }", "comment": "/**\n     * Flushes and closes standard output. Once standard output is closed, you can no\n     * longer write bits to it.\n     */"}}
{"code": {"body": "    public static void write(String s, int r) {\n        for (int i = 0; i < s.length(); i++)\n            write(s.charAt(i), r);\n    }", "comment": "/**\n     * Writes the string of r-bit characters to standard output.\n     * @param s the {@code String} to write.\n     * @param r the number of relevants bits in each character.\n     * @throws IllegalArgumentException if r is not between 1 and 16.\n     * @throws IllegalArgumentException if any character in the string is not\n     * between 0 and 2<sup>r</sup> - 1.\n     */"}}
{"code": {"body": "    public static void main(String[] args) {\n        int m = Integer.parseInt(args[0]);\n\n        \n        for (int i = 0; i < m; i++) {\n            BinaryStdOut.write(i);\n        }\n        BinaryStdOut.flush();\n    }", "comment": "/**\n     * Tests the methods in this class.\n     *\n     * @param args the command-line arguments\n     */"}}
{"code": {"body": "public Queue() {\n        first = null;\n        last  = null;\n        n = 0;\n    }", "comment": "/**\n     * Initializes an empty queue.\n     */"}}
{"code": {"body": "    public boolean isEmpty() {\n        return first == null;\n    }", "comment": "/**\n     * Returns true if this queue is empty.\n     *\n     * @return {@code true} if this queue is empty; {@code false} otherwise\n     */"}}
{"code": {"body": "    public int size() {\n        return n;\n    }", "comment": "/**\n     * Returns the number of items in this queue.\n     *\n     * @return the number of items in this queue\n     */"}}
{"code": {"body": "    public Item peek() {\n        if (isEmpty()) throw new NoSuchElementException(\"\");\n        return first.item;\n    }", "comment": "/**\n     * Returns the item least recently added to this queue.\n     *\n     * @return the item least recently added to this queue\n     * @throws NoSuchElementException if this queue is empty\n     */"}}
{"code": {"body": "    public void enqueue(Item item) {\n        Node<Item> oldlast = last;\n        last = new Node<Item>();\n        last.item = item;\n        last.next = null;\n        if (isEmpty()) first = last;\n        else           oldlast.next = last;\n        n++;\n    }", "comment": "/**\n     * Adds the item to this queue.\n     *\n     * @param  item the item to add\n     */"}}
{"code": {"body": "    public Item dequeue() {\n        if (isEmpty()) throw new NoSuchElementException(\"\");\n        Item item = first.item;\n        first = first.next;\n        n--;\n        if (isEmpty()) last = null;   \n        return item;\n    }", "comment": "/**\n     * Removes and returns the item on this queue that was least recently added.\n     *\n     * @return the item on this queue that was least recently added\n     * @throws NoSuchElementException if this queue is empty\n     */"}}
{"code": {"body": "    public String toString() {\n        StringBuilder s = new StringBuilder();\n        for (Item item : this) {\n            s.append(item);\n            s.append('');\n        }\n        return s.toString();\n    }", "comment": "/**\n     * Returns a string representation of this queue.\n     *\n     * @return the sequence of items in FIFO order, separated by spaces\n     */"}}
{"code": {"body": "    public Iterator<Item> iterator()  {\n        return new ListIterator<Item>(first);  \n    }", "comment": "/**\n     * Returns an iterator that iterates over the items in this queue in FIFO order.\n     *\n     * @return an iterator that iterates over the items in this queue in FIFO order\n     */"}}
{"code": {"body": "    public static void main(String[] args) {\n        Queue<String> queue = new Queue<String>();\n        while (!StdIn.isEmpty()) {\n            String item = StdIn.readString();\n            if (!item.equals(\"\"))\n                queue.enqueue(item);\n            else if (!queue.isEmpty())\n                StdOut.print(queue.dequeue() + \"\");\n        }\n        StdOut.println(\"\" + queue.size() + \"\");\n    }", "comment": "/**\n     * Unit tests the {@code Queue} data type.\n     *\n     * @param args the command-line arguments\n     */"}}
{"code": {"body": "    public static boolean isEmpty() {\n        return !scanner.hasNext();\n    }", "comment": "/**\n     * Returns true if standard input is empty (except possibly for whitespace).\n     * Use this method to know whether the next call to {@link #readString()}, \n     * {@link #readDouble()}, etc will succeed.\n     *\n     * @return {@code true} if standard input is empty (except possibly\n     *         for whitespace); {@code false} otherwise\n     */"}}
{"code": {"body": "    public static boolean hasNextLine() {\n        return scanner.hasNextLine();\n    }", "comment": "/**\n     * Returns true if standard input has a next line.\n     * Use this method to know whether the\n     * next call to {@link #readLine()} will succeed.\n     * This method is functionally equivalent to {@link #hasNextChar()}.\n     *\n     * @return {@code true} if standard input has more input (including whitespace);\n     *         {@code false} otherwise\n     */"}}
{"code": {"body": "    public static boolean hasNextChar() {\n        scanner.useDelimiter(EMPTY_PATTERN);\n        boolean result = scanner.hasNext();\n        scanner.useDelimiter(WHITESPACE_PATTERN);\n        return result;\n    }", "comment": "/**\n     * Returns true if standard input has more input (including whitespace).\n     * Use this method to know whether the next call to {@link #readChar()} will succeed.\n     * This method is functionally equivalent to {@link #hasNextLine()}.\n     *\n     * @return {@code true} if standard input has more input (including whitespace);\n     *         {@code false} otherwise\n     */"}}
{"code": {"body": "    public static String readLine() {\n        String line;\n        try {\n            line = scanner.nextLine();\n        }\n        catch (NoSuchElementException e) {\n            line = null;\n        }\n        return line;\n    }", "comment": "/**\n     * Reads and returns the next line, excluding the line separator if present.\n     *\n     * @return the next line, excluding the line separator if present;\n     *         {@code null} if no such line\n     */"}}
{"code": {"body": "    public static char readChar() {\n        try {\n            scanner.useDelimiter(EMPTY_PATTERN);\n            String ch = scanner.next();\n            assert ch.length() == 1 : \"\"\n                + \"\";\n            scanner.useDelimiter(WHITESPACE_PATTERN);\n            return ch.charAt(0);\n        }\n        catch (NoSuchElementException e) {\n            throw new NoSuchElementException(\"\"\n                                           + \"\");\n        }\n    }", "comment": "/**\n     * Reads and returns the next character.\n     *\n     * @return the next {@code char}\n     * @throws NoSuchElementException if standard input is empty\n     */"}}
{"code": {"body": "    public static String readAll() {\n        if (!scanner.hasNextLine())\n            return \"\";\n\n        String result = scanner.useDelimiter(EVERYTHING_PATTERN).next();\n        \n        scanner.useDelimiter(WHITESPACE_PATTERN); \n        return result;\n    }", "comment": "/**\n     * Reads and returns the remainder of the input, as a string.\n     *\n     * @return the remainder of the input, as a string\n     * @throws NoSuchElementException if standard input is empty\n     */"}}
{"code": {"body": "    public static String readString() {\n        try {\n            return scanner.next();\n        }\n        catch (NoSuchElementException e) {\n            throw new NoSuchElementException(\"\"\n                                           + \"\");\n        }\n    }", "comment": "/**\n     * Reads the next token  and returns the {@code String}.\n     *\n     * @return the next {@code String}\n     * @throws NoSuchElementException if standard input is empty\n     */"}}
{"code": {"body": "    public static int readInt() {\n        try {\n            return scanner.nextInt();\n        }\n        catch (InputMismatchException e) {\n            String token = scanner.next();\n            throw new InputMismatchException(\"\"\n                                           + \"\" + token + \"\");\n        }\n        catch (NoSuchElementException e) {\n            throw new NoSuchElementException(\"\"\n                                           + \"\");\n        }\n\n    }", "comment": "/**\n     * Reads the next token from standard input, parses it as an integer, and returns the integer.\n     *\n     * @return the next integer on standard input\n     * @throws NoSuchElementException if standard input is empty\n     * @throws InputMismatchException if the next token cannot be parsed as an {@code int}\n     */"}}
{"code": {"body": "    public static double readDouble() {\n        try {\n            return scanner.nextDouble();\n        }\n        catch (InputMismatchException e) {\n            String token = scanner.next();\n            throw new InputMismatchException(\"\"\n                                           + \"\" + token + \"\");\n        }\n        catch (NoSuchElementException e) {\n            throw new NoSuchElementException(\"\"\n                                           + \"\");\n        }\n    }", "comment": "/**\n     * Reads the next token from standard input, parses it as a double, and returns the double.\n     *\n     * @return the next double on standard input\n     * @throws NoSuchElementException if standard input is empty\n     * @throws InputMismatchException if the next token cannot be parsed as a {@code double}\n     */"}}
{"code": {"body": "    public static float readFloat() {\n        try {\n            return scanner.nextFloat();\n        }\n        catch (InputMismatchException e) {\n            String token = scanner.next();\n            throw new InputMismatchException(\"\"\n                                           + \"\" + token + \"\");\n        }\n        catch (NoSuchElementException e) {\n            throw new NoSuchElementException(\"\"\n                                           + \"\");\n        }\n    }", "comment": "/**\n     * Reads the next token from standard input, parses it as a float, and returns the float.\n     *\n     * @return the next float on standard input\n     * @throws NoSuchElementException if standard input is empty\n     * @throws InputMismatchException if the next token cannot be parsed as a {@code float}\n     */"}}
{"code": {"body": "    public static long readLong() {\n        try {\n            return scanner.nextLong();\n        }\n        catch (InputMismatchException e) {\n            String token = scanner.next();\n            throw new InputMismatchException(\"\"\n                                           + \"\" + token + \"\");\n        }\n        catch (NoSuchElementException e) {\n            throw new NoSuchElementException(\"\"\n                                           + \"\");\n        }\n    }", "comment": "/**\n     * Reads the next token from standard input, parses it as a long integer, and returns the long integer.\n     *\n     * @return the next long integer on standard input\n     * @throws NoSuchElementException if standard input is empty\n     * @throws InputMismatchException if the next token cannot be parsed as a {@code long}\n     */"}}
{"code": {"body": "    public static short readShort() {\n        try {\n            return scanner.nextShort();\n        }\n        catch (InputMismatchException e) {\n            String token = scanner.next();\n            throw new InputMismatchException(\"\"\n                                           + \"\" + token + \"\");\n        }\n        catch (NoSuchElementException e) {\n            throw new NoSuchElementException(\"\"\n                                           + \"\");\n        }\n    }", "comment": "/**\n     * Reads the next token from standard input, parses it as a short integer, and returns the short integer.\n     *\n     * @return the next short integer on standard input\n     * @throws NoSuchElementException if standard input is empty\n     * @throws InputMismatchException if the next token cannot be parsed as a {@code short}\n     */"}}
{"code": {"body": "    public static byte readByte() {\n        try {\n            return scanner.nextByte();\n        }\n        catch (InputMismatchException e) {\n            String token = scanner.next();\n            throw new InputMismatchException(\"\"\n                                           + \"\" + token + \"\");\n        }\n        catch (NoSuchElementException e) {\n            throw new NoSuchElementException(\"\"\n                                           + \"\");\n        }\n    }", "comment": "/**\n     * Reads the next token from standard input, parses it as a byte, and returns the byte.\n     *\n     * @return the next byte on standard input\n     * @throws NoSuchElementException if standard input is empty\n     * @throws InputMismatchException if the next token cannot be parsed as a {@code byte}\n     */"}}
{"code": {"body": "    public static boolean readBoolean() {\n        try {\n            String token = readString();\n            if (\"\".equalsIgnoreCase(token))  return true;\n            if (\"\".equalsIgnoreCase(token)) return false;\n            if (\"\".equals(token))               return true;\n            if (\"\".equals(token))               return false;\n            throw new InputMismatchException(\"\"\n                                           + \"\" + token + \"\");\n        }\n        catch (NoSuchElementException e) {\n            throw new NoSuchElementException(\"\"\n                                           + \"\");\n        }\n\n    }", "comment": "/**\n     * Reads the next token from standard input, parses it as a boolean,\n     * and returns the boolean.\n     *\n     * @return the next boolean on standard input\n     * @throws NoSuchElementException if standard input is empty\n     * @throws InputMismatchException if the next token cannot be parsed as a {@code boolean}:\n     *    {@code true} or {@code 1} for true, and {@code false} or {@code 0} for false,\n     *    ignoring case\n     */"}}
{"code": {"body": "    public static String[] readAllStrings() {\n        \n        \n        String[] tokens = WHITESPACE_PATTERN.split(readAll());\n        if (tokens.length == 0 || tokens[0].length() > 0)\n            return tokens;\n\n        \n        String[] decapitokens = new String[tokens.length-1];\n        for (int i = 0; i < tokens.length - 1; i++)\n            decapitokens[i] = tokens[i+1];\n        return decapitokens;\n    }", "comment": "/**\n     * Reads all remaining tokens from standard input and returns them as an array of strings.\n     *\n     * @return all remaining tokens on standard input, as an array of strings\n     */"}}
{"code": {"body": "    public static String[] readAllLines() {\n        ArrayList<String> lines = new ArrayList<String>();\n        while (hasNextLine()) {\n            lines.add(readLine());\n        }\n        return lines.toArray(new String[lines.size()]);\n    }", "comment": "/**\n     * Reads all remaining lines from standard input and returns them as an array of strings.\n     * @return all remaining lines on standard input, as an array of strings\n     */"}}
{"code": {"body": "    public static int[] readAllInts() {\n        String[] fields = readAllStrings();\n        int[] vals = new int[fields.length];\n        for (int i = 0; i < fields.length; i++)\n            vals[i] = Integer.parseInt(fields[i]);\n        return vals;\n    }", "comment": "/**\n     * Reads all remaining tokens from standard input, parses them as integers, and returns\n     * them as an array of integers.\n     * @return all remaining integers on standard input, as an array\n     * @throws InputMismatchException if any token cannot be parsed as an {@code int}\n     */"}}
{"code": {"body": "    public static long[] readAllLongs() {\n        String[] fields = readAllStrings();\n        long[] vals = new long[fields.length];\n        for (int i = 0; i < fields.length; i++)\n            vals[i] = Long.parseLong(fields[i]);\n        return vals;\n    }", "comment": "/**\n     * Reads all remaining tokens from standard input, parses them as longs, and returns\n     * them as an array of longs.\n     * @return all remaining longs on standard input, as an array\n     * @throws InputMismatchException if any token cannot be parsed as a {@code long}\n     */"}}
{"code": {"body": "    public static double[] readAllDoubles() {\n        String[] fields = readAllStrings();\n        double[] vals = new double[fields.length];\n        for (int i = 0; i < fields.length; i++)\n            vals[i] = Double.parseDouble(fields[i]);\n        return vals;\n    }", "comment": "/**\n     * Reads all remaining tokens from standard input, parses them as doubles, and returns\n     * them as an array of doubles.\n     * @return all remaining doubles on standard input, as an array\n     * @throws InputMismatchException if any token cannot be parsed as a {@code double}\n     */"}}
{"code": {"body": "    private static void resync() {\n        setScanner(new Scanner(new java.io.BufferedInputStream(System.in), CHARSET_NAME));\n    }", "comment": "/**\n     * If StdIn changes, use this to reinitialize the scanner.\n     */"}}
{"code": {"body": "    public static void main(String[] args) {\n\n        StdOut.print(\"\");\n        String s = StdIn.readString();\n        StdOut.println(\"\" + s);\n        StdOut.println();\n\n        StdOut.print(\"\");\n        int a = StdIn.readInt();\n        StdOut.println(\"\" + a);\n        StdOut.println();\n\n        StdOut.print(\"\");\n        boolean b = StdIn.readBoolean();\n        StdOut.println(\"\" + b);\n        StdOut.println();\n\n        StdOut.print(\"\");\n        double c = StdIn.readDouble();\n        StdOut.println(\"\" + c);\n        StdOut.println();\n    }", "comment": "/**\n     * Interactive test of basic functionality.\n     *\n     * @param args the command-line arguments\n     */"}}
{"code": {"body": "    public static void println(byte x) {\n        out.println(x);\n    }", "comment": "/**\n     * Prints a byte to standard output and then terminates the line.\n     * <p>\n     * To write binary data, see {@link BinaryStdOut}.\n     *\n     * @param x the byte to print\n     */"}}
{"code": {"body": "    public static void print(byte x) {\n        out.print(x);\n        out.flush();\n    }", "comment": "/**\n     * Prints a byte to standard output and flushes standard output.\n     *\n     * @param x the byte to print\n     */"}}
{"code": {"body": "    public static void printf(Locale locale, String format, Object... args) {\n        out.printf(locale, format, args);\n        out.flush();\n    }", "comment": "/**\n     * Prints a formatted string to standard output, using the locale and\n     * the specified format string and arguments; then flushes standard output.\n     *\n     * @param locale the locale\n     * @param format the <a href = \"http://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html#syntax\">format string</a>\n     * @param args   the arguments accompanying the format string\n     */"}}
{"code": {"body": "    public int size() {\n        return n;\n    }", "comment": "/**\n     * Returns the number of key-value pairs in this symbol table.\n     * @return the number of key-value pairs in this symbol table\n     */"}}
{"code": {"body": "    public boolean contains(String key) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        return get(key) != null;\n    }", "comment": "/**\n     * Does this symbol table contain the given key?\n     * @param key the key\n     * @return {@code true} if this symbol table contains {@code key} and\n     *     {@code false} otherwise\n     * @throws IllegalArgumentException if {@code key} is {@code null}\n     */"}}
{"code": {"body": "    public String longestPrefixOf(String query) {\n        if (query == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (query.length() == 0) return null;\n        int length = 0;\n        Node<Value> x = root;\n        int i = 0;\n        while (x != null && i < query.length()) {\n            char c = query.charAt(i);\n            if      (c < x.c) x = x.left;\n            else if (c > x.c) x = x.right;\n            else {\n                i++;\n                if (x.val != null) length = i;\n                x = x.mid;\n            }\n        }\n        return query.substring(0, length);\n    }", "comment": "/**\n     * Returns the string in the symbol table that is the longest prefix of {@code query},\n     * or {@code null}, if no such string.\n     * @param query the query string\n     * @return the string in the symbol table that is the longest prefix of {@code query},\n     *     or {@code null} if no such string\n     * @throws IllegalArgumentException if {@code query} is {@code null}\n     */"}}
{"code": {"body": "    public Iterable<String> keys() {\n        Queue<String> queue = new Queue<String>();\n        collect(root, new StringBuilder(), queue);\n        return queue;\n    }", "comment": "/**\n     * Returns all keys in the symbol table as an {@code Iterable}.\n     * To iterate over all of the keys in the symbol table named {@code st},\n     * use the foreach notation: {@code for (Key key : st.keys())}.\n     * @return all keys in the symbol table as an {@code Iterable}\n     */"}}
{"code": {"body": "    public Iterable<String> keysWithPrefix(String prefix) {\n        if (prefix == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        Queue<String> queue = new Queue<String>();\n        Node<Value> x = get(root, prefix, 0);\n        if (x == null) return queue;\n        if (x.val != null) queue.enqueue(prefix);\n        collect(x.mid, new StringBuilder(prefix), queue);\n        return queue;\n    }", "comment": "/**\n     * Returns all of the keys in the set that start with {@code prefix}.\n     * @param prefix the prefix\n     * @return all of the keys in the set that start with {@code prefix},\n     *     as an iterable\n     * @throws IllegalArgumentException if {@code prefix} is {@code null}\n     */"}}
{"code": {"body": "    public Iterable<String> keysThatMatch(String pattern) {\n        Queue<String> queue = new Queue<String>();\n        collect(root, new StringBuilder(), 0, pattern, queue);\n        return queue;\n    }", "comment": "/**\n     * Returns all of the keys in the symbol table that match {@code pattern},\n     * where . symbol is treated as a wildcard character.\n     * @param pattern the pattern\n     * @return all of the keys in the symbol table that match {@code pattern},\n     *     as an iterable, where . is treated as a wildcard character.\n     */"}}
{"code": {"body": "    public static void main(String[] args) {\n\n        \n        TST<Integer> st = new TST<Integer>();\n        for (int i = 0; !StdIn.isEmpty(); i++) {\n            String key = StdIn.readString();\n            st.put(key, i);\n        }\n\n        \n        if (st.size() < 100) {\n            StdOut.println(\"\");\n            for (String key : st.keys()) {\n                StdOut.println(key + \"\" + st.get(key));\n            }\n            StdOut.println();\n        }\n\n        StdOut.println(\"\");\n        StdOut.println(st.longestPrefixOf(\"\"));\n        StdOut.println();\n\n        StdOut.println(\"\");\n        StdOut.println(st.longestPrefixOf(\"\"));\n        StdOut.println();\n\n        StdOut.println(\"\");\n        for (String s : st.keysWithPrefix(\"\"))\n            StdOut.println(s);\n        StdOut.println();\n\n        StdOut.println(\"\");\n        for (String s : st.keysThatMatch(\"\"))\n            StdOut.println(s);\n    }", "comment": "/**\n     * Unit tests the {@code TST} data type.\n     *\n     * @param args the command-line arguments\n     */"}}
{"code": {"body": "    public static void close() {\n        if (!isInitialized) initialize();\n        try {\n            in.close();\n            isInitialized = false;\n        }\n        catch (IOException ioe) {\n            throw new IllegalStateException(\"\", ioe);\n        }\n    }", "comment": "/**\n     * Close this input stream and release any associated system resources.\n     */"}}
{"code": {"body": "    public static boolean isEmpty() {\n        if (!isInitialized) initialize();\n        return buffer == EOF;\n    }", "comment": "/**\n     * Returns true if standard input is empty.\n     * @return true if and only if standard input is empty\n     */"}}
{"code": {"body": "    public static boolean readBoolean() {\n        if (isEmpty()) throw new NoSuchElementException(\"\");\n        n--;\n        boolean bit = ((buffer >> n) & 1) == 1;\n        if (n == 0) fillBuffer();\n        return bit;\n    }", "comment": "/**\n     * Reads the next bit of data from standard input and return as a boolean.\n     *\n     * @return the next bit of data from standard input as a {@code boolean}\n     * @throws NoSuchElementException if standard input is empty\n     */"}}
{"code": {"body": "    public static char readChar(int r) {\n        if (r < 1 || r > 16) throw new IllegalArgumentException(\"\" + r);\n\n        \n        if (r == 8) return readChar();\n\n        char x = 0;\n        for (int i = 0; i < r; i++) {\n            x <<= 1;\n            boolean bit = readBoolean();\n            if (bit) x |= 1;\n        }\n        return x;\n    }", "comment": "/**\n     * Reads the next r bits from standard input and return as an r-bit character.\n     *\n     * @param  r number of bits to read.\n     * @return the next r bits of data from standard input as a {@code char}\n     * @throws NoSuchElementException if there are fewer than {@code r} bits available on standard input\n     * @throws IllegalArgumentException unless {@code 1 <= r <= 16}\n     */"}}
{"code": {"body": "    public static String readString() {\n        if (isEmpty()) throw new NoSuchElementException(\"\");\n\n        StringBuilder sb = new StringBuilder();\n        while (!isEmpty()) {\n            char c = readChar();\n            sb.append(c);\n        }\n        return sb.toString();\n    }", "comment": "/**\n     * Reads the remaining bytes of data from standard input and return as a string. \n     *\n     * @return the remaining bytes of data from standard input as a {@code String}\n     * @throws NoSuchElementException if standard input is empty or if the number of bits\n     *         available on standard input is not a multiple of 8 (byte-aligned)\n     */"}}
{"code": {"body": "    public static short readShort() {\n        short x = 0;\n        for (int i = 0; i < 2; i++) {\n            char c = readChar();\n            x <<= 8;\n            x |= c;\n        }\n        return x;\n    }", "comment": "/**\n     * Reads the next 16 bits from standard input and return as a 16-bit short.\n     *\n     * @return the next 16 bits of data from standard input as a {@code short}\n     * @throws NoSuchElementException if there are fewer than 16 bits available on standard input\n     */"}}
{"code": {"body": "    public static int readInt(int r) {\n        if (r < 1 || r > 32) throw new IllegalArgumentException(\"\" + r);\n\n        \n        if (r == 32) return readInt();\n\n        int x = 0;\n        for (int i = 0; i < r; i++) {\n            x <<= 1;\n            boolean bit = readBoolean();\n            if (bit) x |= 1;\n        }\n        return x;\n    }", "comment": "/**\n     * Reads the next r bits from standard input and return as an r-bit int.\n     *\n     * @param  r number of bits to read.\n     * @return the next r bits of data from standard input as a {@code int}\n     * @throws NoSuchElementException if there are fewer than {@code r} bits available on standard input\n     * @throws IllegalArgumentException unless {@code 1 <= r <= 32}\n     */"}}
{"code": {"body": "    public static long readLong() {\n        long x = 0;\n        for (int i = 0; i < 8; i++) {\n            char c = readChar();\n            x <<= 8;\n            x |= c;\n        }\n        return x;\n    }", "comment": "/**\n     * Reads the next 64 bits from standard input and return as a 64-bit long.\n     *\n     * @return the next 64 bits of data from standard input as a {@code long}\n     * @throws NoSuchElementException if there are fewer than 64 bits available on standard input\n     */"}}
{"code": {"body": "    public static double readDouble() {\n        return Double.longBitsToDouble(readLong());\n    }", "comment": "/**\n     * Reads the next 64 bits from standard input and return as a 64-bit double.\n     *\n     * @return the next 64 bits of data from standard input as a {@code double}\n     * @throws NoSuchElementException if there are fewer than 64 bits available on standard input\n     */"}}
{"code": {"body": "    public static float readFloat() {\n        return Float.intBitsToFloat(readInt());\n    }", "comment": "/**\n     * Reads the next 32 bits from standard input and return as a 32-bit float.\n     *\n     * @return the next 32 bits of data from standard input as a {@code float}\n     * @throws NoSuchElementException if there are fewer than 32 bits available on standard input\n     */"}}
{"code": {"body": "    public static byte readByte() {\n        char c = readChar();\n        return (byte) (c & 0xff);\n    }", "comment": "/**\n     * Reads the next 8 bits from standard input and return as an 8-bit byte.\n     *\n     * @return the next 8 bits of data from standard input as a {@code byte}\n     * @throws NoSuchElementException if there are fewer than 8 bits available on standard input\n     */"}}
{"code": {"body": "    public static void main(String[] args) {\n\n        \n        while (!BinaryStdIn.isEmpty()) {\n            char c = BinaryStdIn.readChar();\n            BinaryStdOut.write(c);\n        }\n        BinaryStdOut.flush();\n    }", "comment": "/**\n     * Test client. Reads in a binary input file from standard input and writes\n     * it to standard output.\n     *\n     * @param args the command-line arguments\n     */"}}
{"code": {"body": "    public static void writeBit(boolean bit) {\n        if (!isInitialized) initialize();\n\n        \n        buffer <<= 1;\n        if (bit) buffer |= 1;\n\n        \n        n++;\n        if (n == 8) clearBuffer();\n    }", "comment": "/**\n     * Writes the specified bit to standard output.\n     */"}}
{"code": {"body": "    private static void writeByte(int x) {\n        if (!isInitialized) initialize();\n\n        assert x >= 0 && x < 256;\n\n        \n        if (n == 0) {\n            try {\n                out.write(x);\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return;\n        }\n\n        \n        for (int i = 0; i < 8; i++) {\n            boolean bit = ((x >>> (8 - i - 1)) & 1) == 1;\n            writeBit(bit);\n        }\n    }", "comment": "/**\n     * Writes the 8-bit byte to standard output.\n     */"}}
{"code": {"body": "    public static void flush() {\n        clearBuffer();\n        try {\n            out.flush();\n        }\n        catch (IOException e) {\n            e.printStackTrace();\n        }\n    }", "comment": "/**\n     * Flushes standard output, padding 0s if number of bits written so far\n     * is not a multiple of 8.\n     */"}}
{"code": {"body": "    public static void close() {\n        flush();\n        try {\n            out.close();\n            isInitialized = false;\n        }\n        catch (IOException e) {\n            e.printStackTrace();\n        }\n    }", "comment": "/**\n     * Flushes and closes standard output. Once standard output is closed, you can no\n     * longer write bits to it.\n     */"}}
{"code": {"body": "    public static void write(String s, int r) {\n        for (int i = 0; i < s.length(); i++)\n            write(s.charAt(i), r);\n    }", "comment": "/**\n     * Writes the string of r-bit characters to standard output.\n     * @param s the {@code String} to write.\n     * @param r the number of relevants bits in each character.\n     * @throws IllegalArgumentException if r is not between 1 and 16.\n     * @throws IllegalArgumentException if any character in the string is not\n     * between 0 and 2<sup>r</sup> - 1.\n     */"}}
{"code": {"body": "    public static void main(String[] args) {\n        int m = Integer.parseInt(args[0]);\n\n        \n        for (int i = 0; i < m; i++) {\n            BinaryStdOut.write(i);\n        }\n        BinaryStdOut.flush();\n    }", "comment": "/**\n     * Tests the methods in this class.\n     *\n     * @param args the command-line arguments\n     */"}}
{"code": {"body": "public Queue() {\n        first = null;\n        last  = null;\n        n = 0;\n    }", "comment": "/**\n     * Initializes an empty queue.\n     */"}}
{"code": {"body": "    public boolean isEmpty() {\n        return first == null;\n    }", "comment": "/**\n     * Returns true if this queue is empty.\n     *\n     * @return {@code true} if this queue is empty; {@code false} otherwise\n     */"}}
{"code": {"body": "    public int size() {\n        return n;\n    }", "comment": "/**\n     * Returns the number of items in this queue.\n     *\n     * @return the number of items in this queue\n     */"}}
{"code": {"body": "    public Item peek() {\n        if (isEmpty()) throw new NoSuchElementException(\"\");\n        return first.item;\n    }", "comment": "/**\n     * Returns the item least recently added to this queue.\n     *\n     * @return the item least recently added to this queue\n     * @throws NoSuchElementException if this queue is empty\n     */"}}
{"code": {"body": "    public void enqueue(Item item) {\n        Node<Item> oldlast = last;\n        last = new Node<Item>();\n        last.item = item;\n        last.next = null;\n        if (isEmpty()) first = last;\n        else           oldlast.next = last;\n        n++;\n    }", "comment": "/**\n     * Adds the item to this queue.\n     *\n     * @param  item the item to add\n     */"}}
{"code": {"body": "    public Item dequeue() {\n        if (isEmpty()) throw new NoSuchElementException(\"\");\n        Item item = first.item;\n        first = first.next;\n        n--;\n        if (isEmpty()) last = null;   \n        return item;\n    }", "comment": "/**\n     * Removes and returns the item on this queue that was least recently added.\n     *\n     * @return the item on this queue that was least recently added\n     * @throws NoSuchElementException if this queue is empty\n     */"}}
{"code": {"body": "    public String toString() {\n        StringBuilder s = new StringBuilder();\n        for (Item item : this) {\n            s.append(item);\n            s.append('');\n        }\n        return s.toString();\n    }", "comment": "/**\n     * Returns a string representation of this queue.\n     *\n     * @return the sequence of items in FIFO order, separated by spaces\n     */"}}
{"code": {"body": "    public Iterator<Item> iterator()  {\n        return new ListIterator<Item>(first);  \n    }", "comment": "/**\n     * Returns an iterator that iterates over the items in this queue in FIFO order.\n     *\n     * @return an iterator that iterates over the items in this queue in FIFO order\n     */"}}
{"code": {"body": "    public static void main(String[] args) {\n        Queue<String> queue = new Queue<String>();\n        while (!StdIn.isEmpty()) {\n            String item = StdIn.readString();\n            if (!item.equals(\"\"))\n                queue.enqueue(item);\n            else if (!queue.isEmpty())\n                StdOut.print(queue.dequeue() + \"\");\n        }\n        StdOut.println(\"\" + queue.size() + \"\");\n    }", "comment": "/**\n     * Unit tests the {@code Queue} data type.\n     *\n     * @param args the command-line arguments\n     */"}}
{"code": {"body": "    public static boolean isEmpty() {\n        return !scanner.hasNext();\n    }", "comment": "/**\n     * Returns true if standard input is empty (except possibly for whitespace).\n     * Use this method to know whether the next call to {@link #readString()}, \n     * {@link #readDouble()}, etc will succeed.\n     *\n     * @return {@code true} if standard input is empty (except possibly\n     *         for whitespace); {@code false} otherwise\n     */"}}
{"code": {"body": "    public static boolean hasNextLine() {\n        return scanner.hasNextLine();\n    }", "comment": "/**\n     * Returns true if standard input has a next line.\n     * Use this method to know whether the\n     * next call to {@link #readLine()} will succeed.\n     * This method is functionally equivalent to {@link #hasNextChar()}.\n     *\n     * @return {@code true} if standard input has more input (including whitespace);\n     *         {@code false} otherwise\n     */"}}
{"code": {"body": "    public static boolean hasNextChar() {\n        scanner.useDelimiter(EMPTY_PATTERN);\n        boolean result = scanner.hasNext();\n        scanner.useDelimiter(WHITESPACE_PATTERN);\n        return result;\n    }", "comment": "/**\n     * Returns true if standard input has more input (including whitespace).\n     * Use this method to know whether the next call to {@link #readChar()} will succeed.\n     * This method is functionally equivalent to {@link #hasNextLine()}.\n     *\n     * @return {@code true} if standard input has more input (including whitespace);\n     *         {@code false} otherwise\n     */"}}
{"code": {"body": "    public static String readLine() {\n        String line;\n        try {\n            line = scanner.nextLine();\n        }\n        catch (NoSuchElementException e) {\n            line = null;\n        }\n        return line;\n    }", "comment": "/**\n     * Reads and returns the next line, excluding the line separator if present.\n     *\n     * @return the next line, excluding the line separator if present;\n     *         {@code null} if no such line\n     */"}}
{"code": {"body": "    public static char readChar() {\n        try {\n            scanner.useDelimiter(EMPTY_PATTERN);\n            String ch = scanner.next();\n            assert ch.length() == 1 : \"\"\n                + \"\";\n            scanner.useDelimiter(WHITESPACE_PATTERN);\n            return ch.charAt(0);\n        }\n        catch (NoSuchElementException e) {\n            throw new NoSuchElementException(\"\"\n                                           + \"\");\n        }\n    }", "comment": "/**\n     * Reads and returns the next character.\n     *\n     * @return the next {@code char}\n     * @throws NoSuchElementException if standard input is empty\n     */"}}
{"code": {"body": "    public static String readAll() {\n        if (!scanner.hasNextLine())\n            return \"\";\n\n        String result = scanner.useDelimiter(EVERYTHING_PATTERN).next();\n        \n        scanner.useDelimiter(WHITESPACE_PATTERN); \n        return result;\n    }", "comment": "/**\n     * Reads and returns the remainder of the input, as a string.\n     *\n     * @return the remainder of the input, as a string\n     * @throws NoSuchElementException if standard input is empty\n     */"}}
{"code": {"body": "    public static String readString() {\n        try {\n            return scanner.next();\n        }\n        catch (NoSuchElementException e) {\n            throw new NoSuchElementException(\"\"\n                                           + \"\");\n        }\n    }", "comment": "/**\n     * Reads the next token  and returns the {@code String}.\n     *\n     * @return the next {@code String}\n     * @throws NoSuchElementException if standard input is empty\n     */"}}
{"code": {"body": "    public static int readInt() {\n        try {\n            return scanner.nextInt();\n        }\n        catch (InputMismatchException e) {\n            String token = scanner.next();\n            throw new InputMismatchException(\"\"\n                                           + \"\" + token + \"\");\n        }\n        catch (NoSuchElementException e) {\n            throw new NoSuchElementException(\"\"\n                                           + \"\");\n        }\n\n    }", "comment": "/**\n     * Reads the next token from standard input, parses it as an integer, and returns the integer.\n     *\n     * @return the next integer on standard input\n     * @throws NoSuchElementException if standard input is empty\n     * @throws InputMismatchException if the next token cannot be parsed as an {@code int}\n     */"}}
{"code": {"body": "    public static double readDouble() {\n        try {\n            return scanner.nextDouble();\n        }\n        catch (InputMismatchException e) {\n            String token = scanner.next();\n            throw new InputMismatchException(\"\"\n                                           + \"\" + token + \"\");\n        }\n        catch (NoSuchElementException e) {\n            throw new NoSuchElementException(\"\"\n                                           + \"\");\n        }\n    }", "comment": "/**\n     * Reads the next token from standard input, parses it as a double, and returns the double.\n     *\n     * @return the next double on standard input\n     * @throws NoSuchElementException if standard input is empty\n     * @throws InputMismatchException if the next token cannot be parsed as a {@code double}\n     */"}}
{"code": {"body": "    public static float readFloat() {\n        try {\n            return scanner.nextFloat();\n        }\n        catch (InputMismatchException e) {\n            String token = scanner.next();\n            throw new InputMismatchException(\"\"\n                                           + \"\" + token + \"\");\n        }\n        catch (NoSuchElementException e) {\n            throw new NoSuchElementException(\"\"\n                                           + \"\");\n        }\n    }", "comment": "/**\n     * Reads the next token from standard input, parses it as a float, and returns the float.\n     *\n     * @return the next float on standard input\n     * @throws NoSuchElementException if standard input is empty\n     * @throws InputMismatchException if the next token cannot be parsed as a {@code float}\n     */"}}
{"code": {"body": "    public static long readLong() {\n        try {\n            return scanner.nextLong();\n        }\n        catch (InputMismatchException e) {\n            String token = scanner.next();\n            throw new InputMismatchException(\"\"\n                                           + \"\" + token + \"\");\n        }\n        catch (NoSuchElementException e) {\n            throw new NoSuchElementException(\"\"\n                                           + \"\");\n        }\n    }", "comment": "/**\n     * Reads the next token from standard input, parses it as a long integer, and returns the long integer.\n     *\n     * @return the next long integer on standard input\n     * @throws NoSuchElementException if standard input is empty\n     * @throws InputMismatchException if the next token cannot be parsed as a {@code long}\n     */"}}
{"code": {"body": "    public static short readShort() {\n        try {\n            return scanner.nextShort();\n        }\n        catch (InputMismatchException e) {\n            String token = scanner.next();\n            throw new InputMismatchException(\"\"\n                                           + \"\" + token + \"\");\n        }\n        catch (NoSuchElementException e) {\n            throw new NoSuchElementException(\"\"\n                                           + \"\");\n        }\n    }", "comment": "/**\n     * Reads the next token from standard input, parses it as a short integer, and returns the short integer.\n     *\n     * @return the next short integer on standard input\n     * @throws NoSuchElementException if standard input is empty\n     * @throws InputMismatchException if the next token cannot be parsed as a {@code short}\n     */"}}
{"code": {"body": "    public static byte readByte() {\n        try {\n            return scanner.nextByte();\n        }\n        catch (InputMismatchException e) {\n            String token = scanner.next();\n            throw new InputMismatchException(\"\"\n                                           + \"\" + token + \"\");\n        }\n        catch (NoSuchElementException e) {\n            throw new NoSuchElementException(\"\"\n                                           + \"\");\n        }\n    }", "comment": "/**\n     * Reads the next token from standard input, parses it as a byte, and returns the byte.\n     *\n     * @return the next byte on standard input\n     * @throws NoSuchElementException if standard input is empty\n     * @throws InputMismatchException if the next token cannot be parsed as a {@code byte}\n     */"}}
{"code": {"body": "    public static boolean readBoolean() {\n        try {\n            String token = readString();\n            if (\"\".equalsIgnoreCase(token))  return true;\n            if (\"\".equalsIgnoreCase(token)) return false;\n            if (\"\".equals(token))               return true;\n            if (\"\".equals(token))               return false;\n            throw new InputMismatchException(\"\"\n                                           + \"\" + token + \"\");\n        }\n        catch (NoSuchElementException e) {\n            throw new NoSuchElementException(\"\"\n                                           + \"\");\n        }\n\n    }", "comment": "/**\n     * Reads the next token from standard input, parses it as a boolean,\n     * and returns the boolean.\n     *\n     * @return the next boolean on standard input\n     * @throws NoSuchElementException if standard input is empty\n     * @throws InputMismatchException if the next token cannot be parsed as a {@code boolean}:\n     *    {@code true} or {@code 1} for true, and {@code false} or {@code 0} for false,\n     *    ignoring case\n     */"}}
{"code": {"body": "    public static String[] readAllStrings() {\n        \n        \n        String[] tokens = WHITESPACE_PATTERN.split(readAll());\n        if (tokens.length == 0 || tokens[0].length() > 0)\n            return tokens;\n\n        \n        String[] decapitokens = new String[tokens.length-1];\n        for (int i = 0; i < tokens.length - 1; i++)\n            decapitokens[i] = tokens[i+1];\n        return decapitokens;\n    }", "comment": "/**\n     * Reads all remaining tokens from standard input and returns them as an array of strings.\n     *\n     * @return all remaining tokens on standard input, as an array of strings\n     */"}}
{"code": {"body": "    public static String[] readAllLines() {\n        ArrayList<String> lines = new ArrayList<String>();\n        while (hasNextLine()) {\n            lines.add(readLine());\n        }\n        return lines.toArray(new String[lines.size()]);\n    }", "comment": "/**\n     * Reads all remaining lines from standard input and returns them as an array of strings.\n     * @return all remaining lines on standard input, as an array of strings\n     */"}}
{"code": {"body": "    public static int[] readAllInts() {\n        String[] fields = readAllStrings();\n        int[] vals = new int[fields.length];\n        for (int i = 0; i < fields.length; i++)\n            vals[i] = Integer.parseInt(fields[i]);\n        return vals;\n    }", "comment": "/**\n     * Reads all remaining tokens from standard input, parses them as integers, and returns\n     * them as an array of integers.\n     * @return all remaining integers on standard input, as an array\n     * @throws InputMismatchException if any token cannot be parsed as an {@code int}\n     */"}}
{"code": {"body": "    public static long[] readAllLongs() {\n        String[] fields = readAllStrings();\n        long[] vals = new long[fields.length];\n        for (int i = 0; i < fields.length; i++)\n            vals[i] = Long.parseLong(fields[i]);\n        return vals;\n    }", "comment": "/**\n     * Reads all remaining tokens from standard input, parses them as longs, and returns\n     * them as an array of longs.\n     * @return all remaining longs on standard input, as an array\n     * @throws InputMismatchException if any token cannot be parsed as a {@code long}\n     */"}}
{"code": {"body": "    public static double[] readAllDoubles() {\n        String[] fields = readAllStrings();\n        double[] vals = new double[fields.length];\n        for (int i = 0; i < fields.length; i++)\n            vals[i] = Double.parseDouble(fields[i]);\n        return vals;\n    }", "comment": "/**\n     * Reads all remaining tokens from standard input, parses them as doubles, and returns\n     * them as an array of doubles.\n     * @return all remaining doubles on standard input, as an array\n     * @throws InputMismatchException if any token cannot be parsed as a {@code double}\n     */"}}
{"code": {"body": "    private static void resync() {\n        setScanner(new Scanner(new java.io.BufferedInputStream(System.in), CHARSET_NAME));\n    }", "comment": "/**\n     * If StdIn changes, use this to reinitialize the scanner.\n     */"}}
{"code": {"body": "    public static void main(String[] args) {\n\n        StdOut.print(\"\");\n        String s = StdIn.readString();\n        StdOut.println(\"\" + s);\n        StdOut.println();\n\n        StdOut.print(\"\");\n        int a = StdIn.readInt();\n        StdOut.println(\"\" + a);\n        StdOut.println();\n\n        StdOut.print(\"\");\n        boolean b = StdIn.readBoolean();\n        StdOut.println(\"\" + b);\n        StdOut.println();\n\n        StdOut.print(\"\");\n        double c = StdIn.readDouble();\n        StdOut.println(\"\" + c);\n        StdOut.println();\n    }", "comment": "/**\n     * Interactive test of basic functionality.\n     *\n     * @param args the command-line arguments\n     */"}}
{"code": {"body": "    public static void println(byte x) {\n        out.println(x);\n    }", "comment": "/**\n     * Prints a byte to standard output and then terminates the line.\n     * <p>\n     * To write binary data, see {@link BinaryStdOut}.\n     *\n     * @param x the byte to print\n     */"}}
{"code": {"body": "    public static void print(byte x) {\n        out.print(x);\n        out.flush();\n    }", "comment": "/**\n     * Prints a byte to standard output and flushes standard output.\n     *\n     * @param x the byte to print\n     */"}}
{"code": {"body": "    public static void printf(Locale locale, String format, Object... args) {\n        out.printf(locale, format, args);\n        out.flush();\n    }", "comment": "/**\n     * Prints a formatted string to standard output, using the locale and\n     * the specified format string and arguments; then flushes standard output.\n     *\n     * @param locale the locale\n     * @param format the <a href = \"http://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html#syntax\">format string</a>\n     * @param args   the arguments accompanying the format string\n     */"}}
{"code": {"body": "    public int size() {\n        return n;\n    }", "comment": "/**\n     * Returns the number of key-value pairs in this symbol table.\n     * @return the number of key-value pairs in this symbol table\n     */"}}
{"code": {"body": "    public boolean contains(String key) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        return get(key) != null;\n    }", "comment": "/**\n     * Does this symbol table contain the given key?\n     * @param key the key\n     * @return {@code true} if this symbol table contains {@code key} and\n     *     {@code false} otherwise\n     * @throws IllegalArgumentException if {@code key} is {@code null}\n     */"}}
{"code": {"body": "    public String longestPrefixOf(String query) {\n        if (query == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        if (query.length() == 0) return null;\n        int length = 0;\n        Node<Value> x = root;\n        int i = 0;\n        while (x != null && i < query.length()) {\n            char c = query.charAt(i);\n            if      (c < x.c) x = x.left;\n            else if (c > x.c) x = x.right;\n            else {\n                i++;\n                if (x.val != null) length = i;\n                x = x.mid;\n            }\n        }\n        return query.substring(0, length);\n    }", "comment": "/**\n     * Returns the string in the symbol table that is the longest prefix of {@code query},\n     * or {@code null}, if no such string.\n     * @param query the query string\n     * @return the string in the symbol table that is the longest prefix of {@code query},\n     *     or {@code null} if no such string\n     * @throws IllegalArgumentException if {@code query} is {@code null}\n     */"}}
{"code": {"body": "    public Iterable<String> keys() {\n        Queue<String> queue = new Queue<String>();\n        collect(root, new StringBuilder(), queue);\n        return queue;\n    }", "comment": "/**\n     * Returns all keys in the symbol table as an {@code Iterable}.\n     * To iterate over all of the keys in the symbol table named {@code st},\n     * use the foreach notation: {@code for (Key key : st.keys())}.\n     * @return all keys in the symbol table as an {@code Iterable}\n     */"}}
{"code": {"body": "    public Iterable<String> keysWithPrefix(String prefix) {\n        if (prefix == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n        Queue<String> queue = new Queue<String>();\n        Node<Value> x = get(root, prefix, 0);\n        if (x == null) return queue;\n        if (x.val != null) queue.enqueue(prefix);\n        collect(x.mid, new StringBuilder(prefix), queue);\n        return queue;\n    }", "comment": "/**\n     * Returns all of the keys in the set that start with {@code prefix}.\n     * @param prefix the prefix\n     * @return all of the keys in the set that start with {@code prefix},\n     *     as an iterable\n     * @throws IllegalArgumentException if {@code prefix} is {@code null}\n     */"}}
{"code": {"body": "    public Iterable<String> keysThatMatch(String pattern) {\n        Queue<String> queue = new Queue<String>();\n        collect(root, new StringBuilder(), 0, pattern, queue);\n        return queue;\n    }", "comment": "/**\n     * Returns all of the keys in the symbol table that match {@code pattern},\n     * where . symbol is treated as a wildcard character.\n     * @param pattern the pattern\n     * @return all of the keys in the symbol table that match {@code pattern},\n     *     as an iterable, where . is treated as a wildcard character.\n     */"}}
{"code": {"body": "    public static void main(String[] args) {\n\n        \n        TST<Integer> st = new TST<Integer>();\n        for (int i = 0; !StdIn.isEmpty(); i++) {\n            String key = StdIn.readString();\n            st.put(key, i);\n        }\n\n        \n        if (st.size() < 100) {\n            StdOut.println(\"\");\n            for (String key : st.keys()) {\n                StdOut.println(key + \"\" + st.get(key));\n            }\n            StdOut.println();\n        }\n\n        StdOut.println(\"\");\n        StdOut.println(st.longestPrefixOf(\"\"));\n        StdOut.println();\n\n        StdOut.println(\"\");\n        StdOut.println(st.longestPrefixOf(\"\"));\n        StdOut.println();\n\n        StdOut.println(\"\");\n        for (String s : st.keysWithPrefix(\"\"))\n            StdOut.println(s);\n        StdOut.println();\n\n        StdOut.println(\"\");\n        for (String s : st.keysThatMatch(\"\"))\n            StdOut.println(s);\n    }", "comment": "/**\n     * Unit tests the {@code TST} data type.\n     *\n     * @param args the command-line arguments\n     */"}}
{"code": {"body": "    public static void main(String[] args) { \n        LinearProbingHashST<String, Integer> st = new LinearProbingHashST<String, Integer>();\n        for (int i = 0; !StdIn.isEmpty(); i++) {\n            String key = StdIn.readString();\n            st.put(key, i);\n        }\n\n        \n        for (String s : st.keys()) \n            StdOut.println(s + \"\" + st.get(s)); \n    }", "comment": "/***********************************************************************\n    *  Unit test client.\n    ***********************************************************************/"}}
{"code": {"body": "public Queue() {\n        first = null;\n        last  = null;\n        n = 0;\n    }", "comment": "/**\n     * Initializes an empty queue.\n     */"}}
{"code": {"body": "    public boolean isEmpty() {\n        return first == null;\n    }", "comment": "/**\n     * Returns true if this queue is empty.\n     *\n     * @return {@code true} if this queue is empty; {@code false} otherwise\n     */"}}
{"code": {"body": "    public int size() {\n        return n;\n    }", "comment": "/**\n     * Returns the number of items in this queue.\n     *\n     * @return the number of items in this queue\n     */"}}
{"code": {"body": "    public Item peek() {\n        if (isEmpty()) throw new NoSuchElementException(\"\");\n        return first.item;\n    }", "comment": "/**\n     * Returns the item least recently added to this queue.\n     *\n     * @return the item least recently added to this queue\n     * @throws NoSuchElementException if this queue is empty\n     */"}}
{"code": {"body": "    public void enqueue(Item item) {\n        Node<Item> oldlast = last;\n        last = new Node<Item>();\n        last.item = item;\n        last.next = null;\n        if (isEmpty()) first = last;\n        else           oldlast.next = last;\n        n++;\n    }", "comment": "/**\n     * Adds the item to this queue.\n     *\n     * @param  item the item to add\n     */"}}
{"code": {"body": "    public Item dequeue() {\n        if (isEmpty()) throw new NoSuchElementException(\"\");\n        Item item = first.item;\n        first = first.next;\n        n--;\n        if (isEmpty()) last = null;   \n        return item;\n    }", "comment": "/**\n     * Removes and returns the item on this queue that was least recently added.\n     *\n     * @return the item on this queue that was least recently added\n     * @throws NoSuchElementException if this queue is empty\n     */"}}
{"code": {"body": "    public String toString() {\n        StringBuilder s = new StringBuilder();\n        for (Item item : this) {\n            s.append(item);\n            s.append('');\n        }\n        return s.toString();\n    }", "comment": "/**\n     * Returns a string representation of this queue.\n     *\n     * @return the sequence of items in FIFO order, separated by spaces\n     */"}}
{"code": {"body": "    public Iterator<Item> iterator()  {\n        return new ListIterator<Item>(first);  \n    }", "comment": "/**\n     * Returns an iterator that iterates over the items in this queue in FIFO order.\n     *\n     * @return an iterator that iterates over the items in this queue in FIFO order\n     */"}}
{"code": {"body": "    public static void main(String[] args) {\n        Queue<String> queue = new Queue<String>();\n        while (!StdIn.isEmpty()) {\n            String item = StdIn.readString();\n            if (!item.equals(\"\"))\n                queue.enqueue(item);\n            else if (!queue.isEmpty())\n                StdOut.print(queue.dequeue() + \"\");\n        }\n        StdOut.println(\"\" + queue.size() + \"\");\n    }", "comment": "/**\n     * Unit tests the {@code Queue} data type.\n     *\n     * @param args the command-line arguments\n     */"}}
{"code": {"body": "    public static boolean isEmpty() {\n        return !scanner.hasNext();\n    }", "comment": "/**\n     * Returns true if standard input is empty (except possibly for whitespace).\n     * Use this method to know whether the next call to {@link #readString()}, \n     * {@link #readDouble()}, etc will succeed.\n     *\n     * @return {@code true} if standard input is empty (except possibly\n     *         for whitespace); {@code false} otherwise\n     */"}}
{"code": {"body": "    public static boolean hasNextLine() {\n        return scanner.hasNextLine();\n    }", "comment": "/**\n     * Returns true if standard input has a next line.\n     * Use this method to know whether the\n     * next call to {@link #readLine()} will succeed.\n     * This method is functionally equivalent to {@link #hasNextChar()}.\n     *\n     * @return {@code true} if standard input has more input (including whitespace);\n     *         {@code false} otherwise\n     */"}}
{"code": {"body": "    public static boolean hasNextChar() {\n        scanner.useDelimiter(EMPTY_PATTERN);\n        boolean result = scanner.hasNext();\n        scanner.useDelimiter(WHITESPACE_PATTERN);\n        return result;\n    }", "comment": "/**\n     * Returns true if standard input has more input (including whitespace).\n     * Use this method to know whether the next call to {@link #readChar()} will succeed.\n     * This method is functionally equivalent to {@link #hasNextLine()}.\n     *\n     * @return {@code true} if standard input has more input (including whitespace);\n     *         {@code false} otherwise\n     */"}}
{"code": {"body": "    public static String readLine() {\n        String line;\n        try {\n            line = scanner.nextLine();\n        }\n        catch (NoSuchElementException e) {\n            line = null;\n        }\n        return line;\n    }", "comment": "/**\n     * Reads and returns the next line, excluding the line separator if present.\n     *\n     * @return the next line, excluding the line separator if present;\n     *         {@code null} if no such line\n     */"}}
{"code": {"body": "    public static char readChar() {\n        try {\n            scanner.useDelimiter(EMPTY_PATTERN);\n            String ch = scanner.next();\n            assert ch.length() == 1 : \"\"\n                + \"\";\n            scanner.useDelimiter(WHITESPACE_PATTERN);\n            return ch.charAt(0);\n        }\n        catch (NoSuchElementException e) {\n            throw new NoSuchElementException(\"\"\n                                           + \"\");\n        }\n    }", "comment": "/**\n     * Reads and returns the next character.\n     *\n     * @return the next {@code char}\n     * @throws NoSuchElementException if standard input is empty\n     */"}}
{"code": {"body": "    public static String readAll() {\n        if (!scanner.hasNextLine())\n            return \"\";\n\n        String result = scanner.useDelimiter(EVERYTHING_PATTERN).next();\n        \n        scanner.useDelimiter(WHITESPACE_PATTERN); \n        return result;\n    }", "comment": "/**\n     * Reads and returns the remainder of the input, as a string.\n     *\n     * @return the remainder of the input, as a string\n     * @throws NoSuchElementException if standard input is empty\n     */"}}
{"code": {"body": "    public static String readString() {\n        try {\n            return scanner.next();\n        }\n        catch (NoSuchElementException e) {\n            throw new NoSuchElementException(\"\"\n                                           + \"\");\n        }\n    }", "comment": "/**\n     * Reads the next token  and returns the {@code String}.\n     *\n     * @return the next {@code String}\n     * @throws NoSuchElementException if standard input is empty\n     */"}}
{"code": {"body": "    public static int readInt() {\n        try {\n            return scanner.nextInt();\n        }\n        catch (InputMismatchException e) {\n            String token = scanner.next();\n            throw new InputMismatchException(\"\"\n                                           + \"\" + token + \"\");\n        }\n        catch (NoSuchElementException e) {\n            throw new NoSuchElementException(\"\"\n                                           + \"\");\n        }\n\n    }", "comment": "/**\n     * Reads the next token from standard input, parses it as an integer, and returns the integer.\n     *\n     * @return the next integer on standard input\n     * @throws NoSuchElementException if standard input is empty\n     * @throws InputMismatchException if the next token cannot be parsed as an {@code int}\n     */"}}
{"code": {"body": "    public static double readDouble() {\n        try {\n            return scanner.nextDouble();\n        }\n        catch (InputMismatchException e) {\n            String token = scanner.next();\n            throw new InputMismatchException(\"\"\n                                           + \"\" + token + \"\");\n        }\n        catch (NoSuchElementException e) {\n            throw new NoSuchElementException(\"\"\n                                           + \"\");\n        }\n    }", "comment": "/**\n     * Reads the next token from standard input, parses it as a double, and returns the double.\n     *\n     * @return the next double on standard input\n     * @throws NoSuchElementException if standard input is empty\n     * @throws InputMismatchException if the next token cannot be parsed as a {@code double}\n     */"}}
{"code": {"body": "    public static float readFloat() {\n        try {\n            return scanner.nextFloat();\n        }\n        catch (InputMismatchException e) {\n            String token = scanner.next();\n            throw new InputMismatchException(\"\"\n                                           + \"\" + token + \"\");\n        }\n        catch (NoSuchElementException e) {\n            throw new NoSuchElementException(\"\"\n                                           + \"\");\n        }\n    }", "comment": "/**\n     * Reads the next token from standard input, parses it as a float, and returns the float.\n     *\n     * @return the next float on standard input\n     * @throws NoSuchElementException if standard input is empty\n     * @throws InputMismatchException if the next token cannot be parsed as a {@code float}\n     */"}}
{"code": {"body": "    public static long readLong() {\n        try {\n            return scanner.nextLong();\n        }\n        catch (InputMismatchException e) {\n            String token = scanner.next();\n            throw new InputMismatchException(\"\"\n                                           + \"\" + token + \"\");\n        }\n        catch (NoSuchElementException e) {\n            throw new NoSuchElementException(\"\"\n                                           + \"\");\n        }\n    }", "comment": "/**\n     * Reads the next token from standard input, parses it as a long integer, and returns the long integer.\n     *\n     * @return the next long integer on standard input\n     * @throws NoSuchElementException if standard input is empty\n     * @throws InputMismatchException if the next token cannot be parsed as a {@code long}\n     */"}}
{"code": {"body": "    public static short readShort() {\n        try {\n            return scanner.nextShort();\n        }\n        catch (InputMismatchException e) {\n            String token = scanner.next();\n            throw new InputMismatchException(\"\"\n                                           + \"\" + token + \"\");\n        }\n        catch (NoSuchElementException e) {\n            throw new NoSuchElementException(\"\"\n                                           + \"\");\n        }\n    }", "comment": "/**\n     * Reads the next token from standard input, parses it as a short integer, and returns the short integer.\n     *\n     * @return the next short integer on standard input\n     * @throws NoSuchElementException if standard input is empty\n     * @throws InputMismatchException if the next token cannot be parsed as a {@code short}\n     */"}}
{"code": {"body": "    public static byte readByte() {\n        try {\n            return scanner.nextByte();\n        }\n        catch (InputMismatchException e) {\n            String token = scanner.next();\n            throw new InputMismatchException(\"\"\n                                           + \"\" + token + \"\");\n        }\n        catch (NoSuchElementException e) {\n            throw new NoSuchElementException(\"\"\n                                           + \"\");\n        }\n    }", "comment": "/**\n     * Reads the next token from standard input, parses it as a byte, and returns the byte.\n     *\n     * @return the next byte on standard input\n     * @throws NoSuchElementException if standard input is empty\n     * @throws InputMismatchException if the next token cannot be parsed as a {@code byte}\n     */"}}
{"code": {"body": "    public static boolean readBoolean() {\n        try {\n            String token = readString();\n            if (\"\".equalsIgnoreCase(token))  return true;\n            if (\"\".equalsIgnoreCase(token)) return false;\n            if (\"\".equals(token))               return true;\n            if (\"\".equals(token))               return false;\n            throw new InputMismatchException(\"\"\n                                           + \"\" + token + \"\");\n        }\n        catch (NoSuchElementException e) {\n            throw new NoSuchElementException(\"\"\n                                           + \"\");\n        }\n\n    }", "comment": "/**\n     * Reads the next token from standard input, parses it as a boolean,\n     * and returns the boolean.\n     *\n     * @return the next boolean on standard input\n     * @throws NoSuchElementException if standard input is empty\n     * @throws InputMismatchException if the next token cannot be parsed as a {@code boolean}:\n     *    {@code true} or {@code 1} for true, and {@code false} or {@code 0} for false,\n     *    ignoring case\n     */"}}
{"code": {"body": "    public static String[] readAllStrings() {\n        \n        \n        String[] tokens = WHITESPACE_PATTERN.split(readAll());\n        if (tokens.length == 0 || tokens[0].length() > 0)\n            return tokens;\n\n        \n        String[] decapitokens = new String[tokens.length-1];\n        for (int i = 0; i < tokens.length - 1; i++)\n            decapitokens[i] = tokens[i+1];\n        return decapitokens;\n    }", "comment": "/**\n     * Reads all remaining tokens from standard input and returns them as an array of strings.\n     *\n     * @return all remaining tokens on standard input, as an array of strings\n     */"}}
{"code": {"body": "    public static String[] readAllLines() {\n        ArrayList<String> lines = new ArrayList<String>();\n        while (hasNextLine()) {\n            lines.add(readLine());\n        }\n        return lines.toArray(new String[lines.size()]);\n    }", "comment": "/**\n     * Reads all remaining lines from standard input and returns them as an array of strings.\n     * @return all remaining lines on standard input, as an array of strings\n     */"}}
{"code": {"body": "    public static int[] readAllInts() {\n        String[] fields = readAllStrings();\n        int[] vals = new int[fields.length];\n        for (int i = 0; i < fields.length; i++)\n            vals[i] = Integer.parseInt(fields[i]);\n        return vals;\n    }", "comment": "/**\n     * Reads all remaining tokens from standard input, parses them as integers, and returns\n     * them as an array of integers.\n     * @return all remaining integers on standard input, as an array\n     * @throws InputMismatchException if any token cannot be parsed as an {@code int}\n     */"}}
{"code": {"body": "    public static long[] readAllLongs() {\n        String[] fields = readAllStrings();\n        long[] vals = new long[fields.length];\n        for (int i = 0; i < fields.length; i++)\n            vals[i] = Long.parseLong(fields[i]);\n        return vals;\n    }", "comment": "/**\n     * Reads all remaining tokens from standard input, parses them as longs, and returns\n     * them as an array of longs.\n     * @return all remaining longs on standard input, as an array\n     * @throws InputMismatchException if any token cannot be parsed as a {@code long}\n     */"}}
{"code": {"body": "    public static double[] readAllDoubles() {\n        String[] fields = readAllStrings();\n        double[] vals = new double[fields.length];\n        for (int i = 0; i < fields.length; i++)\n            vals[i] = Double.parseDouble(fields[i]);\n        return vals;\n    }", "comment": "/**\n     * Reads all remaining tokens from standard input, parses them as doubles, and returns\n     * them as an array of doubles.\n     * @return all remaining doubles on standard input, as an array\n     * @throws InputMismatchException if any token cannot be parsed as a {@code double}\n     */"}}
{"code": {"body": "    private static void resync() {\n        setScanner(new Scanner(new java.io.BufferedInputStream(System.in), CHARSET_NAME));\n    }", "comment": "/**\n     * If StdIn changes, use this to reinitialize the scanner.\n     */"}}
{"code": {"body": "    public static void main(String[] args) {\n\n        StdOut.print(\"\");\n        String s = StdIn.readString();\n        StdOut.println(\"\" + s);\n        StdOut.println();\n\n        StdOut.print(\"\");\n        int a = StdIn.readInt();\n        StdOut.println(\"\" + a);\n        StdOut.println();\n\n        StdOut.print(\"\");\n        boolean b = StdIn.readBoolean();\n        StdOut.println(\"\" + b);\n        StdOut.println();\n\n        StdOut.print(\"\");\n        double c = StdIn.readDouble();\n        StdOut.println(\"\" + c);\n        StdOut.println();\n    }", "comment": "/**\n     * Interactive test of basic functionality.\n     *\n     * @param args the command-line arguments\n     */"}}
{"code": {"body": "    public static void println(byte x) {\n        out.println(x);\n    }", "comment": "/**\n     * Prints a byte to standard output and then terminates the line.\n     * <p>\n     * To write binary data, see {@link BinaryStdOut}.\n     *\n     * @param x the byte to print\n     */"}}
{"code": {"body": "    public static void print(byte x) {\n        out.print(x);\n        out.flush();\n    }", "comment": "/**\n     * Prints a byte to standard output and flushes standard output.\n     *\n     * @param x the byte to print\n     */"}}
{"code": {"body": "    public static void printf(Locale locale, String format, Object... args) {\n        out.printf(locale, format, args);\n        out.flush();\n    }", "comment": "/**\n     * Prints a formatted string to standard output, using the locale and\n     * the specified format string and arguments; then flushes standard output.\n     *\n     * @param locale the locale\n     * @param format the <a href = \"http://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html#syntax\">format string</a>\n     * @param args   the arguments accompanying the format string\n     */"}}
{"code": {"body": "public IndexMinPQ(int maxN) {\n        if (maxN < 0) throw new IllegalArgumentException();\n        this.maxN = maxN;\n        n = 0;\n        keys = (Key[]) new Comparable[maxN + 1];    \n        pq   = new int[maxN + 1];\n        qp   = new int[maxN + 1];                   \n        for (int i = 0; i <= maxN; i++)\n            qp[i] = -1;\n    }", "comment": "/**\n     * Initializes an empty indexed priority queue with indices between {@code 0}\n     * and {@code maxN - 1}.\n     * @param  maxN the keys on this priority queue are index from {@code 0}\n     *         {@code maxN - 1}\n     * @throws IllegalArgumentException if {@code maxN < 0}\n     */"}}
{"code": {"body": "    public boolean isEmpty() {\n        return n == 0;\n    }", "comment": "/**\n     * Returns true if this priority queue is empty.\n     *\n     * @return {@code true} if this priority queue is empty;\n     *         {@code false} otherwise\n     */"}}
{"code": {"body": "    public boolean contains(int i) {\n        if (i < 0 || i >= maxN) throw new IllegalArgumentException();\n        return qp[i] != -1;\n    }", "comment": "/**\n     * Is {@code i} an index on this priority queue?\n     *\n     * @param  i an index\n     * @return {@code true} if {@code i} is an index on this priority queue;\n     *         {@code false} otherwise\n     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n     */"}}
{"code": {"body": "    public int size() {\n        return n;\n    }", "comment": "/**\n     * Returns the number of keys on this priority queue.\n     *\n     * @return the number of keys on this priority queue\n     */"}}
{"code": {"body": "    public void insert(int i, Key key) {\n        if (i < 0 || i >= maxN) throw new IllegalArgumentException();\n        if (contains(i)) throw new IllegalArgumentException(\"\");\n        n++;\n        qp[i] = n;\n        pq[n] = i;\n        keys[i] = key;\n        swim(n);\n    }", "comment": "/**\n     * Associates key with index {@code i}.\n     *\n     * @param  i an index\n     * @param  key the key to associate with index {@code i}\n     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n     * @throws IllegalArgumentException if there already is an item associated\n     *         with index {@code i}\n     */"}}
{"code": {"body": "    public int minIndex() {\n        if (n == 0) throw new NoSuchElementException(\"\");\n        return pq[1];\n    }", "comment": "/**\n     * Returns an index associated with a minimum key.\n     *\n     * @return an index associated with a minimum key\n     * @throws NoSuchElementException if this priority queue is empty\n     */"}}
{"code": {"body": "    public Key minKey() {\n        if (n == 0) throw new NoSuchElementException(\"\");\n        return keys[pq[1]];\n    }", "comment": "/**\n     * Returns a minimum key.\n     *\n     * @return a minimum key\n     * @throws NoSuchElementException if this priority queue is empty\n     */"}}
{"code": {"body": "    public int delMin() {\n        if (n == 0) throw new NoSuchElementException(\"\");\n        int min = pq[1];\n        exch(1, n--);\n        sink(1);\n        assert min == pq[n+1];\n        qp[min] = -1;        \n        keys[min] = null;    \n        pq[n+1] = -1;        \n        return min;\n    }", "comment": "/**\n     * Removes a minimum key and returns its associated index.\n     * @return an index associated with a minimum key\n     * @throws NoSuchElementException if this priority queue is empty\n     */"}}
{"code": {"body": "    public Key keyOf(int i) {\n        if (i < 0 || i >= maxN) throw new IllegalArgumentException();\n        if (!contains(i)) throw new NoSuchElementException(\"\");\n        else return keys[i];\n    }", "comment": "/**\n     * Returns the key associated with index {@code i}.\n     *\n     * @param  i the index of the key to return\n     * @return the key associated with index {@code i}\n     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n     * @throws NoSuchElementException no key is associated with index {@code i}\n     */"}}
{"code": {"body": "    public void changeKey(int i, Key key) {\n        if (i < 0 || i >= maxN) throw new IllegalArgumentException();\n        if (!contains(i)) throw new NoSuchElementException(\"\");\n        keys[i] = key;\n        swim(qp[i]);\n        sink(qp[i]);\n    }", "comment": "/**\n     * Change the key associated with index {@code i} to the specified value.\n     *\n     * @param  i the index of the key to change\n     * @param  key change the key associated with index {@code i} to this key\n     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n     * @throws NoSuchElementException no key is associated with index {@code i}\n     */"}}
{"code": {"body": "    public void decreaseKey(int i, Key key) {\n        if (i < 0 || i >= maxN) throw new IllegalArgumentException();\n        if (!contains(i)) throw new NoSuchElementException(\"\");\n        if (keys[i].compareTo(key) <= 0)\n            throw new IllegalArgumentException(\"\");\n        keys[i] = key;\n        swim(qp[i]);\n    }", "comment": "/**\n     * Decrease the key associated with index {@code i} to the specified value.\n     *\n     * @param  i the index of the key to decrease\n     * @param  key decrease the key associated with index {@code i} to this key\n     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n     * @throws IllegalArgumentException if {@code key >= keyOf(i)}\n     * @throws NoSuchElementException no key is associated with index {@code i}\n     */"}}
{"code": {"body": "    public void increaseKey(int i, Key key) {\n        if (i < 0 || i >= maxN) throw new IllegalArgumentException();\n        if (!contains(i)) throw new NoSuchElementException(\"\");\n        if (keys[i].compareTo(key) >= 0)\n            throw new IllegalArgumentException(\"\");\n        keys[i] = key;\n        sink(qp[i]);\n    }", "comment": "/**\n     * Increase the key associated with index {@code i} to the specified value.\n     *\n     * @param  i the index of the key to increase\n     * @param  key increase the key associated with index {@code i} to this key\n     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n     * @throws IllegalArgumentException if {@code key <= keyOf(i)}\n     * @throws NoSuchElementException no key is associated with index {@code i}\n     */"}}
{"code": {"body": "    public void delete(int i) {\n        if (i < 0 || i >= maxN) throw new IllegalArgumentException();\n        if (!contains(i)) throw new NoSuchElementException(\"\");\n        int index = qp[i];\n        exch(index, n--);\n        swim(index);\n        sink(index);\n        keys[i] = null;\n        qp[i] = -1;\n    }", "comment": "/**\n     * Remove the key associated with index {@code i}.\n     *\n     * @param  i the index of the key to remove\n     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}\n     * @throws NoSuchElementException no key is associated with index {@code i}\n     */"}}
{"code": {"body": "    private boolean greater(int i, int j) {\n        return keys[pq[i]].compareTo(keys[pq[j]]) > 0;\n    }", "comment": "/***************************************************************************\n    * General helper functions.\n    ***************************************************************************/"}}
{"code": {"body": "    private void swim(int k) {\n        while (k > 1 && greater(k/2, k)) {\n            exch(k, k/2);\n            k = k/2;\n        }\n    }", "comment": "/***************************************************************************\n    * Heap helper functions.\n    ***************************************************************************/"}}
{"code": {"body": "    public Iterator<Integer> iterator() { return new HeapIterator(); }", "comment": "/**\n     * Returns an iterator that iterates over the keys on the\n     * priority queue in ascending order.\n     * The iterator doesn't implement {@code remove()} since it's optional.\n     *\n     * @return an iterator that iterates over the keys in ascending order\n     */"}}
{"code": {"body": "    public static void main(String[] args) {\n        \n        String[] strings = { \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\" };\n\n        IndexMinPQ<String> pq = new IndexMinPQ<String>(strings.length);\n        for (int i = 0; i < strings.length; i++) {\n            pq.insert(i, strings[i]);\n        }\n\n        \n        while (!pq.isEmpty()) {\n            int i = pq.delMin();\n            StdOut.println(i + \"\" + strings[i]);\n        }\n        StdOut.println();\n\n        \n        for (int i = 0; i < strings.length; i++) {\n            pq.insert(i, strings[i]);\n        }\n\n        \n        for (int i : pq) {\n            StdOut.println(i + \"\" + strings[i]);\n        }\n        while (!pq.isEmpty()) {\n            pq.delMin();\n        }\n\n    }", "comment": "/**\n     * Unit tests the {@code IndexMinPQ} data type.\n     *\n     * @param args the command-line arguments\n     */"}}
{"code": {"body": "    public static void close() {\n        out.close();\n    }", "comment": "/**\n     * Closes standard output.\n     */"}}
{"code": {"body": "    public static void println(byte x) {\n        out.println(x);\n    }", "comment": "/**\n     * Prints a byte to standard output and then terminates the line.\n     * <p>\n     * To write binary data, see {@link BinaryStdOut}.\n     *\n     * @param x the byte to print\n     */"}}
{"code": {"body": "    public static void print(byte x) {\n        out.print(x);\n        out.flush();\n    }", "comment": "/**\n     * Prints a byte to standard output and flushes standard output.\n     *\n     * @param x the byte to print\n     */"}}
{"code": {"body": "    public static void printf(Locale locale, String format, Object... args) {\n        out.printf(locale, format, args);\n        out.flush();\n    }", "comment": "/**\n     * Prints a formatted string to standard output, using the locale and\n     * the specified format string and arguments; then flushes standard output.\n     *\n     * @param locale the locale\n     * @param format the <a href = \"http://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html#syntax\">format string</a>\n     * @param args   the arguments accompanying the format string\n     */"}}
{"code": {"body": "    public String generateAppUniqueKey(){\n        int noExistApps = mapAppointments.size() + 1;\n        return \"\" + Integer.toString(noExistApps);\n    }", "comment": "/**\n   * /instance method; generates a uniqueKey for each appointment created.\n   */"}}
{"code": {"body": "    public static void setPutInMap(String uKey, Appointment passedIn){\n         mapAppointments.put(uKey, passedIn);\n    }", "comment": "/**\n   * /instance method; puts the appointment object  in the map.\n   */"}}
{"code": {"body": "    public  static Appointment getAppointment(String uniqueKey){\n        return mapAppointments.get(uniqueKey);\n    }", "comment": "/**\n   * /instance method; pass this routine the unique appointment number and it will return the appointment object.\n   */"}}
{"code": {"body": "    public void testSetCurrentSystemUser(){\n        SystemUserComponent testUser = new SysUserPatient(\"\", \"\", \"\", \"\", \"\", \"\");\n        SystemUserComponent.setCurrentSystemUser(\"\");\n        assertEquals(true, testUser.getLoginCheckUserExists(\"\"));\n    }", "comment": "/*\n    @Test\n    public void testGenerateUserName() {\n        SystemUserComponent testUser = new SysUserPatient(\"Paul\", \"Treadwell\", \"Mr\", 1983, \"More data\");\n        assertEquals(\"paul.treadwell.1983\", testUser.getGenerateUsername(\"Paul\", \"Treadwell\", 1983));\n                \n        SystemUserComponent testUser2 = new Doctor(\"SAndRA\", \"BEans\", \"Mrs\", 1922, \"More data\");\n        assertEquals(\"sandra.beans.1922\", testUser2.getGenerateUsername(\"SAndRA\", \"BEans\", 1922));\n    \n        SystemUserComponent testUser3 = new Secretary(\"harold\", \"BEans\", \"Mr\", 1923, \"More data\");\n        assertEquals(\"harold.beans.1923\", testUser3.getGenerateUsername(\"harold\", \"BEans\", 1923));\n        \n        SystemUserComponent testUser4 = new Pharmacist(\"emMA\", \"BEans\", \"Mrs\", 1924, \"More data\");\n        assertEquals(\"emma.beans.1924\", testUser4.getGenerateUsername(\"emMA\", \"BEans\", 1924));\n    \n    }\n*/"}}
{"code": {"body": "\tpublic boolean requestInCache(String request) {\n\t\treturn cacheOrderList.contains(request);\n\t}", "comment": "/**\n\t * Checks if the request is cached\n\t * @param request\n\t * @return Returns true if the response to this request is cached\n\t */"}}
{"code": {"body": "\tpublic void cacheRequest(String request, String response) {\n\t\tif (cacheOrderList.size() == CACHE_SIZE) {\n\t\t\t\n\t\t\tString key = cacheOrderList.remove();\n\t\t\tcache.remove(key);\n\t\t}\n\t\t\n\t\tcacheOrderList.add(request);\n\t\tcache.put(request, response);\n\t}", "comment": "/**\n\t * Insert the request/response pair into the cache\n\t * @param request The request to cache\n\t * @param response The response to cache\n\t */"}}
{"code": {"body": "\tpublic String getResponseForRequest(String request) {\n\t\t\n\t\tcacheOrderList.remove(request);\n\t\tcacheOrderList.add(request);\n\t\t\n\t\treturn cache.get(request);\n\t}", "comment": "/**\n\t * Fetches the response for the given request from the cache.\n\t * NOTE: there is a precondition that the request IS in the cache.\n\t * \n\t * @param request A request that has a cached response\n\t * @return Returns the response for the given request\n\t */"}}
{"code": {"body": "\tpublic boolean register(String email, String name, String password) {\n\t\topenConnection();\n\t\tString requestType = \"\";\n\t\tString request = requestType + \"\" + email + \"\" + name + \"\" + password; \n\t\tString response = handleSimpleMessages(request);\t\n\t\tcloseConnection();\n\t\tSystem.out.println(\"\" +response);\n\t\tif (!response.equals(\"\")) {\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\treturn true;\n\t\t}\n\t\t\n\t}", "comment": "/**\n\t * Register a new user\n\t * @param email : user email\n\t * @param name : user name\n\t * @param password : user password\n\t * @return boolean is registered\n\t */"}}
{"code": {"body": "\tpublic boolean updateStatus(String email, String status) {\n\t\topenConnection();\n\t\tString requestType = \"\";\n\t\tString request = requestType + \"\" + email + \"\" + status;\n\t\tString response = handleSimpleMessages(request);\n\t\tcloseConnection();\n\t\t\n\t\tif (!response.equals(\"\")) {\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\treturn true;\n\t\t}\n\t}", "comment": "/**\n\t * Get update statuses\n\t * @param email : email of user\n\t * @param status : status to update\n\t * @return updating status was successful \n\t */"}}
{"code": {"body": "\tpublic boolean requestFriend(String email1, String email2) {\n\t\topenConnection();\n\t\tString requestType = \"\";\n\t\tString request = requestType + \"\" + email1 + \"\" + email2;\n\t\tString response = handleSimpleMessages(request);\n\t\tcloseConnection();\n\t\t\n\t\tif (!response.equals(\"\")) {\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\treturn true;\n\t\t}\n\t}", "comment": "/**\n\t * Request a new friend\n\t * @param email1: first users email\n\t * @param email2: second users email\n\t * @return if the two users were made friends\n\t */"}}
{"code": {"body": "\tpublic boolean addFriend(String requesterEmail, String requesteeEmail) {\n\t\topenConnection();\n\t\tString requestType = \"\";\n\t\tString request = requestType + \"\" + requesterEmail + \"\" + requesteeEmail + \"\" + \"\";\n\t\tString response = handleSimpleMessages(request);\n\t\tcloseConnection();\n\t\t\n\t\tif (!response.equals(\"\")) {\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\treturn true;\n\t\t}\n\t}", "comment": "/**\n\t * Add a new friend\n\t * @param requesterEmail: person requesting the email\n\t * @param requesteeEmail: person to friend\n\t * @return if they were friended\n\t */"}}
{"code": {"body": "\tpublic boolean removeFriend(String requesterEmail, String requesteeEmail) {\n\t\topenConnection();\n\t\tString requestType = \"\";\n\t\tString request = requestType + \"\" + requesterEmail + \"\" + requesteeEmail + \"\" + \"\";\n\t\tString response = handleSimpleMessages(request);\n\t\tcloseConnection();\n\t\t\n\t\tif (!response.equals(\"\")) {\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\treturn true;\n\t\t}\n\t}", "comment": "/**\n\t * Remove a friend\n\t * @param requesterEmail: user requesting to remove a friend\n\t * @param requesteeEmail: user to be removed\n\t * @return if they were made friends\n\t */"}}
{"code": {"body": "\tpublic boolean areFriends(String email1, String email2) {\n\t\topenConnection();\n\t\tString requestType = \"\";\n\t\tString request = requestType + \"\" + email1 + \"\" + email2;\n\t\tString response = handleSimpleMessages(request);\n\t\tcloseConnection();\n\t\t\n\t\tif (response.equals(\"\")) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}", "comment": "/**\n\t * Are two users friends\n\t * @param email1: first users email\n\t * @param email2: second users email\n\t * @return if they are friends\n\t */"}}
{"code": {"body": "\tpublic boolean login(String email, String password) {\n\t\topenConnection();\n\t\tString requestType = \"\";\n\t\tString request = requestType + \"\" + email + \"\" + password;\n\t\tString response = handleSimpleMessages(request);\n\t\tcloseConnection();\n\t\t\n\t\tif (!response.equals(\"\")) {\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\treturn true;\n\t\t}\n\t}", "comment": "/**\n\t * Log a user in\n\t * @param email: users email\n\t * @param password: users password\n\t * @return if the users can be logged in\n\t */"}}
{"code": {"body": "\tpublic boolean pendingFriendRequests(String email1, String email2) {\n\t\topenConnection();\n\t\tString requestType = \"\";\n\t\tString request = requestType + \"\" + email1 + \"\" + email2;\n\t\tString response = handleSimpleMessages(request);\n\t\tcloseConnection();\n\t\t\n\t\tif (response.equals(\"\")) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}", "comment": "/**\n\t * Get list of pending friend requests\n\t * @param email1: first user asking for requests\n\t * @param email2: request from second user\n\t * @return if there is a pending friend request\n\t */"}}
{"code": {"body": "\tpublic String getUserInfo(String email) {\n\t\topenConnection();\n\t\tString requestType = \"\";\n\t\tString request = requestType + \"\" + email;\n\t\t\n\t\tString responseLine;\n\t\tString fullName = \"\";\n\t\ttry {\n\t\t\tsendMessage(request);\n\t\t\tresponseLine = reader.readLine();\n\t\t\tif (responseLine == null) {\n\t\t\t\tfullName = null;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString[] args = parseMessage(responseLine);\n\t\t\t\tSystem.out.println(responseLine);\n\t\t\t\tif (args[0].equals(\"\")) {\n\t\t\t\t\tfullName = null;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfullName = args[2];\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t\n\t\t\tfullName = null;\n\t\t\te.printStackTrace();\n\t\t} \n\n\t\tcloseConnection();\n\t\t\n\t\treturn fullName;\n\t}", "comment": "/**\n\t * Get the users information\n\t * @param email: user to get information's email\n\t * @return full name of user\n\t */"}}
{"code": {"body": "\tpublic ArrayList<Status> getStatuses(String email) {\n\t\topenConnection();\n\t\tString requestType = \"\";\n\t\tString request = requestType + \"\" + email;\n\t\tArrayList<Status>statusList = new ArrayList<Status>();\n\t\t\n\t\ttry {\n\t\t\tString responseLine;\n\t\t\tsendMessage(request);\n\t\t\twhile ((responseLine = reader.readLine() ) != null) {\n\t\t\t\tString[] args = parseMessage(responseLine);\n\t\t\t\tString userEmail = args[0];\n\t\t\t\tString message = args[1];\n\t\t\t\tUser u = new User(userEmail, getUserInfo(userEmail), \"\");\n\t\t\t\tDate d = new SimpleDateFormat(\"\").parse(args[2]);\n\t\t\t\tStatus status = new Status(message, u, d);\n\t\t\t\tstatusList.add(status);\n\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t\n\t\t\te.printStackTrace();\n\t\t} catch (ParseException e) {\n\t\t\t\n\t\t\te.printStackTrace();\n\t\t} \n\n\t\tcloseConnection();\n\t\t\n\t\treturn statusList;\n\t}", "comment": "/**\n\t * Get the users statuses\n\t * @param email: the users email\n\t * @return the list of statuses for this user\n\t */"}}
{"code": {"body": "\tpublic ArrayList<User> getFriendRequests(String email) {\n\t\topenConnection();\n\t\tString requestType = \"\";\n\t\tString request = requestType + \"\" + email;\n\t\t\n\t\tArrayList<User>userList = new ArrayList<User>();\n\t\t\n\t\ttry {\n\t\t\tString responseLine;\n\t\t\tsendMessage(request);\n\t\t\twhile ((responseLine = reader.readLine() ) != null) {\n\t\t\t\tString[] args = parseMessage(responseLine);\n\t\t\t\tString userEmail = args[0];\n\t\t\t\tUser u = new User(userEmail, getUserInfo(userEmail), \"\");\n\t\t\t\t\n\t\t\t\tuserList.add(u);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t\n\t\t\te.printStackTrace();\n\t\t} \n\t\t\n\t\tcloseConnection();\n\t\t\n\t\treturn userList;\n\t}", "comment": "/**\n\t * Get all the friend requests for this user\n\t * @param email: email of user to get friend requests\n\t * @return list of friend requests\n\t */"}}
{"code": {"body": "\tpublic ArrayList<User> getFriends(String email) {\n\t\topenConnection();\n\t\tString requestType = \"\";\n\t\tString request = requestType + \"\" + email;\n\t\t\n\t\tArrayList<User>userList = new ArrayList<User>();\n\t\t\n\t\ttry {\n\t\t\tString responseLine;\n\t\t\tsendMessage(request);\n\t\t\twhile ((responseLine = reader.readLine() ) != null) {\n\t\t\t\tString[] args = parseMessage(responseLine);\n\t\t\t\tString userEmail = args[0];\n\t\t\t\tUser u = new User(userEmail, getUserInfo(userEmail), \"\");\n\t\t\t\t\n\t\t\t\tuserList.add(u);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t\n\t\t\te.printStackTrace();\n\t\t}\n\t\t\n\t\tcloseConnection();\n\t\t\n\t\treturn userList;\n\t}", "comment": "/**\n\t * get a users friends\n\t * @param email: email of user to get friends\n\t * @return a list of the users friends\n\t */"}}
{"code": {"body": "\tpublic ArrayList<Status> getFriendUpdates(String email) {\n\t\topenConnection();\n\t\tString requestType = \"\";\n\t\tString request = requestType + \"\" + email;\n\t\t\n\t\t\n\t\tArrayList<Status>statusList = new ArrayList<Status>();\n\t\t\n\t\ttry {\n\t\t\tString responseLine;\n\t\t\tsendMessage(request);\n\t\t\twhile ((responseLine = reader.readLine() ) != null) {\n\t\t\t\tString[] args = parseMessage(responseLine);\n\t\t\t\tif (args.length != 3) continue;\n\t\t\t\tString userEmail = args[0];\n\t\t\t\tString message = args[1];\n\t\t\t\tUser u = new User(userEmail, getUserInfo(userEmail), \"\");\n\t\t\t\tDate d = new SimpleDateFormat(\"\").parse(args[2]);\n\t\t\t\tStatus status = new Status(message, u, d);\n\t\t\t\tstatusList.add(status);\n\t\t\t\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t\n\t\t\te.printStackTrace();\n\t\t} catch (ParseException e) {\n\t\t\t\n\t\t\te.printStackTrace();\n\t\t} \n\t\t\n\t\tcloseConnection();\n\t\t\n\t\treturn statusList;\n\t}", "comment": "/**\n\t * Get friends updates\n\t * @param email: email of user to get friends updates\n\t * @return list of status updates for user\n\t */"}}
{"code": {"body": "\tpublic String[] parseMessage(String message) {\n\t\tString myDelimiter = \"\";\n\t\tString[] result = message.split(myDelimiter);  \n\t\treturn result;\n\t}", "comment": "/**\n\t * Parse the message passed in\n\t * @param message: message to parse\n\t * @return a string array of message fields\n\t */"}}
{"code": {"body": "\tpublic String handleSimpleMessages(String request) {\n\t\tString responseLine = \"\";\n\t\tString dummyString;\n\t\ttry {\n\t\t\tsendMessage(request);\n\t\t\twhile ((dummyString = reader.readLine() ) != null) {\n\t\t\t\tresponseLine = dummyString;\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn responseLine;\n\t\t\n\t}", "comment": "/**\n\t * Handle a simple message between servers where there is only a simple response passed back\n\t * @param request: the request to handle\n\t * @return A response from the server\n\t */"}}
{"code": {"body": "\tpublic void openConnection() {\n\t\ttry {\n\t\t\tcSocket = new Socket(InetAddress.getLocalHost(), serverPort);\n\t\t} catch (UnknownHostException e1) {\n\t\t\t\n\t\t\te1.printStackTrace();\n\t\t} catch (IOException e1) {\n\t\t\t\n\t\t\te1.printStackTrace();\n\t\t}\n\t\t\n\t\tInputStream in = null;\n\t\tOutputStream out = null;\n\t\ttry {\n\t\t\tin = cSocket.getInputStream();\n\t\t\tout = cSocket.getOutputStream();\n\t\t} catch (IOException e) {\n\t\t\t\n\t\t\te.printStackTrace();\n\t\t}\n\t\t\n\t\treader = new BufferedReader(new InputStreamReader(in));\n\t\tsocketWriter = new PrintWriter(out, true);\n\n\t}", "comment": "/**\n\t * Open a socket connection for read and write\n\t */"}}
{"code": {"body": "\tpublic void closeConnection() {\n\t\ttry{\n\t\t\treader.close();\n\t\t\tsocketWriter.close();\n\t\t\tcSocket.close();\n\t\t}\n\t\tcatch(IOException ioException){\n\t\t\tioException.printStackTrace();\n\t\t}\t\n\t}", "comment": "/**\n\t * Close a socket connection for read and write\n\t */"}}
{"code": {"body": "\tpublic void sendMessage(String msg)\n\t{\n\t\tsocketWriter.println(msg);\n\t\tsocketWriter.flush();\n\t}", "comment": "/**\n\t * Send a message to the server\n\t * @param msg: message to send\n\t */"}}
{"code": {"body": "\tpublic void chooseServer() {\n\t\tint serverIndex = (int) (Math.random() * (ServerConstants.serverList.length));\n\t\tserverPort = ServerConstants.servePort + serverIndex;\n\t\tserver = ServerConstants.serverList[serverIndex]+\"\"+serverPort;\n\n\t}", "comment": "/**\n\t * Choose a server randomly from a list of given servers\n\t */"}}
{"code": {"body": "public ServeThread(InputStream in, OutputStream out, Backend b, Map<String, Integer> userTable, int id, Cache c, Socket s) {\n\t\treader = new BufferedReader(new InputStreamReader(in));\n\t\tsocketWriter = new PrintWriter(out, true);\n\t\tdb = b;\n\t\tthis.userTable = userTable;\n\t\tserverID = id;\n\t\tthis.cache = c;\n\t\tthis.s = s;\n\t}", "comment": "/**\n\t * Creates a serverThread to handle requests to register or unregister\n\t * @param in The stream from the client\n\t * @param out The stream back to the client\n\t * @param b The database \n\t */"}}
{"code": {"body": "\tpublic void run() {\n\t\ttry {\n\t\t\tString line = reader.readLine();\n\t\t\tStringWriter responseHolder = new StringWriter();\n\t\t\twriter = new PrintWriter(responseHolder);\n\n\t\t\tif (cache.requestInCache(line)) {\n\t\t\t\tsocketWriter.println(cache.getResponseForRequest(line));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSystem.out.println(serverID + \"\" + line);\n\t\t\thandleRequest(line);\n\t\t\t\n\t\t\twriter.flush();\n\t\t\tString response = responseHolder.toString();\n\t\t\tSystem.out.println(serverID +\"\" + response);\n\t\t\tcache.cacheRequest(line, response);\n\t\t\t\n\t\t\tsocketWriter.write(response);\n\t\t\tsocketWriter.flush();\n\t\t\ts.close();\n\t\t\t\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\t\n\t}", "comment": "/** Reads one line at a time and transfers to the writer */"}}
{"code": {"body": "\tprivate void handleRequest(String line) {\n\t\tString[] args = line.split(\"\");\n\t\tString requestType = args[0];\n\t\tString email = args[1];\n\t\t\n\t\t\n\t\tif (requestType.equals(\"\")) {\n\t\t\t\n\t\t\tif (args.length != 4) {\n\t\t\t\twriter.println(\"\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (userTable.get(args[1]) != null) {\n\t\t\t\twriter.println(\"\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tString name = args[2];\n\t\t\tString password = args[3];\n\t\t\t\n\t\t\tdb.register(new User(email, name, password));\n\t\t\tuserTable.put(email, serverID);\n\t\t\tupdateUserTables(email);\n\t\t\t\n\t\t\twriter.println(\"\");\n\t\t\treturn;\n\t\t}\n\t\telse if (requestType.equals(\"\")) {\n\t\t\t\n\t\t\t\n\t\t\tdb.register(new User(email, args[2], args[3]));\n\t\t\tint serverID = Integer.parseInt(args[4]);\n\t\t\tuserTable.put(email, serverID);\n\t\t\twriter.println(\"\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t\n\t\tif (userTable.get(email) == null) {\n\t\t\twriter.println(\"\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint locationID = userTable.get(email);\n\t\tif (locationID != serverID) {\n\t\t\tforwardRequestToServer(locationID, line, writer);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t\n\t\tif (requestType.equals(\"\")) {\n\t\t\t\n\t\t\tUser u = db.getUser(email);\n\t\t\tString status = args[2];\n\t\t\t\n\t\t\tfor (int i = 3; i < args.length; i++) {\n\t\t\t\tstatus = status + \"\" + args[i];\n\t\t\t}\n\t\t\t\n\t\t\tdb.storeStatus(new Status(status, u, new Date()));\n\t\t\twriter.println(\"\");\n\t\t\treturn;\n\t\t}\n\t\telse if (requestType.equals(\"\")) {\n\t\t\t\n\t\t\tUser u = db.getUser(email);\n\t\t\tUser u2 = new User(args[2]);\n\t\t\t\n\t\t\tint requesterID = userTable.get(u2.getEmail());\n\t\t\tStringWriter responseWriter = new StringWriter();\n\t\t\tforwardRequestToServer(requesterID, \"\" + u2.getEmail() + \"\" + u.getEmail(), responseWriter);\n\t\t\t\n\t\t\tString response = responseWriter.toString();\n\t\t\tif (response.equals(\"\")) {\n\t\t\t\t\n\t\t\t\tdb.storeFriend(u, u2);\n\t\t\t\tforwardRequestToServer(requesterID, \"\" + u2.getEmail() + \"\" + u.getEmail(), new StringWriter());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tList<User> requests = db.getFriendRequests(u);\n\t\t\t\trequests.add(u2);\n\t\t\t}\n\t\t\twriter.println(\"\");\n\t\t\treturn;\n\t\t}\n\t\telse if (requestType.equals(\"\")) {\n\t\t\t\n\t\t\tUser u = db.getUser(email);\n\t\t\tUser u2 = new User(args[2]);\n\t\t\t\n\t\t\tList<User> requests = db.getFriendRequests(u);\n\t\t\trequests.remove(u2);\n\t\t\t\n\t\t\tdb.storeFriend(u, u2);\n\t\t\t\n\t\t\t\n\t\t\twriter.println(\"\");\n\t\t\treturn;\n\t\t}\n\t\telse if (requestType.equals(\"\")) {\n\t\t\t\n\t\t\tUser u = db.getUser(email);\n\t\t\tUser u2 = new User(args[2]);\n\n\t\t\tif (args[3].equals(\"\")) {\n\t\t\t\t\n\t\t\t\tforwardRequestToServer(userTable.get(args[2]), \"\" + args[2] + \"\" + email + \"\", new StringWriter());\n\t\t\t}\n\t\t\t\n\t\t\tdb.removeFriend(u, u2);\n\t\t\twriter.println(\"\");\n\t\t\treturn;\n\t\t}\n\t\telse if (requestType.equals(\"\")) {\n\t\t\t\n\t\t\tString pwd = args[2];\n\t\t\tif (db.login(email, pwd)) {\n\t\t\t\twriter.println(\"\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\twriter.println(\"\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\telse if (requestType.equals(\"\")) {\n\t\t\t\n\t\t\tUser u = db.getUser(email);\n\t\t\tUser u2 = new User(args[2]);\n\t\t\tif (db.getFriendRequests(u).contains(u2)) {\n\t\t\t\twriter.println(\"\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\twriter.println(\"\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\telse if (requestType.equals(\"\")) {\n\t\t\t\n\t\t\tUser u = db.getUser(email);\n\t\t\tUser u2 = new User(args[2]);\n\t\t\tif (db.areFriends(u, u2)) {\n\t\t\t\twriter.println(\"\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\twriter.println(\"\");\n\t\t\t}\n\t\t}\n\t\telse if (requestType.equals(\"\")) {\n\t\t\t\n\t\t\tUser u = db.getUser(email);\n\t\t\tList<User> friends = db.getFriends(u);\n\t\t\t\n\t\t\tfor (User f : friends) {\n\t\t\t\twriter.println(f.getEmail());\n\t\t\t}\n\t\t}\n\t\telse if (requestType.equals(\"\")) {\n\t\t\t\n\t\t\tUser u = db.getUser(email);\n\t\t\twriter.println(\"\" + u.getEmail() + \"\" + u.getFullname());\n\t\t\treturn;\n\t\t}\n\t\telse if (requestType.equals(\"\")) {\n\t\t\t\n\t\t\tUser u = db.getUser(email);\n\t\t\tList<Status> statuses = db.getStatuses(u);\n\t\t\tfor (Status s : statuses) {\n\t\t\t\tString dateString = (new SimpleDateFormat(\"\")).format(s.getTimestamp());\n\t\t\t\twriter.println(s.getPoster().getEmail() + \"\" + s.getMessage() + \"\" + s.getTimestamp().toString());\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\telse if (requestType.equals(\"\")) {\n\t\t\t\n\t\t\tUser u = db.getUser(email);\n\t\t\tList<User> requests = db.getFriendRequests(u);\n\t\t\t\n\t\t\tfor (User requester : requests) {\n\t\t\t\twriter.println(requester.getEmail());\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\telse if (requestType.equals(\"\")) {\n\t\t\t\n\t\t\tUser u = db.getUser(email);\n\t\t\tList<User> friends = db.getFriends(u);\n\t\t\tList<Status> allStatuses = new ArrayList<Status>(10);\n\t\t\tfor (User f : friends) {\n\t\t\t\tString fEmail = f.getEmail();\n\t\t\t\tint friendLocationID = userTable.get(fEmail);\n\t\t\t\tif (friendLocationID == serverID) {\n\t\t\t\t\tallStatuses.addAll(db.getStatuses(db.getUser(fEmail)));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tallStatuses.addAll(getStatusesForUser(fEmail, friendLocationID));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tCollections.sort(allStatuses,((Database)db).new StatusCompare());\n\t\t\t\n\t\t\tif(allStatuses.size() > 10){\n\t\t\t\tList<Status> statArray = new ArrayList<Status>();\n\t\t\t\tfor(int i = 0; i < 10; i ++){\n\t\t\t\t\tstatArray.add(allStatuses.get(i));\n\t\t\t\t}\n\t\t\t\tallStatuses = statArray;\n\t\t\t}\n\t\t\telse if (allStatuses.size() == 0) {\n\t\t\t\tallStatuses.add(new Status(\"\", u, new Date()));\n\t\t\t}\n\t\t\t\n\t\t\tfor (Status s : allStatuses) {\n\t\t\t\twriter.println(s.getPoster().getEmail() + \"\" + s.getMessage() + \"\" + s.getTimestamp().toString());\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}", "comment": "/**\n\t * Handle a client request; speaks to the db and routes messages back to client\n\t * @param line\n\t */"}}
{"code": {"body": "\tprivate void updateUserTables(String email) {\n\t\tUser u = db.getUser(email);\n\t\tString name = u.getFullname();\n\t\tString pwd = u.getPassword();\n\t\tfor (int i = 0; i < ServerConstants.serverList.length; i++) {\n\t\t\t\n\t\t\tif (i == serverID) continue;\n\t\t\t\n\t\t\tforwardRequestToServer(i, \"\" + email + \"\" + name + \"\" + pwd + \"\" + serverID, new StringWriter());\n\t\t}\n\t}", "comment": "/**\n\t * Send a notification to all the other servers that a new user has been registered\n\t * @param email the users email\n\t */"}}
{"code": {"body": "\tprivate void forwardRequestToServer(int destID, String request, Writer responseWriter) {\n\t\ttry {\n\t\t\tSocket requestSock = new Socket(InetAddress.getLocalHost(), ServerConstants.servePort + destID);\n\t\t\tPrintWriter w = new PrintWriter(requestSock.getOutputStream(), true);\n\t\t\tBufferedReader r = new BufferedReader(new InputStreamReader(requestSock.getInputStream()));\n\t\t\tw.println(request);\n\t\t\tString responseLine;\n\t\t\twhile ((responseLine = r.readLine()) != null) {\n\t\t\t\tresponseWriter.write(responseLine + \"\");\n\t\t\t}\n\t\t\t\n\t\t} catch (UnknownHostException e) {\n\t\t\t\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\t\n\t\t\te.printStackTrace();\n\t\t}\n\t}", "comment": "/**\n\t * Forwards a request to a server that can handle it and writes what is returned\n\t * to the output stream of this thread.\n\t * \n\t * @param destID The serverID that can handle the request\n\t * @param request The request string\n\t * @param responseWriter The stream to write any responses to.\n\t */"}}
{"code": {"body": "\tprivate List<Status> getStatusesForUser(String email, int location) {\n\t\tArrayList<Status> allStatus = new ArrayList<Status>();\n\t\tStringWriter w = new StringWriter();\n\t\t\n\t\tforwardRequestToServer(location, \"\" + email, w);\n\t\t\n\t\tBufferedReader r = new BufferedReader(new StringReader(w.toString()));\n\t\t\n\t\tString line;\n\t\ttry {\n\t\t\twhile ((line = r.readLine()) != null) {\n\t\t\t\tString[] args = line.split(\"\");\n\t\t\t\tUser u = db.getUser(args[0]);\n\t\t\t\tString status = args[1];\n\t\t\t\tDate d = DateFormat.getInstance().parse(args[2]);\n\t\t\t\t\n\t\t\t\tStatus s = new Status(status, u, d);\n\t\t\t\tallStatus.add(s);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t\n\t\t\te.printStackTrace();\n\t\t} catch (ParseException e) {\n\t\t\t\n\t\t\te.printStackTrace();\n\t\t}\n\t\t\n\t\treturn allStatus;\n\t}", "comment": "/**\n\t * Performs a status fetch request and parses it into a list of statuses\n\t * \n\t * @param email The users email\n\t * @param location The serverID the user is stored on.\n\t * @return Returns a list of all of the given users statuses.\n\t */"}}
{"code": {"body": "public Status(String m, User p, Date time){\n\t\tmessage = m;\n\t\tposter = p;\n\t\ttimestamp = time;\n\t}", "comment": "/**\n\t * @return the message\n\t */"}}
{"code": {"body": "\tpublic String getMessage() {\n\t\treturn message;\n\t}", "comment": "/**\n\t * @return the message\n\t */"}}
{"code": {"body": "\tpublic User getPoster() {\n\t\treturn poster;\n\t}", "comment": "/**\n\t * @return the poster\n\t */"}}
{"code": {"body": "\tpublic Date getTimestamp() {\n\t\treturn timestamp;\n\t}", "comment": "/**\n\t * @return the timestamp\n\t */"}}
{"code": {"body": "public User(String mail, String name, String pass){\n\t\temail = mail;\n\t\tfullname = name;\n\t\tpassword = pass;\n\t}", "comment": "/**\n\t * The constructor for the User object. \n\t * @param mail the User's email\n\t * @param name the User's full name\n\t * @param pass the User's pass\n\t */"}}
{"code": {"body": "public User(String mail) {\n\t\temail = mail;\n\t\tfullname = \"\";\n\t\tpassword = \"\";\n\t}", "comment": "/**\n\t * Constructs a minimal user object, for use on servers that don't\n\t * hold this users data.\n\t * \n\t * @param mail the email to the User\n\t */"}}
{"code": {"body": "public FacelookAppGUI(String email) {\n\t\tsetDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\t\tsetBounds(100, 100, 771, 540);\n\t\tthis.getContentPane().add(new NewsFeedPanel(email, this));\n\t\tsetVisible(true);\n\t}", "comment": "/**\n\t * Create the frame.\n\t */"}}
{"code": {"body": "\tpublic void replace(JPanel j){\n\t\tthis.getContentPane().removeAll();\n\t\tthis.getContentPane().add(j);\n\t\tvalidate();\n\t}", "comment": "/*\n\t * Use this method to swap between panels!\n\t */"}}
{"code": {"body": "public FacelookInitGUI() {\n\t\tsetDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\t\tsetBounds(100, 100, 450, 300);\n\t\tthis.getContentPane().add(new LoginPanel(this));\n\t}", "comment": "/**\n\t * Create the frame.\n\t */"}}
{"code": {"body": "\tpublic static void main(String[] args) {\n\t\tEventQueue.invokeLater(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tFacelookInitGUI frame = new FacelookInitGUI();\n\t\t\t\t\tframe.setVisible(true);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}", "comment": "/**\n\t * Launch the application.\n\t */"}}
{"code": {"body": "\tpublic void replace(JPanel j){\n\t\tthis.getContentPane().removeAll();\n\t\tthis.getContentPane().add(j);\n\t\tvalidate();\n\t}", "comment": "/*\n\t * Use this method to swap between panels! Example in LoginPanel.java\n\t */"}}
{"code": {"body": "public ProfilePanel(final String emailName, final String emailUser, final FacelookAppGUI a) {\n\t\tsuper();\n\t\tcontainer = a;\n\t\tthis.setBackground(Color.decode(\"\"));\n\t\tthis.setPreferredSize(new Dimension(770,539));\n\t\tsetLayout(null);\n\t\t\n\t\tJLabel lblFacelook = new JLabel(\"\");\n\t\tlblFacelook.setFont(new Font(\"\", Font.PLAIN, 32));\n\t\tlblFacelook.setForeground(Color.WHITE);\n\t\tlblFacelook.setBounds(12, 13, 199, 32);\n\t\tadd(lblFacelook);\n\t\t\n\t\tClientHandler chh = new ClientHandler();\n\t\tString name = chh.getUserInfo(emailName);\n\t\t\n\t\t\n\n\t\tJLabel nameLabel = new JLabel(name);\n\t\tnameLabel.setForeground(Color.WHITE);\n\t\tnameLabel.setBounds(173, 17, 199, 32);\n\t\tnameLabel.setFont(new Font(\"\", Font.PLAIN, 21));\n\t\tadd(nameLabel);\n\t\t\n\t\t\n\t\tJLabel lblLatest = new JLabel(\"\");\n\t\tlblLatest.setFont(new Font(\"\", Font.PLAIN, 20));\n\t\tlblLatest.setForeground(Color.WHITE);\n\t\tlblLatest.setBounds(12, 87, 166, 40);\n\t\tadd(lblLatest);\n\t\t\n\t\tJPanel panel = new JPanel();\n\t\tpanel.setBounds(22, 147, 719, 379);\n\t\tadd(panel);\n\t\tpanel.setLayout(new GridLayout(5, 2, 5, 5));\n\t\t\n\t\t\n\t\tList<Status> posts;\n\t\tif(emailUser.equals(emailName)){\n\t\t\tposts = chh.getFriendUpdates(emailName);\n\t\t}\n\t\telse {\n\t\t\tposts = chh.getStatuses(emailName);\n\t\t}\n\t\t\n\t\tfor (Status post : posts) {\n\t\t\tStatusPost p = new StatusPost(post.getPoster().getFullname(), post.getTimestamp(), post.getMessage());\n\t\t\tfinal String friendEmail = post.getPoster().getFullname();\n\t\t\tp.addActionListener(new ActionListener() {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void actionPerformed(ActionEvent arg0) {\n\t\t\t\t\tcontainer.replace(new ProfilePanel(friendEmail, emailUser, a));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t});\n\t\t\t\n\t\t\tpanel.add(p);\n\t\t}\n\t\t\n\t\t\n\t\tif(!emailUser.equals(emailName)){\n\t\t\tJButton btnAddFriend = new JButton(\"\");\n\t\t\tbtnAddFriend.setBounds(12, 49, 155, 25);\n\t\t\tadd(btnAddFriend);\n\t\t\n\t\t\n\t\t\t\n\t\t\tbtnAddFriend.addActionListener(new ActionListener(){\n\t\n\t\t\t\t@Override\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\t\n\t\t\t\t\tClientHandler ch = new ClientHandler();\n\t\t\t\t\tif(ch.areFriends(emailUser,emailName)) {\n\t\t\t\t\t\tch.removeFriend(emailUser, emailName);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tch.addFriend(emailUser, emailName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t});\n\t\t\t\n\t\t}\n\n\t\t\n\t\tJButton btnNewsFeed = new JButton(\"\");\n\t\tbtnNewsFeed.setBounds(661, 49, 97, 25);\n\t\tadd(btnNewsFeed);\n\t\tbtnNewsFeed.addActionListener(new ActionListener(){\n\n\t\t\t@Override\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tcontainer.replace(new NewsFeedPanel(emailUser, container));\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t\t\n\t\tif(emailUser.equals(emailName)){\n\t\t\ttextField = new JTextField(\"\");\n\t\t\ttextField.setBounds(12, 60, 300, 32);\n\t\t\tadd(textField);\n\t\t\ttextField.setColumns(10);\n\t\t\ttextField.addFocusListener(new FocusListener() {\n\t\n\t\t        public void focusGained(FocusEvent e) {\n\t\t            if (textField.getText().equals(\"\")) {\n\t\t            \ttextField.setText(\"\");\n\t\t            }\n\t\t        }\n\t\n\t\t        public void focusLost(FocusEvent e) {\n\t\t            if (\"\".equalsIgnoreCase(textField.getText().trim())) {\n\t\t            \ttextField.setText(\"\");\n\t\t            }\n\t\t        }});\n\t\t\t\n\t\t\tJButton btnNewButton = new JButton(\"\");\n\t\t\tbtnNewButton.setBounds(312, 60, 97, 32);\n\t\t\tadd(btnNewButton);\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tbtnNewButton.addActionListener(new ActionListener(){\n\t\n\t\t\t\t@Override\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\tClientHandler ch = new ClientHandler();\n\t\t\t\t\tch.updateStatus(emailUser, textField.getText());\n\t\t\t\t\ttextField.setText(\"\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t});\n\t\t\t\n\t\n\t\t\t\n\t\t}\n\t}", "comment": "/*\n\t\t * Fill this GridLayout with StatusPost buttons for the status's\n\t\t * It is ok to generate this at the beginning and only refresh when coming back to this page. \n\t\t * If there are less than 10 then leave the remainder of the grid blank. These don't need to link back to same page.\n\t\t */"}}
{"code": {"body": "public RegisterPanel(FacelookInitGUI j) {\n\t\tsuper();\n\t\tcontainer = j;\n\t\tthis.setBackground(Color.decode(\"\"));\n\t\tthis.setBorder(new EmptyBorder(5, 5, 5, 5));\n\t\tthis.setLayout(new MigLayout(\"\", \"\", \"\"));\n\t\t\n\t\tJLabel lblFacelook = new JLabel(\"\");\n\t\tlblFacelook.setForeground(Color.WHITE);\n\t\tlblFacelook.setFont(new Font(\"\", Font.BOLD, 36));\n\t\tthis.add(lblFacelook, \"\");\n\t\t\n\t\tfinal JTextField txtUsername = new JTextField();\n\t\ttxtUsername.setText(\"\");\n\t\ttxtUsername.setFont(new Font(\"\", Font.PLAIN, 13));\n\t\ttxtUsername.setBackground(Color.decode(\"\"));\n\t\ttxtUsername.setForeground(Color.WHITE);\n\t\tthis.add(txtUsername, \"\");\n\t\ttxtUsername.setColumns(10);\n\t\ttxtUsername.addFocusListener(new FocusListener() {\n\n\t        public void focusGained(FocusEvent e) {\n\t            if (txtUsername.getText().equals(\"\")) {\n\t            \ttxtUsername.setText(\"\");\n\t            }\n\t        }\n\n\t        public void focusLost(FocusEvent e) {\n\t            if (\"\".equalsIgnoreCase(txtUsername.getText().trim())) {\n\t            \ttxtUsername.setText(\"\");\n\t            }\n\t        }});\n\t\t\n\t\tfinal JTextField txtEmail = new JTextField();\n\t\ttxtEmail.setText(\"\");\n\t\ttxtEmail.setFont(new Font(\"\", Font.PLAIN, 13));\n\t\ttxtEmail.setBackground(Color.decode(\"\"));\n\t\ttxtEmail.setForeground(Color.WHITE);\n\t\tthis.add(txtEmail, \"\");\n\t\ttxtEmail.setColumns(10);\n\t\ttxtEmail.addFocusListener(new FocusListener() {\n\n\t        public void focusGained(FocusEvent e) {\n\t            if (txtEmail.getText().equals(\"\")) {\n\t            \ttxtEmail.setText(\"\");\n\t            }\n\t        }\n\n\t        public void focusLost(FocusEvent e) {\n\t            if (\"\".equalsIgnoreCase(txtEmail.getText().trim())) {\n\t            \ttxtEmail.setText(\"\");\n\t            }\n\t        }});\n\t\t\n\t\tfinal JPasswordField txtPass1 = new JPasswordField(\"\");\n\t\ttxtPass1.setEchoChar((char)0);\n\t\ttxtPass1.setFont(new Font(\"\", Font.PLAIN, 13));\n\t\ttxtPass1.setBackground(Color.decode(\"\"));\n\t\ttxtPass1.setForeground(Color.WHITE);\n\t\tthis.add(txtPass1, \"\");\n\t\ttxtPass1.setColumns(10);\n\t\ttxtPass1.addFocusListener(new FocusListener() {\n\n\t        public void focusGained(FocusEvent e) {\n\t            txtPass1.setEchoChar('');\n\t            if (txtPass1.getText().equals(\"\")) {\n\t            \ttxtPass1.setText(\"\");\n\t            }\n\t        }\n\n\t        public void focusLost(FocusEvent e) {\n\t            if (\"\".equalsIgnoreCase(txtPass1.getText().trim())) {\n\t            \ttxtPass1.setEchoChar((char)0);\n\t            \ttxtPass1.setText(\"\");\n\t            }\n\t        }});\n\t\t\n\t\tfinal JPasswordField txtPass2 = new JPasswordField(\"\");\n\t\ttxtPass2.setEchoChar((char)0);\n\t\ttxtPass2.setFont(new Font(\"\", Font.PLAIN, 13));\n\t\ttxtPass2.setBackground(Color.decode(\"\"));\n\t\ttxtPass2.setForeground(Color.WHITE);\n\t\tthis.add(txtPass2, \"\");\n\t\ttxtPass2.setColumns(10);\n\t\t\n\t\tJButton btnRegister = new JButton(\"\");\n\t\tadd(btnRegister, \"\");\n\t\t\n\t\t\n\t\t\n\t\tbtnRegister.addActionListener(new ActionListener() {\n\n\t\t\t@Override\n\t\t\tpublic void actionPerformed(ActionEvent arg0) {\n\t\t\t\tClientHandler ch = new ClientHandler();\n\t\t\t\tif (ch.register(txtEmail.getText(), txtUsername.getText(), txtPass1.getText())) {\n\t\t\t\t\tcontainer.replace(new LoginPanel(container));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} });\n\t\t\n\t\t\n\t\t\n\t\tJButton btnBackToLogin = new JButton(\"\");\n\t\tadd(btnBackToLogin, \"\");\n\t\t\n\t\tbtnBackToLogin.addActionListener(new ActionListener() {\n\n\t\t\t@Override\n\t\t\tpublic void actionPerformed(ActionEvent arg0) {\n\t\t\t\tcontainer.replace(new LoginPanel(container));\n\t\t\t} });\n\t\ttxtPass2.addFocusListener(new FocusListener() {\n\n\t        public void focusGained(FocusEvent e) {\n\t            txtPass2.setEchoChar('');\n\t            if (txtPass2.getText().equals(\"\")) {\n\t            \ttxtPass2.setText(\"\");\n\t            }\n\t        }\n\n\t        public void focusLost(FocusEvent e) {\n\t            if (\"\".equalsIgnoreCase(txtPass2.getText().trim())) {\n\t            \ttxtPass2.setEchoChar((char)0);\n\t            \ttxtPass2.setText(\"\");\n\t            }\n\t        }});\n\t}", "comment": "/**\n\t * Create the panel.\n\t */"}}
{"code": {"body": "    public static List<String> retrieveTwitter(String md5key) throws Exception {\n        Connection con = null;\n        PreparedStatement pstmt = null;\n        ResultSet rs = null;\n        List<String> list = new ArrayList<String>();\n        try {\n            con = ds.getConnection();\n\n            pstmt = con.prepareStatement(\"\"\n                    + \"\");\n            pstmt.setString(1, md5key);\n            rs = pstmt.executeQuery();\n\n            while (rs.next()) {\n                list.add(rs.getString(\"\"));\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (con != null) con.close();\n            if (pstmt != null) pstmt.close();\n            if (rs != null) rs.close();\n        }\n        return list;\n    }", "comment": "/**\n     * Retrieves Q2 result for given key\n     * @param md5key\n     * @return\n     * @throws Exception\n     */"}}
{"code": {"body": "    public static List<String> retrieveRangeWordCount(String startDate,\n                                                      String endDate,\n                                                      String startUid,\n                                                      String endUid)\n            throws Exception {\n\n        Connection con = null;\n        PreparedStatement pstmt = null;\n        ResultSet rs = null;\n        List<String> list = new ArrayList<String>();\n        try {\n            con = ds.getConnection();\n            String startKey = startUid + startDate;\n            String endKey = endUid + endDate;\n            pstmt = con.prepareStatement(\"\");\n            pstmt.setString(1, startKey);\n            pstmt.setString(2, endKey);\n            pstmt.setString(3, startDate);\n            pstmt.setString(4, endDate);\n\n            rs = pstmt.executeQuery();\n\n            while (rs.next()) {\n                list.add(rs.getString(\"\"));\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (con != null) con.close();\n            if (pstmt != null) pstmt.close();\n            if (rs != null) rs.close();\n        }\n        return list;\n    }", "comment": "/**\n     * Retrieves the range for given parameters.\n     * @param startDate\n     * @param endDate\n     * @param startUid\n     * @param endUid\n     * @return list that contains all the word:count pairs in the range\n     * @throws Exception\n     */"}}
{"code": {"body": "    public static void updateRecord(String tweetid, String[] fieldsName,\n                                    String[] fields) throws Exception {\n        Connection con = null;\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            con = ds.getConnection();\n\n            List<String> newFieldsName = new ArrayList<>();\n            List<String> newFields = new ArrayList<>();\n\n            int len = Math.min(fields.length, fieldsName.length);\n\n            for (int i = 0; i < len; i++) {\n                if (fields[i].length() > 0) {\n                    newFieldsName.add(fieldsName[i]);\n                    newFields.add(fields[i]);\n                }\n            }\n\n            StringBuilder sqlInsertPartA = new StringBuilder();\n            sqlInsertPartA.append(\"\");\n\n            StringBuilder sqlInsertPartB = new StringBuilder();\n            sqlInsertPartB.append(\"\");\n\n            StringBuilder sqlUpdate = new StringBuilder();\n            sqlUpdate.append(\"\");\n            for (int i = 0; i < newFieldsName.size(); i++) {\n                sqlInsertPartA.append(newFieldsName.get(i) + \"\");\n                sqlInsertPartB.append(\"\");\n                sqlUpdate.append(newFieldsName.get(i) + \"\");\n            }\n\n            sqlInsertPartA.deleteCharAt(sqlInsertPartA.length() - 1);\n            sqlInsertPartA.append(\"\");\n\n            sqlInsertPartB.deleteCharAt(sqlInsertPartB.length() - 1);\n            sqlInsertPartB.append(\"\");\n\n            sqlUpdate.deleteCharAt(sqlUpdate.length() - 1);\n\n            String sql = new StringBuilder().append(sqlInsertPartA).append(sqlInsertPartB)\n                    .append(sqlUpdate).toString();\n\n            ps = con.prepareStatement(sql);\n\n            ps.setString(1, tweetid);\n\n            for (int i = 0; i < newFields.size(); i++) {\n                ps.setString(i + 2, newFields.get(i));\n                ps.setString(i + newFields.size() + 2, newFields.get(i));\n            }\n\n            ps.executeUpdate();\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (con != null) con.close();\n            if (ps != null) ps.close();\n            if (rs != null) rs.close();\n        }\n    }", "comment": "/**\n     * Update the record for query4\n     * @param tweetid\n     * @param fieldsName\n     * @param fields\n     * @throws Exception\n     */"}}
{"code": {"body": "public TwitterDao(String url) throws Exception {\n        this.url = url;\n\n    }", "comment": "/**\n     * Gives a specific db url to connect.\n     * @param url\n     */"}}
{"code": {"body": "    static int getKeyZ (String keyParameter) {\n        BigInteger keyY = new BigInteger(keyParameter);\n        BigInteger gcd = secretKey.gcd(keyY);\n        return 1 + gcd.mod(new BigInteger(\"\")).intValue();\n    }", "comment": "/**\n     * Generates the key Z from the parameter : key\n     * @param keyParameter\n     * @return keyZ\n     */"}}
{"code": {"body": "    static int getKeyZ (String keyParameter) {\n        BigInteger keyY = new BigInteger(keyParameter);\n        BigInteger gcd = secretKey.gcd(keyY);\n        return 1 + gcd.mod(new BigInteger(\"\")).intValue();\n    }", "comment": "/**\n     * Generates the key Z from the parameter : key\n     * @param keyParameter\n     * @return keyZ\n     */"}}
{"code": {"body": "    public static String decrypt(String keyParameter, String message) {\n        if (message == null) return null;\n        int keyZ = getKeyZ(keyParameter);\n\n        char[] charArray = getCharArray(message, keyZ);\n        return getDecryptedMessage(charArray);\n    }", "comment": "/**\n     * ^^^^^ Need to judge if the input is valid ??? ^^^^\n     * ^^^^^ What if key or message is not valid ^^^^\n     * ^^^^^ Invalid Message: null || length == 0 || not 4,9,25...\n     * @param keyParameter key parameter from url\n     * @param message message from url\n     * @return decrypted message\n     */"}}
{"code": {"body": "    static int getKeyZ (String keyParameter) {\n        BigInteger keyY = new BigInteger(keyParameter);\n        BigInteger gcd = secretKey.gcd(keyY);\n        return 1 + gcd.mod(new BigInteger(\"\")).intValue();\n    }", "comment": "/**\n     * Generates the key Z from the parameter : key\n     * @param keyParameter\n     * @return keyZ\n     */"}}
{"code": {"body": "    public static String getMD5(String message) {\n        String md5str = \"\";\n        try {\n            \n            MessageDigest md = MessageDigest.getInstance(\"\");\n\n            \n            byte[] input = message.getBytes(\"\");\n\n            \n            byte[] buff = md.digest(input);\n\n            \n            md5str = bytesToHex(buff);\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return md5str;\n    }", "comment": "/**\n     * generate md5 String\n     * @param message\n     * @return\n     */"}}
{"code": {"body": "    public static String bytesToHex(byte[] bytes) {\n        StringBuffer md5str = new StringBuffer();\n        int digital;\n        for (int i = 0; i < bytes.length; i++) {\n            digital = bytes[i];\n\n            if(digital < 0) {\n                digital += 256;\n            }\n            if(digital < 16){\n                md5str.append(\"\");\n            }\n            md5str.append(Integer.toHexString(digital));\n        }\n        return md5str.toString();\n    }", "comment": "/**\n     * byte to hex\n     * @param bytes\n     * @return\n     */"}}
{"code": {"body": "    public void add(long _time, float _x, float _y, float _z, boolean _isStepDetected, float _amplitude) {\n        if (m_iLength > 0 && m_list.size() >= m_iLength) {\n            \n            m_list.remove(m_list.size()-1);\n        }\n        m_list.add(0, new LogItem(new float[] {_x, _y, _z}, _isStepDetected, _amplitude, _time));\n    }", "comment": "/*\n     * Ajoute un enregistrement sp\u00e9cifiant ou non un pas \u00e0 l'historique.\n     * Instancie un \u00e9l\u00e9ment de type /LogItem/.\n     */"}}
{"code": {"body": "    public boolean writeLogFile(String _tag, String _dirname, String _filename, boolean _useDateInName) {\n\n        try {\n            \n            boolean externalStorageAvailable = false;\n            boolean externalStorageWriteable = false;\n            String state = Environment.getExternalStorageState();\n\n            if (Environment.MEDIA_MOUNTED.equals(state)) {\n                \n                externalStorageAvailable = externalStorageWriteable = true;\n            } else if(Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) {\n                \n                externalStorageAvailable = true;\n                externalStorageWriteable = false;\n            } else {\n                \n                externalStorageAvailable = externalStorageWriteable = false;\n            }\n            \n            Log.i(_tag, \"\" + externalStorageAvailable + \"\" + externalStorageWriteable);\n\n            \n            File root = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM);\n            File dir = new File (root, _dirname);\n            if (!dir.exists()) {\n                if (!dir.mkdirs()) {\n                    Log.i(_tag, \"\" + dir.getAbsolutePath());\n                    return false;\n                }\n            }\n\n            \n            if (_useDateInName) {\n                SimpleDateFormat dateFormat = new SimpleDateFormat(_filename);\n                Date date = new Date();\n                _filename = dateFormat.format(date);\n            }\n            File file = new File(dir, _filename);\n            if (!file.exists()) {\n               try {\n                   file.createNewFile();\n               } catch (IOException e) {\n                   Log.i(_tag, \"\" + file.getAbsolutePath());\n                   return false;\n               }\n            }\n\n            \n            \n            long lastTimestamp = m_list.get(m_list.size() - 1).getTime();\n            BufferedWriter buf;\n\n            try {\n                buf = new BufferedWriter(new FileWriter(file, false));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n                Log.i(_tag, \"\");\n                return false;\n            }\n\n            \n            String txt;\n            buf.append(CSV_HEAD);\n            for (LogItem li : m_list) {\n                txt = String.format(\n                    \"\",\n                    li.m_lTime - lastTimestamp,\n                    li.m_coords[0],\n                    li.m_coords[1],\n                    li.m_coords[2],\n                    li.m_bIsStepDetected,\n                    li.m_amplitude\n                );\n                buf.append(txt);\n            }\n            buf.newLine();\n            buf.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            Log.e(_tag, \"\" + e.toString());\n            return false;\n        }\n        return true;\n    }", "comment": "/*\n     * Enregistre l'historique courante sous la forme d'un fichier texte CSV.\n     * Chaque ligne indique un enregistrement, donnant:\n     *  . l'instant de capture de l'\u00e9chantillon (en millisecondes, relatives \u00e0\n     *    l'instant d\u00e9but de l'enregistrement)\n     *  . la valeur de l'acc\u00e9l\u00e9rom\u00e8tre selon X\n     *  . la valeur de l'acc\u00e9l\u00e9rom\u00e8tre selon Y\n     *  . la valeur de l'acc\u00e9l\u00e9rom\u00e8tre selon Z\n     */"}}
{"code": {"body": "    public void clear() {\n        m_list.clear();\n    }", "comment": "/*\n     * Vide l'historique.\n     */"}}
{"code": {"body": "public StepDetector(StepActivity _activity, float _limitSensibility, float _amplitudeSensibility) {\n        m_parentActivity        = _activity;\n        \n        if(_limitSensibility < LIMIT_SENSIBILITY_MIN) {\n            m_fLimitSensibility = LIMIT_SENSIBILITY_MIN;\n        } else if(_limitSensibility > LIMIT_SENSIBILITY_MAX) {\n            m_fLimitSensibility = LIMIT_SENSIBILITY_MAX;\n        } else {\n            m_fLimitSensibility = _limitSensibility;\n        }\n        \n        if(_amplitudeSensibility < AMPLITUDE_SENSIBILITY_MIN) {\n            m_fAmplitudeSensibility = AMPLITUDE_SENSIBILITY_MIN;\n        } else if(_amplitudeSensibility > AMPLITUDE_SENSIBILITY_MAX) {\n            m_fAmplitudeSensibility = AMPLITUDE_SENSIBILITY_MAX;\n        } else {\n            m_fAmplitudeSensibility = _amplitudeSensibility;\n        }\n\n        m_sensor        = new Sensor(this);\n        m_sensorManager = (SensorManager)m_parentActivity.getSystemService(Context.SENSOR_SERVICE);\n\n        m_history       = new MyLogs(HISTORY_MAX_LENGTH);\n        m_stateHistory  = new ArrayList<Integer>(3);\n        \n        m_stepListenerList = new ArrayList<IStepListener>();\n    }", "comment": "/**\n     * \n     * @param _activity : activite parente\n     * @param _amplitudeSensibility : sensibilite de l'amplitude (entre 1 et 3)\n     * @param _limitSensibility     : sensibilite de la limite de detection de phases (entre 1 et 3)\n     */"}}
{"code": {"body": "    public SensorManager getSensorManager() {\n        return m_sensorManager;\n    }", "comment": "/*\n     * Getters - Setters\n     */"}}
{"code": {"body": "    public void toggleActivity(boolean on) {\n        m_sensor.toggleActivity(on);\n    }", "comment": "/*\n     * Mets en pause ou reprend l'activite (capture des senseurs, log, mise \u00e0 jour de l'ecran)\n     */"}}
{"code": {"body": "    private void setState(int newState) {\n        state = newState;\n        if (m_stateHistory.size() >= 3) {\n            m_stateHistory.remove(2);\n        }\n        m_stateHistory.add(0, newState);\n    }", "comment": "/*\n     * Change d'\u00e9tat en maintenant une liste des 3 derniers \u00e9tats\n     */"}}
{"code": {"body": "    private float getStepAmplitude() {\n        return m_fLastMax - m_fLastMin;\n    }", "comment": "/*\n     * V\u00e9rifie qu'une certaine amplitude a bien \u00e9t\u00e9 enregistr\u00e9e\n     * lors de la recherche des minimums et maximums locaux.\n     */"}}
{"code": {"body": "    private boolean sequenceCheck() {\n        return m_stateHistory.size() >= 3\n            && m_stateHistory.get(1) == STATE_CAPTURING\n            && m_stateHistory.get(2) == STATE_ASCENDENT;\n    }", "comment": "/*\n     * V\u00e9rifie qu'une s\u00e9quence A-C-D a bien \u00e9t\u00e9 r\u00e9alis\u00e9e.\n     */"}}
{"code": {"body": "    private void stepDetected() {\n        float stepLength = computeStepLength();\n        \n        for(IStepListener _listener : m_stepListenerList) {\n            _listener.stepDetected(stepLength);\n        }\n    }", "comment": "/*\n     * Enregistre un pas.\n     */"}}
{"code": {"body": "    private float computeStepLength() {\n        \n        \n        return CONSTANT_STEP_LENGTH;\n    }", "comment": "/*\n     * Calcule la taille du pas courant.\n     * Cette m\u00e9thode n'est sens\u00e9e \u00eatre appell\u00e9e qu'avant une transition\n     * de l'\u00e9tat final (pas d\u00e9tect\u00e9) vers l'\u00e9tat initial (phase de capture).\n     */"}}
{"code": {"body": "    public void resetHistory() {\n        m_history.clear();\n    }", "comment": "/*\n     * Remet \u00e0 z\u00e9ro l'historique de l'application.\n     */"}}
{"code": {"body": "    public void resetAll() {\n        resetHistory();\n    }", "comment": "/*\n     * Remet \u00e0 z\u00e9ro toute la m\u00e9moire de l'application.\n     */"}}
{"code": {"body": "    private float getAmplitudeMinimum() {\n        return ((m_bMultiAxis) ? AMPLITUDE_DEFAULT_MINIMUM_MULTI_AXIS : AMPLITUDE_DEFAULT_MINIMUM_1_AXIS) * m_fAmplitudeSensibility;\n    }", "comment": "/*\n     * R\u00e9cup\u00e8re l'amplitude minimale \u00e0 d\u00e9passer pour valider un pas.\n     * Prend en compte le mode de l'application (mono-axe ou multi-axe).\n     */"}}
{"code": {"body": "    private float getNegativeLimit() {\n        return ((m_bMultiAxis) ? NEGATIVE_DEFAULT_LIMIT_MULTI_AXIS : NEGATIVE_DEFAULT_LIMIT_1_AXIS) * m_fLimitSensibility;\n    }", "comment": "/*\n     * R\u00e9cup\u00e8re la borne minimale \u00e0 d\u00e9passer pour changer d'\u00e9tat.\n     * Prend en compte le mode de l'application (mono-axe ou multi-axe).\n     */"}}
{"code": {"body": "    private float getPositiveLimit() {\n        return ((m_bMultiAxis) ? POSITIVE_DEFAULT_LIMIT_MULTI_AXIS : POSITIVE_DEFAULT_LIMIT_1_AXIS) * m_fLimitSensibility;\n    }", "comment": "/*\n     * R\u00e9cup\u00e8re la borne maximale \u00e0 d\u00e9passer pour changer d'\u00e9tat.\n     * Prend en compte le mode de l'application (mono-axe ou multi-axe).\n     */"}}
{"code": {"body": "    public void addStepListener(IStepListener _listener) {\n        m_stepListenerList.add(_listener);\n    }", "comment": "/*\n     * Sp\u00e9cifie l'\u00e9couteur de pas.\n     */"}}
{"code": {"body": "    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.steplayout);\n\n        m_tvLogs         = (TextView)findViewById(R.id.tvLogs);\n        m_tvLogButton    = (TextView)findViewById(R.id.tv_log_button);\n        m_tvStepsCounter = (TextView)findViewById(R.id.tv_steps_counter);\n        m_tvAxis         = (TextView)findViewById(R.id.tv_axis);\n        m_tvLimit        = (TextView)findViewById(R.id.tv_limit);\n        m_tvAmpli        = (TextView)findViewById(R.id.tv_ampli);\n\n        m_progressBar = (ProgressBar)findViewById(R.id.progressBar);\n\n        m_stepDetector = new StepDetector(this);\n        m_stepDetector.addStepListener(this);\n\n        \n        findViewById(R.id.button_log).setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                m_stepDetector.toggleActivity(false);\n                if (m_stepDetector.getHistory().writeLogFile(TAG, LOG_DIRNAME, LOG_FILENAME, true)) {\n                    m_tvLogButton.setText(\"\");\n                } else {\n                    m_tvLogButton.setText(\"\");\n                }\n                m_stepDetector.toggleActivity(true);\n            }\n        });\n        \n        findViewById(R.id.button_reset).setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                \n                m_stepDetector.toggleActivity(false);\n                m_tvStepsCounter.setText(String.valueOf(COUNTDOWN_DURATION));\n                m_tvStepsCounter.setTextColor(Color.rgb(0, 175, 45));\n                \n                new CountDownTimer(COUNTDOWN_DURATION*1000, 500) {\n                     @Override\n                    public void onTick(long millisUntilFinished) {\n                         m_tvStepsCounter.setText(String.valueOf((int)(millisUntilFinished / 1000) + 1));\n                     }\n                     @Override\n                    public void onFinish() {\n                         m_tvStepsCounter.setText(\"\");\n                         m_tvStepsCounter.setTextColor(Color.BLACK);\n                         resetAll();\n                         m_stepDetector.toggleActivity(true);\n                         \n                         Vibrator v = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE);\n                         v.vibrate(300);\n                     }\n                  }.start();\n            }\n        });\n        mback = (Button) findViewById(R.id.title_back);\n\t\tmback.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View v)\n    \t\t{\n    \t\t\tStepMActivity.this.finish();\n    \t\t}\n\t\t});\n        findViewById(R.id.tgbtnAxis).setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                m_stepDetector.setIsMultiAxis(!m_stepDetector.getIsMultiAxis());\n                resetAll();\n            }\n        });\n        \n        \n        ((SeekBar)(findViewById(R.id.seekBarLimit))).setOnSeekBarChangeListener(new OnSeekBarChangeListener() {\n            @Override\n            public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {\n                m_stepDetector.setLimitSensibility(3.0f - (float)(progress + 1) / (float)((seekBar.getMax() + 1) / 2.0f));\n                m_tvLimit.setText(getString(R.string.limit) + \"\" + m_stepDetector.getLimitSensibility());\n            }\n            \n            @Override\n            public void onStartTrackingTouch(SeekBar seekBar) {}\n            \n            @Override\n            public void onStopTrackingTouch(SeekBar seekBar) {}\n        });\n        \n        ((SeekBar)(findViewById(R.id.seekBarAmplitude))).setOnSeekBarChangeListener(new OnSeekBarChangeListener() {\n            @Override\n            public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {\n                m_stepDetector.setAmplitudeSensibility(3.0f - (float)(progress + 1) / (float)((seekBar.getMax() + 1) / 2.0f));\n                m_tvAmpli.setText(getString(R.string.amplitude) + \"\" + m_stepDetector.getAmplitudeSensibility());\n            }\n            \n            @Override\n            public void onStartTrackingTouch(SeekBar seekBar) {}\n            \n            @Override\n            public void onStopTrackingTouch(SeekBar seekBar) {}\n        });\n        \n        \n        m_stepDetector.toggleActivity(true);\n    }", "comment": "/*\n     * Methodes de reset\n     */"}}
{"code": {"body": "            public void onClick(View v) {\n                m_stepDetector.toggleActivity(false);\n                if (m_stepDetector.getHistory().writeLogFile(TAG, LOG_DIRNAME, LOG_FILENAME, true)) {\n                    m_tvLogButton.setText(\"\");\n                } else {\n                    m_tvLogButton.setText(\"\");\n                }\n                m_stepDetector.toggleActivity(true);\n            }", "comment": "/*\n     * Methodes de reset\n     */"}}
{"code": {"body": "                    public void onTick(long millisUntilFinished) {\n                         m_tvStepsCounter.setText(String.valueOf((int)(millisUntilFinished / 1000) + 1));\n                     }", "comment": "/*\n     * Methodes de reset\n     */"}}
{"code": {"body": "                    public void onFinish() {\n                         m_tvStepsCounter.setText(\"\");\n                         m_tvStepsCounter.setTextColor(Color.BLACK);\n                         resetAll();\n                         m_stepDetector.toggleActivity(true);\n                         \n                         Vibrator v = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE);\n                         v.vibrate(300);\n                     }", "comment": "/*\n     * Methodes de reset\n     */"}}
{"code": {"body": "    private void resetStepsCounter() {\n        m_iStepsCounter = 0;\n        m_tvStepsCounter.setText(\"\");\n    }", "comment": "/*\n     * Methodes de reset\n     */"}}
{"code": {"body": "public CircleShape(Object tag, int coverColor) {\n\t\tsuper(tag, coverColor);\n\t}", "comment": "/**\n     * Set Center,radius\n     * @param coords centerX,CenterY,radius\n     */"}}
{"code": {"body": "    public static PointF scaleByPoint(float targetPointX,float targetPointY,float scaleCenterX,float scaleCenterY,float scale){\n        Matrix matrix = new Matrix();\n        \n        \n        matrix.preTranslate(targetPointX,targetPointY);\n        matrix.postScale(scale,scale,scaleCenterX,scaleCenterY);\n        float[] values = new float[9];\n        matrix.getValues(values);\n        return new PointF(values[Matrix.MTRANS_X],values[Matrix.MTRANS_Y]);\n    }", "comment": "/**\n     * Get the new position object when scaleBy with a given point.\n     * @param targetPointX the x position before scaleBy\n     * @param targetPointY the y position before scaleBy\n     * @param scaleCenterX the scaleBy point ,x position\n     * @param scaleCenterY the scaleBy point ,y position\n     * @param scale scaleBy\n     * @return the new position after scaleBy\n     */"}}
{"code": {"body": "    public static Charset toCharset(final String charset) {\n        return charset == null ? Charset.defaultCharset() : Charset.forName(charset);\n    }", "comment": "/**\n     * Returns a Charset for the named charset. If the name is null, return the default Charset.\n     *\n     * @param charset\n     *            The name of the requested charset, may be null.\n     * @return a Charset for the named charset\n     * @throws java.nio.charset.UnsupportedCharsetException\n     *             If the named charset is unavailable\n     */"}}
{"code": {"body": "public DecoderException() {\n        super();\n    }", "comment": "/**\n     * Constructs a new exception with <code>null</code> as its detail message. The cause is not initialized, and may\n     * subsequently be initialized by a call to {@link #initCause}.\n     *\n     * @since 1.4\n     */"}}
{"code": {"body": "public DecoderException(final String message) {\n        super(message);\n    }", "comment": "/**\n     * Constructs a new exception with the specified detail message. The cause is not initialized, and may subsequently\n     * be initialized by a call to {@link #initCause}.\n     *\n     * @param message\n     *            The detail message which is saved for later retrieval by the {@link #getMessage()} method.\n     */"}}
{"code": {"body": "public DecoderException(final String message, final Throwable cause) {\n        super(message, cause);\n    }", "comment": "/**\n     * Constructs a new exception with the specified detail message and cause.\n     * <p>\n     * Note that the detail message associated with <code>cause</code> is not automatically incorporated into this\n     * exception's detail message.\n     *\n     * @param message\n     *            The detail message which is saved for later retrieval by the {@link #getMessage()} method.\n     * @param cause\n     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A <code>null</code>\n     *            value is permitted, and indicates that the cause is nonexistent or unknown.\n     * @since 1.4\n     */"}}
{"code": {"body": "public DecoderException(final Throwable cause) {\n        super(cause);\n    }", "comment": "/**\n     * Constructs a new exception with the specified cause and a detail message of <code>(cause==null ?\n     * null : cause.toString())</code> (which typically contains the class and detail message of <code>cause</code>).\n     * This constructor is useful for exceptions that are little more than wrappers for other throwables.\n     *\n     * @param cause\n     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A <code>null</code>\n     *            value is permitted, and indicates that the cause is nonexistent or unknown.\n     * @since 1.4\n     */"}}
{"code": {"body": "public EncoderException() {\n        super();\n    }", "comment": "/**\n     * Constructs a new exception with <code>null</code> as its detail message. The cause is not initialized, and may\n     * subsequently be initialized by a call to {@link #initCause}.\n     *\n     * @since 1.4\n     */"}}
{"code": {"body": "public EncoderException(final String message) {\n        super(message);\n    }", "comment": "/**\n     * Constructs a new exception with the specified detail message. The cause is not initialized, and may subsequently\n     * be initialized by a call to {@link #initCause}.\n     *\n     * @param message\n     *            a useful message relating to the encoder specific error.\n     */"}}
{"code": {"body": "public EncoderException(final String message, final Throwable cause) {\n        super(message, cause);\n    }", "comment": "/**\n     * Constructs a new exception with the specified detail message and cause.\n     *\n     * <p>\n     * Note that the detail message associated with <code>cause</code> is not automatically incorporated into this\n     * exception's detail message.\n     * </p>\n     *\n     * @param message\n     *            The detail message which is saved for later retrieval by the {@link #getMessage()} method.\n     * @param cause\n     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A <code>null</code>\n     *            value is permitted, and indicates that the cause is nonexistent or unknown.\n     * @since 1.4\n     */"}}
{"code": {"body": "public EncoderException(final Throwable cause) {\n        super(cause);\n    }", "comment": "/**\n     * Constructs a new exception with the specified cause and a detail message of <code>(cause==null ?\n     * null : cause.toString())</code> (which typically contains the class and detail message of <code>cause</code>).\n     * This constructor is useful for exceptions that are little more than wrappers for other throwables.\n     *\n     * @param cause\n     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A <code>null</code>\n     *            value is permitted, and indicates that the cause is nonexistent or unknown.\n     * @since 1.4\n     */"}}
{"code": {"body": "public StringEncoderComparator(final StringEncoder stringEncoder) {\n        this.stringEncoder = stringEncoder;\n    }", "comment": "/**\n     * Constructs a new instance with the given algorithm.\n     *\n     * @param stringEncoder\n     *            the StringEncoder used for comparisons.\n     */"}}
{"code": {"body": "public Base32() {\n        this(false);\n    }", "comment": "/**\n     * Creates a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length is 0 (no chunking).\n     * </p>\n     *\n     */"}}
{"code": {"body": "public Base32(final byte pad) {\n        this(false, pad);\n    }", "comment": "/**\n     * Creates a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length is 0 (no chunking).\n     * </p>\n     * @param pad byte used as padding byte.\n     */"}}
{"code": {"body": "public Base32(final boolean useHex) {\n        this(0, null, useHex, PAD_DEFAULT);\n    }", "comment": "/**\n     * Creates a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length is 0 (no chunking).\n     * </p>\n     * @param useHex if {@code true} then use Base32 Hex alphabet\n     */"}}
{"code": {"body": "public Base32(final boolean useHex, final byte pad) {\n        this(0, null, useHex, pad);\n    }", "comment": "/**\n     * Creates a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length is 0 (no chunking).\n     * </p>\n     * @param useHex if {@code true} then use Base32 Hex alphabet\n     * @param pad byte used as padding byte.\n     */"}}
{"code": {"body": "public Base32(final int lineLength) {\n        this(lineLength, CHUNK_SEPARATOR);\n    }", "comment": "/**\n     * Creates a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length is given in the constructor, the line separator is CRLF.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     */"}}
{"code": {"body": "public Base32(final int lineLength, final byte[] lineSeparator) {\n        this(lineLength, lineSeparator, false, PAD_DEFAULT);\n    }", "comment": "/**\n     * Creates a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some Base32 characters. That's not going to work!\n     */"}}
{"code": {"body": "public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex) {\n        this(lineLength, lineSeparator, useHex, PAD_DEFAULT);\n    }", "comment": "/**\n     * Creates a Base32 / Base32 Hex codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param useHex\n     *            if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some Base32 characters. That's not going to work! Or the\n     *             lineLength &gt; 0 and lineSeparator is null.\n     */"}}
{"code": {"body": "public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex, final byte pad) {\n        super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK, lineLength,\n                lineSeparator == null ? 0 : lineSeparator.length, pad);\n        if (useHex) {\n            this.encodeTable = HEX_ENCODE_TABLE;\n            this.decodeTable = HEX_DECODE_TABLE;\n        } else {\n            this.encodeTable = ENCODE_TABLE;\n            this.decodeTable = DECODE_TABLE;\n        }\n        if (lineLength > 0) {\n            if (lineSeparator == null) {\n                throw new IllegalArgumentException(\"\" + lineLength + \"\");\n            }\n            \n            if (containsAlphabetOrPad(lineSeparator)) {\n                final String sep = StringUtils.newStringUtf8(lineSeparator);\n                throw new IllegalArgumentException(\"\" + sep + \"\");\n            }\n            this.encodeSize = BYTES_PER_ENCODED_BLOCK + lineSeparator.length;\n            this.lineSeparator = new byte[lineSeparator.length];\n            System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        } else {\n            this.encodeSize = BYTES_PER_ENCODED_BLOCK;\n            this.lineSeparator = null;\n        }\n        this.decodeSize = this.encodeSize - 1;\n\n        if (isInAlphabet(pad) || isWhiteSpace(pad)) {\n            throw new IllegalArgumentException(\"\");\n        }\n    }", "comment": "/**\n     * Creates a Base32 / Base32 Hex codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param useHex\n     *            if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet\n     * @param pad byte used as padding byte.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some Base32 characters. That's not going to work! Or the\n     *             lineLength &gt; 0 and lineSeparator is null.\n     */"}}
{"code": {"body": "public Base32InputStream(final InputStream in) {\n        this(in, false);\n    }", "comment": "/**\n     * Creates a Base32InputStream such that all data read is Base32-decoded from the original provided InputStream.\n     *\n     * @param in\n     *            InputStream to wrap.\n     */"}}
{"code": {"body": "public Base32InputStream(final InputStream in, final boolean doEncode) {\n        super(in, new Base32(false), doEncode);\n    }", "comment": "/**\n     * Creates a Base32InputStream such that all data read is either Base32-encoded or Base32-decoded from the original\n     * provided InputStream.\n     *\n     * @param in\n     *            InputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data read from us, false if we should decode.\n     */"}}
{"code": {"body": "public Base32InputStream(final InputStream in, final boolean doEncode)", "comment": "/**\n     * Creates a Base32InputStream such that all data read is either Base32-encoded or Base32-decoded from the original\n     * provided InputStream.\n     *\n     * @param in\n     *            InputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data read from us, false if we should decode.\n     */"}}
{"code": {"body": "public Base32OutputStream(final OutputStream out) {\n        this(out, true);\n    }", "comment": "/**\n     * Creates a Base32OutputStream such that all data written is Base32-encoded to the original provided OutputStream.\n     *\n     * @param out\n     *            OutputStream to wrap.\n     */"}}
{"code": {"body": "public Base32OutputStream(final OutputStream out, final boolean doEncode) {\n        super(out, new Base32(false), doEncode);\n    }", "comment": "/**\n     * Creates a Base32OutputStream such that all data written is either Base32-encoded or Base32-decoded to the\n     * original provided OutputStream.\n     *\n     * @param out\n     *            OutputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data written to us, false if we should decode.\n     */"}}
{"code": {"body": "public Base32OutputStream(final OutputStream out, final boolean doEncode)", "comment": "/**\n     * Creates a Base32OutputStream such that all data written is either Base32-encoded or Base32-decoded to the\n     * original provided OutputStream.\n     *\n     * @param out\n     *            OutputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data written to us, false if we should decode.\n     */"}}
{"code": {"body": "public Base64() {\n        this(0);\n    }", "comment": "/**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is 0 (no chunking), and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     *\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     */"}}
{"code": {"body": "public Base64(final boolean urlSafe) {\n        this(MIME_CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n    }", "comment": "/**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n     * <p>\n     * When encoding the line length is 76, the line separator is CRLF, and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     *\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     *\n     * @param urlSafe\n     *            if <code>true</code>, URL-safe encoding is used. In most cases this should be set to\n     *            <code>false</code>.\n     * @since 1.4\n     */"}}
{"code": {"body": "public Base64(final int lineLength) {\n        this(lineLength, CHUNK_SEPARATOR);\n    }", "comment": "/**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n     *            4). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     * @since 1.4\n     */"}}
{"code": {"body": "public Base64(final int lineLength, final byte[] lineSeparator) {\n        this(lineLength, lineSeparator, false);\n    }", "comment": "/**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n     *            4). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @throws IllegalArgumentException\n     *             Thrown when the provided lineSeparator included some base64 characters.\n     * @since 1.4\n     */"}}
{"code": {"body": "public Base64(final int lineLength, final byte[] lineSeparator, final boolean urlSafe) {\n        super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK,\n                lineLength,\n                lineSeparator == null ? 0 : lineSeparator.length);\n        \n        \n        if (lineSeparator != null) {\n            if (containsAlphabetOrPad(lineSeparator)) {\n                final String sep = StringUtils.newStringUtf8(lineSeparator);\n                throw new IllegalArgumentException(\"\" + sep + \"\");\n            }\n            if (lineLength > 0){ \n                this.encodeSize = BYTES_PER_ENCODED_BLOCK + lineSeparator.length;\n                this.lineSeparator = new byte[lineSeparator.length];\n                System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n            } else {\n                this.encodeSize = BYTES_PER_ENCODED_BLOCK;\n                this.lineSeparator = null;\n            }\n        } else {\n            this.encodeSize = BYTES_PER_ENCODED_BLOCK;\n            this.lineSeparator = null;\n        }\n        this.decodeSize = this.encodeSize - 1;\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n    }", "comment": "/**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n     *            4). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param urlSafe\n     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode\n     *            operations. Decoding seamlessly handles both modes.\n     *            <b>Note: no padding is added when using the URL-safe alphabet.</b>\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some base64 characters. That's not going to work!\n     * @since 1.4\n     */"}}
{"code": {"body": "    public boolean isUrlSafe() {\n        return this.encodeTable == URL_SAFE_ENCODE_TABLE;\n    }", "comment": "/**\n     * Returns our current encode mode. True if we're URL-SAFE, false otherwise.\n     *\n     * @return true if we're in URL-SAFE mode, false otherwise.\n     * @since 1.4\n     */"}}
{"code": {"body": "    public static boolean isBase64(final byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {\n                return false;\n            }\n        }\n        return true;\n    }", "comment": "/**\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the\n     * method treats whitespace as valid.\n     *\n     * @param arrayOctet\n     *            byte array to test\n     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;\n     *         <code>false</code>, otherwise\n     * @since 1.5\n     */"}}
{"code": {"body": "    public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked,\n                                      final boolean urlSafe, final int maxResultSize) {\n        if (binaryData == null || binaryData.length == 0) {\n            return binaryData;\n        }\n\n        \n        \n        final Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n        final long len = b64.getEncodedLength(binaryData);\n        if (len > maxResultSize) {\n            throw new IllegalArgumentException(\"\" +\n                len +\n                \"\" +\n                maxResultSize);\n        }\n\n        return b64.encode(binaryData);\n    }", "comment": "/**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     *\n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     *            <b>Note: no padding is added when encoding using the URL-safe alphabet.</b>\n     * @param maxResultSize\n     *            The maximum result size to accept.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than maxResultSize\n     * @since 1.4\n     */"}}
{"code": {"body": "    public static String encodeBase64String(final byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false));\n    }", "comment": "/**\n     * Encodes binary data using the base64 algorithm but does not chunk the output.\n     *\n     * NOTE:  We changed the behaviour of this method from multi-line chunking (commons-codec-1.4) to\n     * single-line non-chunking (commons-codec-1.5).\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters.\n     * @since 1.4 (NOTE:  1.4 chunked the output, whereas 1.5 does not).\n     */"}}
{"code": {"body": "    public static byte[] encodeBase64URLSafe(final byte[] binaryData) {\n        return encodeBase64(binaryData, false, true);\n    }", "comment": "/**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     * <b>Note: no padding is added.</b>\n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     * @since 1.4\n     */"}}
{"code": {"body": "    public static String encodeBase64URLSafeString(final byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n    }", "comment": "/**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     * <b>Note: no padding is added.</b>\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters\n     * @since 1.4\n     */"}}
{"code": {"body": "    public static byte[] encodeBase64Chunked(final byte[] binaryData) {\n        return encodeBase64(binaryData, true);\n    }", "comment": "/**\n     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return Base64 characters chunked in 76 character blocks\n     */"}}
{"code": {"body": "    public static byte[] decodeBase64(final byte[] base64Data) {\n        return new Base64().decode(base64Data);\n    }", "comment": "/**\n     * Decodes Base64 data into octets.\n     * <p>\n     * <b>Note:</b> this method seamlessly handles data encoded in URL-safe or normal mode.\n     * </p>\n     *\n     * @param base64Data\n     *            Byte array containing Base64 data\n     * @return Array containing decoded data.\n     */"}}
{"code": {"body": "    public static BigInteger decodeInteger(final byte[] pArray) {\n        return new BigInteger(1, decodeBase64(pArray));\n    }", "comment": "/**\n     * Decodes a byte64-encoded integer according to crypto standards such as W3C's XML-Signature.\n     *\n     * @param pArray\n     *            a byte array containing base64 character data\n     * @return A BigInteger\n     * @since 1.4\n     */"}}
{"code": {"body": "    public static byte[] encodeInteger(final BigInteger bigInt) {\n        if (bigInt == null) {\n            throw new NullPointerException(\"\");\n        }\n        return encodeBase64(toIntegerBytes(bigInt), false);\n    }", "comment": "/**\n     * Encodes to a byte64-encoded integer according to crypto standards such as W3C's XML-Signature.\n     *\n     * @param bigInt\n     *            a BigInteger\n     * @return A byte array containing base64 character data\n     * @throws NullPointerException\n     *             if null is passed in\n     * @since 1.4\n     */"}}
{"code": {"body": "    static byte[] toIntegerBytes(final BigInteger bigInt) {\n        int bitlen = bigInt.bitLength();\n        \n        bitlen = ((bitlen + 7) >> 3) << 3;\n        final byte[] bigBytes = bigInt.toByteArray();\n\n        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {\n            return bigBytes;\n        }\n        \n        int startSrc = 0;\n        int len = bigBytes.length;\n\n        \n        if ((bigInt.bitLength() % 8) == 0) {\n            startSrc = 1;\n            len--;\n        }\n        final int startDst = bitlen / 8 - len; \n        final byte[] resizedBytes = new byte[bitlen / 8];\n        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);\n        return resizedBytes;\n    }", "comment": "/**\n     * Returns a byte-array representation of a <code>BigInteger</code> without sign bit.\n     *\n     * @param bigInt\n     *            <code>BigInteger</code> to be converted\n     * @return a byte array representation of the BigInteger parameter\n     */"}}
{"code": {"body": "public Base64InputStream(final InputStream in) {\n        this(in, false);\n    }", "comment": "/**\n     * Creates a Base64InputStream such that all data read is Base64-decoded from the original provided InputStream.\n     *\n     * @param in\n     *            InputStream to wrap.\n     */"}}
{"code": {"body": "public Base64InputStream(final InputStream in, final boolean doEncode) {\n        super(in, new Base64(false), doEncode);\n    }", "comment": "/**\n     * Creates a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original\n     * provided InputStream.\n     *\n     * @param in\n     *            InputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data read from us, false if we should decode.\n     */"}}
{"code": {"body": "public Base64InputStream(final InputStream in, final boolean doEncode)", "comment": "/**\n     * Creates a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original\n     * provided InputStream.\n     *\n     * @param in\n     *            InputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data read from us, false if we should decode.\n     */"}}
{"code": {"body": "public Base64OutputStream(final OutputStream out) {\n        this(out, true);\n    }", "comment": "/**\n     * Creates a Base64OutputStream such that all data written is Base64-encoded to the original provided OutputStream.\n     *\n     * @param out\n     *            OutputStream to wrap.\n     */"}}
{"code": {"body": "public Base64OutputStream(final OutputStream out, final boolean doEncode) {\n        super(out,new Base64(false), doEncode);\n    }", "comment": "/**\n     * Creates a Base64OutputStream such that all data written is either Base64-encoded or Base64-decoded to the\n     * original provided OutputStream.\n     *\n     * @param out\n     *            OutputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data written to us, false if we should decode.\n     */"}}
{"code": {"body": "public Base64OutputStream(final OutputStream out, final boolean doEncode)", "comment": "/**\n     * Creates a Base64OutputStream such that all data written is either Base64-encoded or Base64-decoded to the\n     * original provided OutputStream.\n     *\n     * @param out\n     *            OutputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data written to us, false if we should decode.\n     */"}}
{"code": {"body": "    boolean hasData(final Context context) {  \n        return context.buffer != null;\n    }", "comment": "/**\n     * Returns true if this object has buffered data for reading.\n     *\n     * @param context the context to be used\n     * @return true if there is data still available for reading.\n     */"}}
{"code": {"body": "    int available(final Context context) {  \n        return context.buffer != null ? context.pos - context.readPos : 0;\n    }", "comment": "/**\n     * Returns the amount of buffered data available for reading.\n     *\n     * @param context the context to be used\n     * @return The amount of buffered data available for reading.\n     */"}}
{"code": {"body": "    protected int getDefaultBufferSize() {\n        return DEFAULT_BUFFER_SIZE;\n    }", "comment": "/**\n     * Get the default buffer size. Can be overridden.\n     *\n     * @return {@link #DEFAULT_BUFFER_SIZE}\n     */"}}
{"code": {"body": "    private byte[] resizeBuffer(final Context context) {\n        if (context.buffer == null) {\n            context.buffer = new byte[getDefaultBufferSize()];\n            context.pos = 0;\n            context.readPos = 0;\n        } else {\n            final byte[] b = new byte[context.buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];\n            System.arraycopy(context.buffer, 0, b, 0, context.buffer.length);\n            context.buffer = b;\n        }\n        return context.buffer;\n    }", "comment": "/**\n     * Increases our buffer by the {@link #DEFAULT_BUFFER_RESIZE_FACTOR}.\n     * @param context the context to be used\n     */"}}
{"code": {"body": "    protected byte[] ensureBufferSize(final int size, final Context context){\n        if ((context.buffer == null) || (context.buffer.length < context.pos + size)){\n            return resizeBuffer(context);\n        }\n        return context.buffer;\n    }", "comment": "/**\n     * Ensure that the buffer has room for <code>size</code> bytes\n     *\n     * @param size minimum spare space required\n     * @param context the context to be used\n     * @return the buffer\n     */"}}
{"code": {"body": "    int readResults(final byte[] b, final int bPos, final int bAvail, final Context context) {\n        if (context.buffer != null) {\n            final int len = Math.min(available(context), bAvail);\n            System.arraycopy(context.buffer, context.readPos, b, bPos, len);\n            context.readPos += len;\n            if (context.readPos >= context.pos) {\n                context.buffer = null; \n            }\n            return len;\n        }\n        return context.eof ? EOF : 0;\n    }", "comment": "/**\n     * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail\n     * bytes. Returns how many bytes were actually extracted.\n     * <p>\n     * Package protected for access from I/O streams.\n     *\n     * @param b\n     *            byte[] array to extract the buffered data into.\n     * @param bPos\n     *            position in byte[] array to start extraction at.\n     * @param bAvail\n     *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).\n     * @param context\n     *            the context to be used\n     * @return The number of bytes successfully extracted into the provided byte[] array.\n     */"}}
{"code": {"body": "    protected static boolean isWhiteSpace(final byte byteToCheck) {\n        switch (byteToCheck) {\n            case '' :\n            case '' :\n            case '' :\n            case '' :\n                return true;\n            default :\n                return false;\n        }\n    }", "comment": "/**\n     * Checks if a byte value is whitespace or not.\n     * Whitespace is taken to mean: space, tab, CR, LF\n     * @param byteToCheck\n     *            the byte to check\n     * @return true if byte is whitespace, false otherwise\n     */"}}
{"code": {"body": "    public String encodeToString(final byte[] pArray) {\n        return StringUtils.newStringUtf8(encode(pArray));\n    }", "comment": "/**\n     * Encodes a byte[] containing binary data, into a String containing characters in the Base-N alphabet.\n     * Uses UTF8 encoding.\n     *\n     * @param pArray\n     *            a byte array containing binary data\n     * @return A String containing only Base-N character data\n     */"}}
{"code": {"body": "    public String encodeAsString(final byte[] pArray){\n        return StringUtils.newStringUtf8(encode(pArray));\n    }", "comment": "/**\n     * Encodes a byte[] containing binary data, into a String containing characters in the appropriate alphabet.\n     * Uses UTF8 encoding.\n     *\n     * @param pArray a byte array containing binary data\n     * @return String containing only character data in the appropriate alphabet.\n    */"}}
{"code": {"body": "    public boolean isInAlphabet(final String basen) {\n        return isInAlphabet(StringUtils.getBytesUtf8(basen), true);\n    }", "comment": "/**\n     * Tests a given String to see if it contains only valid characters within the alphabet.\n     * The method treats whitespace and PAD as valid.\n     *\n     * @param basen String to test\n     * @return <code>true</code> if all characters in the String are valid characters in the alphabet or if\n     *         the String is empty; <code>false</code>, otherwise\n     * @see #isInAlphabet(byte[], boolean)\n     */"}}
{"code": {"body": "    protected boolean containsAlphabetOrPad(final byte[] arrayOctet) {\n        if (arrayOctet == null) {\n            return false;\n        }\n        for (final byte element : arrayOctet) {\n            if (pad == element || isInAlphabet(element)) {\n                return true;\n            }\n        }\n        return false;\n    }", "comment": "/**\n     * Tests a given byte array to see if it contains any characters within the alphabet or PAD.\n     *\n     * Intended for use in checking line-ending arrays\n     *\n     * @param arrayOctet\n     *            byte array to test\n     * @return <code>true</code> if any byte is a valid character in the alphabet or PAD; <code>false</code> otherwise\n     */"}}
{"code": {"body": "    public long getEncodedLength(final byte[] pArray) {\n        \n        \n        long len = ((pArray.length + unencodedBlockSize-1)  / unencodedBlockSize) * (long) encodedBlockSize;\n        if (lineLength > 0) { \n            \n            len += ((len + lineLength-1) / lineLength) * chunkSeparatorLength;\n        }\n        return len;\n    }", "comment": "/**\n     * Calculates the amount of space needed to encode the supplied array.\n     *\n     * @param pArray byte[] array which will later be encoded\n     *\n     * @return amount of space needed to encoded the supplied array.\n     * Returns a long since a max-len array will require &gt; Integer.MAX_VALUE\n     */"}}
{"code": {"body": "    public byte[] toByteArray(final String ascii) {\n        if (ascii == null) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        return fromAscii(ascii.toCharArray());\n    }", "comment": "/**\n     * Decodes a String where each char of the String represents an ASCII '0' or '1'.\n     *\n     * @param ascii\n     *                  String of '0' and '1' characters\n     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument\n     * @see org.apache.commons.codec.Decoder#decode(Object)\n     */"}}
{"code": {"body": "    public static byte[] fromAscii(final byte[] ascii) {\n        if (isEmpty(ascii)) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        \n        final byte[] l_raw = new byte[ascii.length >> 3];\n        \n        for (int ii = 0, jj = ascii.length - 1; ii < l_raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if (ascii[jj - bits] == '') {\n                    l_raw[ii] |= BITS[bits];\n                }\n            }\n        }\n        return l_raw;\n    }", "comment": "/**\n     * Decodes a byte array where each byte represents an ASCII '0' or '1'.\n     *\n     * @param ascii\n     *                  each byte represents an ASCII '0' or '1'\n     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument\n     */"}}
{"code": {"body": "    private static boolean isEmpty(final byte[] array) {\n        return array == null || array.length == 0;\n    }", "comment": "/**\n     * Returns <code>true</code> if the given array is <code>null</code> or empty (size 0.)\n     *\n     * @param array\n     *            the source array\n     * @return <code>true</code> if the given array is <code>null</code> or empty (size 0.)\n     */"}}
{"code": {"body": "    public static byte[] toAsciiBytes(final byte[] raw) {\n        if (isEmpty(raw)) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        \n        final byte[] l_ascii = new byte[raw.length << 3];\n        \n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\n                    l_ascii[jj - bits] = '';\n                } else {\n                    l_ascii[jj - bits] = '';\n                }\n            }\n        }\n        return l_ascii;\n    }", "comment": "/**\n     * Converts an array of raw binary data into an array of ASCII 0 and 1 character bytes - each byte is a truncated\n     * char.\n     *\n     * @param raw\n     *                  the raw binary data to convert\n     * @return an array of 0 and 1 character bytes for each bit of the argument\n     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])\n     */"}}
{"code": {"body": "    public static char[] toAsciiChars(final byte[] raw) {\n        if (isEmpty(raw)) {\n            return EMPTY_CHAR_ARRAY;\n        }\n        \n        final char[] l_ascii = new char[raw.length << 3];\n        \n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\n                    l_ascii[jj - bits] = '';\n                } else {\n                    l_ascii[jj - bits] = '';\n                }\n            }\n        }\n        return l_ascii;\n    }", "comment": "/**\n     * Converts an array of raw binary data into an array of ASCII 0 and 1 characters.\n     *\n     * @param raw\n     *                  the raw binary data to convert\n     * @return an array of 0 and 1 characters for each bit of the argument\n     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])\n     */"}}
{"code": {"body": "    public static String toAsciiString(final byte[] raw) {\n        return new String(toAsciiChars(raw));\n    }", "comment": "/**\n     * Converts an array of raw binary data into a String of ASCII 0 and 1 characters.\n     *\n     * @param raw\n     *                  the raw binary data to convert\n     * @return a String of 0 and 1 characters representing the binary data\n     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])\n     */"}}
{"code": {"body": "    static boolean regionMatches(final CharSequence cs, final boolean ignoreCase, final int thisStart,\n            final CharSequence substring, final int start, final int length) {\n        if (cs instanceof String && substring instanceof String) {\n            return ((String) cs).regionMatches(ignoreCase, thisStart, (String) substring, start, length);\n        }\n        int index1 = thisStart;\n        int index2 = start;\n        int tmpLen = length;\n\n        while (tmpLen-- > 0) {\n            char c1 = cs.charAt(index1++);\n            char c2 = substring.charAt(index2++);\n\n            if (c1 == c2) {\n                continue;\n            }\n\n            if (!ignoreCase) {\n                return false;\n            }\n\n            \n            if (Character.toUpperCase(c1) != Character.toUpperCase(c2) &&\n                    Character.toLowerCase(c1) != Character.toLowerCase(c2)) {\n                return false;\n            }\n        }\n\n        return true;\n    }", "comment": "/**\n     * Green implementation of regionMatches.\n     *\n     * @param cs\n     *            the <code>CharSequence</code> to be processed\n     * @param ignoreCase\n     *            whether or not to be case insensitive\n     * @param thisStart\n     *            the index to start on the <code>cs</code> CharSequence\n     * @param substring\n     *            the <code>CharSequence</code> to be looked for\n     * @param start\n     *            the index to start on the <code>substring</code> CharSequence\n     * @param length\n     *            character length of the region\n     * @return whether the region matched\n     */"}}
{"code": {"body": "public Hex() {\n        \n        this.charset = DEFAULT_CHARSET;\n    }", "comment": "/**\n     * Creates a new codec with the default charset name {@link #DEFAULT_CHARSET}\n     */"}}
{"code": {"body": "public Hex(final Charset charset) {\n        this.charset = charset;\n    }", "comment": "/**\n     * Creates a new codec with the given Charset.\n     *\n     * @param charset\n     *            the charset.\n     * @since 1.7\n     */"}}
{"code": {"body": "public Hex(final String charsetName) {\n        this(Charset.forName(charsetName));\n    }", "comment": "/**\n     * Creates a new codec with the given charset name.\n     *\n     * @param charsetName\n     *            the charset name.\n     * @throws java.nio.charset.UnsupportedCharsetException\n     *             If the named charset is unavailable\n     * @since 1.4\n     * @since 1.7 throws UnsupportedCharsetException if the named charset is unavailable\n     */"}}
{"code": {"body": "    public static byte[] decodeHex(final char[] data) throws DecoderException {\n\n        final int len = data.length;\n\n        if ((len & 0x01) != 0) {\n            throw new DecoderException(\"\");\n        }\n\n        final byte[] out = new byte[len >> 1];\n\n        \n        for (int i = 0, j = 0; j < len; i++) {\n            int f = toDigit(data[j], j) << 4;\n            j++;\n            f = f | toDigit(data[j], j);\n            j++;\n            out[i] = (byte) (f & 0xFF);\n        }\n\n        return out;\n    }", "comment": "/**\n     * Converts an array of characters representing hexadecimal values into an array of bytes of those same values. The\n     * returned array will be half the length of the passed array, as it takes two characters to represent any given\n     * byte. An exception is thrown if the passed char array has an odd number of elements.\n     *\n     * @param data\n     *            An array of characters containing hexadecimal digits\n     * @return A byte array containing binary data decoded from the supplied char array.\n     * @throws DecoderException\n     *             Thrown if an odd number or illegal of characters is supplied\n     */"}}
{"code": {"body": "    protected static char[] encodeHex(final byte[] data, final char[] toDigits) {\n        final int l = data.length;\n        final char[] out = new char[l << 1];\n        \n        for (int i = 0, j = 0; i < l; i++) {\n            out[j++] = toDigits[(0xF0 & data[i]) >>> 4];\n            out[j++] = toDigits[0x0F & data[i]];\n        }\n        return out;\n    }", "comment": "/**\n     * Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.\n     * The returned array will be double the length of the passed array, as it takes two characters to represent any\n     * given byte.\n     *\n     * @param data\n     *            a byte[] to convert to Hex characters\n     * @param toDigits\n     *            the output alphabet\n     * @return A char[] containing hexadecimal characters\n     * @since 1.4\n     */"}}
{"code": {"body": "    public static String encodeHexString(final byte[] data) {\n        return new String(encodeHex(data));\n    }", "comment": "/**\n     * Converts an array of bytes into a String representing the hexadecimal values of each byte in order. The returned\n     * String will be double the length of the passed array, as it takes two characters to represent any given byte.\n     *\n     * @param data\n     *            a byte[] to convert to Hex characters\n     * @return A String containing hexadecimal characters\n     * @since 1.4\n     */"}}
{"code": {"body": "    protected static int toDigit(final char ch, final int index) throws DecoderException {\n        final int digit = Character.digit(ch, 16);\n        if (digit == -1) {\n            throw new DecoderException(\"\" + ch + \"\" + index);\n        }\n        return digit;\n    }", "comment": "/**\n     * Converts a hexadecimal character to an integer.\n     *\n     * @param ch\n     *            A character to convert to an integer digit\n     * @param index\n     *            The index of the character in the source\n     * @return An integer\n     * @throws DecoderException\n     *             Thrown if ch is an illegal hex character\n     */"}}
{"code": {"body": "    public Charset getCharset() {\n        return this.charset;\n    }", "comment": "/**\n     * Gets the charset.\n     *\n     * @return the charset.\n     * @since 1.7\n     */"}}
{"code": {"body": "    public String getCharsetName() {\n        return this.charset.name();\n    }", "comment": "/**\n     * Gets the charset name.\n     *\n     * @return the charset name.\n     * @since 1.4\n     */"}}
{"code": {"body": "    public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n        if (cs1 == cs2) {\n            return true;\n        }\n        if (cs1 == null || cs2 == null) {\n            return false;\n        }\n        if (cs1 instanceof String && cs2 instanceof String) {\n            return cs1.equals(cs2);\n        }\n        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n    }", "comment": "/**\n     * <p>\n     * Compares two CharSequences, returning <code>true</code> if they represent equal sequences of characters.\n     * </p>\n     *\n     * <p>\n     * <code>null</code>s are handled without exceptions. Two <code>null</code> references are considered to be equal.\n     * The comparison is case sensitive.\n     * </p>\n     *\n     * <pre>\n     * StringUtils.equals(null, null)   = true\n     * StringUtils.equals(null, \"abc\")  = false\n     * StringUtils.equals(\"abc\", null)  = false\n     * StringUtils.equals(\"abc\", \"abc\") = true\n     * StringUtils.equals(\"abc\", \"ABC\") = false\n     * </pre>\n     *\n     * <p>\n     * Copied from Apache Commons Lang r1583482 on April 10, 2014 (day of 3.3.2 release).\n     * </p>\n     *\n     * @see Object#equals(Object)\n     * @param cs1\n     *            the first CharSequence, may be <code>null</code>\n     * @param cs2\n     *            the second CharSequence, may be <code>null</code>\n     * @return <code>true</code> if the CharSequences are equal (case-sensitive), or both <code>null</code>\n     * @since 1.10\n     */"}}
{"code": {"body": "    private static byte[] getBytes(final String string, final Charset charset) {\n        if (string == null) {\n            return null;\n        }\n        return string.getBytes(charset);\n    }", "comment": "/**\n     * Calls {@link String#getBytes(Charset)}\n     *\n     * @param string\n     *            The string to encode (if null, return null).\n     * @param charset\n     *            The {@link Charset} to encode the <code>String</code>\n     * @return the encoded bytes\n     */"}}
{"code": {"body": "    public static byte[] getBytesIso8859_1(final String string) {\n        return getBytes(string, Charsets.ISO_8859_1);\n    }", "comment": "/**\n     * Encodes the given string into a sequence of bytes using the ISO-8859-1 charset, storing the result into a new\n     * byte array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */"}}
{"code": {"body": "    public static byte[] getBytesUnchecked(final String string, final String charsetName) {\n        if (string == null) {\n            return null;\n        }\n        try {\n            return string.getBytes(charsetName);\n        } catch (final UnsupportedEncodingException e) {\n            throw StringUtils.newIllegalStateException(charsetName, e);\n        }\n    }", "comment": "/**\n     * Encodes the given string into a sequence of bytes using the named charset, storing the result into a new byte\n     * array.\n     * <p>\n     * This method catches {@link UnsupportedEncodingException} and rethrows it as {@link IllegalStateException}, which\n     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.\n     * </p>\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @param charsetName\n     *            The name of a required {@link java.nio.charset.Charset}\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws IllegalStateException\n     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a\n     *             required charset name.\n     * @see CharEncoding\n     * @see String#getBytes(String)\n     */"}}
{"code": {"body": "    public static byte[] getBytesUsAscii(final String string) {\n        return getBytes(string, Charsets.US_ASCII);\n    }", "comment": "/**\n     * Encodes the given string into a sequence of bytes using the US-ASCII charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#US_ASCII} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */"}}
{"code": {"body": "    public static byte[] getBytesUtf16(final String string) {\n        return getBytes(string, Charsets.UTF_16);\n    }", "comment": "/**\n     * Encodes the given string into a sequence of bytes using the UTF-16 charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */"}}
{"code": {"body": "    public static byte[] getBytesUtf16Be(final String string) {\n        return getBytes(string, Charsets.UTF_16BE);\n    }", "comment": "/**\n     * Encodes the given string into a sequence of bytes using the UTF-16BE charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16BE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */"}}
{"code": {"body": "    public static byte[] getBytesUtf16Le(final String string) {\n        return getBytes(string, Charsets.UTF_16LE);\n    }", "comment": "/**\n     * Encodes the given string into a sequence of bytes using the UTF-16LE charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16LE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */"}}
{"code": {"body": "    public static byte[] getBytesUtf8(final String string) {\n        return getBytes(string, Charsets.UTF_8);\n    }", "comment": "/**\n     * Encodes the given string into a sequence of bytes using the UTF-8 charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be <code>null</code>\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     */"}}
{"code": {"body": "    public static String newString(final byte[] bytes, final String charsetName) {\n        if (bytes == null) {\n            return null;\n        }\n        try {\n            return new String(bytes, charsetName);\n        } catch (final UnsupportedEncodingException e) {\n            throw StringUtils.newIllegalStateException(charsetName, e);\n        }\n    }", "comment": "/**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the given charset.\n     * <p>\n     * This method catches {@link UnsupportedEncodingException} and re-throws it as {@link IllegalStateException}, which\n     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.\n     * </p>\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters, may be <code>null</code>\n     * @param charsetName\n     *            The name of a required {@link java.nio.charset.Charset}\n     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws IllegalStateException\n     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a\n     *             required charset name.\n     * @see CharEncoding\n     * @see String#String(byte[], String)\n     */"}}
{"code": {"body": "    public static String newStringIso8859_1(final byte[] bytes) {\n        return new String(bytes, Charsets.ISO_8859_1);\n    }", "comment": "/**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters, may be <code>null</code>\n     * @return A new <code>String</code> decoded from the specified array of bytes using the ISO-8859-1 charset, or\n     *         <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */"}}
{"code": {"body": "    public static String newStringUsAscii(final byte[] bytes) {\n        return new String(bytes, Charsets.US_ASCII);\n    }", "comment": "/**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the US-ASCII charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#US_ASCII} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */"}}
{"code": {"body": "    public static String newStringUtf16(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16);\n    }", "comment": "/**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16 charset\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */"}}
{"code": {"body": "    public static String newStringUtf16Be(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16BE);\n    }", "comment": "/**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16BE charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16BE charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16BE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */"}}
{"code": {"body": "    public static String newStringUtf16Le(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16LE);\n    }", "comment": "/**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16LE charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16LE charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16LE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */"}}
{"code": {"body": "    public static String newStringUtf8(final byte[] bytes) {\n        return newString(bytes, Charsets.UTF_8);\n    }", "comment": "/**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-8 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-8 charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */"}}
{"code": {"body": "    static void b64from24bit(final byte b2, final byte b1, final byte b0, final int outLen,\n                             final StringBuilder buffer) {\n        \n        int w = ((b2 << 16) & 0x00ffffff) | ((b1 << 8) & 0x00ffff) | (b0 & 0xff);\n        \n        int n = outLen;\n        while (n-- > 0) {\n            buffer.append(B64T.charAt(w & 0x3f));\n            w >>= 6;\n        }\n    }", "comment": "/**\n     * Base64 like conversion of bytes to ASCII chars.\n     *\n     * @param b2\n     *            A byte from the result.\n     * @param b1\n     *            A byte from the result.\n     * @param b0\n     *            A byte from the result.\n     * @param outLen\n     *            The number of expected output chars.\n     * @param buffer\n     *            Where the output chars is appended to.\n     */"}}
{"code": {"body": "    static String getRandomSalt(final int num) {\n        final StringBuilder saltString = new StringBuilder();\n        for (int i = 1; i <= num; i++) {\n            saltString.append(B64T.charAt(new Random().nextInt(B64T.length())));\n        }\n        return saltString.toString();\n    }", "comment": "/**\n     * Generates a string of random chars from the B64T set.\n     *\n     * @param num\n     *            Number of chars to generate.\n     */"}}
{"code": {"body": "    public static String crypt(final String key, final String salt) {\n        return crypt(key.getBytes(Charsets.UTF_8), salt);\n    }", "comment": "/**\n     * Encrypts a password in a crypt(3) compatible way.\n     * <p>\n     * The exact algorithm depends on the format of the salt string:\n     * <ul>\n     * <li>SHA-512 salts start with {@code $6$} and are up to 16 chars long.\n     * <li>SHA-256 salts start with {@code $5$} and are up to 16 chars long\n     * <li>MD5 salts start with {@code $1$} and are up to 8 chars long\n     * <li>DES, the traditional UnixCrypt algorithm is used with only 2 chars\n     * <li>Only the first 8 chars of the passwords are used in the DES algorithm!\n     * </ul>\n     * The magic strings {@code \"$apr1$\"} and {@code \"$2a$\"} are not recognized by this method as its output should be\n     * identical with that of the libc implementation.\n     * <p>\n     * The rest of the salt string is drawn from the set {@code [a-zA-Z0-9./]} and is cut at the maximum length of if a\n     * {@code \"$\"} sign is encountered. It is therefore valid to enter a complete hash value as salt to e.g. verify a\n     * password with:\n     *\n     * <pre>\n     * storedPwd.equals(crypt(enteredPwd, storedPwd))\n     * </pre>\n     * <p>\n     * The resulting string starts with the marker string ({@code $6$}), continues with the salt value and ends with a\n     * {@code \"$\"} sign followed by the actual hash value. For DES the string only contains the salt and actual hash.\n     * It's total length is dependent on the algorithm used:\n     * <ul>\n     * <li>SHA-512: 106 chars\n     * <li>SHA-256: 63 chars\n     * <li>MD5: 34 chars\n     * <li>DES: 13 chars\n     * </ul>\n     * <p>\n     * Example:\n     *\n     * <pre>\n     *      crypt(\"secret\", \"$1$xxxx\") =&gt; \"$1$xxxx$aMkevjfEIpa35Bh3G4bAc.\"\n     *      crypt(\"secret\", \"xx\") =&gt; \"xxWAum7tHdIUw\"\n     * </pre>\n     * <p>\n     * This method comes in a variation that accepts a byte[] array to support input strings that are not encoded in\n     * UTF-8 but e.g. in ISO-8859-1 where equal characters result in different byte values.\n     *\n     * @see \"The man page of the libc crypt (3) function.\"\n     * @param key\n     *            plaintext password as entered by the used\n     * @param salt\n     *            salt value\n     * @return hash value, i.e. encrypted password including the salt string\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     * @throws RuntimeException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught. *\n     */"}}
{"code": {"body": "    private static byte[] digest(final MessageDigest digest, final InputStream data) throws IOException {\n        return updateDigest(digest, data).digest();\n    }", "comment": "/**\n     * Read through an InputStream and returns the digest for the data\n     *\n     * @param digest\n     *            The MessageDigest to use (e.g. MD5)\n     * @param data\n     *            Data to digest\n     * @return the digest\n     * @throws IOException\n     *             On error reading from the stream\n     */"}}
{"code": {"body": "    public static MessageDigest getDigest(final String algorithm) {\n        try {\n            return MessageDigest.getInstance(algorithm);\n        } catch (final NoSuchAlgorithmException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }", "comment": "/**\n     * Returns a <code>MessageDigest</code> for the given <code>algorithm</code>.\n     *\n     * @param algorithm\n     *            the name of the algorithm requested. See <a\n     *            href=\"http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA\"\n     *            >Appendix A in the Java Cryptography Architecture Reference Guide</a> for information about standard\n     *            algorithm names.\n     * @return A digest instance.\n     * @see MessageDigest#getInstance(String)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught.\n     */"}}
{"code": {"body": "    public static MessageDigest getMd2Digest() {\n        return getDigest(MessageDigestAlgorithms.MD2);\n    }", "comment": "/**\n     * Returns an MD2 MessageDigest.\n     *\n     * @return An MD2 digest instance.\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught, which should never happen because MD2 is a\n     *             built-in algorithm\n     * @see MessageDigestAlgorithms#MD2\n     * @since 1.7\n     */"}}
{"code": {"body": "    public static MessageDigest getMd5Digest() {\n        return getDigest(MessageDigestAlgorithms.MD5);\n    }", "comment": "/**\n     * Returns an MD5 MessageDigest.\n     *\n     * @return An MD5 digest instance.\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught, which should never happen because MD5 is a\n     *             built-in algorithm\n     * @see MessageDigestAlgorithms#MD5\n     */"}}
{"code": {"body": "    public static MessageDigest getSha1Digest() {\n        return getDigest(MessageDigestAlgorithms.SHA_1);\n    }", "comment": "/**\n     * Returns an SHA-1 digest.\n     *\n     * @return An SHA-1 digest instance.\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught, which should never happen because SHA-1 is a\n     *             built-in algorithm\n     * @see MessageDigestAlgorithms#SHA_1\n     * @since 1.7\n     */"}}
{"code": {"body": "    public static MessageDigest getSha256Digest() {\n        return getDigest(MessageDigestAlgorithms.SHA_256);\n    }", "comment": "/**\n     * Returns an SHA-256 digest.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @return An SHA-256 digest instance.\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught, which should never happen because SHA-256 is a\n     *             built-in algorithm\n     * @see MessageDigestAlgorithms#SHA_256\n     */"}}
{"code": {"body": "    public static MessageDigest getSha384Digest() {\n        return getDigest(MessageDigestAlgorithms.SHA_384);\n    }", "comment": "/**\n     * Returns an SHA-384 digest.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @return An SHA-384 digest instance.\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught, which should never happen because SHA-384 is a\n     *             built-in algorithm\n     * @see MessageDigestAlgorithms#SHA_384\n     */"}}
{"code": {"body": "    public static MessageDigest getSha512Digest() {\n        return getDigest(MessageDigestAlgorithms.SHA_512);\n    }", "comment": "/**\n     * Returns an SHA-512 digest.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @return An SHA-512 digest instance.\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught, which should never happen because SHA-512 is a\n     *             built-in algorithm\n     * @see MessageDigestAlgorithms#SHA_512\n     */"}}
{"code": {"body": "    public static byte[] md2(final String data) {\n        return md2(StringUtils.getBytesUtf8(data));\n    }", "comment": "/**\n     * Calculates the MD2 digest and returns the value as a 16 element <code>byte[]</code>.\n     *\n     * @param data\n     *            Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return MD2 digest\n     * @since 1.7\n     */"}}
{"code": {"body": "    public static String md2Hex(final String data) {\n        return Hex.encodeHexString(md2(data));\n    }", "comment": "/**\n     * Calculates the MD2 digest and returns the value as a 32 character hex string.\n     *\n     * @param data\n     *            Data to digest\n     * @return MD2 digest as a hex string\n     * @since 1.7\n     */"}}
{"code": {"body": "    public static byte[] md5(final String data) {\n        return md5(StringUtils.getBytesUtf8(data));\n    }", "comment": "/**\n     * Calculates the MD5 digest and returns the value as a 16 element <code>byte[]</code>.\n     *\n     * @param data\n     *            Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return MD5 digest\n     */"}}
{"code": {"body": "    public static String md5Hex(final String data) {\n        return Hex.encodeHexString(md5(data));\n    }", "comment": "/**\n     * Calculates the MD5 digest and returns the value as a 32 character hex string.\n     *\n     * @param data\n     *            Data to digest\n     * @return MD5 digest as a hex string\n     */"}}
{"code": {"body": "    public static byte[] sha1(final String data) {\n        return sha1(StringUtils.getBytesUtf8(data));\n    }", "comment": "/**\n     * Calculates the SHA-1 digest and returns the value as a <code>byte[]</code>.\n     *\n     * @param data\n     *            Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return SHA-1 digest\n     */"}}
{"code": {"body": "    public static String sha1Hex(final String data) {\n        return Hex.encodeHexString(sha1(data));\n    }", "comment": "/**\n     * Calculates the SHA-1 digest and returns the value as a hex string.\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-1 digest as a hex string\n     * @since 1.7\n     */"}}
{"code": {"body": "    public static byte[] sha256(final String data) {\n        return sha256(StringUtils.getBytesUtf8(data));\n    }", "comment": "/**\n     * Calculates the SHA-256 digest and returns the value as a <code>byte[]</code>.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return SHA-256 digest\n     * @since 1.4\n     */"}}
{"code": {"body": "    public static String sha256Hex(final String data) {\n        return Hex.encodeHexString(sha256(data));\n    }", "comment": "/**\n     * Calculates the SHA-256 digest and returns the value as a hex string.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-256 digest as a hex string\n     * @since 1.4\n     */"}}
{"code": {"body": "    public static byte[] sha384(final String data) {\n        return sha384(StringUtils.getBytesUtf8(data));\n    }", "comment": "/**\n     * Calculates the SHA-384 digest and returns the value as a <code>byte[]</code>.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return SHA-384 digest\n     * @since 1.4\n     */"}}
{"code": {"body": "    public static String sha384Hex(final String data) {\n        return Hex.encodeHexString(sha384(data));\n    }", "comment": "/**\n     * Calculates the SHA-384 digest and returns the value as a hex string.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-384 digest as a hex string\n     * @since 1.4\n     */"}}
{"code": {"body": "    public static byte[] sha512(final String data) {\n        return sha512(StringUtils.getBytesUtf8(data));\n    }", "comment": "/**\n     * Calculates the SHA-512 digest and returns the value as a <code>byte[]</code>.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return SHA-512 digest\n     * @since 1.4\n     */"}}
{"code": {"body": "    public static String sha512Hex(final String data) {\n        return Hex.encodeHexString(sha512(data));\n    }", "comment": "/**\n     * Calculates the SHA-512 digest and returns the value as a hex string.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-512 digest as a hex string\n     * @since 1.4\n     */"}}
{"code": {"body": "    public static MessageDigest updateDigest(final MessageDigest messageDigest, final String valueToDigest) {\n        messageDigest.update(StringUtils.getBytesUtf8(valueToDigest));\n        return messageDigest;\n    }", "comment": "/**\n     * Updates the given {@link MessageDigest}.\n     *\n     * @param messageDigest\n     *            the {@link MessageDigest} to update\n     * @param valueToDigest\n     *            the value to update the {@link MessageDigest} with;\n     *            converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return the updated {@link MessageDigest}\n     * @since 1.7\n     */"}}
{"code": {"body": "    public static Mac getHmacMd5(final byte[] key) {\n        return getInitializedMac(HmacAlgorithms.HMAC_MD5, key);\n    }", "comment": "/**\n     * Returns an initialized <code>Mac</code> for the HmacMD5 algorithm.\n     * <p>\n     * Every implementation of the Java platform is required to support this standard Mac algorithm.\n     * </p>\n     *\n     * @param key\n     *            They key for the keyed digest (must not be null)\n     * @return A Mac instance initialized with the given key.\n     * @see Mac#getInstance(String)\n     * @see Mac#init(Key)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     */"}}
{"code": {"body": "    public static Mac getHmacSha1(final byte[] key) {\n        return getInitializedMac(HmacAlgorithms.HMAC_SHA_1, key);\n    }", "comment": "/**\n     * Returns an initialized <code>Mac</code> for the HmacSHA1 algorithm.\n     * <p>\n     * Every implementation of the Java platform is required to support this standard Mac algorithm.\n     * </p>\n     *\n     * @param key\n     *            They key for the keyed digest (must not be null)\n     * @return A Mac instance initialized with the given key.\n     * @see Mac#getInstance(String)\n     * @see Mac#init(Key)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     */"}}
{"code": {"body": "    public static Mac getHmacSha256(final byte[] key) {\n        return getInitializedMac(HmacAlgorithms.HMAC_SHA_256, key);\n    }", "comment": "/**\n     * Returns an initialized <code>Mac</code> for the HmacSHA256 algorithm.\n     * <p>\n     * Every implementation of the Java platform is required to support this standard Mac algorithm.\n     * </p>\n     *\n     * @param key\n     *            They key for the keyed digest (must not be null)\n     * @return A Mac instance initialized with the given key.\n     * @see Mac#getInstance(String)\n     * @see Mac#init(Key)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     */"}}
{"code": {"body": "    public static Mac getHmacSha384(final byte[] key) {\n        return getInitializedMac(HmacAlgorithms.HMAC_SHA_384, key);\n    }", "comment": "/**\n     * Returns an initialized <code>Mac</code> for the HmacSHA384 algorithm.\n     * <p>\n     * Every implementation of the Java platform is <em>not</em> required to support this Mac algorithm.\n     * </p>\n     *\n     * @param key\n     *            They key for the keyed digest (must not be null)\n     * @return A Mac instance initialized with the given key.\n     * @see Mac#getInstance(String)\n     * @see Mac#init(Key)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     */"}}
{"code": {"body": "    public static Mac getHmacSha512(final byte[] key) {\n        return getInitializedMac(HmacAlgorithms.HMAC_SHA_512, key);\n    }", "comment": "/**\n     * Returns an initialized <code>Mac</code> for the HmacSHA512 algorithm.\n     * <p>\n     * Every implementation of the Java platform is <em>not</em> required to support this Mac algorithm.\n     * </p>\n     *\n     * @param key\n     *            They key for the keyed digest (must not be null)\n     * @return A Mac instance initialized with the given key.\n     * @see Mac#getInstance(String)\n     * @see Mac#init(Key)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     */"}}
{"code": {"body": "    public static Mac getInitializedMac(final String algorithm, final byte[] key) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n\n        try {\n            final SecretKeySpec keySpec = new SecretKeySpec(key, algorithm);\n            final Mac mac = Mac.getInstance(algorithm);\n            mac.init(keySpec);\n            return mac;\n        } catch (final NoSuchAlgorithmException e) {\n            throw new IllegalArgumentException(e);\n        } catch (final InvalidKeyException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }", "comment": "/**\n     * Returns an initialized <code>Mac</code> for the given <code>algorithm</code>.\n     *\n     * @param algorithm\n     *            the name of the algorithm requested. See <a href=\n     *            \"http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA\" >Appendix\n     *            A in the Java Cryptography Architecture Reference Guide</a> for information about standard algorithm\n     *            names.\n     * @param key\n     *            They key for the keyed digest (must not be null)\n     * @return A Mac instance initialized with the given key.\n     * @see Mac#getInstance(String)\n     * @see Mac#init(Key)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     */"}}
{"code": {"body": "    public static byte[] hmacMd5(final String key, final String valueToDigest) {\n        return hmacMd5(StringUtils.getBytesUtf8(key), StringUtils.getBytesUtf8(valueToDigest));\n    }", "comment": "/**\n     * Returns a HmacMD5 Message Authentication Code (MAC) for the given key and value.\n     *\n     * @param key\n     *            They key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacMD5 MAC for the given key and value\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     */"}}
{"code": {"body": "    public static String hmacMd5Hex(final String key, final String valueToDigest) {\n        return Hex.encodeHexString(hmacMd5(key, valueToDigest));\n    }", "comment": "/**\n     * Returns a HmacMD5 Message Authentication Code (MAC) as a hex string (lowercase) for the given key and value.\n     *\n     * @param key\n     *            They key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacMD5 MAC for the given key and value as a hex string (lowercase)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     */"}}
{"code": {"body": "    public static byte[] hmacSha1(final String key, final String valueToDigest) {\n        return hmacSha1(StringUtils.getBytesUtf8(key), StringUtils.getBytesUtf8(valueToDigest));\n    }", "comment": "/**\n     * Returns a HmacSHA1 Message Authentication Code (MAC) for the given key and value.\n     *\n     * @param key\n     *            They key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA1 MAC for the given key and value\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     */"}}
{"code": {"body": "    public static String hmacSha1Hex(final String key, final String valueToDigest) {\n        return Hex.encodeHexString(hmacSha1(key, valueToDigest));\n    }", "comment": "/**\n     * Returns a HmacSHA1 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\n     *\n     * @param key\n     *            They key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA1 MAC for the given key and value as hex string (lowercase)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     */"}}
{"code": {"body": "    public static byte[] hmacSha256(final String key, final String valueToDigest) {\n        return hmacSha256(StringUtils.getBytesUtf8(key), StringUtils.getBytesUtf8(valueToDigest));\n    }", "comment": "/**\n     * Returns a HmacSHA256 Message Authentication Code (MAC) for the given key and value.\n     *\n     * @param key\n     *            They key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA256 MAC for the given key and value\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     */"}}
{"code": {"body": "    public static String hmacSha256Hex(final String key, final String valueToDigest) {\n        return Hex.encodeHexString(hmacSha256(key, valueToDigest));\n    }", "comment": "/**\n     * Returns a HmacSHA256 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\n     *\n     * @param key\n     *            They key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA256 MAC for the given key and value as hex string (lowercase)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     */"}}
{"code": {"body": "    public static byte[] hmacSha384(final String key, final String valueToDigest) {\n        return hmacSha384(StringUtils.getBytesUtf8(key), StringUtils.getBytesUtf8(valueToDigest));\n    }", "comment": "/**\n     * Returns a HmacSHA384 Message Authentication Code (MAC) for the given key and value.\n     *\n     * @param key\n     *            They key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA384 MAC for the given key and value\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     */"}}
{"code": {"body": "    public static String hmacSha384Hex(final String key, final String valueToDigest) {\n        return Hex.encodeHexString(hmacSha384(key, valueToDigest));\n    }", "comment": "/**\n     * Returns a HmacSHA384 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\n     *\n     * @param key\n     *            They key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA384 MAC for the given key and value as hex string (lowercase)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     */"}}
{"code": {"body": "    public static byte[] hmacSha512(final String key, final String valueToDigest) {\n        return hmacSha512(StringUtils.getBytesUtf8(key), StringUtils.getBytesUtf8(valueToDigest));\n    }", "comment": "/**\n     * Returns a HmacSHA512 Message Authentication Code (MAC) for the given key and value.\n     *\n     * @param key\n     *            They key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA512 MAC for the given key and value\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     */"}}
{"code": {"body": "    public static String hmacSha512Hex(final String key, final String valueToDigest) {\n        return Hex.encodeHexString(hmacSha512(key, valueToDigest));\n    }", "comment": "/**\n     * Returns a HmacSHA512 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\n     *\n     * @param key\n     *            They key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA512 MAC for the given key and value as hex string (lowercase)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     */"}}
{"code": {"body": "    public static Mac updateHmac(final Mac mac, final String valueToDigest) {\n        mac.reset();\n        mac.update(StringUtils.getBytesUtf8(valueToDigest));\n        return mac;\n    }", "comment": "/**\n     * Updates the given {@link Mac}. This generates a digest for valueToDigest and the key the Mac was initialized\n     *\n     * @param mac\n     *            the initialized {@link Mac} to update\n     * @param valueToDigest\n     *            the value to update the {@link Mac} with (maybe null or empty)\n     * @return the updated {@link Mac}\n     * @throws IllegalStateException\n     *             if the Mac was not initialized\n     * @since 1.x\n     */"}}
{"code": {"body": "    public static String apr1Crypt(final String keyBytes, final String salt) {\n        return apr1Crypt(keyBytes.getBytes(Charsets.UTF_8), salt);\n    }", "comment": "/**\n     * Generates an Apache htpasswd compatible \"$apr1$\" MD5 based hash value.\n     * <p>\n     * The algorithm is identical to the crypt(3) \"$1$\" one but produces different outputs due to the different salt\n     * prefix.\n     *\n     * @param keyBytes\n     *            plaintext string to hash.\n     * @param salt\n     *            salt string including the prefix and optionally garbage at the end. Will be generated randomly if\n     *            null.\n     * @return the hash value\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     * @throws RuntimeException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     */"}}
{"code": {"body": "    public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) {\n        final int keyLen = keyBytes.length;\n\n        \n        String saltString;\n        if (salt == null) {\n            saltString = B64.getRandomSalt(8);\n        } else {\n            final Pattern p = Pattern.compile(\"\" + prefix.replace(\"\", \"\") + \"\");\n            final Matcher m = p.matcher(salt);\n            if (m == null || !m.find()) {\n                throw new IllegalArgumentException(\"\" + salt);\n            }\n            saltString = m.group(1);\n        }\n        final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);\n\n        final MessageDigest ctx = DigestUtils.getMd5Digest();\n\n        \n        ctx.update(keyBytes);\n\n        \n        ctx.update(prefix.getBytes(Charsets.UTF_8));\n\n        \n        ctx.update(saltBytes);\n\n        \n        MessageDigest ctx1 = DigestUtils.getMd5Digest();\n        ctx1.update(keyBytes);\n        ctx1.update(saltBytes);\n        ctx1.update(keyBytes);\n        byte[] finalb = ctx1.digest();\n        int ii = keyLen;\n        while (ii > 0) {\n            ctx.update(finalb, 0, ii > 16 ? 16 : ii);\n            ii -= 16;\n        }\n\n        \n        Arrays.fill(finalb, (byte) 0);\n\n        \n        ii = keyLen;\n        final int j = 0;\n        while (ii > 0) {\n            if ((ii & 1) == 1) {\n                ctx.update(finalb[j]);\n            } else {\n                ctx.update(keyBytes[j]);\n            }\n            ii >>= 1;\n        }\n\n        \n        final StringBuilder passwd = new StringBuilder(prefix + saltString + \"\");\n        finalb = ctx.digest();\n\n        \n        for (int i = 0; i < ROUNDS; i++) {\n            ctx1 = DigestUtils.getMd5Digest();\n            if ((i & 1) != 0) {\n                ctx1.update(keyBytes);\n            } else {\n                ctx1.update(finalb, 0, BLOCKSIZE);\n            }\n\n            if (i % 3 != 0) {\n                ctx1.update(saltBytes);\n            }\n\n            if (i % 7 != 0) {\n                ctx1.update(keyBytes);\n            }\n\n            if ((i & 1) != 0) {\n                ctx1.update(finalb, 0, BLOCKSIZE);\n            } else {\n                ctx1.update(keyBytes);\n            }\n            finalb = ctx1.digest();\n        }\n\n        \n        \n        \n        B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);\n        B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);\n        B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);\n        B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);\n        B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);\n        B64.b64from24bit((byte) 0, (byte) 0, finalb[11], 2, passwd);\n\n        \n        \n        ctx.reset();\n        ctx1.reset();\n        Arrays.fill(keyBytes, (byte) 0);\n        Arrays.fill(saltBytes, (byte) 0);\n        Arrays.fill(finalb, (byte) 0);\n\n        return passwd.toString();\n    }", "comment": "/**\n     * Generates a libc6 crypt() \"$1$\" or Apache htpasswd \"$apr1$\" hash value.\n     * <p>\n     * See {@link Crypt#crypt(String, String)} or {@link #apr1Crypt(String, String)} for details.\n     *\n     * @param keyBytes\n     *            plaintext string to hash.\n     * @param salt May be null.\n     * @param prefix salt prefix\n     * @return the hash value\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     * @throws RuntimeException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     */"}}
{"code": {"body": "    public static String sha256Crypt(final byte[] keyBytes, String salt) {\n        if (salt == null) {\n            salt = SHA256_PREFIX + B64.getRandomSalt(8);\n        }\n        return sha2Crypt(keyBytes, salt, SHA256_PREFIX, SHA256_BLOCKSIZE, MessageDigestAlgorithms.SHA_256);\n    }", "comment": "/**\n     * Generates a libc6 crypt() compatible \"$5$\" hash value.\n     * <p>\n     * See {@link Crypt#crypt(String, String)} for details.\n     *\n     * @param keyBytes\n     *            plaintext to hash\n     * @param salt\n     *            real salt value without prefix or \"rounds=\"\n     * @return complete hash value including salt\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     * @throws RuntimeException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     */"}}
{"code": {"body": "    private static String sha2Crypt(final byte[] keyBytes, final String salt, final String saltPrefix,\n            final int blocksize, final String algorithm) {\n\n        final int keyLen = keyBytes.length;\n\n        \n        int rounds = ROUNDS_DEFAULT;\n        boolean roundsCustom = false;\n        if (salt == null) {\n            throw new IllegalArgumentException(\"\");\n        }\n\n        final Matcher m = SALT_PATTERN.matcher(salt);\n        if (m == null || !m.find()) {\n            throw new IllegalArgumentException(\"\" + salt);\n        }\n        if (m.group(3) != null) {\n            rounds = Integer.parseInt(m.group(3));\n            rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));\n            roundsCustom = true;\n        }\n        final String saltString = m.group(4);\n        final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);\n        final int saltLen = saltBytes.length;\n\n        \n        \n        MessageDigest ctx = DigestUtils.getDigest(algorithm);\n\n        \n        \n        ctx.update(keyBytes);\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ctx.update(saltBytes);\n\n        \n        \n        MessageDigest altCtx = DigestUtils.getDigest(algorithm);\n\n        \n        \n        altCtx.update(keyBytes);\n\n        \n        \n        altCtx.update(saltBytes);\n\n        \n        \n        altCtx.update(keyBytes);\n\n        \n        \n        byte[] altResult = altCtx.digest();\n\n        \n        \n        \n        \n        int cnt = keyBytes.length;\n        while (cnt > blocksize) {\n            ctx.update(altResult, 0, blocksize);\n            cnt -= blocksize;\n        }\n\n        \n        \n        ctx.update(altResult, 0, cnt);\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        cnt = keyBytes.length;\n        while (cnt > 0) {\n            if ((cnt & 1) != 0) {\n                ctx.update(altResult, 0, blocksize);\n            } else {\n                ctx.update(keyBytes);\n            }\n            cnt >>= 1;\n        }\n\n        \n        \n        altResult = ctx.digest();\n\n        \n        \n        altCtx = DigestUtils.getDigest(algorithm);\n\n        \n        \n        \n        \n        \n        for (int i = 1; i <= keyLen; i++) {\n            altCtx.update(keyBytes);\n        }\n\n        \n        \n        byte[] tempResult = altCtx.digest();\n\n        \n        \n        \n        \n        \n        \n        \n        \n        final byte[] pBytes = new byte[keyLen];\n        int cp = 0;\n        while (cp < keyLen - blocksize) {\n            System.arraycopy(tempResult, 0, pBytes, cp, blocksize);\n            cp += blocksize;\n        }\n        System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);\n\n        \n        \n        altCtx = DigestUtils.getDigest(algorithm);\n\n        \n        \n        \n        \n        \n        for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {\n            altCtx.update(saltBytes);\n        }\n\n        \n        \n        tempResult = altCtx.digest();\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        final byte[] sBytes = new byte[saltLen];\n        cp = 0;\n        while (cp < saltLen - blocksize) {\n            System.arraycopy(tempResult, 0, sBytes, cp, blocksize);\n            cp += blocksize;\n        }\n        System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        for (int i = 0; i <= rounds - 1; i++) {\n            \n            \n            ctx = DigestUtils.getDigest(algorithm);\n\n            \n            \n            \n            if ((i & 1) != 0) {\n                ctx.update(pBytes, 0, keyLen);\n            } else {\n                ctx.update(altResult, 0, blocksize);\n            }\n\n            \n            \n            if (i % 3 != 0) {\n                ctx.update(sBytes, 0, saltLen);\n            }\n\n            \n            \n            if (i % 7 != 0) {\n                ctx.update(pBytes, 0, keyLen);\n            }\n\n            \n            \n            \n            if ((i & 1) != 0) {\n                ctx.update(altResult, 0, blocksize);\n            } else {\n                ctx.update(pBytes, 0, keyLen);\n            }\n\n            \n            \n            altResult = ctx.digest();\n        }\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        final StringBuilder buffer = new StringBuilder(saltPrefix);\n        if (roundsCustom) {\n            buffer.append(ROUNDS_PREFIX);\n            buffer.append(rounds);\n            buffer.append(\"\");\n        }\n        buffer.append(saltString);\n        buffer.append(\"\");\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        \n        \n\n        if (blocksize == 32) {\n            B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);\n            B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);\n            B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);\n            B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);\n            B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);\n            B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);\n            B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);\n            B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);\n            B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);\n            B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);\n            B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);\n        } else {\n            B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);\n            B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);\n            B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);\n            B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);\n            B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);\n            B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);\n            B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);\n            B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);\n            B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);\n            B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);\n            B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);\n            B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);\n            B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);\n            B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);\n            B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);\n            B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);\n            B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);\n            B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);\n            B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);\n            B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);\n            B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);\n            B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);\n        }\n\n        \n        \n        Arrays.fill(tempResult, (byte) 0);\n        Arrays.fill(pBytes, (byte) 0);\n        Arrays.fill(sBytes, (byte) 0);\n        ctx.reset();\n        altCtx.reset();\n        Arrays.fill(keyBytes, (byte) 0);\n        Arrays.fill(saltBytes, (byte) 0);\n\n        return buffer.toString();\n    }", "comment": "/**\n     * Generates a libc6 crypt() compatible \"$5$\" or \"$6$\" SHA2 based hash value.\n     * <p>\n     * This is a nearly line by line conversion of the original C function. The numbered comments are from the algorithm\n     * description, the short C-style ones from the original C code and the ones with \"Remark\" from me.\n     * <p>\n     * See {@link Crypt#crypt(String, String)} for details.\n     *\n     * @param keyBytes\n     *            plaintext to hash\n     * @param salt\n     *            real salt value without prefix or \"rounds=\"\n     * @param saltPrefix\n     *            either $5$ or $6$\n     * @param blocksize\n     *            a value that differs between $5$ and $6$\n     * @param algorithm\n     *            {@link MessageDigest} algorithm identifier string\n     * @return complete hash value including prefix and salt\n     * @throws IllegalArgumentException\n     *             if the given salt is <code>null</code> or does not match the allowed pattern\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught\n     * @see MessageDigestAlgorithms\n     */"}}
{"code": {"body": "    public static String sha512Crypt(final byte[] keyBytes, String salt) {\n        if (salt == null) {\n            salt = SHA512_PREFIX + B64.getRandomSalt(8);\n        }\n        return sha2Crypt(keyBytes, salt, SHA512_PREFIX, SHA512_BLOCKSIZE, MessageDigestAlgorithms.SHA_512);\n    }", "comment": "/**\n     * Generates a libc6 crypt() compatible \"$6$\" hash value.\n     * <p>\n     * See {@link Crypt#crypt(String, String)} for details.\n     *\n     * @param keyBytes\n     *            plaintext to hash\n     * @param salt\n     *            real salt value without prefix or \"rounds=\"\n     * @return complete hash value including salt\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     * @throws RuntimeException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     */"}}
{"code": {"body": "    public static String crypt(final String original, final String salt) {\n        return crypt(original.getBytes(Charsets.UTF_8), salt);\n    }", "comment": "/**\n     * Generates a crypt(3) compatible hash using the DES algorithm.\n     *\n     * @param original\n     *            plaintext password\n     * @param salt\n     *            a two character string drawn from [a-zA-Z0-9./] or null for a random one\n     * @return a 13 character string starting with the salt string\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     */"}}
{"code": {"body": "public AbstractCaverphone() {\n        super();\n    }", "comment": "/**\n     * Creates an instance of the Caverphone encoder\n     */"}}
{"code": {"body": "    public boolean isEncodeEqual(final String str1, final String str2) throws EncoderException {\n        return this.encode(str1).equals(this.encode(str2));\n    }", "comment": "/**\n     * Tests if the encodings of two strings are equal.\n     *\n     * This method might be promoted to a new AbstractStringEncoder superclass.\n     *\n     * @param str1\n     *            First of two strings to compare\n     * @param str2\n     *            Second of two strings to compare\n     * @return <code>true</code> if the encodings of these strings are identical, <code>false</code> otherwise.\n     * @throws EncoderException\n     *             thrown if there is an error condition during the encoding process.\n     */"}}
{"code": {"body": "public Caverphone() {\n        super();\n    }", "comment": "/**\n     * Creates an instance of the Caverphone encoder\n     */"}}
{"code": {"body": "    public String caverphone(final String source) {\n        return this.encoder.encode(source);\n    }", "comment": "/**\n     * Encodes the given String into a Caverphone value.\n     *\n     * @param source\n     *            String the source string\n     * @return A caverphone code for the given String\n     */"}}
{"code": {"body": "    public boolean isCaverphoneEqual(final String str1, final String str2) {\n        return this.caverphone(str1).equals(this.caverphone(str2));\n    }", "comment": "/**\n     * Tests if the caverphones of two strings are identical.\n     *\n     * @param str1\n     *            First of two strings to compare\n     * @param str2\n     *            Second of two strings to compare\n     * @return <code>true</code> if the caverphones of these strings are identical, <code>false</code> otherwise.\n     */"}}
{"code": {"body": "    private static boolean arrayContains(final char[] arr, final char key) {\n        for (final char element : arr) {\n            if (element == key) {\n                return true;\n            }\n        }\n        return false;\n    }", "comment": "/*\n     * Returns whether the array contains the key, or not.\n     */"}}
{"code": {"body": "    public String colognePhonetic(String text) {\n        if (text == null) {\n            return null;\n        }\n\n        text = preprocess(text);\n\n        final CologneOutputBuffer output = new CologneOutputBuffer(text.length() * 2);\n        final CologneInputBuffer input = new CologneInputBuffer(text.toCharArray());\n\n        char nextChar;\n\n        char lastChar = '';\n        char lastCode = '';\n        char code;\n        char chr;\n\n        int rightLength = input.length();\n\n        while (rightLength > 0) {\n            chr = input.removeNext();\n\n            if ((rightLength = input.length()) > 0) {\n                nextChar = input.getNextChar();\n            } else {\n                nextChar = '';\n            }\n\n            if (arrayContains(AEIJOUY, chr)) {\n                code = '';\n            } else if (chr == '' || chr < '' || chr > '') {\n                if (lastCode == '') {\n                    continue;\n                }\n                code = '';\n            } else if (chr == '' || (chr == '' && nextChar != '')) {\n                code = '';\n            } else if ((chr == '' || chr == '') && !arrayContains(SCZ, nextChar)) {\n                code = '';\n            } else if (arrayContains(WFPV, chr)) {\n                code = '';\n            } else if (arrayContains(GKQ, chr)) {\n                code = '';\n            } else if (chr == '' && !arrayContains(CKQ, lastChar)) {\n                code = '';\n                input.addLeft('');\n                rightLength++;\n            } else if (chr == '' || chr == '') {\n                code = '';\n            } else if (chr == '') {\n                if (lastCode == '') {\n                    if (arrayContains(AHKLOQRUX, nextChar)) {\n                        code = '';\n                    } else {\n                        code = '';\n                    }\n                } else {\n                    if (arrayContains(SZ, lastChar) || !arrayContains(AHOUKQX, nextChar)) {\n                        code = '';\n                    } else {\n                        code = '';\n                    }\n                }\n            } else if (arrayContains(TDX, chr)) {\n                code = '';\n            } else if (chr == '') {\n                code = '';\n            } else if (chr == '') {\n                code = '';\n            } else if (chr == '' || chr == '') {\n                code = '';\n            } else {\n                code = chr;\n            }\n\n            if (code != '' && (lastCode != code && (code != '' || lastCode == '') || code < '' || code > '')) {\n                output.addRight(code);\n            }\n\n            lastChar = chr;\n            lastCode = code;\n        }\n        return output.toString();\n    }", "comment": "/**\n     * <p>\n     * Implements the <i>K&ouml;lner Phonetik</i> algorithm.\n     * </p>\n     * <p>\n     * In contrast to the initial description of the algorithm, this implementation does the encoding in one pass.\n     * </p>\n     *\n     * @param text The source text to encode\n     * @return the corresponding encoding according to the <i>K&ouml;lner Phonetik</i> algorithm\n     */"}}
{"code": {"body": "    private String preprocess(String text) {\n        text = text.toUpperCase(Locale.GERMAN);\n\n        final char[] chrs = text.toCharArray();\n\n        for (int index = 0; index < chrs.length; index++) {\n            if (chrs[index] > '') {\n                for (final char[] element : PREPROCESS_MAP) {\n                    if (chrs[index] == element[0]) {\n                        chrs[index] = element[1];\n                        break;\n                    }\n                }\n            }\n        }\n        return new String(chrs);\n    }", "comment": "/**\n     * Converts the string to upper case and replaces germanic characters as defined in {@link #PREPROCESS_MAP}.\n     */"}}
{"code": {"body": "public DaitchMokotoffSoundex() {\n        this(true);\n    }", "comment": "/**\n     * Creates a new instance with ASCII-folding enabled.\n     */"}}
{"code": {"body": "public DaitchMokotoffSoundex(final boolean folding) {\n        this.folding = folding;\n    }", "comment": "/**\n     * Creates a new instance.\n     * <p>\n     * With ASCII-folding enabled, certain accented characters will be transformed to equivalent ASCII characters, e.g.\n     * \u00e8 -&gt; e.\n     * </p>\n     *\n     * @param folding\n     *            if ASCII-folding shall be performed before encoding\n     */"}}
{"code": {"body": "        public Branch createBranch() {\n            final Branch branch = new Branch();\n            branch.builder.append(toString());\n            branch.lastReplacement = this.lastReplacement;\n            return branch;\n        }", "comment": "/**\n         * Creates a new branch, identical to this branch.\n         *\n         * @return a new, identical branch\n         */"}}
{"code": {"body": "        public void finish() {\n            while (builder.length() < MAX_LENGTH) {\n                builder.append('');\n                cachedString = null;\n            }\n        }", "comment": "/**\n         * Finish this branch by appending '0's until the maximum code length has been reached.\n         */"}}
{"code": {"body": "        public void processNextReplacement(final String replacement, final boolean forceAppend) {\n            final boolean append = lastReplacement == null || !lastReplacement.endsWith(replacement) || forceAppend;\n\n            if (append && builder.length() < MAX_LENGTH) {\n                builder.append(replacement);\n                \n                if (builder.length() > MAX_LENGTH) {\n                    builder.delete(MAX_LENGTH, builder.length());\n                }\n                cachedString = null;\n            }\n\n            lastReplacement = replacement;\n        }", "comment": "/**\n         * Process the next replacement to be added to this branch.\n         *\n         * @param replacement\n         *            the next replacement to append\n         * @param forceAppend\n         *            indicates if the default processing shall be overridden\n         */"}}
{"code": {"body": "    private String cleanup(final String input) {\n        final StringBuilder sb = new StringBuilder();\n        for (char ch : input.toCharArray()) {\n            if (Character.isWhitespace(ch)) {\n                continue;\n            }\n\n            ch = Character.toLowerCase(ch);\n            if (folding && FOLDINGS.containsKey(ch)) {\n                ch = FOLDINGS.get(ch);\n            }\n            sb.append(ch);\n        }\n        return sb.toString();\n    }", "comment": "/**\n     * Performs a cleanup of the input string before the actual soundex transformation.\n     * <p>\n     * Removes all whitespace characters and performs ASCII folding if enabled.\n     * </p>\n     *\n     * @param input\n     *            the input string to cleanup\n     * @return a cleaned up string\n     */"}}
{"code": {"body": "    private String[] soundex(final String source, final boolean branching) {\n        if (source == null) {\n            return null;\n        }\n\n        final String input = cleanup(source);\n\n        final Set<Branch> currentBranches = new LinkedHashSet<Branch>();\n        currentBranches.add(new Branch());\n\n        char lastChar = '';\n        for (int index = 0; index < input.length(); index++) {\n            final char ch = input.charAt(index);\n\n            \n            if (Character.isWhitespace(ch)) {\n                continue;\n            }\n\n            final String inputContext = input.substring(index);\n            final List<Rule> rules = RULES.get(ch);\n            if (rules == null) {\n                continue;\n            }\n\n            \n            @SuppressWarnings(\"\")\n            final List<Branch> nextBranches = branching ? new ArrayList<Branch>() : Collections.EMPTY_LIST;\n\n            for (final Rule rule : rules) {\n                if (rule.matches(inputContext)) {\n                    if (branching) {\n                        nextBranches.clear();\n                    }\n                    final String[] replacements = rule.getReplacements(inputContext, lastChar == '');\n                    final boolean branchingRequired = replacements.length > 1 && branching;\n\n                    for (final Branch branch : currentBranches) {\n                        for (final String nextReplacement : replacements) {\n                            \n                            final Branch nextBranch = branchingRequired ? branch.createBranch() : branch;\n\n                            \n                            final boolean force = (lastChar == '' && ch == '') || (lastChar == '' && ch == '');\n\n                            nextBranch.processNextReplacement(nextReplacement, force);\n\n                            if (branching) {\n                                nextBranches.add(nextBranch);\n                            } else {\n                                break;\n                            }\n                        }\n                    }\n\n                    if (branching) {\n                        currentBranches.clear();\n                        currentBranches.addAll(nextBranches);\n                    }\n                    index += rule.getPatternLength() - 1;\n                    break;\n                }\n            }\n\n            lastChar = ch;\n        }\n\n        final String[] result = new String[currentBranches.size()];\n        int index = 0;\n        for (final Branch branch : currentBranches) {\n            branch.finish();\n            result[index++] = branch.toString();\n        }\n\n        return result;\n    }", "comment": "/**\n     * Perform the actual DM Soundex algorithm on the input string.\n     *\n     * @param source\n     *            A String object to encode\n     * @param branching\n     *            If branching shall be performed\n     * @return A string array containing all DM Soundex codes corresponding to the String supplied depending on the\n     *         selected branching mode\n     */"}}
{"code": {"body": "public DoubleMetaphone() {\n        super();\n    }", "comment": "/**\n     * Creates an instance of this DoubleMetaphone encoder\n     */"}}
{"code": {"body": "    public String doubleMetaphone(String value, final boolean alternate) {\n        value = cleanInput(value);\n        if (value == null) {\n            return null;\n        }\n\n        final boolean slavoGermanic = isSlavoGermanic(value);\n        int index = isSilentStart(value) ? 1 : 0;\n\n        final DoubleMetaphoneResult result = new DoubleMetaphoneResult(this.getMaxCodeLen());\n\n        while (!result.isComplete() && index <= value.length() - 1) {\n            switch (value.charAt(index)) {\n            case '':\n            case '':\n            case '':\n            case '':\n            case '':\n            case '':\n                index = handleAEIOUY(result, index);\n                break;\n            case '':\n                result.append('');\n                index = charAt(value, index + 1) == '' ? index + 2 : index + 1;\n                break;\n            case '':\n                \n                result.append('');\n                index++;\n                break;\n            case '':\n                index = handleC(value, result, index);\n                break;\n            case '':\n                index = handleD(value, result, index);\n                break;\n            case '':\n                result.append('');\n                index = charAt(value, index + 1) == '' ? index + 2 : index + 1;\n                break;\n            case '':\n                index = handleG(value, result, index, slavoGermanic);\n                break;\n            case '':\n                index = handleH(value, result, index);\n                break;\n            case '':\n                index = handleJ(value, result, index, slavoGermanic);\n                break;\n            case '':\n                result.append('');\n                index = charAt(value, index + 1) == '' ? index + 2 : index + 1;\n                break;\n            case '':\n                index = handleL(value, result, index);\n                break;\n            case '':\n                result.append('');\n                index = conditionM0(value, index) ? index + 2 : index + 1;\n                break;\n            case '':\n                result.append('');\n                index = charAt(value, index + 1) == '' ? index + 2 : index + 1;\n                break;\n            case '':\n                \n                result.append('');\n                index++;\n                break;\n            case '':\n                index = handleP(value, result, index);\n                break;\n            case '':\n                result.append('');\n                index = charAt(value, index + 1) == '' ? index + 2 : index + 1;\n                break;\n            case '':\n                index = handleR(value, result, index, slavoGermanic);\n                break;\n            case '':\n                index = handleS(value, result, index, slavoGermanic);\n                break;\n            case '':\n                index = handleT(value, result, index);\n                break;\n            case '':\n                result.append('');\n                index = charAt(value, index + 1) == '' ? index + 2 : index + 1;\n                break;\n            case '':\n                index = handleW(value, result, index);\n                break;\n            case '':\n                index = handleX(value, result, index);\n                break;\n            case '':\n                index = handleZ(value, result, index, slavoGermanic);\n                break;\n            default:\n                index++;\n                break;\n            }\n        }\n\n        return alternate ? result.getAlternate() : result.getPrimary();\n    }", "comment": "/**\n     * Encode a value with Double Metaphone, optionally using the alternate encoding.\n     *\n     * @param value String to encode\n     * @param alternate use alternate encode\n     * @return an encoded string\n     */"}}
{"code": {"body": "    public boolean isDoubleMetaphoneEqual(final String value1, final String value2, final boolean alternate) {\n        return StringUtils.equals(doubleMetaphone(value1, alternate), doubleMetaphone(value2, alternate));\n    }", "comment": "/**\n     * Check if the Double Metaphone values of two <code>String</code> values\n     * are equal, optionally using the alternate value.\n     *\n     * @param value1 The left-hand side of the encoded {@link String#equals(Object)}.\n     * @param value2 The right-hand side of the encoded {@link String#equals(Object)}.\n     * @param alternate use the alternate value if <code>true</code>.\n     * @return <code>true</code> if the encoded <code>String</code>s are equal;\n     *          <code>false</code> otherwise.\n     */"}}
{"code": {"body": "    public int getMaxCodeLen() {\n        return this.maxCodeLen;\n    }", "comment": "/**\n     * Returns the maxCodeLen.\n     * @return int\n     */"}}
{"code": {"body": "    public void setMaxCodeLen(final int maxCodeLen) {\n        this.maxCodeLen = maxCodeLen;\n    }", "comment": "/**\n     * Sets the maxCodeLen.\n     * @param maxCodeLen The maxCodeLen to set\n     */"}}
{"code": {"body": "    private int handleAEIOUY(final DoubleMetaphoneResult result, final int index) {\n        if (index == 0) {\n            result.append('');\n        }\n        return index + 1;\n    }", "comment": "/**\n     * Handles 'A', 'E', 'I', 'O', 'U', and 'Y' cases.\n     */"}}
{"code": {"body": "    private int handleC(final String value, final DoubleMetaphoneResult result, int index) {\n        if (conditionC0(value, index)) {  \n            result.append('');\n            index += 2;\n        } else if (index == 0 && contains(value, index, 6, \"\")) {\n            result.append('');\n            index += 2;\n        } else if (contains(value, index, 2, \"\")) {\n            index = handleCH(value, result, index);\n        } else if (contains(value, index, 2, \"\") &&\n                   !contains(value, index - 2, 4, \"\")) {\n            \n            result.append('', '');\n            index += 2;\n        } else if (contains(value, index + 1, 3, \"\")) {\n            \n            result.append('');\n            index += 3;\n        } else if (contains(value, index, 2, \"\") &&\n                   !(index == 1 && charAt(value, 0) == '')) {\n            \n            return handleCC(value, result, index);\n        } else if (contains(value, index, 2, \"\", \"\", \"\")) {\n            result.append('');\n            index += 2;\n        } else if (contains(value, index, 2, \"\", \"\", \"\")) {\n            \n            if (contains(value, index, 3, \"\", \"\", \"\")) {\n                result.append('', '');\n            } else {\n                result.append('');\n            }\n            index += 2;\n        } else {\n            result.append('');\n            if (contains(value, index + 1, 2, \"\", \"\", \"\")) {\n                \n                index += 3;\n            } else if (contains(value, index + 1, 1, \"\", \"\", \"\") &&\n                       !contains(value, index + 1, 2, \"\", \"\")) {\n                index += 2;\n            } else {\n                index++;\n            }\n        }\n\n        return index;\n    }", "comment": "/**\n     * Handles 'C' cases.\n     */"}}
{"code": {"body": "    private int handleCC(final String value, final DoubleMetaphoneResult result, int index) {\n        if (contains(value, index + 2, 1, \"\", \"\", \"\") &&\n            !contains(value, index + 2, 2, \"\")) {\n            \n            if ((index == 1 && charAt(value, index - 1) == '') ||\n                contains(value, index - 1, 5, \"\", \"\")) {\n                \n                result.append(\"\");\n            } else {\n                \n                result.append('');\n            }\n            index += 3;\n        } else {    \n            result.append('');\n            index += 2;\n        }\n\n        return index;\n    }", "comment": "/**\n     * Handles 'CC' cases.\n     */"}}
{"code": {"body": "    private int handleCH(final String value, final DoubleMetaphoneResult result, final int index) {\n        if (index > 0 && contains(value, index, 4, \"\")) {   \n            result.append('', '');\n            return index + 2;\n        } else if (conditionCH0(value, index)) {\n            \n            result.append('');\n            return index + 2;\n        } else if (conditionCH1(value, index)) {\n            \n            result.append('');\n            return index + 2;\n        } else {\n            if (index > 0) {\n                if (contains(value, 0, 2, \"\")) {\n                    result.append('');\n                } else {\n                    result.append('', '');\n                }\n            } else {\n                result.append('');\n            }\n            return index + 2;\n        }\n    }", "comment": "/**\n     * Handles 'CH' cases.\n     */"}}
{"code": {"body": "    private int handleD(final String value, final DoubleMetaphoneResult result, int index) {\n        if (contains(value, index, 2, \"\")) {\n            \n            if (contains(value, index + 2, 1, \"\", \"\", \"\")) {\n                result.append('');\n                index += 3;\n                \n            } else {\n                result.append(\"\");\n                index += 2;\n            }\n        } else if (contains(value, index, 2, \"\", \"\")) {\n            result.append('');\n            index += 2;\n        } else {\n            result.append('');\n            index++;\n        }\n        return index;\n    }", "comment": "/**\n     * Handles 'D' cases.\n     */"}}
{"code": {"body": "    private int handleG(final String value, final DoubleMetaphoneResult result, int index,\n                        final boolean slavoGermanic) {\n        if (charAt(value, index + 1) == '') {\n            index = handleGH(value, result, index);\n        } else if (charAt(value, index + 1) == '') {\n            if (index == 1 && isVowel(charAt(value, 0)) && !slavoGermanic) {\n                result.append(\"\", \"\");\n            } else if (!contains(value, index + 2, 2, \"\") &&\n                       charAt(value, index + 1) != '' && !slavoGermanic) {\n                result.append(\"\", \"\");\n            } else {\n                result.append(\"\");\n            }\n            index = index + 2;\n        } else if (contains(value, index + 1, 2, \"\") && !slavoGermanic) {\n            result.append(\"\", \"\");\n            index += 2;\n        } else if (index == 0 &&\n                   (charAt(value, index + 1) == '' ||\n                    contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) {\n            \n            result.append('', '');\n            index += 2;\n        } else if ((contains(value, index + 1, 2, \"\") ||\n                    charAt(value, index + 1) == '') &&\n                   !contains(value, 0, 6, \"\", \"\", \"\") &&\n                   !contains(value, index - 1, 1, \"\", \"\") &&\n                   !contains(value, index - 1, 3, \"\", \"\")) {\n            \n            result.append('', '');\n            index += 2;\n        } else if (contains(value, index + 1, 1, \"\", \"\", \"\") ||\n                   contains(value, index - 1, 4, \"\", \"\")) {\n            \n            if (contains(value, 0 ,4, \"\", \"\") ||\n                contains(value, 0, 3, \"\") ||\n                contains(value, index + 1, 2, \"\")) {\n                \n                result.append('');\n            } else if (contains(value, index + 1, 3, \"\")) {\n                result.append('');\n            } else {\n                result.append('', '');\n            }\n            index += 2;\n        } else if (charAt(value, index + 1) == '') {\n            index += 2;\n            result.append('');\n        } else {\n            index++;\n            result.append('');\n        }\n        return index;\n    }", "comment": "/**\n     * Handles 'G' cases.\n     */"}}
{"code": {"body": "    private int handleGH(final String value, final DoubleMetaphoneResult result, int index) {\n        if (index > 0 && !isVowel(charAt(value, index - 1))) {\n            result.append('');\n            index += 2;\n        } else if (index == 0) {\n            if (charAt(value, index + 2) == '') {\n                result.append('');\n            } else {\n                result.append('');\n            }\n            index += 2;\n        } else if ((index > 1 && contains(value, index - 2, 1, \"\", \"\", \"\")) ||\n                   (index > 2 && contains(value, index - 3, 1, \"\", \"\", \"\")) ||\n                   (index > 3 && contains(value, index - 4, 1, \"\", \"\"))) {\n            \n            index += 2;\n        } else {\n            if (index > 2 && charAt(value, index - 1) == '' &&\n                contains(value, index - 3, 1, \"\", \"\", \"\", \"\", \"\")) {\n                \n                result.append('');\n            } else if (index > 0 && charAt(value, index - 1) != '') {\n                result.append('');\n            }\n            index += 2;\n        }\n        return index;\n    }", "comment": "/**\n     * Handles 'GH' cases.\n     */"}}
{"code": {"body": "    private int handleH(final String value, final DoubleMetaphoneResult result, int index) {\n        \n        if ((index == 0 || isVowel(charAt(value, index - 1))) &&\n            isVowel(charAt(value, index + 1))) {\n            result.append('');\n            index += 2;\n            \n        } else {\n            index++;\n        }\n        return index;\n    }", "comment": "/**\n     * Handles 'H' cases.\n     */"}}
{"code": {"body": "    private int handleJ(final String value, final DoubleMetaphoneResult result, int index,\n                        final boolean slavoGermanic) {\n        if (contains(value, index, 4, \"\") || contains(value, 0, 4, \"\")) {\n                \n                if ((index == 0 && (charAt(value, index + 4) == '') ||\n                     value.length() == 4) || contains(value, 0, 4, \"\")) {\n                    result.append('');\n                } else {\n                    result.append('', '');\n                }\n                index++;\n            } else {\n                if (index == 0 && !contains(value, index, 4, \"\")) {\n                    result.append('', '');\n                } else if (isVowel(charAt(value, index - 1)) && !slavoGermanic &&\n                           (charAt(value, index + 1) == '' || charAt(value, index + 1) == '')) {\n                    result.append('', '');\n                } else if (index == value.length() - 1) {\n                    result.append('', '');\n                } else if (!contains(value, index + 1, 1, L_T_K_S_N_M_B_Z) &&\n                           !contains(value, index - 1, 1, \"\", \"\", \"\")) {\n                    result.append('');\n                }\n\n                if (charAt(value, index + 1) == '') {\n                    index += 2;\n                } else {\n                    index++;\n                }\n            }\n        return index;\n    }", "comment": "/**\n     * Handles 'J' cases.\n     */"}}
{"code": {"body": "    private int handleL(final String value, final DoubleMetaphoneResult result, int index) {\n        if (charAt(value, index + 1) == '') {\n            if (conditionL0(value, index)) {\n                result.appendPrimary('');\n            } else {\n                result.append('');\n            }\n            index += 2;\n        } else {\n            index++;\n            result.append('');\n        }\n        return index;\n    }", "comment": "/**\n     * Handles 'L' cases.\n     */"}}
{"code": {"body": "    private int handleP(final String value, final DoubleMetaphoneResult result, int index) {\n        if (charAt(value, index + 1) == '') {\n            result.append('');\n            index += 2;\n        } else {\n            result.append('');\n            index = contains(value, index + 1, 1, \"\", \"\") ? index + 2 : index + 1;\n        }\n        return index;\n    }", "comment": "/**\n     * Handles 'P' cases.\n     */"}}
{"code": {"body": "    private int handleR(final String value, final DoubleMetaphoneResult result, final int index,\n                        final boolean slavoGermanic) {\n        if (index == value.length() - 1 && !slavoGermanic &&\n            contains(value, index - 2, 2, \"\") &&\n            !contains(value, index - 4, 2, \"\", \"\")) {\n            result.appendAlternate('');\n        } else {\n            result.append('');\n        }\n        return charAt(value, index + 1) == '' ? index + 2 : index + 1;\n    }", "comment": "/**\n     * Handles 'R' cases.\n     */"}}
{"code": {"body": "    private int handleS(final String value, final DoubleMetaphoneResult result, int index,\n                        final boolean slavoGermanic) {\n        if (contains(value, index - 1, 3, \"\", \"\")) {\n            \n            index++;\n        } else if (index == 0 && contains(value, index, 5, \"\")) {\n            \n            result.append('', '');\n            index++;\n        } else if (contains(value, index, 2, \"\")) {\n            if (contains(value, index + 1, 4, \"\", \"\", \"\", \"\")) {\n                \n                result.append('');\n            } else {\n                result.append('');\n            }\n            index += 2;\n        } else if (contains(value, index, 3, \"\", \"\") || contains(value, index, 4, \"\")) {\n            \n            if (slavoGermanic) {\n                result.append('');\n            } else {\n                result.append('', '');\n            }\n            index += 3;\n        } else if ((index == 0 && contains(value, index + 1, 1, \"\", \"\", \"\", \"\")) ||\n                   contains(value, index + 1, 1, \"\")) {\n            \n            \n            \n            \n            result.append('', '');\n            index = contains(value, index + 1, 1, \"\") ? index + 2 : index + 1;\n        } else if (contains(value, index, 2, \"\")) {\n            index = handleSC(value, result, index);\n        } else {\n            if (index == value.length() - 1 && contains(value, index - 2, 2, \"\", \"\")) {\n                \n                result.appendAlternate('');\n            } else {\n                result.append('');\n            }\n            index = contains(value, index + 1, 1, \"\", \"\") ? index + 2 : index + 1;\n        }\n        return index;\n    }", "comment": "/**\n     * Handles 'S' cases.\n     */"}}
{"code": {"body": "    private int handleSC(final String value, final DoubleMetaphoneResult result, final int index) {\n        if (charAt(value, index + 2) == '') {\n            \n            if (contains(value, index + 3, 2, \"\", \"\", \"\", \"\", \"\", \"\")) {\n                \n                if (contains(value, index + 3, 2, \"\", \"\")) {\n                    \n                    result.append(\"\", \"\");\n                } else {\n                    result.append(\"\");\n                }\n            } else {\n                if (index == 0 && !isVowel(charAt(value, 3)) && charAt(value, 3) != '') {\n                    result.append('', '');\n                } else {\n                    result.append('');\n                }\n            }\n        } else if (contains(value, index + 2, 1, \"\", \"\", \"\")) {\n            result.append('');\n        } else {\n            result.append(\"\");\n        }\n        return index + 3;\n    }", "comment": "/**\n     * Handles 'SC' cases.\n     */"}}
{"code": {"body": "    private int handleT(final String value, final DoubleMetaphoneResult result, int index) {\n        if (contains(value, index, 4, \"\")) {\n            result.append('');\n            index += 3;\n        } else if (contains(value, index, 3, \"\", \"\")) {\n            result.append('');\n            index += 3;\n        } else if (contains(value, index, 2, \"\") || contains(value, index, 3, \"\")) {\n            if (contains(value, index + 2, 2, \"\", \"\") ||\n                \n                contains(value, 0, 4, \"\", \"\") ||\n                contains(value, 0, 3, \"\")) {\n                result.append('');\n            } else {\n                result.append('', '');\n            }\n            index += 2;\n        } else {\n            result.append('');\n            index = contains(value, index + 1, 1, \"\", \"\") ? index + 2 : index + 1;\n        }\n        return index;\n    }", "comment": "/**\n     * Handles 'T' cases.\n     */"}}
{"code": {"body": "    private int handleW(final String value, final DoubleMetaphoneResult result, int index) {\n        if (contains(value, index, 2, \"\")) {\n            \n            result.append('');\n            index += 2;\n        } else {\n            if (index == 0 && (isVowel(charAt(value, index + 1)) ||\n                               contains(value, index, 2, \"\"))) {\n                if (isVowel(charAt(value, index + 1))) {\n                    \n                    result.append('', '');\n                } else {\n                    \n                    result.append('');\n                }\n                index++;\n            } else if ((index == value.length() - 1 && isVowel(charAt(value, index - 1))) ||\n                       contains(value, index - 1, 5, \"\", \"\", \"\", \"\") ||\n                       contains(value, 0, 3, \"\")) {\n                \n                result.appendAlternate('');\n                index++;\n            } else if (contains(value, index, 4, \"\", \"\")) {\n                \n                result.append(\"\", \"\");\n                index += 4;\n            } else {\n                index++;\n            }\n        }\n        return index;\n    }", "comment": "/**\n     * Handles 'W' cases.\n     */"}}
{"code": {"body": "    private int handleX(final String value, final DoubleMetaphoneResult result, int index) {\n        if (index == 0) {\n            result.append('');\n            index++;\n        } else {\n            if (!((index == value.length() - 1) &&\n                  (contains(value, index - 3, 3, \"\", \"\") ||\n                   contains(value, index - 2, 2, \"\", \"\")))) {\n                \n                result.append(\"\");\n            }\n            index = contains(value, index + 1, 1, \"\", \"\") ? index + 2 : index + 1;\n        }\n        return index;\n    }", "comment": "/**\n     * Handles 'X' cases.\n     */"}}
{"code": {"body": "    private int handleZ(final String value, final DoubleMetaphoneResult result, int index,\n                        final boolean slavoGermanic) {\n        if (charAt(value, index + 1) == '') {\n            \n            result.append('');\n            index += 2;\n        } else {\n            if (contains(value, index + 1, 2, \"\", \"\", \"\") ||\n                (slavoGermanic && (index > 0 && charAt(value, index - 1) != ''))) {\n                result.append(\"\", \"\");\n            } else {\n                result.append('');\n            }\n            index = charAt(value, index + 1) == '' ? index + 2 : index + 1;\n        }\n        return index;\n    }", "comment": "/**\n     * Handles 'Z' cases.\n     */"}}
{"code": {"body": "    private boolean conditionC0(final String value, final int index) {\n        if (contains(value, index, 4, \"\")) {\n            return true;\n        } else if (index <= 1) {\n            return false;\n        } else if (isVowel(charAt(value, index - 2))) {\n            return false;\n        } else if (!contains(value, index - 1, 3, \"\")) {\n            return false;\n        } else {\n            final char c = charAt(value, index + 2);\n            return (c != '' && c != '') ||\n                    contains(value, index - 2, 6, \"\", \"\");\n        }\n    }", "comment": "/**\n     * Complex condition 0 for 'C'.\n     */"}}
{"code": {"body": "    private boolean conditionCH0(final String value, final int index) {\n        if (index != 0) {\n            return false;\n        } else if (!contains(value, index + 1, 5, \"\", \"\") &&\n                   !contains(value, index + 1, 3, \"\", \"\", \"\", \"\")) {\n            return false;\n        } else if (contains(value, 0, 5, \"\")) {\n            return false;\n        } else {\n            return true;\n        }\n    }", "comment": "/**\n     * Complex condition 0 for 'CH'.\n     */"}}
{"code": {"body": "    private boolean conditionCH1(final String value, final int index) {\n        return ((contains(value, 0, 4, \"\", \"\") || contains(value, 0, 3, \"\")) ||\n                contains(value, index - 2, 6, \"\", \"\", \"\") ||\n                contains(value, index + 2, 1, \"\", \"\") ||\n                ((contains(value, index - 1, 1, \"\", \"\", \"\", \"\") || index == 0) &&\n                 (contains(value, index + 2, 1, L_R_N_M_B_H_F_V_W_SPACE) || index + 1 == value.length() - 1)));\n    }", "comment": "/**\n     * Complex condition 1 for 'CH'.\n     */"}}
{"code": {"body": "    private boolean conditionL0(final String value, final int index) {\n        if (index == value.length() - 3 &&\n            contains(value, index - 1, 4, \"\", \"\", \"\")) {\n            return true;\n        } else if ((contains(value, value.length() - 2, 2, \"\", \"\") ||\n                    contains(value, value.length() - 1, 1, \"\", \"\")) &&\n                   contains(value, index - 1, 4, \"\")) {\n            return true;\n        } else {\n            return false;\n        }\n    }", "comment": "/**\n     * Complex condition 0 for 'L'.\n     */"}}
{"code": {"body": "    private boolean conditionM0(final String value, final int index) {\n        if (charAt(value, index + 1) == '') {\n            return true;\n        }\n        return contains(value, index - 1, 3, \"\") &&\n               ((index + 1) == value.length() - 1 || contains(value, index + 2, 2, \"\"));\n    }", "comment": "/**\n     * Complex condition 0 for 'M'.\n     */"}}
{"code": {"body": "    private boolean isSlavoGermanic(final String value) {\n        return value.indexOf('') > -1 || value.indexOf('') > -1 ||\n            value.indexOf(\"\") > -1 || value.indexOf(\"\") > -1;\n    }", "comment": "/**\n     * Determines whether or not a value is of slavo-germanic origin. A value is\n     * of slavo-germanic origin if it contians any of 'W', 'K', 'CZ', or 'WITZ'.\n     */"}}
{"code": {"body": "    private boolean isVowel(final char ch) {\n        return VOWELS.indexOf(ch) != -1;\n    }", "comment": "/**\n     * Determines whether or not a character is a vowel or not\n     */"}}
{"code": {"body": "    private boolean isSilentStart(final String value) {\n        boolean result = false;\n        for (final String element : SILENT_START) {\n            if (value.startsWith(element)) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }", "comment": "/**\n     * Determines whether or not the value starts with a silent letter.  It will\n     * return <code>true</code> if the value starts with any of 'GN', 'KN',\n     * 'PN', 'WR' or 'PS'.\n     */"}}
{"code": {"body": "    private String cleanInput(String input) {\n        if (input == null) {\n            return null;\n        }\n        input = input.trim();\n        if (input.length() == 0) {\n            return null;\n        }\n        return input.toUpperCase(java.util.Locale.ENGLISH);\n    }", "comment": "/**\n     * Cleans the input.\n     */"}}
{"code": {"body": "    protected char charAt(final String value, final int index) {\n        if (index < 0 || index >= value.length()) {\n            return Character.MIN_VALUE;\n        }\n        return value.charAt(index);\n    }", "comment": "/*\n     * Gets the character at index <code>index</code> if available, otherwise\n     * it returns <code>Character.MIN_VALUE</code> so that there is some sort\n     * of a default.\n     */"}}
{"code": {"body": "    protected static boolean contains(final String value, final int start, final int length,\n                                      final String... criteria) {\n        boolean result = false;\n        if (start >= 0 && start + length <= value.length()) {\n            final String target = value.substring(start, start + length);\n\n            for (final String element : criteria) {\n                if (target.equals(element)) {\n                    result = true;\n                    break;\n                }\n            }\n        }\n        return result;\n    }", "comment": "/*\n     * Determines whether <code>value</code> contains any of the criteria starting at index <code>start</code> and\n     * matching up to length <code>length</code>.\n     */"}}
{"code": {"body": "    String cleanName(final String name) {\n        String upperName = name.toUpperCase(Locale.ENGLISH);\n\n        final String[] charsToTrim = { \"\", \"\", \"\", \"\", \"\" };\n        for (final String str : charsToTrim) {\n            upperName = upperName.replaceAll(str, EMPTY);\n        }\n\n        upperName = removeAccents(upperName);\n        upperName = upperName.replaceAll(\"\", EMPTY);\n\n        return upperName;\n    }", "comment": "/**\n     * Cleans up a name: 1. Upper-cases everything 2. Removes some common punctuation 3. Removes accents 4. Removes any\n     * spaces.\n     *\n     * <h2>API Usage</h2>\n     * <p>\n     * Consider this method private, it is package protected for unit testing only.\n     * </p>\n     *\n     * @param name\n     *            The name to be cleaned\n     * @return The cleaned name\n     */"}}
{"code": {"body": "    String getFirst3Last3(final String name) {\n        final int nameLength = name.length();\n\n        if (nameLength > SIX) {\n            final String firstThree = name.substring(0, THREE);\n            final String lastThree = name.substring(nameLength - THREE, nameLength);\n            return firstThree + lastThree;\n        } else {\n            return name;\n        }\n    }", "comment": "/**\n     * Gets the first and last 3 letters of a name (if &gt; 6 characters) Else just returns the name.\n     *\n     * <h2>API Usage</h2>\n     * <p>\n     * Consider this method private, it is package protected for unit testing only.\n     * </p>\n     *\n     * @param name\n     *            The string to get the substrings from\n     * @return Annexed first and last 3 letters of input word.\n     */"}}
{"code": {"body": "    int getMinRating(final int sumLength) {\n        int minRating = 0;\n\n        if (sumLength <= FOUR) {\n            minRating = FIVE;\n        } else if (sumLength >= FIVE && sumLength <= SEVEN) {\n            minRating = FOUR;\n        } else if (sumLength >= EIGHT && sumLength <= ELEVEN) {\n            minRating = THREE;\n        } else if (sumLength == TWELVE) {\n            minRating = TWO;\n        } else {\n            minRating = ONE; \n        }\n\n        return minRating;\n    }", "comment": "/**\n     * Obtains the min rating of the length sum of the 2 names. In essence the larger the sum length the smaller the\n     * min rating. Values strictly from documentation.\n     *\n     * <h2>API Usage</h2>\n     * <p>\n     * Consider this method private, it is package protected for unit testing only.\n     * </p>\n     *\n     * @param sumLength\n     *            The length of 2 strings sent down\n     * @return The min rating value\n     */"}}
{"code": {"body": "    public boolean isEncodeEquals(String name1, String name2) {\n        \n        if (name1 == null || EMPTY.equalsIgnoreCase(name1) || SPACE.equalsIgnoreCase(name1)) {\n            return false;\n        } else if (name2 == null || EMPTY.equalsIgnoreCase(name2) || SPACE.equalsIgnoreCase(name2)) {\n            return false;\n        } else if (name1.length() == 1 || name2.length() == 1) {\n            return false;\n        } else if (name1.equalsIgnoreCase(name2)) {\n            return true;\n        }\n\n        \n        name1 = cleanName(name1);\n        name2 = cleanName(name2);\n\n        \n\n        \n        name1 = removeVowels(name1);\n        name2 = removeVowels(name2);\n\n        \n        name1 = removeDoubleConsonants(name1);\n        name2 = removeDoubleConsonants(name2);\n\n        \n        name1 = getFirst3Last3(name1);\n        name2 = getFirst3Last3(name2);\n\n        \n        \n        if (Math.abs(name1.length() - name2.length()) >= THREE) {\n            return false;\n        }\n\n        \n        \n        final int sumLength = Math.abs(name1.length() + name2.length());\n        int minRating = 0;\n        minRating = getMinRating(sumLength);\n\n        \n        \n        final int count = leftToRightThenRightToLeftProcessing(name1, name2);\n\n        \n        \n        return count >= minRating;\n\n    }", "comment": "/**\n     * Determines if two names are homophonous via Match Rating Approach (MRA) algorithm. It should be noted that the\n     * strings are cleaned in the same way as {@link #encode(String)}.\n     *\n     * @param name1\n     *            First of the 2 strings (names) to compare\n     * @param name2\n     *            Second of the 2 names to compare\n     * @return <code>true</code> if the encodings are identical <code>false</code> otherwise.\n     */"}}
{"code": {"body": "    boolean isVowel(final String letter) {\n        return letter.equalsIgnoreCase(\"\") || letter.equalsIgnoreCase(\"\") || letter.equalsIgnoreCase(\"\") ||\n               letter.equalsIgnoreCase(\"\") || letter.equalsIgnoreCase(\"\");\n    }", "comment": "/**\n     * Determines if a letter is a vowel.\n     *\n     * <h2>API Usage</h2>\n     * <p>\n     * Consider this method private, it is package protected for unit testing only.\n     * </p>\n     *\n     * @param letter\n     *            The letter under investiagtion\n     * @return True if a vowel, else false\n     */"}}
{"code": {"body": "    int leftToRightThenRightToLeftProcessing(final String name1, final String name2) {\n        final char[] name1Char = name1.toCharArray();\n        final char[] name2Char = name2.toCharArray();\n\n        final int name1Size = name1.length() - 1;\n        final int name2Size = name2.length() - 1;\n\n        String name1LtRStart = EMPTY;\n        String name1LtREnd = EMPTY;\n\n        String name2RtLStart = EMPTY;\n        String name2RtLEnd = EMPTY;\n\n        for (int i = 0; i < name1Char.length; i++) {\n            if (i > name2Size) {\n                break;\n            }\n\n            name1LtRStart = name1.substring(i, i + 1);\n            name1LtREnd = name1.substring(name1Size - i, name1Size - i + 1);\n\n            name2RtLStart = name2.substring(i, i + 1);\n            name2RtLEnd = name2.substring(name2Size - i, name2Size - i + 1);\n\n            \n            if (name1LtRStart.equals(name2RtLStart)) {\n                name1Char[i] = '';\n                name2Char[i] = '';\n            }\n\n            \n            if (name1LtREnd.equals(name2RtLEnd)) {\n                name1Char[name1Size - i] = '';\n                name2Char[name2Size - i] = '';\n            }\n        }\n\n        \n        final String strA = new String(name1Char).replaceAll(\"\", EMPTY);\n        final String strB = new String(name2Char).replaceAll(\"\", EMPTY);\n\n        \n        if (strA.length() > strB.length()) {\n            return Math.abs(SIX - strA.length());\n        } else {\n            return Math.abs(SIX - strB.length());\n        }\n    }", "comment": "/**\n     * Processes the names from left to right (first) then right to left removing identical letters in same positions.\n     * Then subtracts the longer string that remains from 6 and returns this.\n     *\n     * <h2>API Usage</h2>\n     * <p>\n     * Consider this method private, it is package protected for unit testing only.\n     * </p>\n     *\n     * @param name1\n     *            name2\n     * @return\n     */"}}
{"code": {"body": "    String removeAccents(final String accentedWord) {\n        if (accentedWord == null) {\n            return null;\n        }\n\n        final StringBuilder sb = new StringBuilder();\n        final int n = accentedWord.length();\n\n        for (int i = 0; i < n; i++) {\n            final char c = accentedWord.charAt(i);\n            final int pos = UNICODE.indexOf(c);\n            if (pos > -1) {\n                sb.append(PLAIN_ASCII.charAt(pos));\n            } else {\n                sb.append(c);\n            }\n        }\n\n        return sb.toString();\n    }", "comment": "/**\n     * Removes accented letters and replaces with non-accented ascii equivalent Case is preserved.\n     * http://www.codecodex.com/wiki/Remove_accent_from_letters_%28ex_.%C3%A9_to_e%29\n     *\n     * @param accentedWord\n     *            The word that may have accents in it.\n     * @return De-accented word\n     */"}}
{"code": {"body": "    String removeDoubleConsonants(final String name) {\n        String replacedName = name.toUpperCase();\n        for (final String dc : DOUBLE_CONSONANT) {\n            if (replacedName.contains(dc)) {\n                final String singleLetter = dc.substring(0, 1);\n                replacedName = replacedName.replace(dc, singleLetter);\n            }\n        }\n        return replacedName;\n    }", "comment": "/**\n     * Replaces any double consonant pair with the single letter equivalent.\n     *\n     * <h2>API Usage</h2>\n     * <p>\n     * Consider this method private, it is package protected for unit testing only.\n     * </p>\n     *\n     * @param name\n     *            String to have double consonants removed\n     * @return Single consonant word\n     */"}}
{"code": {"body": "    String removeVowels(String name) {\n        \n        final String firstLetter = name.substring(0, 1);\n\n        name = name.replaceAll(\"\", EMPTY);\n        name = name.replaceAll(\"\", EMPTY);\n        name = name.replaceAll(\"\", EMPTY);\n        name = name.replaceAll(\"\", EMPTY);\n        name = name.replaceAll(\"\", EMPTY);\n\n        name = name.replaceAll(\"\", SPACE);\n\n        \n        if (isVowel(firstLetter)) {\n            return firstLetter + name;\n        } else {\n            return name;\n        }\n    }", "comment": "/**\n     * Deletes all vowels unless the vowel begins the word.\n     *\n     * <h2>API Usage</h2>\n     * <p>\n     * Consider this method private, it is package protected for unit testing only.\n     * </p>\n     *\n     * @param name\n     *            The name to have vowels removed\n     * @return De-voweled word\n     */"}}
{"code": {"body": "public Metaphone() {\n        super();\n    }", "comment": "/**\n     * Creates an instance of the Metaphone encoder\n     */"}}
{"code": {"body": "    public String metaphone(final String txt) {\n        boolean hard = false;\n        int txtLength;\n        if (txt == null || (txtLength = txt.length()) == 0) {\n            return \"\";\n        }\n        \n        if (txtLength == 1) {\n            return txt.toUpperCase(java.util.Locale.ENGLISH);\n        }\n\n        final char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();\n\n        final StringBuilder local = new StringBuilder(40); \n        final StringBuilder code = new StringBuilder(10); \n        \n        switch(inwd[0]) {\n        case '':\n        case '':\n        case '': \n            if (inwd[1] == '') {\n                local.append(inwd, 1, inwd.length - 1);\n            } else {\n                local.append(inwd);\n            }\n            break;\n        case '': \n            if (inwd[1] == '') {\n                local.append(inwd, 1, inwd.length - 1);\n            } else {\n                local.append(inwd);\n            }\n            break;\n        case '': \n            if (inwd[1] == '') {   \n                local.append(inwd, 1, inwd.length - 1);\n                break;\n            }\n            if (inwd[1] == '') {\n                local.append(inwd, 1, inwd.length - 1);\n                local.setCharAt(0, ''); \n            } else {\n                local.append(inwd);\n            }\n            break;\n        case '': \n            inwd[0] = '';\n            local.append(inwd);\n            break;\n        default:\n            local.append(inwd);\n        } \n\n        final int wdsz = local.length();\n        int n = 0;\n\n        while (code.length() < this.getMaxCodeLen() &&\n               n < wdsz ) { \n            final char symb = local.charAt(n);\n            \n            if (symb != '' && isPreviousChar( local, n, symb ) ) {\n                n++;\n            } else { \n                switch(symb) {\n                case '':\n                case '':\n                case '':\n                case '':\n                case '':\n                    if (n == 0) {\n                        code.append(symb);\n                    }\n                    break; \n                case '':\n                    if ( isPreviousChar(local, n, '') &&\n                         isLastChar(wdsz, n) ) { \n                        break;\n                    }\n                    code.append(symb);\n                    break;\n                case '': \n                    \n                    if ( isPreviousChar(local, n, '') &&\n                         !isLastChar(wdsz, n) &&\n                         FRONTV.indexOf(local.charAt(n + 1)) >= 0 ) {\n                        break;\n                    }\n                    if (regionMatch(local, n, \"\")) { \n                        code.append('');\n                        break;\n                    }\n                    if (!isLastChar(wdsz, n) &&\n                        FRONTV.indexOf(local.charAt(n + 1)) >= 0) {\n                        code.append('');\n                        break; \n                    }\n                    if (isPreviousChar(local, n, '') &&\n                        isNextChar(local, n, '') ) { \n                        code.append('');\n                        break;\n                    }\n                    if (isNextChar(local, n, '')) { \n                        if (n == 0 &&\n                            wdsz >= 3 &&\n                            isVowel(local,2) ) { \n                            code.append('');\n                        } else {\n                            code.append(''); \n                        }\n                    } else {\n                        code.append('');\n                    }\n                    break;\n                case '':\n                    if (!isLastChar(wdsz, n + 1) &&\n                        isNextChar(local, n, '') &&\n                        FRONTV.indexOf(local.charAt(n + 2)) >= 0) { \n                        code.append(''); n += 2;\n                    } else {\n                        code.append('');\n                    }\n                    break;\n                case '': \n                    if (isLastChar(wdsz, n + 1) &&\n                        isNextChar(local, n, '')) {\n                        break;\n                    }\n                    if (!isLastChar(wdsz, n + 1) &&\n                        isNextChar(local,n,'') &&\n                        !isVowel(local,n+2)) {\n                        break;\n                    }\n                    if (n > 0 &&\n                        ( regionMatch(local, n, \"\") ||\n                          regionMatch(local, n, \"\") ) ) {\n                        break; \n                    }\n                    if (isPreviousChar(local, n, '')) {\n                        \n                        hard = true;\n                    } else {\n                        hard = false;\n                    }\n                    if (!isLastChar(wdsz, n) &&\n                        FRONTV.indexOf(local.charAt(n + 1)) >= 0 &&\n                        !hard) {\n                        code.append('');\n                    } else {\n                        code.append('');\n                    }\n                    break;\n                case '':\n                    if (isLastChar(wdsz, n)) {\n                        break; \n                    }\n                    if (n > 0 &&\n                        VARSON.indexOf(local.charAt(n - 1)) >= 0) {\n                        break;\n                    }\n                    if (isVowel(local,n+1)) {\n                        code.append(''); \n                    }\n                    break;\n                case '':\n                case '':\n                case '':\n                case '':\n                case '':\n                case '':\n                    code.append(symb);\n                    break;\n                case '':\n                    if (n > 0) { \n                        if (!isPreviousChar(local, n, '')) {\n                            code.append(symb);\n                        }\n                    } else {\n                        code.append(symb); \n                    }\n                    break;\n                case '':\n                    if (isNextChar(local,n,'')) {\n                        \n                        code.append('');\n                    } else {\n                        code.append(symb);\n                    }\n                    break;\n                case '':\n                    code.append('');\n                    break;\n                case '':\n                    if (regionMatch(local,n,\"\") ||\n                        regionMatch(local,n,\"\") ||\n                        regionMatch(local,n,\"\")) {\n                        code.append('');\n                    } else {\n                        code.append('');\n                    }\n                    break;\n                case '':\n                    if (regionMatch(local,n,\"\") ||\n                        regionMatch(local,n,\"\")) {\n                        code.append('');\n                        break;\n                    }\n                    if (regionMatch(local,n,\"\")) {\n                        \n                        break;\n                    }\n                    \n                    if (regionMatch(local,n,\"\")) {\n                        code.append('');\n                    } else {\n                        code.append('');\n                    }\n                    break;\n                case '':\n                    code.append(''); break;\n                case '':\n                case '': \n                    if (!isLastChar(wdsz,n) &&\n                        isVowel(local,n+1)) {\n                        code.append(symb);\n                    }\n                    break;\n                case '':\n                    code.append('');\n                    code.append('');\n                    break;\n                case '':\n                    code.append('');\n                    break;\n                default:\n                    \n                    break;\n                } \n                n++;\n            } \n            if (code.length() > this.getMaxCodeLen()) {\n                code.setLength(this.getMaxCodeLen());\n            }\n        }\n        return code.toString();\n    }", "comment": "/**\n     * Find the metaphone value of a String. This is similar to the\n     * soundex algorithm, but better at finding similar sounding words.\n     * All input is converted to upper case.\n     * Limitations: Input format is expected to be a single ASCII word\n     * with only characters in the A - Z range, no punctuation or numbers.\n     *\n     * @param txt String to find the metaphone code for\n     * @return A metaphone code corresponding to the String supplied\n     */"}}
{"code": {"body": "    public boolean isMetaphoneEqual(final String str1, final String str2) {\n        return metaphone(str1).equals(metaphone(str2));\n    }", "comment": "/**\n     * Tests is the metaphones of two strings are identical.\n     *\n     * @param str1 First of two strings to compare\n     * @param str2 Second of two strings to compare\n     * @return <code>true</code> if the metaphones of these strings are identical,\n     *        <code>false</code> otherwise.\n     */"}}
{"code": {"body": "    public int getMaxCodeLen() { return this.maxCodeLen; }", "comment": "/**\n     * Returns the maxCodeLen.\n     * @return int\n     */"}}
{"code": {"body": "    public void setMaxCodeLen(final int maxCodeLen) { this.maxCodeLen = maxCodeLen; }", "comment": "/**\n     * Sets the maxCodeLen.\n     * @param maxCodeLen The maxCodeLen to set\n     */"}}
{"code": {"body": "public Nysiis() {\n        this(true);\n    }", "comment": "/**\n     * Creates an instance of the {@link Nysiis} encoder with strict mode (original form),\n     * i.e. encoded strings have a maximum length of 6.\n     */"}}
{"code": {"body": "public Nysiis(final boolean strict) {\n        this.strict = strict;\n    }", "comment": "/**\n     * Create an instance of the {@link Nysiis} encoder with the specified strict mode:\n     *\n     * <ul>\n     *  <li><code>true</code>: encoded strings have a maximum length of 6</li>\n     *  <li><code>false</code>: encoded strings may have arbitrary length</li>\n     * </ul>\n     *\n     * @param strict\n     *            the strict mode\n     */"}}
{"code": {"body": "    private static boolean isVowel(final char c) {\n        return c == '' || c == '' || c == '' || c == '' || c == '';\n    }", "comment": "/**\n     * Tests if the given character is a vowel.\n     *\n     * @param c\n     *            the character to test\n     * @return <code>true</code> if the character is a vowel, <code>false</code> otherwise\n     */"}}
{"code": {"body": "    private static char[] transcodeRemaining(final char prev, final char curr, final char next, final char aNext) {\n        \n        if (curr == '' && next == '') {\n            return CHARS_AF;\n        }\n\n        \n        if (isVowel(curr)) {\n            return CHARS_A;\n        }\n\n        \n        if (curr == '') {\n            return CHARS_G;\n        } else if (curr == '') {\n            return CHARS_S;\n        } else if (curr == '') {\n            return CHARS_N;\n        }\n\n        \n        if (curr == '') {\n            if (next == '') {\n                return CHARS_NN;\n            } else {\n                return CHARS_C;\n            }\n        }\n\n        \n        if (curr == '' && next == '' && aNext == '') {\n            return CHARS_SSS;\n        }\n\n        \n        if (curr == '' && next == '') {\n            return CHARS_FF;\n        }\n\n        \n        if (curr == '' && (!isVowel(prev) || !isVowel(next))) {\n            return new char[] { prev };\n        }\n\n        \n        if (curr == '' && isVowel(prev)) {\n            return new char[] { prev };\n        }\n\n        return new char[] { curr };\n    }", "comment": "/**\n     * Transcodes the remaining parts of the String. The method operates on a sliding window, looking at 4 characters at\n     * a time: [i-1, i, i+1, i+2].\n     *\n     * @param prev\n     *            the previous character\n     * @param curr\n     *            the current character\n     * @param next\n     *            the next character\n     * @param aNext\n     *            the after next character\n     * @return a transcoded array of characters, starting from the current position\n     */"}}
{"code": {"body": "    public boolean isStrict() {\n        return this.strict;\n    }", "comment": "/**\n     * Indicates the strict mode for this {@link Nysiis} encoder.\n     *\n     * @return <code>true</code> if the encoder is configured for strict mode, <code>false</code> otherwise\n     */"}}
{"code": {"body": "    public String nysiis(String str) {\n        if (str == null) {\n            return null;\n        }\n\n        \n        str = SoundexUtils.clean(str);\n\n        if (str.length() == 0) {\n            return str;\n        }\n\n        \n        \n        str = PAT_MAC.matcher(str).replaceFirst(\"\");\n        str = PAT_KN.matcher(str).replaceFirst(\"\");\n        str = PAT_K.matcher(str).replaceFirst(\"\");\n        str = PAT_PH_PF.matcher(str).replaceFirst(\"\");\n        str = PAT_SCH.matcher(str).replaceFirst(\"\");\n\n        \n        \n        str = PAT_EE_IE.matcher(str).replaceFirst(\"\");\n        str = PAT_DT_ETC.matcher(str).replaceFirst(\"\");\n\n        \n        final StringBuilder key = new StringBuilder(str.length());\n        key.append(str.charAt(0));\n\n        \n        final char[] chars = str.toCharArray();\n        final int len = chars.length;\n\n        for (int i = 1; i < len; i++) {\n            final char next = i < len - 1 ? chars[i + 1] : SPACE;\n            final char aNext = i < len - 2 ? chars[i + 2] : SPACE;\n            final char[] transcoded = transcodeRemaining(chars[i - 1], chars[i], next, aNext);\n            System.arraycopy(transcoded, 0, chars, i, transcoded.length);\n\n            \n            if (chars[i] != chars[i - 1]) {\n                key.append(chars[i]);\n            }\n        }\n\n        if (key.length() > 1) {\n            char lastChar = key.charAt(key.length() - 1);\n\n            \n            if (lastChar == '') {\n                key.deleteCharAt(key.length() - 1);\n                lastChar = key.charAt(key.length() - 1);\n            }\n\n            if (key.length() > 2) {\n                final char last2Char = key.charAt(key.length() - 2);\n                \n                if (last2Char == '' && lastChar == '') {\n                    key.deleteCharAt(key.length() - 2);\n                }\n            }\n\n            \n            if (lastChar == '') {\n                key.deleteCharAt(key.length() - 1);\n            }\n        }\n\n        final String string = key.toString();\n        return this.isStrict() ? string.substring(0, Math.min(TRUE_LENGTH, string.length())) : string;\n    }", "comment": "/**\n     * Retrieves the NYSIIS code for a given String object.\n     *\n     * @param str\n     *            String to encode using the NYSIIS algorithm\n     * @return A NYSIIS code for the String supplied\n     */"}}
{"code": {"body": "public RefinedSoundex() {\n        this.soundexMapping = US_ENGLISH_MAPPING;\n    }", "comment": "/**\n     * Creates an instance of the RefinedSoundex object using the default US\n     * English mapping.\n     */"}}
{"code": {"body": "public RefinedSoundex(final char[] mapping) {\n        this.soundexMapping = new char[mapping.length];\n        System.arraycopy(mapping, 0, this.soundexMapping, 0, mapping.length);\n    }", "comment": "/**\n     * Creates a refined soundex instance using a custom mapping. This\n     * constructor can be used to customize the mapping, and/or possibly\n     * provide an internationalized mapping for a non-Western character set.\n     *\n     * @param mapping\n     *                  Mapping array to use when finding the corresponding code for\n     *                  a given character\n     */"}}
{"code": {"body": "public RefinedSoundex(final String mapping) {\n        this.soundexMapping = mapping.toCharArray();\n    }", "comment": "/**\n     * Creates a refined Soundex instance using a custom mapping. This constructor can be used to customize the mapping,\n     * and/or possibly provide an internationalized mapping for a non-Western character set.\n     *\n     * @param mapping\n     *            Mapping string to use when finding the corresponding code for a given character\n     * @since 1.4\n     */"}}
{"code": {"body": "    public int difference(final String s1, final String s2) throws EncoderException {\n        return SoundexUtils.difference(this, s1, s2);\n    }", "comment": "/**\n     * Returns the number of characters in the two encoded Strings that are the\n     * same. This return value ranges from 0 to the length of the shortest\n     * encoded String: 0 indicates little or no similarity, and 4 out of 4 (for\n     * example) indicates strong similarity or identical values. For refined\n     * Soundex, the return value can be greater than 4.\n     *\n     * @param s1\n     *                  A String that will be encoded and compared.\n     * @param s2\n     *                  A String that will be encoded and compared.\n     * @return The number of characters in the two encoded Strings that are the\n     *             same from 0 to to the length of the shortest encoded String.\n     *\n     * @see SoundexUtils#difference(StringEncoder,String,String)\n     * @see <a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\">\n     *          MS T-SQL DIFFERENCE</a>\n     *\n     * @throws EncoderException\n     *                  if an error occurs encoding one of the strings\n     * @since 1.3\n     */"}}
{"code": {"body": "    char getMappingCode(final char c) {\n        if (!Character.isLetter(c)) {\n            return 0;\n        }\n        return this.soundexMapping[Character.toUpperCase(c) - ''];\n    }", "comment": "/**\n     * Returns the mapping code for a given character. The mapping codes are\n     * maintained in an internal char array named soundexMapping, and the\n     * default values of these mappings are US English.\n     *\n     * @param c\n     *                  char to get mapping for\n     * @return A character (really a numeral) to return for the given char\n     */"}}
{"code": {"body": "    public String soundex(String str) {\n        if (str == null) {\n            return null;\n        }\n        str = SoundexUtils.clean(str);\n        if (str.length() == 0) {\n            return str;\n        }\n\n        final StringBuilder sBuf = new StringBuilder();\n        sBuf.append(str.charAt(0));\n\n        char last, current;\n        last = '';\n\n        for (int i = 0; i < str.length(); i++) {\n\n            current = getMappingCode(str.charAt(i));\n            if (current == last) {\n                continue;\n            } else if (current != 0) {\n                sBuf.append(current);\n            }\n\n            last = current;\n\n        }\n\n        return sBuf.toString();\n    }", "comment": "/**\n     * Retrieves the Refined Soundex code for a given String object.\n     *\n     * @param str\n     *                  String to encode using the Refined Soundex algorithm\n     * @return A soundex code for the String supplied\n     */"}}
{"code": {"body": "public Soundex() {\n        this.soundexMapping = US_ENGLISH_MAPPING;\n    }", "comment": "/**\n     * Creates an instance using US_ENGLISH_MAPPING\n     *\n     * @see Soundex#Soundex(char[])\n     * @see Soundex#US_ENGLISH_MAPPING\n     */"}}
{"code": {"body": "public Soundex(final char[] mapping) {\n        this.soundexMapping = new char[mapping.length];\n        System.arraycopy(mapping, 0, this.soundexMapping, 0, mapping.length);\n    }", "comment": "/**\n     * Creates a soundex instance using the given mapping. This constructor can be used to provide an internationalized\n     * mapping for a non-Western character set.\n     *\n     * Every letter of the alphabet is \"mapped\" to a numerical value. This char array holds the values to which each\n     * letter is mapped. This implementation contains a default map for US_ENGLISH\n     *\n     * @param mapping\n     *                  Mapping array to use when finding the corresponding code for a given character\n     */"}}
{"code": {"body": "public Soundex(final String mapping) {\n        this.soundexMapping = mapping.toCharArray();\n    }", "comment": "/**\n     * Creates a refined soundex instance using a custom mapping. This constructor can be used to customize the mapping,\n     * and/or possibly provide an internationalized mapping for a non-Western character set.\n     *\n     * @param mapping\n     *            Mapping string to use when finding the corresponding code for a given character\n     * @since 1.4\n     */"}}
{"code": {"body": "    public int difference(final String s1, final String s2) throws EncoderException {\n        return SoundexUtils.difference(this, s1, s2);\n    }", "comment": "/**\n     * Encodes the Strings and returns the number of characters in the two encoded Strings that are the same. This\n     * return value ranges from 0 through 4: 0 indicates little or no similarity, and 4 indicates strong similarity or\n     * identical values.\n     *\n     * @param s1\n     *                  A String that will be encoded and compared.\n     * @param s2\n     *                  A String that will be encoded and compared.\n     * @return The number of characters in the two encoded Strings that are the same from 0 to 4.\n     *\n     * @see SoundexUtils#difference(StringEncoder,String,String)\n     * @see <a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\"> MS\n     *          T-SQL DIFFERENCE </a>\n     *\n     * @throws EncoderException\n     *                  if an error occurs encoding one of the strings\n     * @since 1.3\n     */"}}
{"code": {"body": "    private char getMappingCode(final String str, final int index) {\n        \n        final char mappedChar = this.map(str.charAt(index));\n        \n        if (index > 1 && mappedChar != '') {\n            final char hwChar = str.charAt(index - 1);\n            if ('' == hwChar || '' == hwChar) {\n                final char preHWChar = str.charAt(index - 2);\n                final char firstCode = this.map(preHWChar);\n                if (firstCode == mappedChar || '' == preHWChar || '' == preHWChar) {\n                    return 0;\n                }\n            }\n        }\n        return mappedChar;\n    }", "comment": "/**\n     * Used internally by the SoundEx algorithm.\n     *\n     * Consonants from the same code group separated by W or H are treated as one.\n     *\n     * @param str\n     *                  the cleaned working string to encode (in upper case).\n     * @param index\n     *                  the character position to encode\n     * @return Mapping code for a particular character\n     * @throws IllegalArgumentException\n     *                  if the character is not mapped\n     */"}}
{"code": {"body": "    private char[] getSoundexMapping() {\n        return this.soundexMapping;\n    }", "comment": "/**\n     * Returns the soundex mapping.\n     *\n     * @return soundexMapping.\n     */"}}
{"code": {"body": "    private char map(final char ch) {\n        final int index = ch - '';\n        if (index < 0 || index >= this.getSoundexMapping().length) {\n            throw new IllegalArgumentException(\"\" + ch);\n        }\n        return this.getSoundexMapping()[index];\n    }", "comment": "/**\n     * Maps the given upper-case character to its Soundex code.\n     *\n     * @param ch\n     *                  An upper-case character.\n     * @return A Soundex code.\n     * @throws IllegalArgumentException\n     *                  Thrown if <code>ch</code> is not mapped.\n     */"}}
{"code": {"body": "    public String soundex(String str) {\n        if (str == null) {\n            return null;\n        }\n        str = SoundexUtils.clean(str);\n        if (str.length() == 0) {\n            return str;\n        }\n        final char out[] = {'', '', '', ''};\n        char last, mapped;\n        int incount = 1, count = 1;\n        out[0] = str.charAt(0);\n        \n        last = getMappingCode(str, 0);\n        while (incount < str.length() && count < out.length) {\n            mapped = getMappingCode(str, incount++);\n            if (mapped != 0) {\n                if (mapped != '' && mapped != last) {\n                    out[count++] = mapped;\n                }\n                last = mapped;\n            }\n        }\n        return new String(out);\n    }", "comment": "/**\n     * Retrieves the Soundex code for a given String object.\n     *\n     * @param str\n     *                  String to encode using the Soundex algorithm\n     * @return A soundex code for the String supplied\n     * @throws IllegalArgumentException\n     *                  if a character is not mapped\n     */"}}
{"code": {"body": "    static String clean(final String str) {\n        if (str == null || str.length() == 0) {\n            return str;\n        }\n        final int len = str.length();\n        final char[] chars = new char[len];\n        int count = 0;\n        for (int i = 0; i < len; i++) {\n            if (Character.isLetter(str.charAt(i))) {\n                chars[count++] = str.charAt(i);\n            }\n        }\n        if (count == len) {\n            return str.toUpperCase(java.util.Locale.ENGLISH);\n        }\n        return new String(chars, 0, count).toUpperCase(java.util.Locale.ENGLISH);\n    }", "comment": "/**\n     * Cleans up the input string before Soundex processing by only returning\n     * upper case letters.\n     *\n     * @param str\n     *                  The String to clean.\n     * @return A clean String.\n     */"}}
{"code": {"body": "    static int difference(final StringEncoder encoder, final String s1, final String s2) throws EncoderException {\n        return differenceEncoded(encoder.encode(s1), encoder.encode(s2));\n    }", "comment": "/**\n     * Encodes the Strings and returns the number of characters in the two\n     * encoded Strings that are the same.\n     * <ul>\n     * <li>For Soundex, this return value ranges from 0 through 4: 0 indicates\n     * little or no similarity, and 4 indicates strong similarity or identical\n     * values.</li>\n     * <li>For refined Soundex, the return value can be greater than 4.</li>\n     * </ul>\n     *\n     * @param encoder\n     *                  The encoder to use to encode the Strings.\n     * @param s1\n     *                  A String that will be encoded and compared.\n     * @param s2\n     *                  A String that will be encoded and compared.\n     * @return The number of characters in the two Soundex encoded Strings that\n     *             are the same.\n     *\n     * @see #differenceEncoded(String,String)\n     * @see <a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\">\n     *          MS T-SQL DIFFERENCE</a>\n     *\n     * @throws EncoderException\n     *                  if an error occurs encoding one of the strings\n     */"}}
{"code": {"body": "    static int differenceEncoded(final String es1, final String es2) {\n\n        if (es1 == null || es2 == null) {\n            return 0;\n        }\n        final int lengthToMatch = Math.min(es1.length(), es2.length());\n        int diff = 0;\n        for (int i = 0; i < lengthToMatch; i++) {\n            if (es1.charAt(i) == es2.charAt(i)) {\n                diff++;\n            }\n        }\n        return diff;\n    }", "comment": "/**\n     * Returns the number of characters in the two Soundex encoded Strings that\n     * are the same.\n     * <ul>\n     * <li>For Soundex, this return value ranges from 0 through 4: 0 indicates\n     * little or no similarity, and 4 indicates strong similarity or identical\n     * values.</li>\n     * <li>For refined Soundex, the return value can be greater than 4.</li>\n     * </ul>\n     *\n     * @param es1\n     *                  An encoded String.\n     * @param es2\n     *                  An encoded String.\n     * @return The number of characters in the two Soundex encoded Strings that\n     *             are the same.\n     *\n     * @see <a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\">\n     *          MS T-SQL DIFFERENCE</a>\n     */"}}
{"code": {"body": "    public NameType getNameType() {\n        return this.engine.getNameType();\n    }", "comment": "/**\n     * Gets the name type currently in operation.\n     *\n     * @return the NameType currently being used\n     */"}}
{"code": {"body": "    public RuleType getRuleType() {\n        return this.engine.getRuleType();\n    }", "comment": "/**\n     * Gets the rule type currently in operation.\n     *\n     * @return the RuleType currently being used\n     */"}}
{"code": {"body": "    public boolean isConcat() {\n        return this.engine.isConcat();\n    }", "comment": "/**\n     * Discovers if multiple possible encodings are concatenated.\n     *\n     * @return true if multiple encodings are concatenated, false if just the first one is returned\n     */"}}
{"code": {"body": "    public void setConcat(final boolean concat) {\n        this.engine = new PhoneticEngine(this.engine.getNameType(),\n                                         this.engine.getRuleType(),\n                                         concat,\n                                         this.engine.getMaxPhonemes());\n    }", "comment": "/**\n     * Sets how multiple possible phonetic encodings are combined.\n     *\n     * @param concat\n     *            true if multiple encodings are to be combined with a '|', false if just the first one is\n     *            to be considered\n     */"}}
{"code": {"body": "    public void setNameType(final NameType nameType) {\n        this.engine = new PhoneticEngine(nameType,\n                                         this.engine.getRuleType(),\n                                         this.engine.isConcat(),\n                                         this.engine.getMaxPhonemes());\n    }", "comment": "/**\n     * Sets the type of name. Use {@link NameType#GENERIC} unless you specifically want phonetic encodings\n     * optimized for Ashkenazi or Sephardic Jewish family names.\n     *\n     * @param nameType\n     *            the NameType in use\n     */"}}
{"code": {"body": "    public void setRuleType(final RuleType ruleType) {\n        this.engine = new PhoneticEngine(this.engine.getNameType(),\n                                         ruleType,\n                                         this.engine.isConcat(),\n                                         this.engine.getMaxPhonemes());\n    }", "comment": "/**\n     * Sets the rule type to apply. This will widen or narrow the range of phonetic encodings considered.\n     *\n     * @param ruleType\n     *            {@link RuleType#APPROX} or {@link RuleType#EXACT} for approximate or exact phonetic matches\n     */"}}
{"code": {"body": "    public void setMaxPhonemes(final int maxPhonemes) {\n        this.engine = new PhoneticEngine(this.engine.getNameType(),\n                                         this.engine.getRuleType(),\n                                         this.engine.isConcat(),\n                                         maxPhonemes);\n    }", "comment": "/**\n     * Sets the number of maximum of phonemes that shall be considered by the engine.\n     *\n     * @param maxPhonemes\n     *            the maximum number of phonemes returned by the engine\n     * @since 1.7\n     */"}}
{"code": {"body": "public Languages.LanguageSet guessLanguages(final String input) {\n        final String text = input.toLowerCase(Locale.ENGLISH);\n\n        final Set<String> langs = new HashSet<String>(this.languages.getLanguages());\n        for (final LangRule rule : this.rules) {\n            if (rule.matches(text)) {\n                if (rule.acceptOnMatch) {\n                    langs.retainAll(rule.languages);\n                } else {\n                    langs.removeAll(rule.languages);\n                }\n            }\n        }\n\n        final Languages.LanguageSet ls = Languages.LanguageSet.from(langs);\n        return ls.equals(Languages.NO_LANGUAGES) ? Languages.ANY_LANGUAGE : ls;\n    }", "comment": "/**\n     * Guesses the languages of a word.\n     *\n     * @param input\n     *            the word\n     * @return a Set of Strings of language names that are potential matches for the input word\n     */"}}
{"code": {"body": "    public static Lang instance(final NameType nameType) {\n        return Langs.get(nameType);\n    }", "comment": "/**\n     * Gets a Lang instance for one of the supported NameTypes.\n     *\n     * @param nameType\n     *            the NameType to look up\n     * @return a Lang encapsulating the language guessing rules for that name type\n     */"}}
{"code": {"body": "    public static Lang loadFromResource(final String languageRulesResourceName, final Languages languages) {\n        final List<LangRule> rules = new ArrayList<LangRule>();\n        final InputStream lRulesIS = Lang.class.getClassLoader().getResourceAsStream(languageRulesResourceName);\n\n        if (lRulesIS == null) {\n            throw new IllegalStateException(\"\" + LANGUAGE_RULES_RN);\n        }\n\n        final Scanner scanner = new Scanner(lRulesIS, ResourceConstants.ENCODING);\n        try {\n            boolean inExtendedComment = false;\n            while (scanner.hasNextLine()) {\n                final String rawLine = scanner.nextLine();\n                String line = rawLine;\n                if (inExtendedComment) {\n                    \n                    if (line.endsWith(ResourceConstants.EXT_CMT_END)) {\n                        inExtendedComment = false;\n                    }\n                } else {\n                    if (line.startsWith(ResourceConstants.EXT_CMT_START)) {\n                        inExtendedComment = true;\n                    } else {\n                        \n                        final int cmtI = line.indexOf(ResourceConstants.CMT);\n                        if (cmtI >= 0) {\n                            line = line.substring(0, cmtI);\n                        }\n\n                        \n                        line = line.trim();\n\n                        if (line.length() == 0) {\n                            continue; \n                        }\n\n                        \n                        final String[] parts = line.split(\"\");\n\n                        if (parts.length != 3) {\n                            throw new IllegalArgumentException(\"\" + rawLine +\n                                    \"\" + languageRulesResourceName + \"\");\n                        }\n\n                        final Pattern pattern = Pattern.compile(parts[0]);\n                        final String[] langs = parts[1].split(\"\");\n                        final boolean accept = parts[2].equals(\"\");\n\n                        rules.add(new LangRule(pattern, new HashSet<String>(Arrays.asList(langs)), accept));\n                    }\n                }\n            }\n        } finally {\n            scanner.close();\n        }\n        return new Lang(rules, languages);\n    }", "comment": "/**\n     * Loads language rules from a resource.\n     * <p>\n     * In normal use, you will obtain instances of Lang through the {@link #instance(NameType)} method.\n     * You will only need to call this yourself if you are developing custom language mapping rules.\n     *\n     * @param languageRulesResourceName\n     *            the fully-qualified resource name to load\n     * @param languages\n     *            the languages that these rules will support\n     * @return a Lang encapsulating the loaded language-guessing rules.\n     */"}}
{"code": {"body": "    public String guessLanguage(final String text) {\n        final Languages.LanguageSet ls = guessLanguages(text);\n        return ls.isSingleton() ? ls.getAny() : Languages.ANY;\n    }", "comment": "/**\n     * Guesses the language of a word.\n     *\n     * @param text\n     *            the word\n     * @return the language that the word originates from or {@link Languages#ANY} if there was no unique match\n     */"}}
{"code": {"body": "    public Languages.LanguageSet guessLanguages(final String input) {\n        final String text = input.toLowerCase(Locale.ENGLISH);\n\n        final Set<String> langs = new HashSet<String>(this.languages.getLanguages());\n        for (final LangRule rule : this.rules) {\n            if (rule.matches(text)) {\n                if (rule.acceptOnMatch) {\n                    langs.retainAll(rule.languages);\n                } else {\n                    langs.removeAll(rule.languages);\n                }\n            }\n        }\n\n        final Languages.LanguageSet ls = Languages.LanguageSet.from(langs);\n        return ls.equals(Languages.NO_LANGUAGES) ? Languages.ANY_LANGUAGE : ls;\n    }", "comment": "/**\n     * Guesses the languages of a word.\n     *\n     * @param input\n     *            the word\n     * @return a Set of Strings of language names that are potential matches for the input word\n     */"}}
{"code": {"body": "    public String getName() {\n        return this.name;\n    }", "comment": "/**\n     * Gets the short version of the name type.\n     *\n     * @return the NameType short string\n     */"}}
{"code": {"body": "public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concat) {\n        this(nameType, ruleType, concat, DEFAULT_MAX_PHONEMES);\n    }", "comment": "/**\n     * Generates a new, fully-configured phonetic engine.\n     *\n     * @param nameType\n     *            the type of names it will use\n     * @param ruleType\n     *            the type of rules it will apply\n     * @param concat\n     *            if it will concatenate multiple encodings\n     */"}}
{"code": {"body": "public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concat)", "comment": "/**\n     * Generates a new, fully-configured phonetic engine.\n     *\n     * @param nameType\n     *            the type of names it will use\n     * @param ruleType\n     *            the type of rules it will apply\n     * @param concat\n     *            if it will concatenate multiple encodings\n     */"}}
{"code": {"body": "        public static PhonemeBuilder empty(final Languages.LanguageSet languages) {\n            return new PhonemeBuilder(new Rule.Phoneme(\"\", languages));\n        }", "comment": "/**\n         * An empty builder where all phonemes must come from some set of languages. This will contain a single\n         * phoneme of zero characters. This can then be appended to. This should be the only way to create a new\n         * phoneme from scratch.\n         *\n         * @param languages the set of languages\n         * @return  a new, empty phoneme builder\n         */"}}
{"code": {"body": "        public void append(final CharSequence str) {\n            for (final Rule.Phoneme ph : this.phonemes) {\n                ph.append(str);\n            }\n        }", "comment": "/**\n         * Creates a new phoneme builder containing all phonemes in this one extended by <code>str</code>.\n         *\n         * @param str   the characters to append to the phonemes\n         */"}}
{"code": {"body": "        public void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {\n            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);\n\n            EXPR: for (final Rule.Phoneme left : this.phonemes) {\n                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {\n                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());\n                    if (!languages.isEmpty()) {\n                        final Rule.Phoneme join = new Phoneme(left, right, languages);\n                        if (newPhonemes.size() < maxPhonemes) {\n                            newPhonemes.add(join);\n                            if (newPhonemes.size() >= maxPhonemes) {\n                                break EXPR;\n                            }\n                        }\n                    }\n                }\n            }\n\n            this.phonemes.clear();\n            this.phonemes.addAll(newPhonemes);\n        }", "comment": "/**\n         * Applies the given phoneme expression to all phonemes in this phoneme builder.\n         * <p>\n         * This will lengthen phonemes that have compatible language sets to the expression, and drop those that are\n         * incompatible.\n         *\n         * @param phonemeExpr   the expression to apply\n         * @param maxPhonemes   the maximum number of phonemes to build up\n         */"}}
{"code": {"body": "        public Set<Rule.Phoneme> getPhonemes() {\n            return this.phonemes;\n        }", "comment": "/**\n         * Gets underlying phoneme set. Please don't mutate.\n         *\n         * @return  the phoneme set\n         */"}}
{"code": {"body": "        public String makeString() {\n            final StringBuilder sb = new StringBuilder();\n\n            for (final Rule.Phoneme ph : this.phonemes) {\n                if (sb.length() > 0) {\n                    sb.append(\"\");\n                }\n                sb.append(ph.getPhonemeText());\n            }\n\n            return sb.toString();\n        }", "comment": "/**\n         * Stringifies the phoneme set. This produces a single string of the strings of each phoneme,\n         * joined with a pipe. This is explicitly provided in place of toString as it is a potentially\n         * expensive operation, which should be avoided when debugging.\n         *\n         * @return  the stringified phoneme set\n         */"}}
{"code": {"body": "        public RulesApplication invoke() {\n            this.found = false;\n            int patternLength = 1;\n            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));\n            if (rules != null) {\n                for (final Rule rule : rules) {\n                    final String pattern = rule.getPattern();\n                    patternLength = pattern.length();\n                    if (rule.patternAndContextMatches(this.input, this.i)) {\n                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);\n                        this.found = true;\n                        break;\n                    }\n                }\n            }\n\n            if (!this.found) {\n                patternLength = 1;\n            }\n\n            this.i += patternLength;\n            return this;\n        }", "comment": "/**\n         * Invokes the rules. Loops over the rules list, stopping at the first one that has a matching context\n         * and pattern. Then applies this rule to the phoneme builder to produce updated phonemes. If there was no\n         * match, <code>i</code> is advanced one and the character is silently dropped from the phonetic spelling.\n         *\n         * @return <code>this</code>\n         */"}}
{"code": {"body": "    private static String join(final Iterable<String> strings, final String sep) {\n        final StringBuilder sb = new StringBuilder();\n        final Iterator<String> si = strings.iterator();\n        if (si.hasNext()) {\n            sb.append(si.next());\n        }\n        while (si.hasNext()) {\n            sb.append(sep).append(si.next());\n        }\n\n        return sb.toString();\n    }", "comment": "/**\n     * Joins some strings with an internal separator.\n     * @param strings   Strings to join\n     * @param sep       String to separate them with\n     * @return a single String consisting of each element of <code>strings</code> interleaved by <code>sep</code>\n     */"}}
{"code": {"body": "    private PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,\n                                           final Map<String, List<Rule>> finalRules) {\n        if (finalRules == null) {\n            throw new NullPointerException(\"\");\n        }\n        if (finalRules.isEmpty()) {\n            return phonemeBuilder;\n        }\n\n        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =\n            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);\n\n        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {\n            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());\n            final String phonemeText = phoneme.getPhonemeText().toString();\n\n            for (int i = 0; i < phonemeText.length();) {\n                final RulesApplication rulesApplication =\n                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();\n                final boolean found = rulesApplication.isFound();\n                subBuilder = rulesApplication.getPhonemeBuilder();\n\n                if (!found) {\n                    \n                    subBuilder.append(phonemeText.subSequence(i, i + 1));\n                }\n\n                i = rulesApplication.getI();\n            }\n\n            \n            \n            \n            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {\n                if (phonemes.containsKey(newPhoneme)) {\n                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);\n                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());\n                    phonemes.put(mergedPhoneme, mergedPhoneme);\n                } else {\n                    phonemes.put(newPhoneme, newPhoneme);\n                }\n            }\n        }\n\n        return new PhonemeBuilder(phonemes.keySet());\n    }", "comment": "/**\n     * Applies the final rules to convert from a language-specific phonetic representation to a\n     * language-independent representation.\n     *\n     * @param phonemeBuilder the current phonemes\n     * @param finalRules the final rules to apply\n     * @return the resulting phonemes\n     */"}}
{"code": {"body": "    public String encode(String input, final Languages.LanguageSet languageSet) {\n        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);\n        \n        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, \"\");\n        \n        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);\n\n        \n        \n        input = input.toLowerCase(Locale.ENGLISH).replace('', '').trim();\n\n        if (this.nameType == NameType.GENERIC) {\n            if (input.length() >= 2 && input.substring(0, 2).equals(\"\")) { \n                final String remainder = input.substring(2);\n                final String combined = \"\" + remainder;\n                return \"\" + encode(remainder) + \"\" + encode(combined) + \"\";\n            }\n            for (final String l : NAME_PREFIXES.get(this.nameType)) {\n                \n                if (input.startsWith(l + \"\")) {\n                    \n                    final String remainder = input.substring(l.length() + 1); \n                    final String combined = l + remainder; \n                    return \"\" + encode(remainder) + \"\" + encode(combined) + \"\";\n                }\n            }\n        }\n\n        final List<String> words = Arrays.asList(input.split(\"\"));\n        final List<String> words2 = new ArrayList<String>();\n\n        \n        switch (this.nameType) {\n        case SEPHARDIC:\n            for (final String aWord : words) {\n                final String[] parts = aWord.split(\"\");\n                final String lastPart = parts[parts.length - 1];\n                words2.add(lastPart);\n            }\n            words2.removeAll(NAME_PREFIXES.get(this.nameType));\n            break;\n        case ASHKENAZI:\n            words2.addAll(words);\n            words2.removeAll(NAME_PREFIXES.get(this.nameType));\n            break;\n        case GENERIC:\n            words2.addAll(words);\n            break;\n        default:\n            throw new IllegalStateException(\"\" + this.nameType);\n        }\n\n        if (this.concat) {\n            \n            input = join(words2, \"\");\n        } else if (words2.size() == 1) {\n            \n            input = words.iterator().next();\n        } else {\n            \n            final StringBuilder result = new StringBuilder();\n            for (final String word : words2) {\n                result.append(\"\").append(encode(word));\n            }\n            \n            return result.substring(1);\n        }\n\n        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);\n\n        \n        for (int i = 0; i < input.length();) {\n            final RulesApplication rulesApplication =\n                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();\n            i = rulesApplication.getI();\n            phonemeBuilder = rulesApplication.getPhonemeBuilder();\n        }\n\n        \n        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);\n        \n        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);\n\n        return phonemeBuilder.makeString();\n    }", "comment": "/**\n     * Encodes an input string into an output phonetic representation, given a set of possible origin languages.\n     *\n     * @param input\n     *            String to phoneticise; a String with dashes or spaces separating each word\n     * @param languageSet\n     *            set of possible origin languages\n     * @return a phonetic representation of the input; a String containing '-'-separated phonetic representations of the\n     *         input\n     */"}}
{"code": {"body": "    public Lang getLang() {\n        return this.lang;\n    }", "comment": "/**\n     * Gets the Lang language guessing rules being used.\n     *\n     * @return the Lang in use\n     */"}}
{"code": {"body": "    public NameType getNameType() {\n        return this.nameType;\n    }", "comment": "/**\n     * Gets the NameType being used.\n     *\n     * @return the NameType in use\n     */"}}
{"code": {"body": "    public RuleType getRuleType() {\n        return this.ruleType;\n    }", "comment": "/**\n     * Gets the RuleType being used.\n     *\n     * @return the RuleType in use\n     */"}}
{"code": {"body": "    public boolean isConcat() {\n        return this.concat;\n    }", "comment": "/**\n     * Gets if multiple phonetic encodings are concatenated or if just the first one is kept.\n     *\n     * @return true if multiple phonetic encodings are returned, false if just the first is\n     */"}}
{"code": {"body": "    public int getMaxPhonemes() {\n        return this.maxPhonemes;\n    }", "comment": "/**\n     * Gets the maximum number of phonemes the engine will calculate for a given input.\n     *\n     * @return the maximum number of phonemes\n     * @since 1.7\n     */"}}
{"code": {"body": "public Rule(final String pattern, final String lContext, final String rContext, final PhonemeExpr phoneme) {\n        this.pattern = pattern;\n        this.lContext = pattern(lContext + \"\");\n        this.rContext = pattern(\"\" + rContext);\n        this.phoneme = phoneme;\n    }", "comment": "/**\n     * Creates a new rule.\n     *\n     * @param pattern\n     *            the pattern\n     * @param lContext\n     *            the left context\n     * @param rContext\n     *            the right context\n     * @param phoneme\n     *            the resulting phoneme\n     */"}}
{"code": {"body": "        public Phoneme mergeWithLanguage(final LanguageSet lang) {\n          return new Phoneme(this.phonemeText.toString(), this.languages.merge(lang));\n        }", "comment": "/**\n         * Returns a new Phoneme with the same text but a union of its\n         * current language set and the given one.\n         *\n         * @param lang the language set to merge\n         * @return a new Phoneme\n         */"}}
{"code": {"body": "    public static List<Rule> getInstance(final NameType nameType, final RuleType rt, final String lang) {\n        return getInstance(nameType, rt, LanguageSet.from(new HashSet<String>(Arrays.asList(lang))));\n    }", "comment": "/**\n     * Gets rules for a combination of name type, rule type and a single language.\n     *\n     * @param nameType\n     *            the NameType to consider\n     * @param rt\n     *            the RuleType to consider\n     * @param lang\n     *            the language to consider\n     * @return a list of Rules that apply\n     */"}}
{"code": {"body": "    public static Map<String, List<Rule>> getInstanceMap(final NameType nameType, final RuleType rt,\n                                                         final String lang) {\n        final Map<String, List<Rule>> rules = RULES.get(nameType).get(rt).get(lang);\n\n        if (rules == null) {\n            throw new IllegalArgumentException(String.format(\"\",\n                                               nameType.getName(), rt.getName(), lang));\n        }\n\n        return rules;\n    }", "comment": "/**\n     * Gets rules for a combination of name type, rule type and a single language.\n     *\n     * @param nameType\n     *            the NameType to consider\n     * @param rt\n     *            the RuleType to consider\n     * @param lang\n     *            the language to consider\n     * @return a map containing all Rules that apply, grouped by the first character of the rule pattern\n     * @since 1.9\n     */"}}
{"code": {"body": "    private static RPattern pattern(final String regex) {\n        final boolean startsWith = regex.startsWith(\"\");\n        final boolean endsWith = regex.endsWith(\"\");\n        final String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length());\n        final boolean boxes = content.contains(\"\");\n\n        if (!boxes) {\n            if (startsWith && endsWith) {\n                \n                if (content.length() == 0) {\n                    \n                    return new RPattern() {\n                        @Override\n                        public boolean isMatch(final CharSequence input) {\n                            return input.length() == 0;\n                        }\n                    };\n                } else {\n                    return new RPattern() {\n                        @Override\n                        public boolean isMatch(final CharSequence input) {\n                            return input.equals(content);\n                        }\n                    };\n                }\n            } else if ((startsWith || endsWith) && content.length() == 0) {\n                \n                return ALL_STRINGS_RMATCHER;\n            } else if (startsWith) {\n                \n                return new RPattern() {\n                    @Override\n                    public boolean isMatch(final CharSequence input) {\n                        return startsWith(input, content);\n                    }\n                };\n            } else if (endsWith) {\n                \n                return new RPattern() {\n                    @Override\n                    public boolean isMatch(final CharSequence input) {\n                        return endsWith(input, content);\n                    }\n                };\n            }\n        } else {\n            final boolean startsWithBox = content.startsWith(\"\");\n            final boolean endsWithBox = content.endsWith(\"\");\n\n            if (startsWithBox && endsWithBox) {\n                String boxContent = content.substring(1, content.length() - 1);\n                if (!boxContent.contains(\"\")) {\n                    \n                    final boolean negate = boxContent.startsWith(\"\");\n                    if (negate) {\n                        boxContent = boxContent.substring(1);\n                    }\n                    final String bContent = boxContent;\n                    final boolean shouldMatch = !negate;\n\n                    if (startsWith && endsWith) {\n                        \n                        return new RPattern() {\n                            @Override\n                            public boolean isMatch(final CharSequence input) {\n                                return input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch;\n                            }\n                        };\n                    } else if (startsWith) {\n                        \n                        return new RPattern() {\n                            @Override\n                            public boolean isMatch(final CharSequence input) {\n                                return input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch;\n                            }\n                        };\n                    } else if (endsWith) {\n                        \n                        return new RPattern() {\n                            @Override\n                            public boolean isMatch(final CharSequence input) {\n                                return input.length() > 0 &&\n                                       contains(bContent, input.charAt(input.length() - 1)) == shouldMatch;\n                            }\n                        };\n                    }\n                }\n            }\n        }\n\n        return new RPattern() {\n            Pattern pattern = Pattern.compile(regex);\n\n            @Override\n            public boolean isMatch(final CharSequence input) {\n                final Matcher matcher = pattern.matcher(input);\n                return matcher.find();\n            }\n        };\n    }", "comment": "/**\n     * Attempts to compile the regex into direct string ops, falling back to Pattern and Matcher in the worst case.\n     *\n     * @param regex\n     *            the regular expression to compile\n     * @return an RPattern that will match this regex\n     */"}}
{"code": {"body": "    public RPattern getLContext() {\n        return this.lContext;\n    }", "comment": "/**\n     * Gets the left context. This is a regular expression that must match to the left of the pattern.\n     *\n     * @return the left context Pattern\n     */"}}
{"code": {"body": "    public String getPattern() {\n        return this.pattern;\n    }", "comment": "/**\n     * Gets the pattern. This is a string-literal that must exactly match.\n     *\n     * @return the pattern\n     */"}}
{"code": {"body": "    public PhonemeExpr getPhoneme() {\n        return this.phoneme;\n    }", "comment": "/**\n     * Gets the phoneme. If the rule matches, this is the phoneme associated with the pattern match.\n     *\n     * @return the phoneme\n     */"}}
{"code": {"body": "    public RPattern getRContext() {\n        return this.rContext;\n    }", "comment": "/**\n     * Gets the right context. This is a regular expression that must match to the right of the pattern.\n     *\n     * @return the right context Pattern\n     */"}}
{"code": {"body": "    public boolean patternAndContextMatches(final CharSequence input, final int i) {\n        if (i < 0) {\n            throw new IndexOutOfBoundsException(\"\");\n        }\n\n        final int patternLength = this.pattern.length();\n        final int ipl = i + patternLength;\n\n        if (ipl > input.length()) {\n            \n            return false;\n        }\n\n        \n        \n        if (!input.subSequence(i, ipl).equals(this.pattern)) {\n            return false;\n        } else if (!this.rContext.isMatch(input.subSequence(ipl, input.length()))) {\n            return false;\n        }\n        return this.lContext.isMatch(input.subSequence(0, i));\n    }", "comment": "/**\n     * Decides if the pattern and context match the input starting at a position. It is a match if the\n     * <code>lContext</code> matches <code>input</code> up to <code>i</code>, <code>pattern</code> matches at i and\n     * <code>rContext</code> matches from the end of the match of <code>pattern</code> to the end of <code>input</code>.\n     *\n     * @param input\n     *            the input String\n     * @param i\n     *            the int position within the input\n     * @return true if the pattern and left/right context match, false otherwise\n     */"}}
{"code": {"body": "    public String getName() {\n        return this.name;\n    }", "comment": "/**\n     * Gets the rule name.\n     *\n     * @return the rule name.\n     */"}}
{"code": {"body": "public BCodec() {\n        this(Charsets.UTF_8);\n    }", "comment": "/**\n     * Default constructor.\n     */"}}
{"code": {"body": "public BCodec(final Charset charset) {\n        this.charset = charset;\n    }", "comment": "/**\n     * Constructor which allows for the selection of a default charset\n     *\n     * @param charset\n     *            the default string charset to use.\n     *\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @since 1.7\n     */"}}
{"code": {"body": "public BCodec(final String charsetName) {\n        this(Charset.forName(charsetName));\n    }", "comment": "/**\n     * Constructor which allows for the selection of a default charset\n     *\n     * @param charsetName\n     *            the default charset to use.\n     * @throws java.nio.charset.UnsupportedCharsetException\n     *             If the named charset is unavailable\n     * @since 1.7 throws UnsupportedCharsetException if the named charset is unavailable\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     */"}}
{"code": {"body": "    public Charset getCharset() {\n        return this.charset;\n    }", "comment": "/**\n     * Gets the default charset name used for string decoding and encoding.\n     *\n     * @return the default charset name\n     * @since 1.7\n     */"}}
{"code": {"body": "    public String getDefaultCharset() {\n        return this.charset.name();\n    }", "comment": "/**\n     * Gets the default charset name used for string decoding and encoding.\n     *\n     * @return the default charset name\n     */"}}
{"code": {"body": "public QCodec() {\n        this(Charsets.UTF_8);\n    }", "comment": "/**\n     * Default constructor.\n     */"}}
{"code": {"body": "public QCodec(final Charset charset) {\n        super();\n        this.charset = charset;\n    }", "comment": "/**\n     * Constructor which allows for the selection of a default charset.\n     *\n     * @param charset\n     *            the default string charset to use.\n     *\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @since 1.7\n     */"}}
{"code": {"body": "public QCodec(final String charsetName) {\n        this(Charset.forName(charsetName));\n    }", "comment": "/**\n     * Constructor which allows for the selection of a default charset.\n     *\n     * @param charsetName\n     *            the charset to use.\n     * @throws java.nio.charset.UnsupportedCharsetException\n     *             If the named charset is unavailable\n     * @since 1.7 throws UnsupportedCharsetException if the named charset is unavailable\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     */"}}
{"code": {"body": "    public Charset getCharset() {\n        return this.charset;\n    }", "comment": "/**\n     * Gets the default charset name used for string decoding and encoding.\n     *\n     * @return the default charset name\n     * @since 1.7\n     */"}}
{"code": {"body": "    public String getDefaultCharset() {\n        return this.charset.name();\n    }", "comment": "/**\n     * Gets the default charset name used for string decoding and encoding.\n     *\n     * @return the default charset name\n     */"}}
{"code": {"body": "    public boolean isEncodeBlanks() {\n        return this.encodeBlanks;\n    }", "comment": "/**\n     * Tests if optional transformation of SPACE characters is to be used\n     *\n     * @return <code>true</code> if SPACE characters are to be transformed, <code>false</code> otherwise\n     */"}}
{"code": {"body": "    public void setEncodeBlanks(final boolean b) {\n        this.encodeBlanks = b;\n    }", "comment": "/**\n     * Defines whether optional transformation of SPACE characters is to be used\n     *\n     * @param b\n     *            <code>true</code> if SPACE characters are to be transformed, <code>false</code> otherwise\n     */"}}
{"code": {"body": "public QuotedPrintableCodec() {\n        this(Charsets.UTF_8, false);\n    }", "comment": "/**\n     * Default constructor, assumes default charset of {@link Charsets#UTF_8}\n     */"}}
{"code": {"body": "public QuotedPrintableCodec(final boolean strict) {\n        this(Charsets.UTF_8, strict);\n    }", "comment": "/**\n     * Constructor which allows for the selection of the strict mode.\n     *\n     * @param strict\n     *            if {@code true}, soft line breaks will be used\n     * @since 1.10\n     */"}}
{"code": {"body": "public QuotedPrintableCodec(final Charset charset) {\n        this(charset, false);\n    }", "comment": "/**\n     * Constructor which allows for the selection of a default charset.\n     *\n     * @param charset\n     *            the default string charset to use.\n     * @since 1.7\n     */"}}
{"code": {"body": "public QuotedPrintableCodec(final Charset charset, final boolean strict) {\n        this.charset = charset;\n        this.strict = strict;\n    }", "comment": "/**\n     * Constructor which allows for the selection of a default charset and strict mode.\n     *\n     * @param charset\n     *            the default string charset to use.\n     * @param strict\n     *            if {@code true}, soft line breaks will be used\n     * @since 1.10\n     */"}}
{"code": {"body": "public QuotedPrintableCodec(final String charsetName)", "comment": "/**\n     * Constructor which allows for the selection of a default charset.\n     *\n     * @param charsetName\n     *            the default string charset to use.\n     * @throws UnsupportedCharsetException\n     *             If no support for the named charset is available\n     *             in this instance of the Java virtual machine\n     * @throws IllegalArgumentException\n     *             If the given charsetName is null\n     * @throws IllegalCharsetNameException\n     *             If the given charset name is illegal\n     *\n     * @since 1.7 throws UnsupportedCharsetException if the named charset is unavailable\n     */"}}
{"code": {"body": "    public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes, boolean strict) {\n        if (bytes == null) {\n            return null;\n        }\n        if (printable == null) {\n            printable = PRINTABLE_CHARS;\n        }\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n\n        if (strict) {\n            int pos = 1;\n            \n            \n            for (int i = 0; i < bytes.length - 3; i++) {\n                int b = getUnsignedOctet(i, bytes);\n                if (pos < SAFE_LENGTH) {\n                    \n                    pos += encodeByte(b, !printable.get(b), buffer);\n                } else {\n                    \n                    encodeByte(b, !printable.get(b) || isWhitespace(b), buffer);\n\n                    \n                    buffer.write(ESCAPE_CHAR);\n                    buffer.write(CR);\n                    buffer.write(LF);\n                    pos = 1;\n                }\n            }\n\n            \n            \n            int b = getUnsignedOctet(bytes.length - 3, bytes);\n            boolean encode = !printable.get(b) || (isWhitespace(b) && pos > SAFE_LENGTH - 5);\n            pos += encodeByte(b, encode, buffer);\n\n            \n            \n            \n            if (pos > SAFE_LENGTH - 2) {\n                buffer.write(ESCAPE_CHAR);\n                buffer.write(CR);\n                buffer.write(LF);\n            }\n            for (int i = bytes.length - 2; i < bytes.length; i++) {\n                b = getUnsignedOctet(i, bytes);\n                \n                encode = !printable.get(b) || (i > bytes.length - 2 && isWhitespace(b));\n                encodeByte(b, encode, buffer);\n            }\n        } else {\n            for (final byte c : bytes) {\n                int b = c;\n                if (b < 0) {\n                    b = 256 + b;\n                }\n                if (printable.get(b)) {\n                    buffer.write(b);\n                } else {\n                    encodeQuotedPrintable(b, buffer);\n                }\n            }\n        }\n        return buffer.toByteArray();\n    }", "comment": "/**\n     * Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.\n     * <p>\n     * Depending on the selection of the {@code strict} parameter, this function either implements the full ruleset\n     * or only a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n     * RFC 1521 and is suitable for encoding binary data and unformatted text.\n     *\n     * @param printable\n     *            bitset of characters deemed quoted-printable\n     * @param bytes\n     *            array of bytes to be encoded\n     * @param strict\n     *            if {@code true} the full ruleset is used, otherwise only rule #1 and rule #2\n     * @return array of bytes containing quoted-printable data\n     * @since 1.10\n     */"}}
{"code": {"body": "    private static int getUnsignedOctet(final int index, final byte[] bytes) {\n        int b = bytes[index];\n        if (b < 0) {\n            b = 256 + b;\n        }\n        return b;\n    }", "comment": "/**\n     * Return the byte at position <code>index</code> of the byte array and\n     * make sure it is unsigned.\n     *\n     * @param index\n     *            position in the array\n     * @param bytes\n     *            the byte array\n     * @return the unsigned octet at position <code>index</code> from the array\n     */"}}
{"code": {"body": "    private static int encodeByte(final int b, final boolean encode,\n                                  final ByteArrayOutputStream buffer) {\n        if (encode) {\n            return encodeQuotedPrintable(b, buffer);\n        } else {\n            buffer.write(b);\n            return 1;\n        }\n    }", "comment": "/**\n     * Write a byte to the buffer.\n     *\n     * @param b\n     *            byte to write\n     * @param encode\n     *            indicates whether the octet shall be encoded\n     * @param buffer\n     *            the buffer to write to\n     * @return the number of bytes that have been written to the buffer\n     */"}}
{"code": {"body": "    private static boolean isWhitespace(final int b) {\n        return b == SPACE || b == TAB;\n    }", "comment": "/**\n     * Checks whether the given byte is whitespace.\n     *\n     * @param b\n     *            byte to be checked\n     * @return <code>true</code> if the byte is either a space or tab character\n     */"}}
{"code": {"body": "    public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {\n        if (bytes == null) {\n            return null;\n        }\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            final int b = bytes[i];\n            if (b == ESCAPE_CHAR) {\n                try {\n                    \n                    if (bytes[++i] == CR) {\n                        continue;\n                    }\n                    final int u = Utils.digit16(bytes[i]);\n                    final int l = Utils.digit16(bytes[++i]);\n                    buffer.write((char) ((u << 4) + l));\n                } catch (final ArrayIndexOutOfBoundsException e) {\n                    throw new DecoderException(\"\", e);\n                }\n            } else if (b != CR && b != LF) {\n                \n                buffer.write(b);\n            }\n        }\n        return buffer.toByteArray();\n    }", "comment": "/**\n     * Decodes an array quoted-printable characters into an array of original bytes. Escaped characters are converted\n     * back to their original representation.\n     * <p>\n     * This function fully implements the quoted-printable encoding specification (rule #1 through rule #5) as\n     * defined in RFC 1521.\n     *\n     * @param bytes\n     *            array of quoted-printable characters\n     * @return array of original bytes\n     * @throws DecoderException\n     *             Thrown if quoted-printable decoding is unsuccessful\n     */"}}
{"code": {"body": "    public String encode(final String str, final String charset) throws UnsupportedEncodingException {\n        if (str == null) {\n            return null;\n        }\n        return StringUtils.newStringUsAscii(encode(str.getBytes(charset)));\n    }", "comment": "/**\n     * Encodes a string into its quoted-printable form using the specified charset. Unsafe characters are escaped.\n     * <p>\n     * Depending on the selection of the {@code strict} parameter, this function either implements the full ruleset\n     * or only a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n     * RFC 1521 and is suitable for encoding binary data and unformatted text.\n     *\n     * @param str\n     *            string to convert to quoted-printable form\n     * @param charset\n     *            the charset for str\n     * @return quoted-printable string\n     * @throws UnsupportedEncodingException\n     *             Thrown if the charset is not supported\n     */"}}
{"code": {"body": "    public Charset getCharset() {\n        return this.charset;\n    }", "comment": "/**\n     * Gets the default charset name used for string decoding and encoding.\n     *\n     * @return the default charset name\n     * @since 1.7\n     */"}}
{"code": {"body": "    public String getDefaultCharset() {\n        return this.charset.name();\n    }", "comment": "/**\n     * Gets the default charset name used for string decoding and encoding.\n     *\n     * @return the default charset name\n     */"}}
{"code": {"body": "    protected String encodeText(final String text, final String charsetName)\n            throws EncoderException, UnsupportedEncodingException {\n        if (text == null) {\n            return null;\n        }\n        return this.encodeText(text, Charset.forName(charsetName));\n    }", "comment": "/**\n     * Applies an RFC 1522 compliant encoding scheme to the given string of text with the given charset.\n     * <p>\n     * This method constructs the \"encoded-word\" header common to all the RFC 1522 codecs and then invokes\n     * {@link #doEncoding(byte [])} method of a concrete class to perform the specific encoding.\n     *\n     * @param text\n     *            a string to encode\n     * @param charsetName\n     *            the charset to use\n     * @return RFC 1522 compliant \"encoded-word\"\n     * @throws EncoderException\n     *             thrown if there is an error condition during the Encoding process.\n     * @throws UnsupportedEncodingException\n     *             if charset is not available\n     *\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     */"}}
{"code": {"body": "    protected String decodeText(final String text)\n            throws DecoderException, UnsupportedEncodingException {\n        if (text == null) {\n            return null;\n        }\n        if (!text.startsWith(PREFIX) || !text.endsWith(POSTFIX)) {\n            throw new DecoderException(\"\");\n        }\n        final int terminator = text.length() - 2;\n        int from = 2;\n        int to = text.indexOf(SEP, from);\n        if (to == terminator) {\n            throw new DecoderException(\"\");\n        }\n        final String charset = text.substring(from, to);\n        if (charset.equals(\"\")) {\n            throw new DecoderException(\"\");\n        }\n        from = to + 1;\n        to = text.indexOf(SEP, from);\n        if (to == terminator) {\n            throw new DecoderException(\"\");\n        }\n        final String encoding = text.substring(from, to);\n        if (!getEncoding().equalsIgnoreCase(encoding)) {\n            throw new DecoderException(\"\" + encoding + \"\");\n        }\n        from = to + 1;\n        to = text.indexOf(SEP, from);\n        byte[] data = StringUtils.getBytesUsAscii(text.substring(from, to));\n        data = doDecoding(data);\n        return new String(data, charset);\n    }", "comment": "/**\n     * Applies an RFC 1522 compliant decoding scheme to the given string of text.\n     * <p>\n     * This method processes the \"encoded-word\" header common to all the RFC 1522 codecs and then invokes\n     * {@link #doEncoding(byte [])} method of a concrete class to perform the specific decoding.\n     *\n     * @param text\n     *            a string to decode\n     * @return A new decoded String or <code>null</code> if the input is <code>null</code>.\n     * @throws DecoderException\n     *             thrown if there is an error condition during the decoding process.\n     * @throws UnsupportedEncodingException\n     *             thrown if charset specified in the \"encoded-word\" header is not supported\n     */"}}
{"code": {"body": "public URLCodec() {\n        this(CharEncoding.UTF_8);\n    }", "comment": "/**\n     * Default constructor.\n     */"}}
{"code": {"body": "public URLCodec(final String charset) {\n        super();\n        this.charset = charset;\n    }", "comment": "/**\n     * Constructor which allows for the selection of a default charset.\n     *\n     * @param charset the default string charset to use.\n     */"}}
{"code": {"body": "    public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {\n        if (bytes == null) {\n            return null;\n        }\n        if (urlsafe == null) {\n            urlsafe = WWW_FORM_URL;\n        }\n\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (final byte c : bytes) {\n            int b = c;\n            if (b < 0) {\n                b = 256 + b;\n            }\n            if (urlsafe.get(b)) {\n                if (b == '') {\n                    b = '';\n                }\n                buffer.write(b);\n            } else {\n                buffer.write(ESCAPE_CHAR);\n                final char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));\n                final char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));\n                buffer.write(hex1);\n                buffer.write(hex2);\n            }\n        }\n        return buffer.toByteArray();\n    }", "comment": "/**\n     * Encodes an array of bytes into an array of URL safe 7-bit characters. Unsafe characters are escaped.\n     *\n     * @param urlsafe\n     *            bitset of characters deemed URL safe\n     * @param bytes\n     *            array of bytes to convert to URL safe characters\n     * @return array of bytes containing URL safe characters\n     */"}}
{"code": {"body": "    public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {\n        if (bytes == null) {\n            return null;\n        }\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            final int b = bytes[i];\n            if (b == '') {\n                buffer.write('');\n            } else if (b == ESCAPE_CHAR) {\n                try {\n                    final int u = Utils.digit16(bytes[++i]);\n                    final int l = Utils.digit16(bytes[++i]);\n                    buffer.write((char) ((u << 4) + l));\n                } catch (final ArrayIndexOutOfBoundsException e) {\n                    throw new DecoderException(\"\", e);\n                }\n            } else {\n                buffer.write(b);\n            }\n        }\n        return buffer.toByteArray();\n    }", "comment": "/**\n     * Decodes an array of URL safe 7-bit characters into an array of original bytes. Escaped characters are converted\n     * back to their original representation.\n     *\n     * @param bytes\n     *            array of URL safe characters\n     * @return array of original bytes\n     * @throws DecoderException\n     *             Thrown if URL decoding is unsuccessful\n     */"}}
{"code": {"body": "    public String getDefaultCharset() {\n        return this.charset;\n    }", "comment": "/**\n     * The default charset used for string decoding and encoding.\n     *\n     * @return the default string charset.\n     */"}}
{"code": {"body": "    static int digit16(final byte b) throws DecoderException {\n        final int i = Character.digit((char) b, URLCodec.RADIX);\n        if (i == -1) {\n            throw new DecoderException(\"\" + URLCodec.RADIX + \"\" + b);\n        }\n        return i;\n    }", "comment": "/**\n     * Returns the numeric value of the character <code>b</code> in radix 16.\n     *\n     * @param b\n     *            The byte to be converted.\n     * @return The numeric value represented by the character in radix 16.\n     *\n     * @throws DecoderException\n     *             Thrown when the byte is not valid per {@link Character#digit(char,int)}\n     */"}}
{"code": {"body": "    public static Charset toCharset(final String charset) {\n        return charset == null ? Charset.defaultCharset() : Charset.forName(charset);\n    }", "comment": "/**\n     * Returns a Charset for the named charset. If the name is null, return the default Charset.\n     *\n     * @param charset\n     *            The name of the requested charset, may be null.\n     * @return a Charset for the named charset\n     * @throws java.nio.charset.UnsupportedCharsetException\n     *             If the named charset is unavailable\n     */"}}
{"code": {"body": "public DecoderException() {\n        super();\n    }", "comment": "/**\n     * Constructs a new exception with <code>null</code> as its detail message. The cause is not initialized, and may\n     * subsequently be initialized by a call to {@link #initCause}.\n     *\n     * @since 1.4\n     */"}}
{"code": {"body": "public DecoderException(final String message) {\n        super(message);\n    }", "comment": "/**\n     * Constructs a new exception with the specified detail message. The cause is not initialized, and may subsequently\n     * be initialized by a call to {@link #initCause}.\n     *\n     * @param message\n     *            The detail message which is saved for later retrieval by the {@link #getMessage()} method.\n     */"}}
{"code": {"body": "public DecoderException(final String message, final Throwable cause) {\n        super(message, cause);\n    }", "comment": "/**\n     * Constructs a new exception with the specified detail message and cause.\n     * <p>\n     * Note that the detail message associated with <code>cause</code> is not automatically incorporated into this\n     * exception's detail message.\n     *\n     * @param message\n     *            The detail message which is saved for later retrieval by the {@link #getMessage()} method.\n     * @param cause\n     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A <code>null</code>\n     *            value is permitted, and indicates that the cause is nonexistent or unknown.\n     * @since 1.4\n     */"}}
{"code": {"body": "public DecoderException(final Throwable cause) {\n        super(cause);\n    }", "comment": "/**\n     * Constructs a new exception with the specified cause and a detail message of <code>(cause==null ?\n     * null : cause.toString())</code> (which typically contains the class and detail message of <code>cause</code>).\n     * This constructor is useful for exceptions that are little more than wrappers for other throwables.\n     *\n     * @param cause\n     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A <code>null</code>\n     *            value is permitted, and indicates that the cause is nonexistent or unknown.\n     * @since 1.4\n     */"}}
{"code": {"body": "public EncoderException() {\n        super();\n    }", "comment": "/**\n     * Constructs a new exception with <code>null</code> as its detail message. The cause is not initialized, and may\n     * subsequently be initialized by a call to {@link #initCause}.\n     *\n     * @since 1.4\n     */"}}
{"code": {"body": "public EncoderException(final String message) {\n        super(message);\n    }", "comment": "/**\n     * Constructs a new exception with the specified detail message. The cause is not initialized, and may subsequently\n     * be initialized by a call to {@link #initCause}.\n     *\n     * @param message\n     *            a useful message relating to the encoder specific error.\n     */"}}
{"code": {"body": "public EncoderException(final String message, final Throwable cause) {\n        super(message, cause);\n    }", "comment": "/**\n     * Constructs a new exception with the specified detail message and cause.\n     *\n     * <p>\n     * Note that the detail message associated with <code>cause</code> is not automatically incorporated into this\n     * exception's detail message.\n     * </p>\n     *\n     * @param message\n     *            The detail message which is saved for later retrieval by the {@link #getMessage()} method.\n     * @param cause\n     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A <code>null</code>\n     *            value is permitted, and indicates that the cause is nonexistent or unknown.\n     * @since 1.4\n     */"}}
{"code": {"body": "public EncoderException(final Throwable cause) {\n        super(cause);\n    }", "comment": "/**\n     * Constructs a new exception with the specified cause and a detail message of <code>(cause==null ?\n     * null : cause.toString())</code> (which typically contains the class and detail message of <code>cause</code>).\n     * This constructor is useful for exceptions that are little more than wrappers for other throwables.\n     *\n     * @param cause\n     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A <code>null</code>\n     *            value is permitted, and indicates that the cause is nonexistent or unknown.\n     * @since 1.4\n     */"}}
{"code": {"body": "public StringEncoderComparator(final StringEncoder stringEncoder) {\n        this.stringEncoder = stringEncoder;\n    }", "comment": "/**\n     * Constructs a new instance with the given algorithm.\n     *\n     * @param stringEncoder\n     *            the StringEncoder used for comparisons.\n     */"}}
{"code": {"body": "public Base32() {\n        this(false);\n    }", "comment": "/**\n     * Creates a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length is 0 (no chunking).\n     * </p>\n     *\n     */"}}
{"code": {"body": "public Base32(final byte pad) {\n        this(false, pad);\n    }", "comment": "/**\n     * Creates a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length is 0 (no chunking).\n     * </p>\n     * @param pad byte used as padding byte.\n     */"}}
{"code": {"body": "public Base32(final boolean useHex) {\n        this(0, null, useHex, PAD_DEFAULT);\n    }", "comment": "/**\n     * Creates a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length is 0 (no chunking).\n     * </p>\n     * @param useHex if {@code true} then use Base32 Hex alphabet\n     */"}}
{"code": {"body": "public Base32(final boolean useHex, final byte pad) {\n        this(0, null, useHex, pad);\n    }", "comment": "/**\n     * Creates a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length is 0 (no chunking).\n     * </p>\n     * @param useHex if {@code true} then use Base32 Hex alphabet\n     * @param pad byte used as padding byte.\n     */"}}
{"code": {"body": "public Base32(final int lineLength) {\n        this(lineLength, CHUNK_SEPARATOR);\n    }", "comment": "/**\n     * Creates a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length is given in the constructor, the line separator is CRLF.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     */"}}
{"code": {"body": "public Base32(final int lineLength, final byte[] lineSeparator) {\n        this(lineLength, lineSeparator, false, PAD_DEFAULT);\n    }", "comment": "/**\n     * Creates a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some Base32 characters. That's not going to work!\n     */"}}
{"code": {"body": "public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex) {\n        this(lineLength, lineSeparator, useHex, PAD_DEFAULT);\n    }", "comment": "/**\n     * Creates a Base32 / Base32 Hex codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param useHex\n     *            if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some Base32 characters. That's not going to work! Or the\n     *             lineLength &gt; 0 and lineSeparator is null.\n     */"}}
{"code": {"body": "public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex, final byte pad) {\n        super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK, lineLength,\n                lineSeparator == null ? 0 : lineSeparator.length, pad);\n        if (useHex) {\n            this.encodeTable = HEX_ENCODE_TABLE;\n            this.decodeTable = HEX_DECODE_TABLE;\n        } else {\n            this.encodeTable = ENCODE_TABLE;\n            this.decodeTable = DECODE_TABLE;\n        }\n        if (lineLength > 0) {\n            if (lineSeparator == null) {\n                throw new IllegalArgumentException(\"\" + lineLength + \"\");\n            }\n            \n            if (containsAlphabetOrPad(lineSeparator)) {\n                final String sep = StringUtils.newStringUtf8(lineSeparator);\n                throw new IllegalArgumentException(\"\" + sep + \"\");\n            }\n            this.encodeSize = BYTES_PER_ENCODED_BLOCK + lineSeparator.length;\n            this.lineSeparator = new byte[lineSeparator.length];\n            System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        } else {\n            this.encodeSize = BYTES_PER_ENCODED_BLOCK;\n            this.lineSeparator = null;\n        }\n        this.decodeSize = this.encodeSize - 1;\n\n        if (isInAlphabet(pad) || isWhiteSpace(pad)) {\n            throw new IllegalArgumentException(\"\");\n        }\n    }", "comment": "/**\n     * Creates a Base32 / Base32 Hex codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param useHex\n     *            if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet\n     * @param pad byte used as padding byte.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some Base32 characters. That's not going to work! Or the\n     *             lineLength &gt; 0 and lineSeparator is null.\n     */"}}
{"code": {"body": "public Base32InputStream(final InputStream in) {\n        this(in, false);\n    }", "comment": "/**\n     * Creates a Base32InputStream such that all data read is Base32-decoded from the original provided InputStream.\n     *\n     * @param in\n     *            InputStream to wrap.\n     */"}}
{"code": {"body": "public Base32InputStream(final InputStream in, final boolean doEncode) {\n        super(in, new Base32(false), doEncode);\n    }", "comment": "/**\n     * Creates a Base32InputStream such that all data read is either Base32-encoded or Base32-decoded from the original\n     * provided InputStream.\n     *\n     * @param in\n     *            InputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data read from us, false if we should decode.\n     */"}}
{"code": {"body": "public Base32InputStream(final InputStream in, final boolean doEncode)", "comment": "/**\n     * Creates a Base32InputStream such that all data read is either Base32-encoded or Base32-decoded from the original\n     * provided InputStream.\n     *\n     * @param in\n     *            InputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data read from us, false if we should decode.\n     */"}}
{"code": {"body": "public Base32OutputStream(final OutputStream out) {\n        this(out, true);\n    }", "comment": "/**\n     * Creates a Base32OutputStream such that all data written is Base32-encoded to the original provided OutputStream.\n     *\n     * @param out\n     *            OutputStream to wrap.\n     */"}}
{"code": {"body": "public Base32OutputStream(final OutputStream out, final boolean doEncode) {\n        super(out, new Base32(false), doEncode);\n    }", "comment": "/**\n     * Creates a Base32OutputStream such that all data written is either Base32-encoded or Base32-decoded to the\n     * original provided OutputStream.\n     *\n     * @param out\n     *            OutputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data written to us, false if we should decode.\n     */"}}
{"code": {"body": "public Base32OutputStream(final OutputStream out, final boolean doEncode)", "comment": "/**\n     * Creates a Base32OutputStream such that all data written is either Base32-encoded or Base32-decoded to the\n     * original provided OutputStream.\n     *\n     * @param out\n     *            OutputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data written to us, false if we should decode.\n     */"}}
{"code": {"body": "public Base64() {\n        this(0);\n    }", "comment": "/**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is 0 (no chunking), and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     *\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     */"}}
{"code": {"body": "public Base64(final boolean urlSafe) {\n        this(MIME_CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n    }", "comment": "/**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n     * <p>\n     * When encoding the line length is 76, the line separator is CRLF, and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     *\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     *\n     * @param urlSafe\n     *            if <code>true</code>, URL-safe encoding is used. In most cases this should be set to\n     *            <code>false</code>.\n     * @since 1.4\n     */"}}
{"code": {"body": "public Base64(final int lineLength) {\n        this(lineLength, CHUNK_SEPARATOR);\n    }", "comment": "/**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n     *            4). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     * @since 1.4\n     */"}}
{"code": {"body": "public Base64(final int lineLength, final byte[] lineSeparator) {\n        this(lineLength, lineSeparator, false);\n    }", "comment": "/**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n     *            4). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @throws IllegalArgumentException\n     *             Thrown when the provided lineSeparator included some base64 characters.\n     * @since 1.4\n     */"}}
{"code": {"body": "public Base64(final int lineLength, final byte[] lineSeparator, final boolean urlSafe) {\n        super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK,\n                lineLength,\n                lineSeparator == null ? 0 : lineSeparator.length);\n        \n        \n        if (lineSeparator != null) {\n            if (containsAlphabetOrPad(lineSeparator)) {\n                final String sep = StringUtils.newStringUtf8(lineSeparator);\n                throw new IllegalArgumentException(\"\" + sep + \"\");\n            }\n            if (lineLength > 0){ \n                this.encodeSize = BYTES_PER_ENCODED_BLOCK + lineSeparator.length;\n                this.lineSeparator = new byte[lineSeparator.length];\n                System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n            } else {\n                this.encodeSize = BYTES_PER_ENCODED_BLOCK;\n                this.lineSeparator = null;\n            }\n        } else {\n            this.encodeSize = BYTES_PER_ENCODED_BLOCK;\n            this.lineSeparator = null;\n        }\n        this.decodeSize = this.encodeSize - 1;\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n    }", "comment": "/**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n     *            4). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param urlSafe\n     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode\n     *            operations. Decoding seamlessly handles both modes.\n     *            <b>Note: no padding is added when using the URL-safe alphabet.</b>\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some base64 characters. That's not going to work!\n     * @since 1.4\n     */"}}
{"code": {"body": "    public boolean isUrlSafe() {\n        return this.encodeTable == URL_SAFE_ENCODE_TABLE;\n    }", "comment": "/**\n     * Returns our current encode mode. True if we're URL-SAFE, false otherwise.\n     *\n     * @return true if we're in URL-SAFE mode, false otherwise.\n     * @since 1.4\n     */"}}
{"code": {"body": "    public static boolean isBase64(final byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {\n                return false;\n            }\n        }\n        return true;\n    }", "comment": "/**\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the\n     * method treats whitespace as valid.\n     *\n     * @param arrayOctet\n     *            byte array to test\n     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;\n     *         <code>false</code>, otherwise\n     * @since 1.5\n     */"}}
{"code": {"body": "    public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked,\n                                      final boolean urlSafe, final int maxResultSize) {\n        if (binaryData == null || binaryData.length == 0) {\n            return binaryData;\n        }\n\n        \n        \n        final Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n        final long len = b64.getEncodedLength(binaryData);\n        if (len > maxResultSize) {\n            throw new IllegalArgumentException(\"\" +\n                len +\n                \"\" +\n                maxResultSize);\n        }\n\n        return b64.encode(binaryData);\n    }", "comment": "/**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     *\n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     *            <b>Note: no padding is added when encoding using the URL-safe alphabet.</b>\n     * @param maxResultSize\n     *            The maximum result size to accept.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than maxResultSize\n     * @since 1.4\n     */"}}
{"code": {"body": "    public static String encodeBase64String(final byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false));\n    }", "comment": "/**\n     * Encodes binary data using the base64 algorithm but does not chunk the output.\n     *\n     * NOTE:  We changed the behaviour of this method from multi-line chunking (commons-codec-1.4) to\n     * single-line non-chunking (commons-codec-1.5).\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters.\n     * @since 1.4 (NOTE:  1.4 chunked the output, whereas 1.5 does not).\n     */"}}
{"code": {"body": "    public static byte[] encodeBase64URLSafe(final byte[] binaryData) {\n        return encodeBase64(binaryData, false, true);\n    }", "comment": "/**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     * <b>Note: no padding is added.</b>\n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     * @since 1.4\n     */"}}
{"code": {"body": "    public static String encodeBase64URLSafeString(final byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n    }", "comment": "/**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     * <b>Note: no padding is added.</b>\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters\n     * @since 1.4\n     */"}}
{"code": {"body": "    public static byte[] encodeBase64Chunked(final byte[] binaryData) {\n        return encodeBase64(binaryData, true);\n    }", "comment": "/**\n     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return Base64 characters chunked in 76 character blocks\n     */"}}
{"code": {"body": "    public static byte[] decodeBase64(final byte[] base64Data) {\n        return new Base64().decode(base64Data);\n    }", "comment": "/**\n     * Decodes Base64 data into octets.\n     * <p>\n     * <b>Note:</b> this method seamlessly handles data encoded in URL-safe or normal mode.\n     * </p>\n     *\n     * @param base64Data\n     *            Byte array containing Base64 data\n     * @return Array containing decoded data.\n     */"}}
{"code": {"body": "    public static BigInteger decodeInteger(final byte[] pArray) {\n        return new BigInteger(1, decodeBase64(pArray));\n    }", "comment": "/**\n     * Decodes a byte64-encoded integer according to crypto standards such as W3C's XML-Signature.\n     *\n     * @param pArray\n     *            a byte array containing base64 character data\n     * @return A BigInteger\n     * @since 1.4\n     */"}}
{"code": {"body": "    public static byte[] encodeInteger(final BigInteger bigInt) {\n        if (bigInt == null) {\n            throw new NullPointerException(\"\");\n        }\n        return encodeBase64(toIntegerBytes(bigInt), false);\n    }", "comment": "/**\n     * Encodes to a byte64-encoded integer according to crypto standards such as W3C's XML-Signature.\n     *\n     * @param bigInt\n     *            a BigInteger\n     * @return A byte array containing base64 character data\n     * @throws NullPointerException\n     *             if null is passed in\n     * @since 1.4\n     */"}}
{"code": {"body": "    static byte[] toIntegerBytes(final BigInteger bigInt) {\n        int bitlen = bigInt.bitLength();\n        \n        bitlen = ((bitlen + 7) >> 3) << 3;\n        final byte[] bigBytes = bigInt.toByteArray();\n\n        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {\n            return bigBytes;\n        }\n        \n        int startSrc = 0;\n        int len = bigBytes.length;\n\n        \n        if ((bigInt.bitLength() % 8) == 0) {\n            startSrc = 1;\n            len--;\n        }\n        final int startDst = bitlen / 8 - len; \n        final byte[] resizedBytes = new byte[bitlen / 8];\n        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);\n        return resizedBytes;\n    }", "comment": "/**\n     * Returns a byte-array representation of a <code>BigInteger</code> without sign bit.\n     *\n     * @param bigInt\n     *            <code>BigInteger</code> to be converted\n     * @return a byte array representation of the BigInteger parameter\n     */"}}
{"code": {"body": "public Base64InputStream(final InputStream in) {\n        this(in, false);\n    }", "comment": "/**\n     * Creates a Base64InputStream such that all data read is Base64-decoded from the original provided InputStream.\n     *\n     * @param in\n     *            InputStream to wrap.\n     */"}}
{"code": {"body": "public Base64InputStream(final InputStream in, final boolean doEncode) {\n        super(in, new Base64(false), doEncode);\n    }", "comment": "/**\n     * Creates a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original\n     * provided InputStream.\n     *\n     * @param in\n     *            InputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data read from us, false if we should decode.\n     */"}}
{"code": {"body": "public Base64InputStream(final InputStream in, final boolean doEncode)", "comment": "/**\n     * Creates a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original\n     * provided InputStream.\n     *\n     * @param in\n     *            InputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data read from us, false if we should decode.\n     */"}}
{"code": {"body": "public Base64OutputStream(final OutputStream out) {\n        this(out, true);\n    }", "comment": "/**\n     * Creates a Base64OutputStream such that all data written is Base64-encoded to the original provided OutputStream.\n     *\n     * @param out\n     *            OutputStream to wrap.\n     */"}}
{"code": {"body": "public Base64OutputStream(final OutputStream out, final boolean doEncode) {\n        super(out,new Base64(false), doEncode);\n    }", "comment": "/**\n     * Creates a Base64OutputStream such that all data written is either Base64-encoded or Base64-decoded to the\n     * original provided OutputStream.\n     *\n     * @param out\n     *            OutputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data written to us, false if we should decode.\n     */"}}
{"code": {"body": "public Base64OutputStream(final OutputStream out, final boolean doEncode)", "comment": "/**\n     * Creates a Base64OutputStream such that all data written is either Base64-encoded or Base64-decoded to the\n     * original provided OutputStream.\n     *\n     * @param out\n     *            OutputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data written to us, false if we should decode.\n     */"}}
{"code": {"body": "    boolean hasData(final Context context) {  \n        return context.buffer != null;\n    }", "comment": "/**\n     * Returns true if this object has buffered data for reading.\n     *\n     * @param context the context to be used\n     * @return true if there is data still available for reading.\n     */"}}
{"code": {"body": "    int available(final Context context) {  \n        return context.buffer != null ? context.pos - context.readPos : 0;\n    }", "comment": "/**\n     * Returns the amount of buffered data available for reading.\n     *\n     * @param context the context to be used\n     * @return The amount of buffered data available for reading.\n     */"}}
{"code": {"body": "    protected int getDefaultBufferSize() {\n        return DEFAULT_BUFFER_SIZE;\n    }", "comment": "/**\n     * Get the default buffer size. Can be overridden.\n     *\n     * @return {@link #DEFAULT_BUFFER_SIZE}\n     */"}}
{"code": {"body": "    private byte[] resizeBuffer(final Context context) {\n        if (context.buffer == null) {\n            context.buffer = new byte[getDefaultBufferSize()];\n            context.pos = 0;\n            context.readPos = 0;\n        } else {\n            final byte[] b = new byte[context.buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];\n            System.arraycopy(context.buffer, 0, b, 0, context.buffer.length);\n            context.buffer = b;\n        }\n        return context.buffer;\n    }", "comment": "/**\n     * Increases our buffer by the {@link #DEFAULT_BUFFER_RESIZE_FACTOR}.\n     * @param context the context to be used\n     */"}}
{"code": {"body": "    protected byte[] ensureBufferSize(final int size, final Context context){\n        if ((context.buffer == null) || (context.buffer.length < context.pos + size)){\n            return resizeBuffer(context);\n        }\n        return context.buffer;\n    }", "comment": "/**\n     * Ensure that the buffer has room for <code>size</code> bytes\n     *\n     * @param size minimum spare space required\n     * @param context the context to be used\n     * @return the buffer\n     */"}}
{"code": {"body": "    int readResults(final byte[] b, final int bPos, final int bAvail, final Context context) {\n        if (context.buffer != null) {\n            final int len = Math.min(available(context), bAvail);\n            System.arraycopy(context.buffer, context.readPos, b, bPos, len);\n            context.readPos += len;\n            if (context.readPos >= context.pos) {\n                context.buffer = null; \n            }\n            return len;\n        }\n        return context.eof ? EOF : 0;\n    }", "comment": "/**\n     * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail\n     * bytes. Returns how many bytes were actually extracted.\n     * <p>\n     * Package protected for access from I/O streams.\n     *\n     * @param b\n     *            byte[] array to extract the buffered data into.\n     * @param bPos\n     *            position in byte[] array to start extraction at.\n     * @param bAvail\n     *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).\n     * @param context\n     *            the context to be used\n     * @return The number of bytes successfully extracted into the provided byte[] array.\n     */"}}
{"code": {"body": "    protected static boolean isWhiteSpace(final byte byteToCheck) {\n        switch (byteToCheck) {\n            case '' :\n            case '' :\n            case '' :\n            case '' :\n                return true;\n            default :\n                return false;\n        }\n    }", "comment": "/**\n     * Checks if a byte value is whitespace or not.\n     * Whitespace is taken to mean: space, tab, CR, LF\n     * @param byteToCheck\n     *            the byte to check\n     * @return true if byte is whitespace, false otherwise\n     */"}}
{"code": {"body": "    public String encodeToString(final byte[] pArray) {\n        return StringUtils.newStringUtf8(encode(pArray));\n    }", "comment": "/**\n     * Encodes a byte[] containing binary data, into a String containing characters in the Base-N alphabet.\n     * Uses UTF8 encoding.\n     *\n     * @param pArray\n     *            a byte array containing binary data\n     * @return A String containing only Base-N character data\n     */"}}
{"code": {"body": "    public String encodeAsString(final byte[] pArray){\n        return StringUtils.newStringUtf8(encode(pArray));\n    }", "comment": "/**\n     * Encodes a byte[] containing binary data, into a String containing characters in the appropriate alphabet.\n     * Uses UTF8 encoding.\n     *\n     * @param pArray a byte array containing binary data\n     * @return String containing only character data in the appropriate alphabet.\n    */"}}
{"code": {"body": "    public boolean isInAlphabet(final String basen) {\n        return isInAlphabet(StringUtils.getBytesUtf8(basen), true);\n    }", "comment": "/**\n     * Tests a given String to see if it contains only valid characters within the alphabet.\n     * The method treats whitespace and PAD as valid.\n     *\n     * @param basen String to test\n     * @return <code>true</code> if all characters in the String are valid characters in the alphabet or if\n     *         the String is empty; <code>false</code>, otherwise\n     * @see #isInAlphabet(byte[], boolean)\n     */"}}
{"code": {"body": "    protected boolean containsAlphabetOrPad(final byte[] arrayOctet) {\n        if (arrayOctet == null) {\n            return false;\n        }\n        for (final byte element : arrayOctet) {\n            if (pad == element || isInAlphabet(element)) {\n                return true;\n            }\n        }\n        return false;\n    }", "comment": "/**\n     * Tests a given byte array to see if it contains any characters within the alphabet or PAD.\n     *\n     * Intended for use in checking line-ending arrays\n     *\n     * @param arrayOctet\n     *            byte array to test\n     * @return <code>true</code> if any byte is a valid character in the alphabet or PAD; <code>false</code> otherwise\n     */"}}
{"code": {"body": "    public long getEncodedLength(final byte[] pArray) {\n        \n        \n        long len = ((pArray.length + unencodedBlockSize-1)  / unencodedBlockSize) * (long) encodedBlockSize;\n        if (lineLength > 0) { \n            \n            len += ((len + lineLength-1) / lineLength) * chunkSeparatorLength;\n        }\n        return len;\n    }", "comment": "/**\n     * Calculates the amount of space needed to encode the supplied array.\n     *\n     * @param pArray byte[] array which will later be encoded\n     *\n     * @return amount of space needed to encoded the supplied array.\n     * Returns a long since a max-len array will require &gt; Integer.MAX_VALUE\n     */"}}
{"code": {"body": "    public byte[] toByteArray(final String ascii) {\n        if (ascii == null) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        return fromAscii(ascii.toCharArray());\n    }", "comment": "/**\n     * Decodes a String where each char of the String represents an ASCII '0' or '1'.\n     *\n     * @param ascii\n     *                  String of '0' and '1' characters\n     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument\n     * @see org.apache.commons.codec.Decoder#decode(Object)\n     */"}}
{"code": {"body": "    public static byte[] fromAscii(final byte[] ascii) {\n        if (isEmpty(ascii)) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        \n        final byte[] l_raw = new byte[ascii.length >> 3];\n        \n        for (int ii = 0, jj = ascii.length - 1; ii < l_raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if (ascii[jj - bits] == '') {\n                    l_raw[ii] |= BITS[bits];\n                }\n            }\n        }\n        return l_raw;\n    }", "comment": "/**\n     * Decodes a byte array where each byte represents an ASCII '0' or '1'.\n     *\n     * @param ascii\n     *                  each byte represents an ASCII '0' or '1'\n     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument\n     */"}}
{"code": {"body": "    private static boolean isEmpty(final byte[] array) {\n        return array == null || array.length == 0;\n    }", "comment": "/**\n     * Returns <code>true</code> if the given array is <code>null</code> or empty (size 0.)\n     *\n     * @param array\n     *            the source array\n     * @return <code>true</code> if the given array is <code>null</code> or empty (size 0.)\n     */"}}
{"code": {"body": "    public static byte[] toAsciiBytes(final byte[] raw) {\n        if (isEmpty(raw)) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        \n        final byte[] l_ascii = new byte[raw.length << 3];\n        \n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\n                    l_ascii[jj - bits] = '';\n                } else {\n                    l_ascii[jj - bits] = '';\n                }\n            }\n        }\n        return l_ascii;\n    }", "comment": "/**\n     * Converts an array of raw binary data into an array of ASCII 0 and 1 character bytes - each byte is a truncated\n     * char.\n     *\n     * @param raw\n     *                  the raw binary data to convert\n     * @return an array of 0 and 1 character bytes for each bit of the argument\n     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])\n     */"}}
{"code": {"body": "    public static char[] toAsciiChars(final byte[] raw) {\n        if (isEmpty(raw)) {\n            return EMPTY_CHAR_ARRAY;\n        }\n        \n        final char[] l_ascii = new char[raw.length << 3];\n        \n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\n                    l_ascii[jj - bits] = '';\n                } else {\n                    l_ascii[jj - bits] = '';\n                }\n            }\n        }\n        return l_ascii;\n    }", "comment": "/**\n     * Converts an array of raw binary data into an array of ASCII 0 and 1 characters.\n     *\n     * @param raw\n     *                  the raw binary data to convert\n     * @return an array of 0 and 1 characters for each bit of the argument\n     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])\n     */"}}
{"code": {"body": "    public static String toAsciiString(final byte[] raw) {\n        return new String(toAsciiChars(raw));\n    }", "comment": "/**\n     * Converts an array of raw binary data into a String of ASCII 0 and 1 characters.\n     *\n     * @param raw\n     *                  the raw binary data to convert\n     * @return a String of 0 and 1 characters representing the binary data\n     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])\n     */"}}
{"code": {"body": "    static boolean regionMatches(final CharSequence cs, final boolean ignoreCase, final int thisStart,\n            final CharSequence substring, final int start, final int length) {\n        if (cs instanceof String && substring instanceof String) {\n            return ((String) cs).regionMatches(ignoreCase, thisStart, (String) substring, start, length);\n        }\n        int index1 = thisStart;\n        int index2 = start;\n        int tmpLen = length;\n\n        while (tmpLen-- > 0) {\n            char c1 = cs.charAt(index1++);\n            char c2 = substring.charAt(index2++);\n\n            if (c1 == c2) {\n                continue;\n            }\n\n            if (!ignoreCase) {\n                return false;\n            }\n\n            \n            if (Character.toUpperCase(c1) != Character.toUpperCase(c2) &&\n                    Character.toLowerCase(c1) != Character.toLowerCase(c2)) {\n                return false;\n            }\n        }\n\n        return true;\n    }", "comment": "/**\n     * Green implementation of regionMatches.\n     *\n     * @param cs\n     *            the <code>CharSequence</code> to be processed\n     * @param ignoreCase\n     *            whether or not to be case insensitive\n     * @param thisStart\n     *            the index to start on the <code>cs</code> CharSequence\n     * @param substring\n     *            the <code>CharSequence</code> to be looked for\n     * @param start\n     *            the index to start on the <code>substring</code> CharSequence\n     * @param length\n     *            character length of the region\n     * @return whether the region matched\n     */"